// Code generated from Hplsql.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Hplsql

import (
	"fmt"
	"strconv"
	"strings"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type HplsqlParser struct {
	*antlr.BaseParser
}

var HplsqlParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func hplsqlParserInit() {
	staticData := &HplsqlParserStaticData
	staticData.LiteralNames = []string{
		"", "'@'", "'#'", "'%'", "'!'", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "'+'", "':'", "','", "'||'",
		"'/'", "'.'", "'..'", "'='", "'=='", "'<>'", "'!='", "'>'", "'>='",
		"'<'", "'<='", "'*'", "'{'", "'('", "'['", "'}'", "')'", "']'", "';'",
		"'-'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "T_ACTION", "T_ADD2", "T_ALL", "T_ALLOCATE", "T_ALTER",
		"T_AND", "T_ANSI_NULLS", "T_ANSI_PADDING", "T_AS", "T_ASC", "T_ASSOCIATE",
		"T_AT", "T_AUTO_INCREMENT", "T_AVG", "T_BATCHSIZE", "T_BEGIN", "T_BETWEEN",
		"T_BIGINT", "T_BINARY_DOUBLE", "T_BINARY_FLOAT", "T_BINARY_INTEGER",
		"T_BIT", "T_BODY", "T_BREAK", "T_BULK", "T_BY", "T_BYTE", "T_CALL",
		"T_CALLER", "T_CASCADE", "T_CASE", "T_CASESPECIFIC", "T_CAST", "T_CHAR",
		"T_CHARACTER", "T_CHARSET", "T_CLIENT", "T_CLOSE", "T_CLUSTERED", "T_CMP",
		"T_COLLECT", "T_COLLECTION", "T_COLUMN", "T_COMMENT", "T_CONSTANT",
		"T_COMMIT", "T_COMPRESS", "T_CONCAT", "T_CONDITION", "T_CONSTRAINT",
		"T_CONTINUE", "T_COPY", "T_COUNT", "T_COUNT_BIG", "T_CREATE", "T_CREATION",
		"T_CREATOR", "T_CS", "T_CURRENT", "T_CURRENT_SCHEMA", "T_CURSOR", "T_DATABASE",
		"T_DATA", "T_DATE", "T_DATETIME", "T_DAY", "T_DAYS", "T_DEC", "T_DECIMAL",
		"T_DECLARE", "T_DEFAULT", "T_DEFERRED", "T_DEFINED", "T_DEFINER", "T_DEFINITION",
		"T_DELETE", "T_DELIMITED", "T_DELIMITER", "T_DESC", "T_DESCRIBE", "T_DIAGNOSTICS",
		"T_DIR", "T_DIRECTORY", "T_DISTINCT", "T_DISTRIBUTE", "T_DO", "T_DOUBLE",
		"T_DROP", "T_DYNAMIC", "T_ELSE", "T_ELSEIF", "T_ELSIF", "T_ENABLE",
		"T_END", "T_ENGINE", "T_ESCAPED", "T_EXCEPT", "T_EXEC", "T_EXECUTE",
		"T_EXCEPTION", "T_EXCLUSIVE", "T_EXISTS", "T_EXIT", "T_FALLBACK", "T_FALSE",
		"T_FETCH", "T_FIELDS", "T_FILE", "T_FILES", "T_FLOAT", "T_FOR", "T_FOREIGN",
		"T_FORMAT", "T_FOUND", "T_FROM", "T_FULL", "T_FUNCTION", "T_GET", "T_GLOBAL",
		"T_GO", "T_GRANT", "T_GROUP", "T_HANDLER", "T_HASH", "T_HAVING", "T_HDFS",
		"T_HIVE", "T_HOST", "T_IDENTITY", "T_IF", "T_IGNORE", "T_IMMEDIATE",
		"T_IN", "T_INCLUDE", "T_INDEX", "T_INITRANS", "T_INNER", "T_INOUT",
		"T_INSERT", "T_INT", "T_INT2", "T_INT4", "T_INT8", "T_INTEGER", "T_INTERSECT",
		"T_INTERVAL", "T_INTO", "T_INVOKER", "T_IS", "T_ISOPEN", "T_ITEMS",
		"T_JOIN", "T_KEEP", "T_KEY", "T_KEYS", "T_LANGUAGE", "T_LEAVE", "T_LEFT",
		"T_LIKE", "T_LIMIT", "T_LINES", "T_LOCAL", "T_LOCATION", "T_LOCATOR",
		"T_LOCATORS", "T_LOCKS", "T_LOG", "T_LOGGED", "T_LOGGING", "T_LOOP",
		"T_MAP", "T_MATCHED", "T_MAX", "T_MAXTRANS", "T_MERGE", "T_MESSAGE_TEXT",
		"T_MICROSECOND", "T_MICROSECONDS", "T_MILLIS", "T_MIN", "T_MULTISET",
		"T_NCHAR", "T_NEW", "T_NVARCHAR", "T_NO", "T_NOCOUNT", "T_NOCOMPRESS",
		"T_NOLOGGING", "T_NONE", "T_NOT", "T_NOTFOUND", "T_NULL", "T_NUMERIC",
		"T_NUMBER", "T_OBJECT", "T_OFF", "T_OF", "T_ON", "T_ONLY", "T_OPEN",
		"T_OR", "T_ORDER", "T_OUT", "T_OUTER", "T_OVER", "T_OVERWRITE", "T_OWNER",
		"T_PACKAGE", "T_PARTITION", "T_PCTFREE", "T_PCTUSED", "T_PLS_INTEGER",
		"T_PRECISION", "T_PRESERVE", "T_PRIMARY", "T_PRINT", "T_PROC", "T_PROCEDURE",
		"T_QUALIFY", "T_QUERY_BAND", "T_QUIT", "T_QUOTED_IDENTIFIER", "T_RAISE",
		"T_REAL", "T_REFERENCES", "T_REGEXP", "T_REPLACE", "T_RESIGNAL", "T_RESTRICT",
		"T_RESULT", "T_RESULT_SET_LOCATOR", "T_RETURN", "T_RETURNS", "T_REVERSE",
		"T_RIGHT", "T_RLIKE", "T_ROLE", "T_ROLLBACK", "T_ROW", "T_ROWS", "T_ROWTYPE",
		"T_ROW_COUNT", "T_RR", "T_RS", "T_PWD", "T_TRIM", "T_SCHEMA", "T_SECOND",
		"T_SECONDS", "T_SECURITY", "T_SEGMENT", "T_SEL", "T_SELECT", "T_SET",
		"T_SESSION", "T_SESSIONS", "T_SETS", "T_SHARE", "T_SIGNAL", "T_SIMPLE_DOUBLE",
		"T_SIMPLE_FLOAT", "T_SIMPLE_INTEGER", "T_SMALLDATETIME", "T_SMALLINT",
		"T_SQL", "T_SQLEXCEPTION", "T_SQLINSERT", "T_SQLSTATE", "T_SQLWARNING",
		"T_STATS", "T_STATISTICS", "T_STEP", "T_STORAGE", "T_STORED", "T_STRING",
		"T_SUBDIR", "T_SUBSTRING", "T_SUM", "T_SUMMARY", "T_SYS_REFCURSOR",
		"T_TABLE", "T_TABLESPACE", "T_TEMPORARY", "T_TERMINATED", "T_TEXTIMAGE_ON",
		"T_THEN", "T_TIME", "T_TIMESTAMP", "T_TINYINT", "T_TITLE", "T_TO", "T_TOP",
		"T_TRANSACTION", "T_TRUE", "T_TRUNCATE", "T_TYPE", "T_UNION", "T_UNIQUE",
		"T_UPDATE", "T_UR", "T_USE", "T_USING", "T_VALUE", "T_VALUES", "T_VAR",
		"T_VARCHAR", "T_VARCHAR2", "T_VARYING", "T_VOLATILE", "T_WHEN", "T_WHERE",
		"T_WHILE", "T_WITH", "T_WITHOUT", "T_WORK", "T_XACT_ABORT", "T_XML",
		"T_YES", "T_ACTIVITY_COUNT", "T_CUME_DIST", "T_CURRENT_DATE", "T_CURRENT_TIME_MILLIS",
		"T_CURRENT_TIMESTAMP", "T_CURRENT_USER", "T_DENSE_RANK", "T_FIRST_VALUE",
		"T_LAG", "T_LAST_VALUE", "T_LEAD", "T_MAX_PART_STRING", "T_MIN_PART_STRING",
		"T_MAX_PART_INT", "T_MIN_PART_INT", "T_MAX_PART_DATE", "T_MIN_PART_DATE",
		"T_PART_COUNT", "T_PART_LOC", "T_RANK", "T_ROW_NUMBER", "T_STDEV", "T_SYSDATE",
		"T_VARIANCE", "T_USER", "T_ADD", "T_COLON", "T_COMMA", "T_PIPE", "T_DIV",
		"T_DOT", "T_DOT2", "T_EQUAL", "T_EQUAL2", "T_NOTEQUAL", "T_NOTEQUAL2",
		"T_GREATER", "T_GREATEREQUAL", "T_LESS", "T_LESSEQUAL", "T_MUL", "T_OPEN_B",
		"T_OPEN_P", "T_OPEN_SB", "T_CLOSE_B", "T_CLOSE_P", "T_CLOSE_SB", "T_SEMICOLON",
		"T_SUB", "L_ID", "L_S_STRING", "L_D_STRING", "L_INT", "L_DEC", "L_WS",
		"L_M_COMMENT", "L_S_COMMENT", "L_FILE", "L_LABEL",
	}
	staticData.RuleNames = []string{
		"program", "block", "begin_end_block", "single_block_stmt", "block_end",
		"proc_block", "stmt", "semicolon_stmt", "exception_block", "exception_block_item",
		"null_stmt", "expr_stmt", "assignment_stmt", "assignment_stmt_item",
		"assignment_stmt_single_item", "assignment_stmt_collection_item", "assignment_stmt_multiple_item",
		"assignment_stmt_select_item", "allocate_cursor_stmt", "associate_locator_stmt",
		"begin_transaction_stmt", "break_stmt", "call_stmt", "declare_stmt",
		"declare_block", "declare_block_inplace", "declare_stmt_item", "declare_var_item",
		"declare_condition_item", "declare_cursor_item", "cursor_with_return",
		"cursor_without_return", "declare_handler_item", "declare_temporary_table_item",
		"create_table_stmt", "create_local_temp_table_stmt", "create_table_definition",
		"create_table_columns", "create_table_columns_item", "create_table_type_stmt",
		"tbl_type", "sql_type", "column_name", "create_table_column_inline_cons",
		"create_table_column_cons", "create_table_fk_action", "create_table_preoptions",
		"create_table_preoptions_item", "create_table_preoptions_td_item", "create_table_options",
		"create_table_options_item", "create_table_options_ora_item", "create_table_options_db2_item",
		"create_table_options_td_item", "create_table_options_hive_item", "create_table_hive_row_format",
		"create_table_hive_row_format_fields", "create_table_options_mssql_item",
		"create_table_options_mysql_item", "alter_table_stmt", "alter_table_item",
		"alter_table_add_constraint", "alter_table_add_constraint_item", "dtype",
		"dtype_len", "dtype_attr", "dtype_default", "create_database_stmt",
		"create_database_option", "create_function_stmt", "create_function_return",
		"create_package_stmt", "package_spec", "package_spec_item", "create_package_body_stmt",
		"package_body", "package_body_item", "create_procedure_stmt", "create_routine_params",
		"create_routine_param_item", "create_routine_options", "create_routine_option",
		"drop_stmt", "end_transaction_stmt", "exec_stmt", "if_stmt", "if_plsql_stmt",
		"if_tsql_stmt", "if_bteq_stmt", "elseif_block", "else_block", "include_stmt",
		"insert_stmt", "insert_stmt_cols", "insert_stmt_rows", "insert_stmt_row",
		"insert_directory_stmt", "exit_stmt", "get_diag_stmt", "get_diag_stmt_item",
		"get_diag_stmt_exception_item", "get_diag_stmt_rowcount_item", "grant_stmt",
		"grant_stmt_item", "leave_stmt", "map_object_stmt", "open_stmt", "fetch_stmt",
		"fetch_limit", "collect_stats_stmt", "collect_stats_clause", "close_stmt",
		"cmp_stmt", "cmp_source", "copy_from_local_stmt", "copy_stmt", "copy_source",
		"copy_target", "copy_option", "copy_file_option", "commit_stmt", "create_index_stmt",
		"create_index_col", "index_storage_clause", "index_mssql_storage_clause",
		"print_stmt", "quit_stmt", "raise_stmt", "resignal_stmt", "return_stmt",
		"rollback_stmt", "set_session_option", "set_current_schema_option",
		"set_mssql_session_option", "set_teradata_session_option", "signal_stmt",
		"summary_stmt", "truncate_stmt", "use_stmt", "values_into_stmt", "while_stmt",
		"unconditional_loop_stmt", "for_cursor_stmt", "for_range_stmt", "label",
		"using_clause", "select_stmt", "cte_select_stmt", "cte_select_stmt_item",
		"cte_select_cols", "fullselect_stmt", "fullselect_stmt_item", "fullselect_set_clause",
		"subselect_stmt", "select_list", "select_list_set", "select_list_limit",
		"select_list_item", "select_list_alias", "select_list_asterisk", "table_row",
		"into_clause", "bulk_collect_clause", "from_clause", "from_table_clause",
		"from_table_name_clause", "from_subselect_clause", "from_join_clause",
		"from_join_type_clause", "from_table_values_clause", "from_table_values_row",
		"from_alias_clause", "table_name", "where_clause", "group_by_clause",
		"having_clause", "qualify_clause", "order_by_clause", "select_options",
		"select_options_item", "update_stmt", "update_assignment", "update_table",
		"update_upsert", "merge_stmt", "merge_table", "merge_condition", "merge_action",
		"delete_stmt", "delete_alias", "describe_stmt", "bool_expr", "bool_expr_atom",
		"bool_expr_unary", "bool_expr_single_in", "bool_expr_multi_in", "bool_expr_binary",
		"bool_expr_logical_operator", "bool_expr_binary_operator", "expr", "expr_atom",
		"expr_interval", "interval_item", "expr_concat", "expr_concat_item",
		"expr_case", "expr_case_simple", "expr_case_searched", "expr_cursor_attribute",
		"expr_agg_window_func", "expr_func_all_distinct", "expr_func_over_clause",
		"expr_func_partition_by_clause", "expr_spec_func", "expr_func", "expr_dot",
		"expr_dot_method_call", "expr_dot_property_access", "expr_func_params",
		"func_param", "expr_select", "expr_file", "hive", "hive_item", "host",
		"host_cmd", "host_stmt", "file_name", "date_literal", "timestamp_literal",
		"ident", "qident", "string", "int_number", "dec_number", "bool_literal",
		"null_const", "non_reserved_words",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 381, 3450, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 1, 0, 1, 0, 1, 0,
		1, 1, 1, 1, 3, 1, 482, 8, 1, 1, 1, 3, 1, 485, 8, 1, 4, 1, 487, 8, 1, 11,
		1, 12, 1, 488, 1, 2, 3, 2, 492, 8, 2, 1, 2, 1, 2, 1, 2, 3, 2, 497, 8, 2,
		1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 3, 3, 504, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		3, 3, 510, 8, 3, 3, 3, 512, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 4, 5, 519,
		8, 5, 11, 5, 12, 5, 520, 1, 5, 3, 5, 524, 8, 5, 3, 5, 526, 8, 5, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 3, 6, 591, 8, 6, 1, 7, 1, 7, 1, 8, 1, 8, 4, 8, 597, 8, 8, 11,
		8, 12, 8, 598, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 11,
		1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 3, 12, 615, 8, 12, 1, 12, 1, 12, 1,
		12, 5, 12, 620, 8, 12, 10, 12, 12, 12, 623, 9, 12, 3, 12, 625, 8, 12, 1,
		13, 1, 13, 1, 13, 1, 13, 3, 13, 631, 8, 13, 1, 14, 1, 14, 3, 14, 635, 8,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 644, 8, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 649, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 660, 8, 16, 10, 16, 12, 16, 663,
		9, 16, 1, 16, 1, 16, 3, 16, 667, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 5, 16, 674, 8, 16, 10, 16, 12, 16, 677, 9, 16, 1, 16, 1, 16, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 686, 8, 17, 10, 17, 12, 17, 689, 9,
		17, 1, 17, 1, 17, 3, 17, 693, 8, 17, 1, 17, 3, 17, 696, 8, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		3, 18, 710, 8, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 3, 19, 717, 8, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 724, 8, 19, 10, 19, 12, 19, 727,
		9, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1,
		21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 743, 8, 22, 1, 23, 1, 23, 1, 23,
		1, 23, 5, 23, 749, 8, 23, 10, 23, 12, 23, 752, 9, 23, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 5, 24, 760, 8, 24, 10, 24, 12, 24, 763, 9, 24,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 770, 8, 25, 10, 25, 12, 25, 773,
		9, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 780, 8, 26, 1, 27, 1,
		27, 1, 27, 5, 27, 785, 8, 27, 10, 27, 12, 27, 788, 9, 27, 1, 27, 3, 27,
		791, 8, 27, 1, 27, 1, 27, 3, 27, 795, 8, 27, 1, 27, 5, 27, 798, 8, 27,
		10, 27, 12, 27, 801, 9, 27, 1, 27, 3, 27, 804, 8, 27, 1, 27, 1, 27, 1,
		27, 3, 27, 809, 8, 27, 1, 27, 1, 27, 3, 27, 813, 8, 27, 1, 27, 1, 27, 3,
		27, 817, 8, 27, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		3, 29, 827, 8, 29, 1, 29, 1, 29, 3, 29, 831, 8, 29, 1, 29, 1, 29, 1, 29,
		3, 29, 836, 8, 29, 1, 30, 1, 30, 1, 30, 3, 30, 841, 8, 30, 1, 30, 1, 30,
		3, 30, 845, 8, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 1, 32, 1, 32, 3, 32, 858, 8, 32, 1, 32, 1, 32, 1, 33, 3, 33,
		863, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 869, 8, 33, 1, 33, 1, 33,
		1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 878, 8, 34, 1, 34, 1, 34, 3,
		34, 882, 8, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 890, 8,
		35, 1, 35, 3, 35, 893, 8, 35, 1, 35, 1, 35, 1, 35, 3, 35, 898, 8, 35, 1,
		35, 1, 35, 1, 36, 3, 36, 903, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		3, 36, 910, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3,
		36, 919, 8, 36, 1, 36, 3, 36, 922, 8, 36, 1, 37, 1, 37, 1, 37, 5, 37, 927,
		8, 37, 10, 37, 12, 37, 930, 9, 37, 1, 38, 1, 38, 1, 38, 3, 38, 935, 8,
		38, 1, 38, 5, 38, 938, 8, 38, 10, 38, 12, 38, 941, 9, 38, 1, 38, 5, 38,
		944, 8, 38, 10, 38, 12, 38, 947, 9, 38, 1, 38, 1, 38, 3, 38, 951, 8, 38,
		1, 38, 3, 38, 954, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 3, 39, 964, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40,
		3, 40, 972, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1,
		43, 3, 43, 982, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 5, 43, 994, 8, 43, 10, 43, 12, 43, 997, 9, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 1004, 8, 43, 10, 43, 12, 43, 1007,
		9, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1012, 8, 43, 1, 44, 1, 44, 1, 44, 3,
		44, 1017, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1022, 8, 44, 1, 44, 1, 44,
		1, 44, 3, 44, 1027, 8, 44, 5, 44, 1029, 8, 44, 10, 44, 12, 44, 1032, 9,
		44, 1, 44, 1, 44, 3, 44, 1036, 8, 44, 1, 44, 3, 44, 1039, 8, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 1047, 8, 44, 10, 44, 12, 44,
		1050, 9, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 1059,
		8, 44, 10, 44, 12, 44, 1062, 9, 44, 1, 44, 1, 44, 5, 44, 1066, 8, 44, 10,
		44, 12, 44, 1069, 9, 44, 3, 44, 1071, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1083, 8, 45, 1, 46, 4,
		46, 1086, 8, 46, 11, 46, 12, 46, 1087, 1, 47, 1, 47, 1, 47, 3, 47, 1093,
		8, 47, 1, 48, 3, 48, 1096, 8, 48, 1, 48, 1, 48, 1, 49, 4, 49, 1101, 8,
		49, 11, 49, 12, 49, 1102, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 3, 50, 1115, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51,
		1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 4, 51, 1128, 8, 51, 11,
		51, 12, 51, 1129, 1, 51, 1, 51, 1, 51, 3, 51, 1135, 8, 51, 1, 52, 3, 52,
		1138, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 5, 52, 1151, 8, 52, 10, 52, 12, 52, 1154, 9, 52, 1, 52,
		1, 52, 1, 52, 3, 52, 1159, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 3, 52, 1170, 8, 52, 1, 53, 3, 53, 1173, 8, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 1181, 8, 53, 10, 53, 12,
		53, 1184, 9, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1190, 8, 53, 1, 54,
		1, 54, 1, 54, 1, 54, 3, 54, 1196, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 5,
		55, 1202, 8, 55, 10, 55, 12, 55, 1205, 9, 55, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 1214, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 1234, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 3,
		57, 1240, 8, 57, 1, 58, 1, 58, 3, 58, 1244, 8, 58, 1, 58, 1, 58, 1, 58,
		3, 58, 1249, 8, 58, 1, 58, 1, 58, 3, 58, 1253, 8, 58, 1, 58, 1, 58, 1,
		58, 3, 58, 1258, 8, 58, 1, 58, 3, 58, 1261, 8, 58, 1, 58, 1, 58, 1, 58,
		3, 58, 1266, 8, 58, 1, 58, 3, 58, 1269, 8, 58, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 3, 61, 1281, 8, 61, 1, 61,
		1, 61, 1, 62, 1, 62, 1, 62, 3, 62, 1288, 8, 62, 1, 62, 1, 62, 1, 62, 3,
		62, 1293, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1298, 8, 62, 5, 62, 1300,
		8, 62, 10, 62, 12, 62, 1303, 9, 62, 1, 62, 1, 62, 3, 62, 1307, 8, 62, 1,
		62, 3, 62, 1310, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62,
		1318, 8, 62, 10, 62, 12, 62, 1321, 9, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 5, 62, 1330, 8, 62, 10, 62, 12, 62, 1333, 9, 62, 1, 62,
		1, 62, 5, 62, 1337, 8, 62, 10, 62, 12, 62, 1340, 9, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 3, 62, 1347, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1362, 8,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1393,
		8, 63, 3, 63, 1395, 8, 63, 1, 64, 1, 64, 1, 64, 3, 64, 1400, 8, 64, 1,
		64, 1, 64, 3, 64, 1404, 8, 64, 1, 64, 1, 64, 1, 65, 3, 65, 1409, 8, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1416, 8, 65, 1, 65, 3, 65, 1419,
		8, 65, 1, 66, 3, 66, 1422, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1427, 8,
		66, 1, 66, 1, 66, 3, 66, 1431, 8, 66, 3, 66, 1433, 8, 66, 1, 67, 1, 67,
		1, 67, 1, 67, 1, 67, 3, 67, 1440, 8, 67, 1, 67, 1, 67, 5, 67, 1444, 8,
		67, 10, 67, 12, 67, 1447, 9, 67, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1453,
		8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1459, 8, 69, 1, 69, 3, 69, 1462,
		8, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1467, 8, 69, 1, 69, 1, 69, 3, 69, 1471,
		8, 69, 1, 69, 3, 69, 1474, 8, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 3,
		70, 1481, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1487, 8, 71, 1, 71,
		3, 71, 1490, 8, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1,
		71, 3, 71, 1500, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 5, 72, 1507,
		8, 72, 10, 72, 12, 72, 1510, 9, 72, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73,
		1516, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1523, 8, 73, 3,
		73, 1525, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1531, 8, 74, 1, 74,
		3, 74, 1534, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 3, 74, 1545, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 5, 75,
		1552, 8, 75, 10, 75, 12, 75, 1555, 9, 75, 1, 76, 1, 76, 1, 76, 3, 76, 1560,
		8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1566, 8, 77, 1, 77, 3, 77, 1569,
		8, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1574, 8, 77, 1, 77, 3, 77, 1577, 8,
		77, 1, 77, 3, 77, 1580, 8, 77, 1, 77, 3, 77, 1583, 8, 77, 1, 77, 3, 77,
		1586, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1592, 8, 77, 1, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 1600, 8, 78, 10, 78, 12, 78, 1603,
		9, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 1611, 8, 78, 10,
		78, 12, 78, 1614, 9, 78, 3, 78, 1616, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79,
		1, 79, 3, 79, 1623, 8, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1628, 8, 79, 1,
		79, 5, 79, 1631, 8, 79, 10, 79, 12, 79, 1634, 9, 79, 1, 79, 3, 79, 1637,
		8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1645, 8, 79, 1,
		79, 1, 79, 3, 79, 1649, 8, 79, 1, 79, 5, 79, 1652, 8, 79, 10, 79, 12, 79,
		1655, 9, 79, 1, 79, 3, 79, 1658, 8, 79, 3, 79, 1660, 8, 79, 1, 80, 4, 80,
		1663, 8, 80, 11, 80, 12, 80, 1664, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1,
		81, 3, 81, 1673, 8, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1678, 8, 81, 1, 82,
		1, 82, 1, 82, 1, 82, 3, 82, 1684, 8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1,
		82, 3, 82, 1691, 8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1698,
		8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1705, 8, 82, 1, 82, 3,
		82, 1708, 8, 82, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 3, 84, 1715, 8, 84,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1723, 8, 84, 1, 84, 1,
		84, 1, 84, 1, 84, 5, 84, 1729, 8, 84, 10, 84, 12, 84, 1732, 9, 84, 3, 84,
		1734, 8, 84, 1, 84, 3, 84, 1737, 8, 84, 1, 85, 1, 85, 1, 85, 3, 85, 1742,
		8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 1749, 8, 86, 10, 86, 12,
		86, 1752, 9, 86, 1, 86, 3, 86, 1755, 8, 86, 1, 86, 1, 86, 1, 86, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1765, 8, 87, 1, 88, 1, 88, 1, 88, 1,
		88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90,
		1, 91, 1, 91, 1, 91, 3, 91, 1784, 8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 3, 92, 1791, 8, 92, 3, 92, 1793, 8, 92, 1, 92, 1, 92, 3, 92, 1797,
		8, 92, 1, 92, 1, 92, 3, 92, 1801, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 5,
		93, 1807, 8, 93, 10, 93, 12, 93, 1810, 9, 93, 1, 93, 1, 93, 1, 94, 1, 94,
		1, 94, 1, 94, 5, 94, 1818, 8, 94, 10, 94, 12, 94, 1821, 9, 94, 1, 95, 1,
		95, 1, 95, 1, 95, 5, 95, 1827, 8, 95, 10, 95, 12, 95, 1830, 9, 95, 1, 95,
		1, 95, 1, 96, 1, 96, 1, 96, 3, 96, 1837, 8, 96, 1, 96, 1, 96, 1, 96, 1,
		96, 1, 97, 1, 97, 3, 97, 1845, 8, 97, 1, 97, 1, 97, 3, 97, 1849, 8, 97,
		1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 3, 99, 1857, 8, 99, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		102, 1, 102, 1, 102, 1, 102, 5, 102, 1873, 8, 102, 10, 102, 12, 102, 1876,
		9, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103,
		1, 103, 1, 104, 1, 104, 3, 104, 1889, 8, 104, 1, 105, 1, 105, 1, 105, 1,
		105, 1, 105, 3, 105, 1896, 8, 105, 1, 105, 1, 105, 3, 105, 1900, 8, 105,
		1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1907, 8, 106, 3, 106, 1909,
		8, 106, 1, 107, 1, 107, 3, 107, 1913, 8, 107, 1, 107, 1, 107, 3, 107, 1917,
		8, 107, 1, 107, 1, 107, 1, 107, 1, 107, 5, 107, 1923, 8, 107, 10, 107,
		12, 107, 1926, 9, 107, 1, 107, 3, 107, 1929, 8, 107, 1, 108, 1, 108, 1,
		108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1939, 8, 109, 1, 110,
		1, 110, 1, 110, 1, 110, 1, 110, 5, 110, 1946, 8, 110, 10, 110, 12, 110,
		1949, 9, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 3, 113, 1964, 8, 113, 1, 113,
		1, 113, 1, 113, 1, 113, 3, 113, 1970, 8, 113, 1, 113, 1, 113, 3, 113, 1974,
		8, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 5, 114, 1982, 8,
		114, 10, 114, 12, 114, 1985, 9, 114, 1, 114, 1, 114, 1, 114, 5, 114, 1990,
		8, 114, 10, 114, 12, 114, 1993, 9, 114, 1, 115, 1, 115, 1, 115, 1, 115,
		1, 115, 1, 115, 3, 115, 2001, 8, 115, 1, 115, 1, 115, 3, 115, 2005, 8,
		115, 1, 115, 1, 115, 5, 115, 2009, 8, 115, 10, 115, 12, 115, 2012, 9, 115,
		1, 116, 1, 116, 3, 116, 2016, 8, 116, 1, 117, 1, 117, 3, 117, 2020, 8,
		117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3,
		118, 2030, 8, 118, 1, 119, 1, 119, 1, 120, 1, 120, 3, 120, 2036, 8, 120,
		1, 121, 1, 121, 3, 121, 2040, 8, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1,
		121, 1, 121, 1, 121, 1, 121, 5, 121, 2050, 8, 121, 10, 121, 12, 121, 2053,
		9, 121, 1, 121, 1, 121, 1, 122, 1, 122, 3, 122, 2059, 8, 122, 1, 123, 1,
		123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1,
		124, 1, 124, 5, 124, 2073, 8, 124, 10, 124, 12, 124, 2076, 9, 124, 1, 124,
		1, 124, 5, 124, 2080, 8, 124, 10, 124, 12, 124, 2083, 9, 124, 1, 125, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 2092, 8, 125, 1, 126,
		3, 126, 2095, 8, 126, 1, 126, 1, 126, 3, 126, 2099, 8, 126, 1, 127, 1,
		127, 1, 128, 1, 128, 1, 128, 3, 128, 2106, 8, 128, 1, 128, 1, 128, 1, 128,
		1, 128, 1, 128, 3, 128, 2113, 8, 128, 3, 128, 2115, 8, 128, 1, 129, 1,
		129, 3, 129, 2119, 8, 129, 1, 130, 1, 130, 3, 130, 2123, 8, 130, 1, 131,
		1, 131, 1, 131, 3, 131, 2128, 8, 131, 1, 132, 3, 132, 2131, 8, 132, 1,
		132, 1, 132, 3, 132, 2135, 8, 132, 1, 132, 3, 132, 2138, 8, 132, 1, 132,
		1, 132, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134,
		2149, 8, 134, 1, 134, 3, 134, 2152, 8, 134, 1, 134, 1, 134, 1, 134, 1,
		135, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136, 3, 136, 2163, 8, 136, 1, 136,
		1, 136, 1, 136, 1, 136, 3, 136, 2169, 8, 136, 1, 136, 1, 136, 3, 136, 2173,
		8, 136, 3, 136, 2175, 8, 136, 1, 137, 1, 137, 3, 137, 2179, 8, 137, 1,
		137, 1, 137, 1, 138, 1, 138, 1, 138, 1, 139, 1, 139, 3, 139, 2188, 8, 139,
		1, 139, 1, 139, 1, 139, 5, 139, 2193, 8, 139, 10, 139, 12, 139, 2196, 9,
		139, 1, 139, 3, 139, 2199, 8, 139, 1, 139, 1, 139, 3, 139, 2203, 8, 139,
		1, 139, 1, 139, 1, 139, 5, 139, 2208, 8, 139, 10, 139, 12, 139, 2211, 9,
		139, 1, 139, 3, 139, 2214, 8, 139, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140,
		1, 140, 3, 140, 2222, 8, 140, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1,
		142, 1, 142, 1, 142, 1, 142, 3, 142, 2233, 8, 142, 1, 142, 1, 142, 3, 142,
		2237, 8, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 143, 1, 143, 1,
		143, 1, 143, 3, 143, 2248, 8, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143,
		3, 143, 2255, 8, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 144, 1,
		144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 2268, 8, 144, 1, 145, 1, 145,
		1, 145, 1, 145, 5, 145, 2274, 8, 145, 10, 145, 12, 145, 2277, 9, 145, 1,
		146, 3, 146, 2280, 8, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1, 147, 1, 147,
		5, 147, 2288, 8, 147, 10, 147, 12, 147, 2291, 9, 147, 1, 148, 1, 148, 3,
		148, 2295, 8, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149,
		1, 149, 1, 149, 5, 149, 2306, 8, 149, 10, 149, 12, 149, 2309, 9, 149, 1,
		149, 1, 149, 1, 150, 1, 150, 1, 150, 1, 150, 5, 150, 2317, 8, 150, 10,
		150, 12, 150, 2320, 9, 150, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3,
		151, 2327, 8, 151, 1, 152, 1, 152, 3, 152, 2331, 8, 152, 1, 152, 1, 152,
		3, 152, 2335, 8, 152, 1, 152, 1, 152, 3, 152, 2339, 8, 152, 3, 152, 2341,
		8, 152, 1, 153, 1, 153, 1, 153, 3, 153, 2346, 8, 153, 1, 153, 3, 153, 2349,
		8, 153, 1, 153, 3, 153, 2352, 8, 153, 1, 153, 3, 153, 2355, 8, 153, 1,
		153, 1, 153, 3, 153, 2359, 8, 153, 1, 153, 3, 153, 2362, 8, 153, 1, 153,
		3, 153, 2365, 8, 153, 1, 154, 3, 154, 2368, 8, 154, 1, 154, 3, 154, 2371,
		8, 154, 1, 154, 1, 154, 1, 154, 5, 154, 2376, 8, 154, 10, 154, 12, 154,
		2379, 9, 154, 1, 155, 1, 155, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157, 1,
		157, 3, 157, 2389, 8, 157, 1, 157, 1, 157, 3, 157, 2393, 8, 157, 1, 157,
		3, 157, 2396, 8, 157, 1, 158, 1, 158, 3, 158, 2400, 8, 158, 1, 158, 1,
		158, 1, 158, 1, 158, 1, 158, 3, 158, 2407, 8, 158, 1, 159, 1, 159, 3, 159,
		2411, 8, 159, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1,
		161, 3, 161, 2421, 8, 161, 1, 161, 1, 161, 1, 161, 3, 161, 2426, 8, 161,
		1, 161, 1, 161, 1, 161, 3, 161, 2431, 8, 161, 5, 161, 2433, 8, 161, 10,
		161, 12, 161, 2436, 9, 161, 1, 162, 1, 162, 1, 162, 1, 163, 1, 163, 1,
		163, 5, 163, 2444, 8, 163, 10, 163, 12, 163, 2447, 9, 163, 1, 164, 1, 164,
		1, 164, 3, 164, 2452, 8, 164, 1, 165, 1, 165, 3, 165, 2456, 8, 165, 1,
		166, 1, 166, 1, 166, 1, 166, 3, 166, 2462, 8, 166, 1, 167, 1, 167, 1, 167,
		1, 167, 1, 167, 1, 167, 1, 167, 3, 167, 2471, 8, 167, 1, 168, 3, 168, 2474,
		8, 168, 1, 168, 1, 168, 1, 168, 3, 168, 2479, 8, 168, 1, 168, 3, 168, 2482,
		8, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 2490, 8,
		169, 10, 169, 12, 169, 2493, 9, 169, 1, 169, 1, 169, 3, 169, 2497, 8, 169,
		1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 5, 170, 2504, 8, 170, 10, 170,
		12, 170, 2507, 9, 170, 1, 170, 1, 170, 3, 170, 2511, 8, 170, 1, 171, 1,
		171, 3, 171, 2515, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 5, 171,
		2522, 8, 171, 10, 171, 12, 171, 2525, 9, 171, 1, 171, 3, 171, 2528, 8,
		171, 1, 172, 1, 172, 1, 173, 1, 173, 1, 173, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 5, 174, 2540, 8, 174, 10, 174, 12, 174, 2543, 9, 174, 1, 175,
		1, 175, 1, 175, 1, 176, 1, 176, 1, 176, 1, 177, 1, 177, 1, 177, 1, 177,
		3, 177, 2555, 8, 177, 1, 177, 1, 177, 1, 177, 3, 177, 2560, 8, 177, 5,
		177, 2562, 8, 177, 10, 177, 12, 177, 2565, 9, 177, 1, 178, 4, 178, 2568,
		8, 178, 11, 178, 12, 178, 2569, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179,
		1, 179, 1, 179, 1, 179, 1, 179, 3, 179, 2581, 8, 179, 3, 179, 2583, 8,
		179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 2590, 8, 180, 1, 180,
		3, 180, 2593, 8, 180, 1, 181, 1, 181, 1, 181, 5, 181, 2598, 8, 181, 10,
		181, 12, 181, 2601, 9, 181, 1, 182, 1, 182, 3, 182, 2605, 8, 182, 1, 182,
		1, 182, 1, 182, 1, 182, 3, 182, 2611, 8, 182, 1, 182, 3, 182, 2614, 8,
		182, 1, 182, 3, 182, 2617, 8, 182, 1, 183, 1, 183, 1, 183, 1, 184, 1, 184,
		1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 4, 184, 2630, 8, 184, 11,
		184, 12, 184, 2631, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 2639,
		8, 185, 1, 185, 3, 185, 2642, 8, 185, 1, 185, 3, 185, 2645, 8, 185, 1,
		186, 1, 186, 3, 186, 2649, 8, 186, 1, 186, 1, 186, 1, 186, 3, 186, 2654,
		8, 186, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 2660, 8, 186, 1, 187, 1,
		187, 3, 187, 2664, 8, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187,
		1, 187, 5, 187, 2673, 8, 187, 10, 187, 12, 187, 2676, 9, 187, 1, 187, 3,
		187, 2679, 8, 187, 1, 187, 3, 187, 2682, 8, 187, 1, 188, 1, 188, 3, 188,
		2686, 8, 188, 1, 188, 1, 188, 3, 188, 2690, 8, 188, 1, 188, 1, 188, 3,
		188, 2694, 8, 188, 1, 189, 1, 189, 3, 189, 2698, 8, 189, 1, 189, 1, 189,
		1, 190, 1, 190, 3, 190, 2704, 8, 190, 1, 190, 1, 190, 1, 191, 1, 191, 3,
		191, 2710, 8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 2717,
		8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 5, 191, 2723, 8, 191, 10, 191,
		12, 191, 2726, 9, 191, 1, 192, 1, 192, 1, 192, 3, 192, 2731, 8, 192, 1,
		193, 1, 193, 1, 193, 3, 193, 2736, 8, 193, 1, 193, 1, 193, 1, 193, 1, 193,
		1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 2747, 8, 193, 1, 193, 1,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 2756, 8, 193, 1, 194,
		1, 194, 3, 194, 2760, 8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 5,
		194, 2767, 8, 194, 10, 194, 12, 194, 2770, 9, 194, 1, 194, 3, 194, 2773,
		8, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 195, 1, 195, 5, 195, 2781, 8,
		195, 10, 195, 12, 195, 2784, 9, 195, 1, 195, 1, 195, 3, 195, 2788, 8, 195,
		1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1, 196, 1, 196,
		1, 197, 1, 197, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198,
		1, 198, 1, 198, 3, 198, 2810, 8, 198, 1, 198, 3, 198, 2813, 8, 198, 1,
		199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3,
		199, 2833, 8, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199,
		1, 199, 5, 199, 2843, 8, 199, 10, 199, 12, 199, 2846, 9, 199, 1, 200, 1,
		200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2856, 8, 200,
		1, 201, 1, 201, 1, 201, 1, 201, 1, 202, 1, 202, 1, 203, 1, 203, 1, 203,
		1, 203, 1, 203, 5, 203, 2869, 8, 203, 10, 203, 12, 203, 2872, 9, 203, 1,
		204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1,
		204, 3, 204, 2884, 8, 204, 1, 205, 1, 205, 3, 205, 2888, 8, 205, 1, 206,
		1, 206, 1, 206, 1, 206, 1, 206, 1, 206, 1, 206, 4, 206, 2897, 8, 206, 11,
		206, 12, 206, 2898, 1, 206, 1, 206, 3, 206, 2903, 8, 206, 1, 206, 1, 206,
		1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 4, 207, 2913, 8, 207, 11,
		207, 12, 207, 2914, 1, 207, 1, 207, 3, 207, 2919, 8, 207, 1, 207, 1, 207,
		1, 208, 1, 208, 1, 208, 1, 208, 1, 209, 1, 209, 1, 209, 3, 209, 2930, 8,
		209, 1, 209, 1, 209, 1, 209, 3, 209, 2935, 8, 209, 1, 209, 1, 209, 1, 209,
		3, 209, 2940, 8, 209, 1, 209, 1, 209, 3, 209, 2944, 8, 209, 1, 209, 1,
		209, 3, 209, 2948, 8, 209, 1, 209, 1, 209, 1, 209, 3, 209, 2953, 8, 209,
		1, 209, 1, 209, 3, 209, 2957, 8, 209, 1, 209, 1, 209, 3, 209, 2961, 8,
		209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 209, 3, 209, 2984, 8, 209, 3, 209, 2986, 8, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 3004, 8,
		209, 3, 209, 3006, 8, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
		3, 209, 3014, 8, 209, 1, 209, 1, 209, 1, 209, 3, 209, 3019, 8, 209, 1,
		209, 1, 209, 1, 209, 3, 209, 3024, 8, 209, 1, 209, 1, 209, 1, 209, 3, 209,
		3029, 8, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 209, 3, 209, 3042, 8, 209, 1, 209, 1, 209, 1, 209,
		3, 209, 3047, 8, 209, 1, 209, 1, 209, 1, 209, 3, 209, 3052, 8, 209, 1,
		209, 1, 209, 1, 209, 3, 209, 3057, 8, 209, 1, 209, 1, 209, 1, 209, 3, 209,
		3062, 8, 209, 1, 209, 1, 209, 1, 209, 3, 209, 3067, 8, 209, 1, 209, 1,
		209, 1, 209, 3, 209, 3072, 8, 209, 1, 209, 1, 209, 1, 209, 3, 209, 3077,
		8, 209, 3, 209, 3079, 8, 209, 1, 210, 1, 210, 1, 211, 1, 211, 1, 211, 3,
		211, 3086, 8, 211, 1, 211, 3, 211, 3089, 8, 211, 1, 211, 1, 211, 1, 212,
		1, 212, 1, 212, 1, 212, 1, 212, 5, 212, 3098, 8, 212, 10, 212, 12, 212,
		3101, 9, 212, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3,
		213, 3110, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213,
		3118, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3,
		213, 3127, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213, 3133, 8, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 5, 213, 3148, 8, 213, 10, 213, 12, 213,
		3151, 9, 213, 3, 213, 3153, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 5, 213, 3167,
		8, 213, 10, 213, 12, 213, 3170, 9, 213, 3, 213, 3172, 8, 213, 1, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1,
		213, 1, 213, 5, 213, 3186, 8, 213, 10, 213, 12, 213, 3189, 9, 213, 3, 213,
		3191, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 1, 213, 5, 213, 3205, 8, 213, 10, 213, 12,
		213, 3208, 9, 213, 3, 213, 3210, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 5, 213,
		3224, 8, 213, 10, 213, 12, 213, 3227, 9, 213, 3, 213, 3229, 8, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1,
		213, 1, 213, 1, 213, 5, 213, 3243, 8, 213, 10, 213, 12, 213, 3246, 9, 213,
		3, 213, 3248, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 5, 213, 3260, 8, 213, 10, 213, 12, 213, 3263,
		9, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 4, 213, 3275, 8, 213, 11, 213, 12, 213, 3276, 1, 213, 1,
		213, 3, 213, 3281, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213,
		3297, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213, 3303, 8, 213, 1,
		214, 1, 214, 1, 214, 3, 214, 3308, 8, 214, 1, 214, 1, 214, 1, 215, 1, 215,
		3, 215, 3314, 8, 215, 1, 216, 1, 216, 3, 216, 3318, 8, 216, 1, 216, 1,
		216, 1, 216, 1, 217, 1, 217, 3, 217, 3325, 8, 217, 1, 217, 1, 217, 1, 217,
		1, 218, 1, 218, 1, 218, 5, 218, 3333, 8, 218, 10, 218, 12, 218, 3336, 9,
		218, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 3342, 8, 219, 3, 219, 3344,
		8, 219, 1, 219, 1, 219, 1, 220, 1, 220, 3, 220, 3350, 8, 220, 1, 221, 1,
		221, 3, 221, 3354, 8, 221, 1, 222, 1, 222, 5, 222, 3358, 8, 222, 10, 222,
		12, 222, 3361, 9, 222, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223,
		1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 3, 223, 3375, 8, 223, 1,
		224, 1, 224, 1, 224, 1, 224, 1, 224, 3, 224, 3382, 8, 224, 1, 225, 5, 225,
		3385, 8, 225, 10, 225, 12, 225, 3388, 9, 225, 1, 226, 1, 226, 1, 226, 1,
		227, 1, 227, 1, 227, 1, 227, 3, 227, 3397, 8, 227, 1, 227, 1, 227, 1, 227,
		5, 227, 3402, 8, 227, 10, 227, 12, 227, 3405, 9, 227, 3, 227, 3407, 8,
		227, 1, 228, 1, 228, 1, 228, 1, 229, 1, 229, 1, 229, 1, 230, 3, 230, 3416,
		8, 230, 1, 230, 1, 230, 3, 230, 3420, 8, 230, 1, 231, 1, 231, 1, 231, 5,
		231, 3425, 8, 231, 10, 231, 12, 231, 3428, 9, 231, 1, 232, 1, 232, 3, 232,
		3432, 8, 232, 1, 233, 3, 233, 3435, 8, 233, 1, 233, 1, 233, 1, 234, 3,
		234, 3440, 8, 234, 1, 234, 1, 234, 1, 235, 1, 235, 1, 236, 1, 236, 1, 237,
		1, 237, 1, 237, 1, 3386, 2, 382, 398, 238, 0, 2, 4, 6, 8, 10, 12, 14, 16,
		18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
		54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
		90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
		212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
		242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
		272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300,
		302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330,
		332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360,
		362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390,
		392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420,
		422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450,
		452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 0, 51, 3, 0,
		1, 2, 352, 352, 370, 370, 2, 0, 98, 98, 314, 314, 1, 0, 168, 169, 3, 0,
		13, 13, 115, 115, 153, 153, 2, 0, 33, 33, 41, 41, 2, 0, 55, 55, 107, 107,
		2, 0, 185, 185, 258, 258, 2, 0, 245, 245, 300, 300, 2, 0, 14, 14, 83, 83,
		2, 0, 80, 80, 303, 303, 2, 0, 108, 108, 171, 171, 2, 0, 80, 80, 218, 218,
		2, 0, 76, 76, 136, 136, 3, 0, 140, 140, 178, 178, 214, 215, 2, 0, 173,
		173, 192, 192, 2, 0, 189, 189, 322, 322, 2, 0, 177, 177, 375, 375, 2, 0,
		31, 31, 38, 38, 2, 0, 36, 36, 62, 62, 2, 0, 66, 66, 251, 251, 2, 0, 13,
		13, 153, 153, 1, 0, 236, 237, 1, 0, 221, 222, 4, 0, 61, 61, 78, 78, 152,
		152, 211, 211, 2, 0, 121, 121, 222, 222, 1, 0, 102, 103, 1, 0, 95, 96,
		1, 0, 274, 275, 2, 0, 246, 246, 282, 282, 3, 0, 80, 80, 135, 135, 210,
		210, 4, 0, 11, 12, 190, 190, 226, 226, 320, 320, 2, 0, 200, 200, 202, 202,
		2, 0, 259, 259, 297, 297, 4, 0, 20, 20, 90, 90, 174, 174, 290, 290, 2,
		0, 174, 174, 316, 316, 2, 0, 30, 30, 276, 276, 1, 0, 256, 257, 2, 0, 7,
		7, 88, 88, 3, 0, 120, 120, 162, 162, 239, 239, 3, 0, 62, 62, 247, 248,
		304, 304, 3, 0, 105, 105, 262, 262, 303, 303, 1, 0, 83, 84, 2, 0, 10, 10,
		205, 205, 3, 0, 163, 163, 230, 230, 240, 240, 2, 0, 352, 352, 363, 363,
		2, 0, 348, 348, 371, 371, 3, 0, 70, 71, 181, 182, 252, 253, 2, 0, 52, 52,
		351, 351, 3, 0, 118, 118, 154, 154, 195, 195, 2, 0, 109, 109, 298, 298,
		14, 0, 5, 24, 26, 93, 97, 97, 99, 182, 184, 195, 197, 200, 202, 215, 217,
		244, 246, 265, 267, 292, 294, 299, 302, 313, 316, 333, 340, 347, 3880,
		0, 476, 1, 0, 0, 0, 2, 486, 1, 0, 0, 0, 4, 491, 1, 0, 0, 0, 6, 511, 1,
		0, 0, 0, 8, 513, 1, 0, 0, 0, 10, 525, 1, 0, 0, 0, 12, 590, 1, 0, 0, 0,
		14, 592, 1, 0, 0, 0, 16, 594, 1, 0, 0, 0, 18, 600, 1, 0, 0, 0, 20, 606,
		1, 0, 0, 0, 22, 608, 1, 0, 0, 0, 24, 624, 1, 0, 0, 0, 26, 630, 1, 0, 0,
		0, 28, 648, 1, 0, 0, 0, 30, 650, 1, 0, 0, 0, 32, 655, 1, 0, 0, 0, 34, 692,
		1, 0, 0, 0, 36, 702, 1, 0, 0, 0, 38, 713, 1, 0, 0, 0, 40, 733, 1, 0, 0,
		0, 42, 736, 1, 0, 0, 0, 44, 738, 1, 0, 0, 0, 46, 744, 1, 0, 0, 0, 48, 753,
		1, 0, 0, 0, 50, 764, 1, 0, 0, 0, 52, 779, 1, 0, 0, 0, 54, 816, 1, 0, 0,
		0, 56, 818, 1, 0, 0, 0, 58, 826, 1, 0, 0, 0, 60, 837, 1, 0, 0, 0, 62, 846,
		1, 0, 0, 0, 64, 849, 1, 0, 0, 0, 66, 862, 1, 0, 0, 0, 68, 872, 1, 0, 0,
		0, 70, 885, 1, 0, 0, 0, 72, 918, 1, 0, 0, 0, 74, 923, 1, 0, 0, 0, 76, 953,
		1, 0, 0, 0, 78, 955, 1, 0, 0, 0, 80, 971, 1, 0, 0, 0, 82, 973, 1, 0, 0,
		0, 84, 977, 1, 0, 0, 0, 86, 1011, 1, 0, 0, 0, 88, 1070, 1, 0, 0, 0, 90,
		1072, 1, 0, 0, 0, 92, 1085, 1, 0, 0, 0, 94, 1092, 1, 0, 0, 0, 96, 1095,
		1, 0, 0, 0, 98, 1100, 1, 0, 0, 0, 100, 1114, 1, 0, 0, 0, 102, 1134, 1,
		0, 0, 0, 104, 1169, 1, 0, 0, 0, 106, 1189, 1, 0, 0, 0, 108, 1195, 1, 0,
		0, 0, 110, 1197, 1, 0, 0, 0, 112, 1233, 1, 0, 0, 0, 114, 1239, 1, 0, 0,
		0, 116, 1268, 1, 0, 0, 0, 118, 1270, 1, 0, 0, 0, 120, 1275, 1, 0, 0, 0,
		122, 1277, 1, 0, 0, 0, 124, 1346, 1, 0, 0, 0, 126, 1394, 1, 0, 0, 0, 128,
		1396, 1, 0, 0, 0, 130, 1418, 1, 0, 0, 0, 132, 1432, 1, 0, 0, 0, 134, 1434,
		1, 0, 0, 0, 136, 1452, 1, 0, 0, 0, 138, 1461, 1, 0, 0, 0, 140, 1477, 1,
		0, 0, 0, 142, 1489, 1, 0, 0, 0, 144, 1501, 1, 0, 0, 0, 146, 1524, 1, 0,
		0, 0, 148, 1533, 1, 0, 0, 0, 150, 1546, 1, 0, 0, 0, 152, 1559, 1, 0, 0,
		0, 154, 1568, 1, 0, 0, 0, 156, 1615, 1, 0, 0, 0, 158, 1659, 1, 0, 0, 0,
		160, 1662, 1, 0, 0, 0, 162, 1677, 1, 0, 0, 0, 164, 1707, 1, 0, 0, 0, 166,
		1709, 1, 0, 0, 0, 168, 1712, 1, 0, 0, 0, 170, 1741, 1, 0, 0, 0, 172, 1743,
		1, 0, 0, 0, 174, 1759, 1, 0, 0, 0, 176, 1766, 1, 0, 0, 0, 178, 1772, 1,
		0, 0, 0, 180, 1777, 1, 0, 0, 0, 182, 1780, 1, 0, 0, 0, 184, 1785, 1, 0,
		0, 0, 186, 1802, 1, 0, 0, 0, 188, 1813, 1, 0, 0, 0, 190, 1822, 1, 0, 0,
		0, 192, 1833, 1, 0, 0, 0, 194, 1842, 1, 0, 0, 0, 196, 1850, 1, 0, 0, 0,
		198, 1856, 1, 0, 0, 0, 200, 1858, 1, 0, 0, 0, 202, 1864, 1, 0, 0, 0, 204,
		1868, 1, 0, 0, 0, 206, 1881, 1, 0, 0, 0, 208, 1886, 1, 0, 0, 0, 210, 1890,
		1, 0, 0, 0, 212, 1901, 1, 0, 0, 0, 214, 1910, 1, 0, 0, 0, 216, 1930, 1,
		0, 0, 0, 218, 1933, 1, 0, 0, 0, 220, 1940, 1, 0, 0, 0, 222, 1952, 1, 0,
		0, 0, 224, 1955, 1, 0, 0, 0, 226, 1969, 1, 0, 0, 0, 228, 1975, 1, 0, 0,
		0, 230, 1994, 1, 0, 0, 0, 232, 2015, 1, 0, 0, 0, 234, 2019, 1, 0, 0, 0,
		236, 2029, 1, 0, 0, 0, 238, 2031, 1, 0, 0, 0, 240, 2033, 1, 0, 0, 0, 242,
		2037, 1, 0, 0, 0, 244, 2056, 1, 0, 0, 0, 246, 2060, 1, 0, 0, 0, 248, 2062,
		1, 0, 0, 0, 250, 2091, 1, 0, 0, 0, 252, 2094, 1, 0, 0, 0, 254, 2100, 1,
		0, 0, 0, 256, 2102, 1, 0, 0, 0, 258, 2116, 1, 0, 0, 0, 260, 2120, 1, 0,
		0, 0, 262, 2127, 1, 0, 0, 0, 264, 2134, 1, 0, 0, 0, 266, 2141, 1, 0, 0,
		0, 268, 2144, 1, 0, 0, 0, 270, 2156, 1, 0, 0, 0, 272, 2159, 1, 0, 0, 0,
		274, 2176, 1, 0, 0, 0, 276, 2182, 1, 0, 0, 0, 278, 2185, 1, 0, 0, 0, 280,
		2215, 1, 0, 0, 0, 282, 2223, 1, 0, 0, 0, 284, 2228, 1, 0, 0, 0, 286, 2243,
		1, 0, 0, 0, 288, 2267, 1, 0, 0, 0, 290, 2269, 1, 0, 0, 0, 292, 2279, 1,
		0, 0, 0, 294, 2283, 1, 0, 0, 0, 296, 2292, 1, 0, 0, 0, 298, 2301, 1, 0,
		0, 0, 300, 2312, 1, 0, 0, 0, 302, 2326, 1, 0, 0, 0, 304, 2340, 1, 0, 0,
		0, 306, 2342, 1, 0, 0, 0, 308, 2367, 1, 0, 0, 0, 310, 2380, 1, 0, 0, 0,
		312, 2382, 1, 0, 0, 0, 314, 2395, 1, 0, 0, 0, 316, 2406, 1, 0, 0, 0, 318,
		2410, 1, 0, 0, 0, 320, 2414, 1, 0, 0, 0, 322, 2420, 1, 0, 0, 0, 324, 2437,
		1, 0, 0, 0, 326, 2440, 1, 0, 0, 0, 328, 2451, 1, 0, 0, 0, 330, 2453, 1,
		0, 0, 0, 332, 2457, 1, 0, 0, 0, 334, 2470, 1, 0, 0, 0, 336, 2481, 1, 0,
		0, 0, 338, 2483, 1, 0, 0, 0, 340, 2510, 1, 0, 0, 0, 342, 2512, 1, 0, 0,
		0, 344, 2529, 1, 0, 0, 0, 346, 2531, 1, 0, 0, 0, 348, 2534, 1, 0, 0, 0,
		350, 2544, 1, 0, 0, 0, 352, 2547, 1, 0, 0, 0, 354, 2550, 1, 0, 0, 0, 356,
		2567, 1, 0, 0, 0, 358, 2582, 1, 0, 0, 0, 360, 2584, 1, 0, 0, 0, 362, 2594,
		1, 0, 0, 0, 364, 2610, 1, 0, 0, 0, 366, 2618, 1, 0, 0, 0, 368, 2621, 1,
		0, 0, 0, 370, 2638, 1, 0, 0, 0, 372, 2659, 1, 0, 0, 0, 374, 2681, 1, 0,
		0, 0, 376, 2683, 1, 0, 0, 0, 378, 2695, 1, 0, 0, 0, 380, 2701, 1, 0, 0,
		0, 382, 2716, 1, 0, 0, 0, 384, 2730, 1, 0, 0, 0, 386, 2755, 1, 0, 0, 0,
		388, 2757, 1, 0, 0, 0, 390, 2776, 1, 0, 0, 0, 392, 2794, 1, 0, 0, 0, 394,
		2798, 1, 0, 0, 0, 396, 2812, 1, 0, 0, 0, 398, 2832, 1, 0, 0, 0, 400, 2855,
		1, 0, 0, 0, 402, 2857, 1, 0, 0, 0, 404, 2861, 1, 0, 0, 0, 406, 2863, 1,
		0, 0, 0, 408, 2883, 1, 0, 0, 0, 410, 2887, 1, 0, 0, 0, 412, 2889, 1, 0,
		0, 0, 414, 2906, 1, 0, 0, 0, 416, 2922, 1, 0, 0, 0, 418, 3078, 1, 0, 0,
		0, 420, 3080, 1, 0, 0, 0, 422, 3082, 1, 0, 0, 0, 424, 3092, 1, 0, 0, 0,
		426, 3302, 1, 0, 0, 0, 428, 3304, 1, 0, 0, 0, 430, 3313, 1, 0, 0, 0, 432,
		3317, 1, 0, 0, 0, 434, 3324, 1, 0, 0, 0, 436, 3329, 1, 0, 0, 0, 438, 3337,
		1, 0, 0, 0, 440, 3349, 1, 0, 0, 0, 442, 3353, 1, 0, 0, 0, 444, 3355, 1,
		0, 0, 0, 446, 3374, 1, 0, 0, 0, 448, 3381, 1, 0, 0, 0, 450, 3386, 1, 0,
		0, 0, 452, 3389, 1, 0, 0, 0, 454, 3406, 1, 0, 0, 0, 456, 3408, 1, 0, 0,
		0, 458, 3411, 1, 0, 0, 0, 460, 3415, 1, 0, 0, 0, 462, 3421, 1, 0, 0, 0,
		464, 3431, 1, 0, 0, 0, 466, 3434, 1, 0, 0, 0, 468, 3439, 1, 0, 0, 0, 470,
		3443, 1, 0, 0, 0, 472, 3445, 1, 0, 0, 0, 474, 3447, 1, 0, 0, 0, 476, 477,
		3, 2, 1, 0, 477, 478, 5, 0, 0, 1, 478, 1, 1, 0, 0, 0, 479, 482, 3, 4, 2,
		0, 480, 482, 3, 12, 6, 0, 481, 479, 1, 0, 0, 0, 481, 480, 1, 0, 0, 0, 482,
		484, 1, 0, 0, 0, 483, 485, 5, 124, 0, 0, 484, 483, 1, 0, 0, 0, 484, 485,
		1, 0, 0, 0, 485, 487, 1, 0, 0, 0, 486, 481, 1, 0, 0, 0, 487, 488, 1, 0,
		0, 0, 488, 486, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489, 3, 1, 0, 0, 0, 490,
		492, 3, 48, 24, 0, 491, 490, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 493,
		1, 0, 0, 0, 493, 494, 5, 20, 0, 0, 494, 496, 3, 2, 1, 0, 495, 497, 3, 16,
		8, 0, 496, 495, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0, 497, 498, 1, 0, 0, 0,
		498, 499, 3, 8, 4, 0, 499, 5, 1, 0, 0, 0, 500, 501, 5, 20, 0, 0, 501, 503,
		3, 2, 1, 0, 502, 504, 3, 16, 8, 0, 503, 502, 1, 0, 0, 0, 503, 504, 1, 0,
		0, 0, 504, 505, 1, 0, 0, 0, 505, 506, 3, 8, 4, 0, 506, 512, 1, 0, 0, 0,
		507, 509, 3, 12, 6, 0, 508, 510, 5, 370, 0, 0, 509, 508, 1, 0, 0, 0, 509,
		510, 1, 0, 0, 0, 510, 512, 1, 0, 0, 0, 511, 500, 1, 0, 0, 0, 511, 507,
		1, 0, 0, 0, 512, 7, 1, 0, 0, 0, 513, 514, 4, 4, 0, 0, 514, 515, 5, 98,
		0, 0, 515, 9, 1, 0, 0, 0, 516, 526, 3, 4, 2, 0, 517, 519, 3, 12, 6, 0,
		518, 517, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 520,
		521, 1, 0, 0, 0, 521, 523, 1, 0, 0, 0, 522, 524, 5, 124, 0, 0, 523, 522,
		1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 526, 1, 0, 0, 0, 525, 516, 1, 0,
		0, 0, 525, 518, 1, 0, 0, 0, 526, 11, 1, 0, 0, 0, 527, 591, 3, 24, 12, 0,
		528, 591, 3, 36, 18, 0, 529, 591, 3, 118, 59, 0, 530, 591, 3, 38, 19, 0,
		531, 591, 3, 40, 20, 0, 532, 591, 3, 42, 21, 0, 533, 591, 3, 44, 22, 0,
		534, 591, 3, 218, 109, 0, 535, 591, 3, 222, 111, 0, 536, 591, 3, 224, 112,
		0, 537, 591, 3, 228, 114, 0, 538, 591, 3, 230, 115, 0, 539, 591, 3, 240,
		120, 0, 540, 591, 3, 134, 67, 0, 541, 591, 3, 138, 69, 0, 542, 591, 3,
		242, 121, 0, 543, 591, 3, 70, 35, 0, 544, 591, 3, 142, 71, 0, 545, 591,
		3, 148, 74, 0, 546, 591, 3, 154, 77, 0, 547, 591, 3, 68, 34, 0, 548, 591,
		3, 78, 39, 0, 549, 591, 3, 46, 23, 0, 550, 591, 3, 376, 188, 0, 551, 591,
		3, 380, 190, 0, 552, 591, 3, 164, 82, 0, 553, 591, 3, 166, 83, 0, 554,
		591, 3, 168, 84, 0, 555, 591, 3, 194, 97, 0, 556, 591, 3, 214, 107, 0,
		557, 591, 3, 284, 142, 0, 558, 591, 3, 286, 143, 0, 559, 591, 3, 170, 85,
		0, 560, 591, 3, 182, 91, 0, 561, 591, 3, 184, 92, 0, 562, 591, 3, 192,
		96, 0, 563, 591, 3, 196, 98, 0, 564, 591, 3, 204, 102, 0, 565, 591, 3,
		208, 104, 0, 566, 591, 3, 210, 105, 0, 567, 591, 3, 368, 184, 0, 568, 591,
		3, 212, 106, 0, 569, 591, 3, 250, 125, 0, 570, 591, 3, 252, 126, 0, 571,
		591, 3, 254, 127, 0, 572, 591, 3, 256, 128, 0, 573, 591, 3, 258, 129, 0,
		574, 591, 3, 260, 130, 0, 575, 591, 3, 292, 146, 0, 576, 591, 3, 270, 135,
		0, 577, 591, 3, 272, 136, 0, 578, 591, 3, 360, 180, 0, 579, 591, 3, 276,
		138, 0, 580, 591, 3, 274, 137, 0, 581, 591, 3, 278, 139, 0, 582, 591, 3,
		280, 140, 0, 583, 591, 3, 282, 141, 0, 584, 591, 3, 288, 144, 0, 585, 591,
		3, 444, 222, 0, 586, 591, 3, 448, 224, 0, 587, 591, 3, 20, 10, 0, 588,
		591, 3, 22, 11, 0, 589, 591, 3, 14, 7, 0, 590, 527, 1, 0, 0, 0, 590, 528,
		1, 0, 0, 0, 590, 529, 1, 0, 0, 0, 590, 530, 1, 0, 0, 0, 590, 531, 1, 0,
		0, 0, 590, 532, 1, 0, 0, 0, 590, 533, 1, 0, 0, 0, 590, 534, 1, 0, 0, 0,
		590, 535, 1, 0, 0, 0, 590, 536, 1, 0, 0, 0, 590, 537, 1, 0, 0, 0, 590,
		538, 1, 0, 0, 0, 590, 539, 1, 0, 0, 0, 590, 540, 1, 0, 0, 0, 590, 541,
		1, 0, 0, 0, 590, 542, 1, 0, 0, 0, 590, 543, 1, 0, 0, 0, 590, 544, 1, 0,
		0, 0, 590, 545, 1, 0, 0, 0, 590, 546, 1, 0, 0, 0, 590, 547, 1, 0, 0, 0,
		590, 548, 1, 0, 0, 0, 590, 549, 1, 0, 0, 0, 590, 550, 1, 0, 0, 0, 590,
		551, 1, 0, 0, 0, 590, 552, 1, 0, 0, 0, 590, 553, 1, 0, 0, 0, 590, 554,
		1, 0, 0, 0, 590, 555, 1, 0, 0, 0, 590, 556, 1, 0, 0, 0, 590, 557, 1, 0,
		0, 0, 590, 558, 1, 0, 0, 0, 590, 559, 1, 0, 0, 0, 590, 560, 1, 0, 0, 0,
		590, 561, 1, 0, 0, 0, 590, 562, 1, 0, 0, 0, 590, 563, 1, 0, 0, 0, 590,
		564, 1, 0, 0, 0, 590, 565, 1, 0, 0, 0, 590, 566, 1, 0, 0, 0, 590, 567,
		1, 0, 0, 0, 590, 568, 1, 0, 0, 0, 590, 569, 1, 0, 0, 0, 590, 570, 1, 0,
		0, 0, 590, 571, 1, 0, 0, 0, 590, 572, 1, 0, 0, 0, 590, 573, 1, 0, 0, 0,
		590, 574, 1, 0, 0, 0, 590, 575, 1, 0, 0, 0, 590, 576, 1, 0, 0, 0, 590,
		577, 1, 0, 0, 0, 590, 578, 1, 0, 0, 0, 590, 579, 1, 0, 0, 0, 590, 580,
		1, 0, 0, 0, 590, 581, 1, 0, 0, 0, 590, 582, 1, 0, 0, 0, 590, 583, 1, 0,
		0, 0, 590, 584, 1, 0, 0, 0, 590, 585, 1, 0, 0, 0, 590, 586, 1, 0, 0, 0,
		590, 587, 1, 0, 0, 0, 590, 588, 1, 0, 0, 0, 590, 589, 1, 0, 0, 0, 591,
		13, 1, 0, 0, 0, 592, 593, 7, 0, 0, 0, 593, 15, 1, 0, 0, 0, 594, 596, 5,
		104, 0, 0, 595, 597, 3, 18, 9, 0, 596, 595, 1, 0, 0, 0, 597, 598, 1, 0,
		0, 0, 598, 596, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 17, 1, 0, 0, 0,
		600, 601, 5, 314, 0, 0, 601, 602, 5, 372, 0, 0, 602, 603, 5, 290, 0, 0,
		603, 604, 3, 2, 1, 0, 604, 605, 8, 1, 0, 0, 605, 19, 1, 0, 0, 0, 606, 607,
		5, 196, 0, 0, 607, 21, 1, 0, 0, 0, 608, 609, 4, 11, 1, 0, 609, 610, 3,
		398, 199, 0, 610, 23, 1, 0, 0, 0, 611, 612, 5, 258, 0, 0, 612, 625, 3,
		262, 131, 0, 613, 615, 5, 258, 0, 0, 614, 613, 1, 0, 0, 0, 614, 615, 1,
		0, 0, 0, 615, 616, 1, 0, 0, 0, 616, 621, 3, 26, 13, 0, 617, 618, 5, 350,
		0, 0, 618, 620, 3, 26, 13, 0, 619, 617, 1, 0, 0, 0, 620, 623, 1, 0, 0,
		0, 621, 619, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 625, 1, 0, 0, 0, 623,
		621, 1, 0, 0, 0, 624, 611, 1, 0, 0, 0, 624, 614, 1, 0, 0, 0, 625, 25, 1,
		0, 0, 0, 626, 631, 3, 28, 14, 0, 627, 631, 3, 32, 16, 0, 628, 631, 3, 34,
		17, 0, 629, 631, 3, 30, 15, 0, 630, 626, 1, 0, 0, 0, 630, 627, 1, 0, 0,
		0, 630, 628, 1, 0, 0, 0, 630, 629, 1, 0, 0, 0, 631, 27, 1, 0, 0, 0, 632,
		634, 3, 462, 231, 0, 633, 635, 5, 349, 0, 0, 634, 633, 1, 0, 0, 0, 634,
		635, 1, 0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 637, 5, 355, 0, 0, 637, 638,
		3, 398, 199, 0, 638, 649, 1, 0, 0, 0, 639, 640, 5, 365, 0, 0, 640, 641,
		3, 462, 231, 0, 641, 643, 5, 368, 0, 0, 642, 644, 5, 349, 0, 0, 643, 642,
		1, 0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 646, 5, 355,
		0, 0, 646, 647, 3, 398, 199, 0, 647, 649, 1, 0, 0, 0, 648, 632, 1, 0, 0,
		0, 648, 639, 1, 0, 0, 0, 649, 29, 1, 0, 0, 0, 650, 651, 3, 428, 214, 0,
		651, 652, 5, 349, 0, 0, 652, 653, 5, 355, 0, 0, 653, 654, 3, 398, 199,
		0, 654, 31, 1, 0, 0, 0, 655, 656, 5, 365, 0, 0, 656, 661, 3, 460, 230,
		0, 657, 658, 5, 350, 0, 0, 658, 660, 3, 460, 230, 0, 659, 657, 1, 0, 0,
		0, 660, 663, 1, 0, 0, 0, 661, 659, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662,
		664, 1, 0, 0, 0, 663, 661, 1, 0, 0, 0, 664, 666, 5, 368, 0, 0, 665, 667,
		5, 349, 0, 0, 666, 665, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 668, 1,
		0, 0, 0, 668, 669, 5, 355, 0, 0, 669, 670, 5, 365, 0, 0, 670, 675, 3, 398,
		199, 0, 671, 672, 5, 350, 0, 0, 672, 674, 3, 398, 199, 0, 673, 671, 1,
		0, 0, 0, 674, 677, 1, 0, 0, 0, 675, 673, 1, 0, 0, 0, 675, 676, 1, 0, 0,
		0, 676, 678, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 678, 679, 5, 368, 0, 0,
		679, 33, 1, 0, 0, 0, 680, 693, 3, 460, 230, 0, 681, 682, 5, 365, 0, 0,
		682, 687, 3, 460, 230, 0, 683, 684, 5, 350, 0, 0, 684, 686, 3, 460, 230,
		0, 685, 683, 1, 0, 0, 0, 686, 689, 1, 0, 0, 0, 687, 685, 1, 0, 0, 0, 687,
		688, 1, 0, 0, 0, 688, 690, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 690, 691,
		5, 368, 0, 0, 691, 693, 1, 0, 0, 0, 692, 680, 1, 0, 0, 0, 692, 681, 1,
		0, 0, 0, 693, 695, 1, 0, 0, 0, 694, 696, 5, 349, 0, 0, 695, 694, 1, 0,
		0, 0, 695, 696, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 698, 5, 355, 0,
		0, 698, 699, 5, 365, 0, 0, 699, 700, 3, 292, 146, 0, 700, 701, 5, 368,
		0, 0, 701, 35, 1, 0, 0, 0, 702, 703, 5, 8, 0, 0, 703, 704, 3, 460, 230,
		0, 704, 705, 5, 65, 0, 0, 705, 709, 5, 115, 0, 0, 706, 707, 5, 234, 0,
		0, 707, 710, 5, 258, 0, 0, 708, 710, 5, 222, 0, 0, 709, 706, 1, 0, 0, 0,
		709, 708, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 712, 3, 460, 230, 0, 712,
		37, 1, 0, 0, 0, 713, 716, 5, 15, 0, 0, 714, 715, 5, 234, 0, 0, 715, 717,
		5, 258, 0, 0, 716, 714, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 718, 1,
		0, 0, 0, 718, 719, 7, 2, 0, 0, 719, 720, 5, 365, 0, 0, 720, 725, 3, 460,
		230, 0, 721, 722, 5, 350, 0, 0, 722, 724, 3, 460, 230, 0, 723, 721, 1,
		0, 0, 0, 724, 727, 1, 0, 0, 0, 725, 723, 1, 0, 0, 0, 725, 726, 1, 0, 0,
		0, 726, 728, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 728, 729, 5, 368, 0, 0,
		729, 730, 5, 317, 0, 0, 730, 731, 5, 222, 0, 0, 731, 732, 3, 460, 230,
		0, 732, 39, 1, 0, 0, 0, 733, 734, 5, 20, 0, 0, 734, 735, 5, 297, 0, 0,
		735, 41, 1, 0, 0, 0, 736, 737, 5, 28, 0, 0, 737, 43, 1, 0, 0, 0, 738, 742,
		5, 32, 0, 0, 739, 743, 3, 430, 215, 0, 740, 743, 3, 428, 214, 0, 741, 743,
		3, 460, 230, 0, 742, 739, 1, 0, 0, 0, 742, 740, 1, 0, 0, 0, 742, 741, 1,
		0, 0, 0, 743, 45, 1, 0, 0, 0, 744, 745, 5, 74, 0, 0, 745, 750, 3, 52, 26,
		0, 746, 747, 5, 350, 0, 0, 747, 749, 3, 52, 26, 0, 748, 746, 1, 0, 0, 0,
		749, 752, 1, 0, 0, 0, 750, 748, 1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751,
		47, 1, 0, 0, 0, 752, 750, 1, 0, 0, 0, 753, 754, 5, 74, 0, 0, 754, 755,
		3, 52, 26, 0, 755, 761, 5, 370, 0, 0, 756, 757, 3, 52, 26, 0, 757, 758,
		5, 370, 0, 0, 758, 760, 1, 0, 0, 0, 759, 756, 1, 0, 0, 0, 760, 763, 1,
		0, 0, 0, 761, 759, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 49, 1, 0, 0,
		0, 763, 761, 1, 0, 0, 0, 764, 765, 3, 52, 26, 0, 765, 771, 5, 370, 0, 0,
		766, 767, 3, 52, 26, 0, 767, 768, 5, 370, 0, 0, 768, 770, 1, 0, 0, 0, 769,
		766, 1, 0, 0, 0, 770, 773, 1, 0, 0, 0, 771, 769, 1, 0, 0, 0, 771, 772,
		1, 0, 0, 0, 772, 51, 1, 0, 0, 0, 773, 771, 1, 0, 0, 0, 774, 780, 3, 58,
		29, 0, 775, 780, 3, 56, 28, 0, 776, 780, 3, 64, 32, 0, 777, 780, 3, 54,
		27, 0, 778, 780, 3, 66, 33, 0, 779, 774, 1, 0, 0, 0, 779, 775, 1, 0, 0,
		0, 779, 776, 1, 0, 0, 0, 779, 777, 1, 0, 0, 0, 779, 778, 1, 0, 0, 0, 780,
		53, 1, 0, 0, 0, 781, 786, 3, 460, 230, 0, 782, 783, 5, 350, 0, 0, 783,
		785, 3, 460, 230, 0, 784, 782, 1, 0, 0, 0, 785, 788, 1, 0, 0, 0, 786, 784,
		1, 0, 0, 0, 786, 787, 1, 0, 0, 0, 787, 790, 1, 0, 0, 0, 788, 786, 1, 0,
		0, 0, 789, 791, 5, 13, 0, 0, 790, 789, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0,
		791, 792, 1, 0, 0, 0, 792, 794, 3, 126, 63, 0, 793, 795, 3, 128, 64, 0,
		794, 793, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 799, 1, 0, 0, 0, 796,
		798, 3, 130, 65, 0, 797, 796, 1, 0, 0, 0, 798, 801, 1, 0, 0, 0, 799, 797,
		1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 803, 1, 0, 0, 0, 801, 799, 1, 0,
		0, 0, 802, 804, 3, 132, 66, 0, 803, 802, 1, 0, 0, 0, 803, 804, 1, 0, 0,
		0, 804, 817, 1, 0, 0, 0, 805, 806, 3, 460, 230, 0, 806, 808, 5, 49, 0,
		0, 807, 809, 5, 13, 0, 0, 808, 807, 1, 0, 0, 0, 808, 809, 1, 0, 0, 0, 809,
		810, 1, 0, 0, 0, 810, 812, 3, 126, 63, 0, 811, 813, 3, 128, 64, 0, 812,
		811, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 815,
		3, 132, 66, 0, 815, 817, 1, 0, 0, 0, 816, 781, 1, 0, 0, 0, 816, 805, 1,
		0, 0, 0, 817, 55, 1, 0, 0, 0, 818, 819, 3, 460, 230, 0, 819, 820, 5, 53,
		0, 0, 820, 57, 1, 0, 0, 0, 821, 822, 5, 65, 0, 0, 822, 827, 3, 460, 230,
		0, 823, 824, 3, 460, 230, 0, 824, 825, 5, 65, 0, 0, 825, 827, 1, 0, 0,
		0, 826, 821, 1, 0, 0, 0, 826, 823, 1, 0, 0, 0, 827, 830, 1, 0, 0, 0, 828,
		831, 3, 60, 30, 0, 829, 831, 3, 62, 31, 0, 830, 828, 1, 0, 0, 0, 830, 829,
		1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 835, 7, 3,
		0, 0, 833, 836, 3, 292, 146, 0, 834, 836, 3, 398, 199, 0, 835, 833, 1,
		0, 0, 0, 835, 834, 1, 0, 0, 0, 836, 59, 1, 0, 0, 0, 837, 838, 5, 317, 0,
		0, 838, 840, 5, 236, 0, 0, 839, 841, 5, 203, 0, 0, 840, 839, 1, 0, 0, 0,
		840, 841, 1, 0, 0, 0, 841, 844, 1, 0, 0, 0, 842, 843, 5, 295, 0, 0, 843,
		845, 7, 4, 0, 0, 844, 842, 1, 0, 0, 0, 844, 845, 1, 0, 0, 0, 845, 61, 1,
		0, 0, 0, 846, 847, 5, 318, 0, 0, 847, 848, 5, 236, 0, 0, 848, 63, 1, 0,
		0, 0, 849, 850, 7, 5, 0, 0, 850, 851, 5, 127, 0, 0, 851, 857, 5, 115, 0,
		0, 852, 858, 5, 270, 0, 0, 853, 858, 5, 273, 0, 0, 854, 855, 5, 194, 0,
		0, 855, 858, 5, 118, 0, 0, 856, 858, 3, 460, 230, 0, 857, 852, 1, 0, 0,
		0, 857, 853, 1, 0, 0, 0, 857, 854, 1, 0, 0, 0, 857, 856, 1, 0, 0, 0, 858,
		859, 1, 0, 0, 0, 859, 860, 3, 6, 3, 0, 860, 65, 1, 0, 0, 0, 861, 863, 5,
		123, 0, 0, 862, 861, 1, 0, 0, 0, 862, 863, 1, 0, 0, 0, 863, 864, 1, 0,
		0, 0, 864, 865, 5, 287, 0, 0, 865, 866, 5, 285, 0, 0, 866, 868, 3, 462,
		231, 0, 867, 869, 3, 92, 46, 0, 868, 867, 1, 0, 0, 0, 868, 869, 1, 0, 0,
		0, 869, 870, 1, 0, 0, 0, 870, 871, 3, 72, 36, 0, 871, 67, 1, 0, 0, 0, 872,
		873, 5, 59, 0, 0, 873, 877, 5, 285, 0, 0, 874, 875, 5, 134, 0, 0, 875,
		876, 5, 194, 0, 0, 876, 878, 5, 106, 0, 0, 877, 874, 1, 0, 0, 0, 877, 878,
		1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 881, 3, 344, 172, 0, 880, 882, 3,
		92, 46, 0, 881, 880, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 883, 1, 0,
		0, 0, 883, 884, 3, 72, 36, 0, 884, 69, 1, 0, 0, 0, 885, 892, 5, 59, 0,
		0, 886, 887, 5, 166, 0, 0, 887, 893, 5, 287, 0, 0, 888, 890, 7, 6, 0, 0,
		889, 888, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 891, 1, 0, 0, 0, 891,
		893, 5, 313, 0, 0, 892, 886, 1, 0, 0, 0, 892, 889, 1, 0, 0, 0, 893, 894,
		1, 0, 0, 0, 894, 895, 5, 285, 0, 0, 895, 897, 3, 462, 231, 0, 896, 898,
		3, 92, 46, 0, 897, 896, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 899, 1,
		0, 0, 0, 899, 900, 3, 72, 36, 0, 900, 71, 1, 0, 0, 0, 901, 903, 5, 13,
		0, 0, 902, 901, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0, 903, 904, 1, 0, 0, 0,
		904, 905, 5, 365, 0, 0, 905, 906, 3, 292, 146, 0, 906, 907, 5, 368, 0,
		0, 907, 919, 1, 0, 0, 0, 908, 910, 5, 13, 0, 0, 909, 908, 1, 0, 0, 0, 909,
		910, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 919, 3, 292, 146, 0, 912, 913,
		5, 365, 0, 0, 913, 914, 3, 74, 37, 0, 914, 915, 5, 368, 0, 0, 915, 919,
		1, 0, 0, 0, 916, 917, 5, 163, 0, 0, 917, 919, 3, 344, 172, 0, 918, 902,
		1, 0, 0, 0, 918, 909, 1, 0, 0, 0, 918, 912, 1, 0, 0, 0, 918, 916, 1, 0,
		0, 0, 919, 921, 1, 0, 0, 0, 920, 922, 3, 98, 49, 0, 921, 920, 1, 0, 0,
		0, 921, 922, 1, 0, 0, 0, 922, 73, 1, 0, 0, 0, 923, 928, 3, 76, 38, 0, 924,
		925, 5, 350, 0, 0, 925, 927, 3, 76, 38, 0, 926, 924, 1, 0, 0, 0, 927, 930,
		1, 0, 0, 0, 928, 926, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929, 75, 1, 0,
		0, 0, 930, 928, 1, 0, 0, 0, 931, 932, 3, 84, 42, 0, 932, 934, 3, 126, 63,
		0, 933, 935, 3, 128, 64, 0, 934, 933, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0,
		935, 939, 1, 0, 0, 0, 936, 938, 3, 130, 65, 0, 937, 936, 1, 0, 0, 0, 938,
		941, 1, 0, 0, 0, 939, 937, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 945,
		1, 0, 0, 0, 941, 939, 1, 0, 0, 0, 942, 944, 3, 86, 43, 0, 943, 942, 1,
		0, 0, 0, 944, 947, 1, 0, 0, 0, 945, 943, 1, 0, 0, 0, 945, 946, 1, 0, 0,
		0, 946, 954, 1, 0, 0, 0, 947, 945, 1, 0, 0, 0, 948, 949, 5, 54, 0, 0, 949,
		951, 3, 462, 231, 0, 950, 948, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 952,
		1, 0, 0, 0, 952, 954, 3, 88, 44, 0, 953, 931, 1, 0, 0, 0, 953, 950, 1,
		0, 0, 0, 954, 77, 1, 0, 0, 0, 955, 956, 5, 300, 0, 0, 956, 957, 3, 460,
		230, 0, 957, 958, 5, 153, 0, 0, 958, 959, 5, 285, 0, 0, 959, 960, 5, 201,
		0, 0, 960, 963, 3, 80, 40, 0, 961, 962, 5, 194, 0, 0, 962, 964, 5, 196,
		0, 0, 963, 961, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0,
		965, 966, 5, 139, 0, 0, 966, 967, 5, 30, 0, 0, 967, 968, 3, 126, 63, 0,
		968, 79, 1, 0, 0, 0, 969, 972, 3, 82, 41, 0, 970, 972, 3, 126, 63, 0, 971,
		969, 1, 0, 0, 0, 971, 970, 1, 0, 0, 0, 972, 81, 1, 0, 0, 0, 973, 974, 3,
		462, 231, 0, 974, 975, 5, 3, 0, 0, 975, 976, 7, 7, 0, 0, 976, 83, 1, 0,
		0, 0, 977, 978, 3, 462, 231, 0, 978, 85, 1, 0, 0, 0, 979, 1012, 3, 132,
		66, 0, 980, 982, 5, 194, 0, 0, 981, 980, 1, 0, 0, 0, 981, 982, 1, 0, 0,
		0, 982, 983, 1, 0, 0, 0, 983, 1012, 5, 196, 0, 0, 984, 985, 5, 219, 0,
		0, 985, 1012, 5, 158, 0, 0, 986, 1012, 5, 302, 0, 0, 987, 988, 5, 229,
		0, 0, 988, 989, 3, 344, 172, 0, 989, 990, 5, 365, 0, 0, 990, 991, 3, 462,
		231, 0, 991, 995, 5, 368, 0, 0, 992, 994, 3, 90, 45, 0, 993, 992, 1, 0,
		0, 0, 994, 997, 1, 0, 0, 0, 995, 993, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0,
		996, 1012, 1, 0, 0, 0, 997, 995, 1, 0, 0, 0, 998, 999, 5, 133, 0, 0, 999,
		1000, 5, 365, 0, 0, 1000, 1005, 5, 375, 0, 0, 1001, 1002, 5, 350, 0, 0,
		1002, 1004, 5, 375, 0, 0, 1003, 1001, 1, 0, 0, 0, 1004, 1007, 1, 0, 0,
		0, 1005, 1003, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1008, 1, 0, 0,
		0, 1007, 1005, 1, 0, 0, 0, 1008, 1012, 5, 368, 0, 0, 1009, 1012, 5, 17,
		0, 0, 1010, 1012, 5, 97, 0, 0, 1011, 979, 1, 0, 0, 0, 1011, 981, 1, 0,
		0, 0, 1011, 984, 1, 0, 0, 0, 1011, 986, 1, 0, 0, 0, 1011, 987, 1, 0, 0,
		0, 1011, 998, 1, 0, 0, 0, 1011, 1009, 1, 0, 0, 0, 1011, 1010, 1, 0, 0,
		0, 1012, 87, 1, 0, 0, 0, 1013, 1014, 5, 219, 0, 0, 1014, 1016, 5, 158,
		0, 0, 1015, 1017, 5, 43, 0, 0, 1016, 1015, 1, 0, 0, 0, 1016, 1017, 1, 0,
		0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1019, 5, 365, 0, 0, 1019, 1021, 3,
		462, 231, 0, 1020, 1022, 7, 8, 0, 0, 1021, 1020, 1, 0, 0, 0, 1021, 1022,
		1, 0, 0, 0, 1022, 1030, 1, 0, 0, 0, 1023, 1024, 5, 350, 0, 0, 1024, 1026,
		3, 462, 231, 0, 1025, 1027, 7, 8, 0, 0, 1026, 1025, 1, 0, 0, 0, 1026, 1027,
		1, 0, 0, 0, 1027, 1029, 1, 0, 0, 0, 1028, 1023, 1, 0, 0, 0, 1029, 1032,
		1, 0, 0, 0, 1030, 1028, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031, 1033,
		1, 0, 0, 0, 1032, 1030, 1, 0, 0, 0, 1033, 1035, 5, 368, 0, 0, 1034, 1036,
		5, 97, 0, 0, 1035, 1034, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1038,
		1, 0, 0, 0, 1037, 1039, 3, 246, 123, 0, 1038, 1037, 1, 0, 0, 0, 1038, 1039,
		1, 0, 0, 0, 1039, 1071, 1, 0, 0, 0, 1040, 1041, 5, 116, 0, 0, 1041, 1042,
		5, 158, 0, 0, 1042, 1043, 5, 365, 0, 0, 1043, 1048, 3, 462, 231, 0, 1044,
		1045, 5, 350, 0, 0, 1045, 1047, 3, 462, 231, 0, 1046, 1044, 1, 0, 0, 0,
		1047, 1050, 1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0,
		1049, 1051, 1, 0, 0, 0, 1050, 1048, 1, 0, 0, 0, 1051, 1052, 5, 368, 0,
		0, 1052, 1053, 5, 229, 0, 0, 1053, 1054, 3, 344, 172, 0, 1054, 1055, 5,
		365, 0, 0, 1055, 1060, 3, 462, 231, 0, 1056, 1057, 5, 350, 0, 0, 1057,
		1059, 3, 462, 231, 0, 1058, 1056, 1, 0, 0, 0, 1059, 1062, 1, 0, 0, 0, 1060,
		1058, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1063, 1, 0, 0, 0, 1062,
		1060, 1, 0, 0, 0, 1063, 1067, 5, 368, 0, 0, 1064, 1066, 3, 90, 45, 0, 1065,
		1064, 1, 0, 0, 0, 1066, 1069, 1, 0, 0, 0, 1067, 1065, 1, 0, 0, 0, 1067,
		1068, 1, 0, 0, 0, 1068, 1071, 1, 0, 0, 0, 1069, 1067, 1, 0, 0, 0, 1070,
		1013, 1, 0, 0, 0, 1070, 1040, 1, 0, 0, 0, 1071, 89, 1, 0, 0, 0, 1072, 1073,
		5, 202, 0, 0, 1073, 1082, 7, 9, 0, 0, 1074, 1075, 5, 189, 0, 0, 1075, 1083,
		5, 5, 0, 0, 1076, 1083, 5, 233, 0, 0, 1077, 1078, 5, 258, 0, 0, 1078, 1083,
		5, 196, 0, 0, 1079, 1080, 5, 258, 0, 0, 1080, 1083, 5, 75, 0, 0, 1081,
		1083, 5, 34, 0, 0, 1082, 1074, 1, 0, 0, 0, 1082, 1076, 1, 0, 0, 0, 1082,
		1077, 1, 0, 0, 0, 1082, 1079, 1, 0, 0, 0, 1082, 1081, 1, 0, 0, 0, 1083,
		91, 1, 0, 0, 0, 1084, 1086, 3, 94, 47, 0, 1085, 1084, 1, 0, 0, 0, 1086,
		1087, 1, 0, 0, 0, 1087, 1085, 1, 0, 0, 0, 1087, 1088, 1, 0, 0, 0, 1088,
		93, 1, 0, 0, 0, 1089, 1090, 5, 350, 0, 0, 1090, 1093, 3, 96, 48, 0, 1091,
		1093, 3, 108, 54, 0, 1092, 1089, 1, 0, 0, 0, 1092, 1091, 1, 0, 0, 0, 1093,
		95, 1, 0, 0, 0, 1094, 1096, 5, 189, 0, 0, 1095, 1094, 1, 0, 0, 0, 1095,
		1096, 1, 0, 0, 0, 1096, 1097, 1, 0, 0, 0, 1097, 1098, 7, 10, 0, 0, 1098,
		97, 1, 0, 0, 0, 1099, 1101, 3, 100, 50, 0, 1100, 1099, 1, 0, 0, 0, 1101,
		1102, 1, 0, 0, 0, 1102, 1100, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103,
		99, 1, 0, 0, 0, 1104, 1105, 5, 202, 0, 0, 1105, 1106, 5, 50, 0, 0, 1106,
		1107, 7, 11, 0, 0, 1107, 1115, 5, 244, 0, 0, 1108, 1115, 3, 102, 51, 0,
		1109, 1115, 3, 104, 52, 0, 1110, 1115, 3, 106, 53, 0, 1111, 1115, 3, 108,
		54, 0, 1112, 1115, 3, 114, 57, 0, 1113, 1115, 3, 116, 58, 0, 1114, 1104,
		1, 0, 0, 0, 1114, 1108, 1, 0, 0, 0, 1114, 1109, 1, 0, 0, 0, 1114, 1110,
		1, 0, 0, 0, 1114, 1111, 1, 0, 0, 0, 1114, 1112, 1, 0, 0, 0, 1114, 1113,
		1, 0, 0, 0, 1115, 101, 1, 0, 0, 0, 1116, 1117, 5, 255, 0, 0, 1117, 1118,
		5, 60, 0, 0, 1118, 1135, 7, 12, 0, 0, 1119, 1120, 7, 13, 0, 0, 1120, 1135,
		5, 375, 0, 0, 1121, 1135, 5, 191, 0, 0, 1122, 1135, 7, 14, 0, 0, 1123,
		1124, 5, 277, 0, 0, 1124, 1127, 5, 365, 0, 0, 1125, 1128, 3, 462, 231,
		0, 1126, 1128, 5, 375, 0, 0, 1127, 1125, 1, 0, 0, 0, 1127, 1126, 1, 0,
		0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1127, 1, 0, 0, 0, 1129, 1130, 1, 0,
		0, 0, 1130, 1131, 1, 0, 0, 0, 1131, 1135, 5, 368, 0, 0, 1132, 1133, 5,
		286, 0, 0, 1133, 1135, 3, 462, 231, 0, 1134, 1116, 1, 0, 0, 0, 1134, 1119,
		1, 0, 0, 0, 1134, 1121, 1, 0, 0, 0, 1134, 1122, 1, 0, 0, 0, 1134, 1123,
		1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1135, 103, 1, 0, 0, 0, 1136, 1138,
		5, 139, 0, 0, 1137, 1136, 1, 0, 0, 0, 1137, 1138, 1, 0, 0, 0, 1138, 1139,
		1, 0, 0, 0, 1139, 1140, 5, 137, 0, 0, 1140, 1170, 3, 462, 231, 0, 1141,
		1142, 5, 317, 0, 0, 1142, 1170, 5, 231, 0, 0, 1143, 1144, 5, 89, 0, 0,
		1144, 1145, 5, 30, 0, 0, 1145, 1146, 5, 128, 0, 0, 1146, 1147, 5, 365,
		0, 0, 1147, 1152, 3, 462, 231, 0, 1148, 1149, 5, 350, 0, 0, 1149, 1151,
		3, 462, 231, 0, 1150, 1148, 1, 0, 0, 0, 1151, 1154, 1, 0, 0, 0, 1152, 1150,
		1, 0, 0, 0, 1152, 1153, 1, 0, 0, 0, 1153, 1155, 1, 0, 0, 0, 1154, 1152,
		1, 0, 0, 0, 1155, 1156, 5, 368, 0, 0, 1156, 1170, 1, 0, 0, 0, 1157, 1159,
		5, 194, 0, 0, 1158, 1157, 1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1160,
		1, 0, 0, 0, 1160, 1170, 5, 172, 0, 0, 1161, 1162, 5, 51, 0, 0, 1162, 1170,
		7, 15, 0, 0, 1163, 1164, 5, 79, 0, 0, 1164, 1170, 5, 203, 0, 0, 1165, 1166,
		5, 317, 0, 0, 1166, 1167, 5, 233, 0, 0, 1167, 1168, 5, 202, 0, 0, 1168,
		1170, 5, 92, 0, 0, 1169, 1137, 1, 0, 0, 0, 1169, 1141, 1, 0, 0, 0, 1169,
		1143, 1, 0, 0, 0, 1169, 1158, 1, 0, 0, 0, 1169, 1161, 1, 0, 0, 0, 1169,
		1163, 1, 0, 0, 0, 1169, 1165, 1, 0, 0, 0, 1170, 105, 1, 0, 0, 0, 1171,
		1173, 5, 302, 0, 0, 1172, 1171, 1, 0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173,
		1174, 1, 0, 0, 0, 1174, 1175, 5, 219, 0, 0, 1175, 1176, 5, 139, 0, 0, 1176,
		1177, 5, 365, 0, 0, 1177, 1182, 3, 462, 231, 0, 1178, 1179, 5, 350, 0,
		0, 1179, 1181, 3, 462, 231, 0, 1180, 1178, 1, 0, 0, 0, 1181, 1184, 1, 0,
		0, 0, 1182, 1180, 1, 0, 0, 0, 1182, 1183, 1, 0, 0, 0, 1183, 1185, 1, 0,
		0, 0, 1184, 1182, 1, 0, 0, 0, 1185, 1186, 5, 368, 0, 0, 1186, 1190, 1,
		0, 0, 0, 1187, 1188, 5, 317, 0, 0, 1188, 1190, 5, 67, 0, 0, 1189, 1172,
		1, 0, 0, 0, 1189, 1187, 1, 0, 0, 0, 1190, 107, 1, 0, 0, 0, 1191, 1196,
		3, 110, 55, 0, 1192, 1193, 5, 278, 0, 0, 1193, 1194, 5, 13, 0, 0, 1194,
		1196, 3, 462, 231, 0, 1195, 1191, 1, 0, 0, 0, 1195, 1192, 1, 0, 0, 0, 1196,
		109, 1, 0, 0, 0, 1197, 1198, 5, 243, 0, 0, 1198, 1199, 5, 117, 0, 0, 1199,
		1203, 5, 81, 0, 0, 1200, 1202, 3, 112, 56, 0, 1201, 1200, 1, 0, 0, 0, 1202,
		1205, 1, 0, 0, 0, 1203, 1201, 1, 0, 0, 0, 1203, 1204, 1, 0, 0, 0, 1204,
		111, 1, 0, 0, 0, 1205, 1203, 1, 0, 0, 0, 1206, 1207, 5, 111, 0, 0, 1207,
		1208, 5, 288, 0, 0, 1208, 1209, 5, 30, 0, 0, 1209, 1213, 3, 398, 199, 0,
		1210, 1211, 5, 100, 0, 0, 1211, 1212, 5, 30, 0, 0, 1212, 1214, 3, 398,
		199, 0, 1213, 1210, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214, 1234, 1,
		0, 0, 0, 1215, 1216, 5, 46, 0, 0, 1216, 1217, 5, 155, 0, 0, 1217, 1218,
		5, 288, 0, 0, 1218, 1219, 5, 30, 0, 0, 1219, 1234, 3, 398, 199, 0, 1220,
		1221, 5, 175, 0, 0, 1221, 1222, 5, 159, 0, 0, 1222, 1223, 5, 288, 0, 0,
		1223, 1224, 5, 30, 0, 0, 1224, 1234, 3, 398, 199, 0, 1225, 1226, 5, 165,
		0, 0, 1226, 1227, 5, 288, 0, 0, 1227, 1228, 5, 30, 0, 0, 1228, 1234, 3,
		398, 199, 0, 1229, 1230, 5, 196, 0, 0, 1230, 1231, 5, 77, 0, 0, 1231, 1232,
		5, 13, 0, 0, 1232, 1234, 3, 398, 199, 0, 1233, 1206, 1, 0, 0, 0, 1233,
		1215, 1, 0, 0, 0, 1233, 1220, 1, 0, 0, 0, 1233, 1225, 1, 0, 0, 0, 1233,
		1229, 1, 0, 0, 0, 1234, 113, 1, 0, 0, 0, 1235, 1236, 5, 202, 0, 0, 1236,
		1240, 3, 462, 231, 0, 1237, 1238, 5, 289, 0, 0, 1238, 1240, 3, 462, 231,
		0, 1239, 1235, 1, 0, 0, 0, 1239, 1237, 1, 0, 0, 0, 1240, 115, 1, 0, 0,
		0, 1241, 1243, 5, 17, 0, 0, 1242, 1244, 5, 355, 0, 0, 1243, 1242, 1, 0,
		0, 0, 1243, 1244, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 1269, 3, 398,
		199, 0, 1246, 1248, 5, 48, 0, 0, 1247, 1249, 5, 355, 0, 0, 1248, 1247,
		1, 0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250, 1269,
		3, 398, 199, 0, 1251, 1253, 5, 75, 0, 0, 1252, 1251, 1, 0, 0, 0, 1252,
		1253, 1, 0, 0, 0, 1253, 1257, 1, 0, 0, 0, 1254, 1255, 5, 39, 0, 0, 1255,
		1258, 5, 258, 0, 0, 1256, 1258, 5, 40, 0, 0, 1257, 1254, 1, 0, 0, 0, 1257,
		1256, 1, 0, 0, 0, 1258, 1260, 1, 0, 0, 0, 1259, 1261, 5, 355, 0, 0, 1260,
		1259, 1, 0, 0, 0, 1260, 1261, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262,
		1269, 3, 398, 199, 0, 1263, 1265, 5, 99, 0, 0, 1264, 1266, 5, 355, 0, 0,
		1265, 1264, 1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1267, 1, 0, 0, 0,
		1267, 1269, 3, 398, 199, 0, 1268, 1241, 1, 0, 0, 0, 1268, 1246, 1, 0, 0,
		0, 1268, 1252, 1, 0, 0, 0, 1268, 1263, 1, 0, 0, 0, 1269, 117, 1, 0, 0,
		0, 1270, 1271, 5, 9, 0, 0, 1271, 1272, 5, 285, 0, 0, 1272, 1273, 3, 344,
		172, 0, 1273, 1274, 3, 120, 60, 0, 1274, 119, 1, 0, 0, 0, 1275, 1276, 3,
		122, 61, 0, 1276, 121, 1, 0, 0, 0, 1277, 1280, 5, 6, 0, 0, 1278, 1279,
		5, 54, 0, 0, 1279, 1281, 3, 462, 231, 0, 1280, 1278, 1, 0, 0, 0, 1280,
		1281, 1, 0, 0, 0, 1281, 1282, 1, 0, 0, 0, 1282, 1283, 3, 124, 62, 0, 1283,
		123, 1, 0, 0, 0, 1284, 1285, 5, 219, 0, 0, 1285, 1287, 5, 158, 0, 0, 1286,
		1288, 5, 43, 0, 0, 1287, 1286, 1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288,
		1289, 1, 0, 0, 0, 1289, 1290, 5, 365, 0, 0, 1290, 1292, 3, 462, 231, 0,
		1291, 1293, 7, 8, 0, 0, 1292, 1291, 1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0,
		1293, 1301, 1, 0, 0, 0, 1294, 1295, 5, 350, 0, 0, 1295, 1297, 3, 462, 231,
		0, 1296, 1298, 7, 8, 0, 0, 1297, 1296, 1, 0, 0, 0, 1297, 1298, 1, 0, 0,
		0, 1298, 1300, 1, 0, 0, 0, 1299, 1294, 1, 0, 0, 0, 1300, 1303, 1, 0, 0,
		0, 1301, 1299, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1304, 1, 0, 0,
		0, 1303, 1301, 1, 0, 0, 0, 1304, 1306, 5, 368, 0, 0, 1305, 1307, 5, 97,
		0, 0, 1306, 1305, 1, 0, 0, 0, 1306, 1307, 1, 0, 0, 0, 1307, 1309, 1, 0,
		0, 0, 1308, 1310, 3, 246, 123, 0, 1309, 1308, 1, 0, 0, 0, 1309, 1310, 1,
		0, 0, 0, 1310, 1347, 1, 0, 0, 0, 1311, 1312, 5, 116, 0, 0, 1312, 1313,
		5, 158, 0, 0, 1313, 1314, 5, 365, 0, 0, 1314, 1319, 3, 462, 231, 0, 1315,
		1316, 5, 350, 0, 0, 1316, 1318, 3, 462, 231, 0, 1317, 1315, 1, 0, 0, 0,
		1318, 1321, 1, 0, 0, 0, 1319, 1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0,
		1320, 1322, 1, 0, 0, 0, 1321, 1319, 1, 0, 0, 0, 1322, 1323, 5, 368, 0,
		0, 1323, 1324, 5, 229, 0, 0, 1324, 1325, 3, 344, 172, 0, 1325, 1326, 5,
		365, 0, 0, 1326, 1331, 3, 462, 231, 0, 1327, 1328, 5, 350, 0, 0, 1328,
		1330, 3, 462, 231, 0, 1329, 1327, 1, 0, 0, 0, 1330, 1333, 1, 0, 0, 0, 1331,
		1329, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1334, 1, 0, 0, 0, 1333,
		1331, 1, 0, 0, 0, 1334, 1338, 5, 368, 0, 0, 1335, 1337, 3, 90, 45, 0, 1336,
		1335, 1, 0, 0, 0, 1337, 1340, 1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1338,
		1339, 1, 0, 0, 0, 1339, 1347, 1, 0, 0, 0, 1340, 1338, 1, 0, 0, 0, 1341,
		1342, 5, 75, 0, 0, 1342, 1343, 3, 398, 199, 0, 1343, 1344, 5, 115, 0, 0,
		1344, 1345, 3, 462, 231, 0, 1345, 1347, 1, 0, 0, 0, 1346, 1284, 1, 0, 0,
		0, 1346, 1311, 1, 0, 0, 0, 1346, 1341, 1, 0, 0, 0, 1347, 125, 1, 0, 0,
		0, 1348, 1395, 5, 38, 0, 0, 1349, 1395, 5, 39, 0, 0, 1350, 1395, 5, 22,
		0, 0, 1351, 1395, 5, 23, 0, 0, 1352, 1395, 5, 24, 0, 0, 1353, 1395, 5,
		25, 0, 0, 1354, 1395, 5, 26, 0, 0, 1355, 1395, 5, 68, 0, 0, 1356, 1395,
		5, 69, 0, 0, 1357, 1395, 5, 72, 0, 0, 1358, 1395, 5, 73, 0, 0, 1359, 1361,
		5, 91, 0, 0, 1360, 1362, 5, 217, 0, 0, 1361, 1360, 1, 0, 0, 0, 1361, 1362,
		1, 0, 0, 0, 1362, 1395, 1, 0, 0, 0, 1363, 1395, 5, 114, 0, 0, 1364, 1395,
		5, 144, 0, 0, 1365, 1395, 5, 145, 0, 0, 1366, 1395, 5, 146, 0, 0, 1367,
		1395, 5, 147, 0, 0, 1368, 1395, 5, 148, 0, 0, 1369, 1395, 5, 186, 0, 0,
		1370, 1395, 5, 188, 0, 0, 1371, 1395, 5, 198, 0, 0, 1372, 1395, 5, 197,
		0, 0, 1373, 1395, 5, 216, 0, 0, 1374, 1395, 5, 228, 0, 0, 1375, 1376, 5,
		235, 0, 0, 1376, 1395, 5, 312, 0, 0, 1377, 1395, 5, 265, 0, 0, 1378, 1395,
		5, 264, 0, 0, 1379, 1395, 5, 266, 0, 0, 1380, 1395, 5, 268, 0, 0, 1381,
		1395, 5, 267, 0, 0, 1382, 1395, 5, 279, 0, 0, 1383, 1395, 5, 284, 0, 0,
		1384, 1395, 5, 292, 0, 0, 1385, 1395, 5, 293, 0, 0, 1386, 1395, 5, 310,
		0, 0, 1387, 1395, 5, 311, 0, 0, 1388, 1395, 5, 321, 0, 0, 1389, 1392, 3,
		462, 231, 0, 1390, 1391, 5, 3, 0, 0, 1391, 1393, 7, 7, 0, 0, 1392, 1390,
		1, 0, 0, 0, 1392, 1393, 1, 0, 0, 0, 1393, 1395, 1, 0, 0, 0, 1394, 1348,
		1, 0, 0, 0, 1394, 1349, 1, 0, 0, 0, 1394, 1350, 1, 0, 0, 0, 1394, 1351,
		1, 0, 0, 0, 1394, 1352, 1, 0, 0, 0, 1394, 1353, 1, 0, 0, 0, 1394, 1354,
		1, 0, 0, 0, 1394, 1355, 1, 0, 0, 0, 1394, 1356, 1, 0, 0, 0, 1394, 1357,
		1, 0, 0, 0, 1394, 1358, 1, 0, 0, 0, 1394, 1359, 1, 0, 0, 0, 1394, 1363,
		1, 0, 0, 0, 1394, 1364, 1, 0, 0, 0, 1394, 1365, 1, 0, 0, 0, 1394, 1366,
		1, 0, 0, 0, 1394, 1367, 1, 0, 0, 0, 1394, 1368, 1, 0, 0, 0, 1394, 1369,
		1, 0, 0, 0, 1394, 1370, 1, 0, 0, 0, 1394, 1371, 1, 0, 0, 0, 1394, 1372,
		1, 0, 0, 0, 1394, 1373, 1, 0, 0, 0, 1394, 1374, 1, 0, 0, 0, 1394, 1375,
		1, 0, 0, 0, 1394, 1377, 1, 0, 0, 0, 1394, 1378, 1, 0, 0, 0, 1394, 1379,
		1, 0, 0, 0, 1394, 1380, 1, 0, 0, 0, 1394, 1381, 1, 0, 0, 0, 1394, 1382,
		1, 0, 0, 0, 1394, 1383, 1, 0, 0, 0, 1394, 1384, 1, 0, 0, 0, 1394, 1385,
		1, 0, 0, 0, 1394, 1386, 1, 0, 0, 0, 1394, 1387, 1, 0, 0, 0, 1394, 1388,
		1, 0, 0, 0, 1394, 1389, 1, 0, 0, 0, 1395, 127, 1, 0, 0, 0, 1396, 1397,
		5, 365, 0, 0, 1397, 1399, 7, 16, 0, 0, 1398, 1400, 7, 17, 0, 0, 1399, 1398,
		1, 0, 0, 0, 1399, 1400, 1, 0, 0, 0, 1400, 1403, 1, 0, 0, 0, 1401, 1402,
		5, 350, 0, 0, 1402, 1404, 5, 375, 0, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1404,
		1, 0, 0, 0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 5, 368, 0, 0, 1406, 129,
		1, 0, 0, 0, 1407, 1409, 5, 194, 0, 0, 1408, 1407, 1, 0, 0, 0, 1408, 1409,
		1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1419, 5, 196, 0, 0, 1411, 1412,
		5, 39, 0, 0, 1412, 1413, 5, 258, 0, 0, 1413, 1419, 3, 460, 230, 0, 1414,
		1416, 5, 194, 0, 0, 1415, 1414, 1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416,
		1417, 1, 0, 0, 0, 1417, 1419, 7, 18, 0, 0, 1418, 1408, 1, 0, 0, 0, 1418,
		1411, 1, 0, 0, 0, 1418, 1415, 1, 0, 0, 0, 1419, 131, 1, 0, 0, 0, 1420,
		1422, 5, 349, 0, 0, 1421, 1420, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422,
		1423, 1, 0, 0, 0, 1423, 1424, 5, 355, 0, 0, 1424, 1433, 3, 398, 199, 0,
		1425, 1427, 5, 317, 0, 0, 1426, 1425, 1, 0, 0, 0, 1426, 1427, 1, 0, 0,
		0, 1427, 1428, 1, 0, 0, 0, 1428, 1430, 5, 75, 0, 0, 1429, 1431, 3, 398,
		199, 0, 1430, 1429, 1, 0, 0, 0, 1430, 1431, 1, 0, 0, 0, 1431, 1433, 1,
		0, 0, 0, 1432, 1421, 1, 0, 0, 0, 1432, 1426, 1, 0, 0, 0, 1433, 133, 1,
		0, 0, 0, 1434, 1435, 5, 59, 0, 0, 1435, 1439, 7, 19, 0, 0, 1436, 1437,
		5, 134, 0, 0, 1437, 1438, 5, 194, 0, 0, 1438, 1440, 5, 106, 0, 0, 1439,
		1436, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1441, 1, 0, 0, 0, 1441,
		1445, 3, 398, 199, 0, 1442, 1444, 3, 136, 68, 0, 1443, 1442, 1, 0, 0, 0,
		1444, 1447, 1, 0, 0, 0, 1445, 1443, 1, 0, 0, 0, 1445, 1446, 1, 0, 0, 0,
		1446, 135, 1, 0, 0, 0, 1447, 1445, 1, 0, 0, 0, 1448, 1449, 5, 48, 0, 0,
		1449, 1453, 3, 398, 199, 0, 1450, 1451, 5, 167, 0, 0, 1451, 1453, 3, 398,
		199, 0, 1452, 1448, 1, 0, 0, 0, 1452, 1450, 1, 0, 0, 0, 1453, 137, 1, 0,
		0, 0, 1454, 1462, 5, 9, 0, 0, 1455, 1458, 5, 59, 0, 0, 1456, 1457, 5, 205,
		0, 0, 1457, 1459, 5, 231, 0, 0, 1458, 1456, 1, 0, 0, 0, 1458, 1459, 1,
		0, 0, 0, 1459, 1462, 1, 0, 0, 0, 1460, 1462, 5, 231, 0, 0, 1461, 1454,
		1, 0, 0, 0, 1461, 1455, 1, 0, 0, 0, 1461, 1460, 1, 0, 0, 0, 1461, 1462,
		1, 0, 0, 0, 1462, 1463, 1, 0, 0, 0, 1463, 1464, 5, 121, 0, 0, 1464, 1466,
		3, 460, 230, 0, 1465, 1467, 3, 156, 78, 0, 1466, 1465, 1, 0, 0, 0, 1466,
		1467, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1470, 3, 140, 70, 0, 1469,
		1471, 7, 20, 0, 0, 1470, 1469, 1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471,
		1473, 1, 0, 0, 0, 1472, 1474, 3, 50, 25, 0, 1473, 1472, 1, 0, 0, 0, 1473,
		1474, 1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1476, 3, 6, 3, 0, 1476,
		139, 1, 0, 0, 0, 1477, 1478, 7, 21, 0, 0, 1478, 1480, 3, 126, 63, 0, 1479,
		1481, 3, 128, 64, 0, 1480, 1479, 1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481,
		141, 1, 0, 0, 0, 1482, 1490, 5, 9, 0, 0, 1483, 1486, 5, 59, 0, 0, 1484,
		1485, 5, 205, 0, 0, 1485, 1487, 5, 231, 0, 0, 1486, 1484, 1, 0, 0, 0, 1486,
		1487, 1, 0, 0, 0, 1487, 1490, 1, 0, 0, 0, 1488, 1490, 5, 231, 0, 0, 1489,
		1482, 1, 0, 0, 0, 1489, 1483, 1, 0, 0, 0, 1489, 1488, 1, 0, 0, 0, 1489,
		1490, 1, 0, 0, 0, 1490, 1491, 1, 0, 0, 0, 1491, 1492, 5, 212, 0, 0, 1492,
		1493, 3, 460, 230, 0, 1493, 1494, 7, 20, 0, 0, 1494, 1495, 3, 144, 72,
		0, 1495, 1499, 5, 98, 0, 0, 1496, 1497, 3, 460, 230, 0, 1497, 1498, 5,
		370, 0, 0, 1498, 1500, 1, 0, 0, 0, 1499, 1496, 1, 0, 0, 0, 1499, 1500,
		1, 0, 0, 0, 1500, 143, 1, 0, 0, 0, 1501, 1502, 3, 146, 73, 0, 1502, 1508,
		5, 370, 0, 0, 1503, 1504, 3, 146, 73, 0, 1504, 1505, 5, 370, 0, 0, 1505,
		1507, 1, 0, 0, 0, 1506, 1503, 1, 0, 0, 0, 1507, 1510, 1, 0, 0, 0, 1508,
		1506, 1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509, 145, 1, 0, 0, 0, 1510,
		1508, 1, 0, 0, 0, 1511, 1525, 3, 52, 26, 0, 1512, 1513, 5, 121, 0, 0, 1513,
		1515, 3, 460, 230, 0, 1514, 1516, 3, 156, 78, 0, 1515, 1514, 1, 0, 0, 0,
		1515, 1516, 1, 0, 0, 0, 1516, 1517, 1, 0, 0, 0, 1517, 1518, 3, 140, 70,
		0, 1518, 1525, 1, 0, 0, 0, 1519, 1520, 7, 22, 0, 0, 1520, 1522, 3, 460,
		230, 0, 1521, 1523, 3, 156, 78, 0, 1522, 1521, 1, 0, 0, 0, 1522, 1523,
		1, 0, 0, 0, 1523, 1525, 1, 0, 0, 0, 1524, 1511, 1, 0, 0, 0, 1524, 1512,
		1, 0, 0, 0, 1524, 1519, 1, 0, 0, 0, 1525, 147, 1, 0, 0, 0, 1526, 1534,
		5, 9, 0, 0, 1527, 1530, 5, 59, 0, 0, 1528, 1529, 5, 205, 0, 0, 1529, 1531,
		5, 231, 0, 0, 1530, 1528, 1, 0, 0, 0, 1530, 1531, 1, 0, 0, 0, 1531, 1534,
		1, 0, 0, 0, 1532, 1534, 5, 231, 0, 0, 1533, 1526, 1, 0, 0, 0, 1533, 1527,
		1, 0, 0, 0, 1533, 1532, 1, 0, 0, 0, 1533, 1534, 1, 0, 0, 0, 1534, 1535,
		1, 0, 0, 0, 1535, 1536, 5, 212, 0, 0, 1536, 1537, 5, 27, 0, 0, 1537, 1538,
		3, 460, 230, 0, 1538, 1539, 7, 20, 0, 0, 1539, 1540, 3, 150, 75, 0, 1540,
		1544, 5, 98, 0, 0, 1541, 1542, 3, 460, 230, 0, 1542, 1543, 5, 370, 0, 0,
		1543, 1545, 1, 0, 0, 0, 1544, 1541, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0,
		1545, 149, 1, 0, 0, 0, 1546, 1547, 3, 152, 76, 0, 1547, 1553, 5, 370, 0,
		0, 1548, 1549, 3, 152, 76, 0, 1549, 1550, 5, 370, 0, 0, 1550, 1552, 1,
		0, 0, 0, 1551, 1548, 1, 0, 0, 0, 1552, 1555, 1, 0, 0, 0, 1553, 1551, 1,
		0, 0, 0, 1553, 1554, 1, 0, 0, 0, 1554, 151, 1, 0, 0, 0, 1555, 1553, 1,
		0, 0, 0, 1556, 1560, 3, 52, 26, 0, 1557, 1560, 3, 138, 69, 0, 1558, 1560,
		3, 154, 77, 0, 1559, 1556, 1, 0, 0, 0, 1559, 1557, 1, 0, 0, 0, 1559, 1558,
		1, 0, 0, 0, 1560, 153, 1, 0, 0, 0, 1561, 1569, 5, 9, 0, 0, 1562, 1565,
		5, 59, 0, 0, 1563, 1564, 5, 205, 0, 0, 1564, 1566, 5, 231, 0, 0, 1565,
		1563, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 1569, 1, 0, 0, 0, 1567,
		1569, 5, 231, 0, 0, 1568, 1561, 1, 0, 0, 0, 1568, 1562, 1, 0, 0, 0, 1568,
		1567, 1, 0, 0, 0, 1568, 1569, 1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570,
		1571, 7, 22, 0, 0, 1571, 1573, 3, 460, 230, 0, 1572, 1574, 3, 156, 78,
		0, 1573, 1572, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574, 1576, 1, 0, 0,
		0, 1575, 1577, 3, 160, 80, 0, 1576, 1575, 1, 0, 0, 0, 1576, 1577, 1, 0,
		0, 0, 1577, 1579, 1, 0, 0, 0, 1578, 1580, 7, 20, 0, 0, 1579, 1578, 1, 0,
		0, 0, 1579, 1580, 1, 0, 0, 0, 1580, 1582, 1, 0, 0, 0, 1581, 1583, 3, 50,
		25, 0, 1582, 1581, 1, 0, 0, 0, 1582, 1583, 1, 0, 0, 0, 1583, 1585, 1, 0,
		0, 0, 1584, 1586, 3, 288, 144, 0, 1585, 1584, 1, 0, 0, 0, 1585, 1586, 1,
		0, 0, 0, 1586, 1587, 1, 0, 0, 0, 1587, 1591, 3, 10, 5, 0, 1588, 1589, 3,
		460, 230, 0, 1589, 1590, 5, 370, 0, 0, 1590, 1592, 1, 0, 0, 0, 1591, 1588,
		1, 0, 0, 0, 1591, 1592, 1, 0, 0, 0, 1592, 155, 1, 0, 0, 0, 1593, 1594,
		5, 365, 0, 0, 1594, 1616, 5, 368, 0, 0, 1595, 1596, 5, 365, 0, 0, 1596,
		1601, 3, 158, 79, 0, 1597, 1598, 5, 350, 0, 0, 1598, 1600, 3, 158, 79,
		0, 1599, 1597, 1, 0, 0, 0, 1600, 1603, 1, 0, 0, 0, 1601, 1599, 1, 0, 0,
		0, 1601, 1602, 1, 0, 0, 0, 1602, 1604, 1, 0, 0, 0, 1603, 1601, 1, 0, 0,
		0, 1604, 1605, 5, 368, 0, 0, 1605, 1616, 1, 0, 0, 0, 1606, 1607, 4, 78,
		2, 0, 1607, 1612, 3, 158, 79, 0, 1608, 1609, 5, 350, 0, 0, 1609, 1611,
		3, 158, 79, 0, 1610, 1608, 1, 0, 0, 0, 1611, 1614, 1, 0, 0, 0, 1612, 1610,
		1, 0, 0, 0, 1612, 1613, 1, 0, 0, 0, 1613, 1616, 1, 0, 0, 0, 1614, 1612,
		1, 0, 0, 0, 1615, 1593, 1, 0, 0, 0, 1615, 1595, 1, 0, 0, 0, 1615, 1606,
		1, 0, 0, 0, 1616, 157, 1, 0, 0, 0, 1617, 1623, 5, 137, 0, 0, 1618, 1623,
		5, 207, 0, 0, 1619, 1623, 5, 142, 0, 0, 1620, 1621, 5, 137, 0, 0, 1621,
		1623, 5, 207, 0, 0, 1622, 1617, 1, 0, 0, 0, 1622, 1618, 1, 0, 0, 0, 1622,
		1619, 1, 0, 0, 0, 1622, 1620, 1, 0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623,
		1624, 1, 0, 0, 0, 1624, 1625, 3, 460, 230, 0, 1625, 1627, 3, 126, 63, 0,
		1626, 1628, 3, 128, 64, 0, 1627, 1626, 1, 0, 0, 0, 1627, 1628, 1, 0, 0,
		0, 1628, 1632, 1, 0, 0, 0, 1629, 1631, 3, 130, 65, 0, 1630, 1629, 1, 0,
		0, 0, 1631, 1634, 1, 0, 0, 0, 1632, 1630, 1, 0, 0, 0, 1632, 1633, 1, 0,
		0, 0, 1633, 1636, 1, 0, 0, 0, 1634, 1632, 1, 0, 0, 0, 1635, 1637, 3, 132,
		66, 0, 1636, 1635, 1, 0, 0, 0, 1636, 1637, 1, 0, 0, 0, 1637, 1660, 1, 0,
		0, 0, 1638, 1644, 3, 460, 230, 0, 1639, 1645, 5, 137, 0, 0, 1640, 1645,
		5, 207, 0, 0, 1641, 1645, 5, 142, 0, 0, 1642, 1643, 5, 137, 0, 0, 1643,
		1645, 5, 207, 0, 0, 1644, 1639, 1, 0, 0, 0, 1644, 1640, 1, 0, 0, 0, 1644,
		1641, 1, 0, 0, 0, 1644, 1642, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645,
		1646, 1, 0, 0, 0, 1646, 1648, 3, 126, 63, 0, 1647, 1649, 3, 128, 64, 0,
		1648, 1647, 1, 0, 0, 0, 1648, 1649, 1, 0, 0, 0, 1649, 1653, 1, 0, 0, 0,
		1650, 1652, 3, 130, 65, 0, 1651, 1650, 1, 0, 0, 0, 1652, 1655, 1, 0, 0,
		0, 1653, 1651, 1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654, 1657, 1, 0, 0,
		0, 1655, 1653, 1, 0, 0, 0, 1656, 1658, 3, 132, 66, 0, 1657, 1656, 1, 0,
		0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1660, 1, 0, 0, 0, 1659, 1622, 1, 0,
		0, 0, 1659, 1638, 1, 0, 0, 0, 1660, 159, 1, 0, 0, 0, 1661, 1663, 3, 162,
		81, 0, 1662, 1661, 1, 0, 0, 0, 1663, 1664, 1, 0, 0, 0, 1664, 1662, 1, 0,
		0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 161, 1, 0, 0, 0, 1666, 1667, 5, 160,
		0, 0, 1667, 1678, 5, 269, 0, 0, 1668, 1669, 5, 269, 0, 0, 1669, 1670, 5,
		254, 0, 0, 1670, 1678, 7, 23, 0, 0, 1671, 1673, 5, 93, 0, 0, 1672, 1671,
		1, 0, 0, 0, 1672, 1673, 1, 0, 0, 0, 1673, 1674, 1, 0, 0, 0, 1674, 1675,
		5, 234, 0, 0, 1675, 1676, 5, 261, 0, 0, 1676, 1678, 5, 375, 0, 0, 1677,
		1666, 1, 0, 0, 0, 1677, 1668, 1, 0, 0, 0, 1677, 1672, 1, 0, 0, 0, 1678,
		163, 1, 0, 0, 0, 1679, 1680, 5, 92, 0, 0, 1680, 1683, 5, 285, 0, 0, 1681,
		1682, 5, 134, 0, 0, 1682, 1684, 5, 106, 0, 0, 1683, 1681, 1, 0, 0, 0, 1683,
		1684, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1708, 3, 344, 172, 0, 1686,
		1687, 5, 92, 0, 0, 1687, 1690, 5, 212, 0, 0, 1688, 1689, 5, 134, 0, 0,
		1689, 1691, 5, 106, 0, 0, 1690, 1688, 1, 0, 0, 0, 1690, 1691, 1, 0, 0,
		0, 1691, 1692, 1, 0, 0, 0, 1692, 1708, 3, 460, 230, 0, 1693, 1694, 5, 92,
		0, 0, 1694, 1697, 7, 24, 0, 0, 1695, 1696, 5, 134, 0, 0, 1696, 1698, 5,
		106, 0, 0, 1697, 1695, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1699,
		1, 0, 0, 0, 1699, 1708, 3, 460, 230, 0, 1700, 1701, 5, 92, 0, 0, 1701,
		1704, 7, 19, 0, 0, 1702, 1703, 5, 134, 0, 0, 1703, 1705, 5, 106, 0, 0,
		1704, 1702, 1, 0, 0, 0, 1704, 1705, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0,
		1706, 1708, 3, 398, 199, 0, 1707, 1679, 1, 0, 0, 0, 1707, 1686, 1, 0, 0,
		0, 1707, 1693, 1, 0, 0, 0, 1707, 1700, 1, 0, 0, 0, 1708, 165, 1, 0, 0,
		0, 1709, 1710, 5, 98, 0, 0, 1710, 1711, 5, 297, 0, 0, 1711, 167, 1, 0,
		0, 0, 1712, 1714, 7, 25, 0, 0, 1713, 1715, 5, 136, 0, 0, 1714, 1713, 1,
		0, 0, 0, 1714, 1715, 1, 0, 0, 0, 1715, 1716, 1, 0, 0, 0, 1716, 1722, 3,
		398, 199, 0, 1717, 1718, 5, 365, 0, 0, 1718, 1719, 3, 436, 218, 0, 1719,
		1720, 5, 368, 0, 0, 1720, 1723, 1, 0, 0, 0, 1721, 1723, 3, 436, 218, 0,
		1722, 1717, 1, 0, 0, 0, 1722, 1721, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0,
		1723, 1733, 1, 0, 0, 0, 1724, 1725, 5, 151, 0, 0, 1725, 1730, 5, 372, 0,
		0, 1726, 1727, 5, 350, 0, 0, 1727, 1729, 5, 372, 0, 0, 1728, 1726, 1, 0,
		0, 0, 1729, 1732, 1, 0, 0, 0, 1730, 1728, 1, 0, 0, 0, 1730, 1731, 1, 0,
		0, 0, 1731, 1734, 1, 0, 0, 0, 1732, 1730, 1, 0, 0, 0, 1733, 1724, 1, 0,
		0, 0, 1733, 1734, 1, 0, 0, 0, 1734, 1736, 1, 0, 0, 0, 1735, 1737, 3, 290,
		145, 0, 1736, 1735, 1, 0, 0, 0, 1736, 1737, 1, 0, 0, 0, 1737, 169, 1, 0,
		0, 0, 1738, 1742, 3, 172, 86, 0, 1739, 1742, 3, 174, 87, 0, 1740, 1742,
		3, 176, 88, 0, 1741, 1738, 1, 0, 0, 0, 1741, 1739, 1, 0, 0, 0, 1741, 1740,
		1, 0, 0, 0, 1742, 171, 1, 0, 0, 0, 1743, 1744, 5, 134, 0, 0, 1744, 1745,
		3, 382, 191, 0, 1745, 1746, 5, 290, 0, 0, 1746, 1750, 3, 2, 1, 0, 1747,
		1749, 3, 178, 89, 0, 1748, 1747, 1, 0, 0, 0, 1749, 1752, 1, 0, 0, 0, 1750,
		1748, 1, 0, 0, 0, 1750, 1751, 1, 0, 0, 0, 1751, 1754, 1, 0, 0, 0, 1752,
		1750, 1, 0, 0, 0, 1753, 1755, 3, 180, 90, 0, 1754, 1753, 1, 0, 0, 0, 1754,
		1755, 1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756, 1757, 5, 98, 0, 0, 1757,
		1758, 5, 134, 0, 0, 1758, 173, 1, 0, 0, 0, 1759, 1760, 5, 134, 0, 0, 1760,
		1761, 3, 382, 191, 0, 1761, 1764, 3, 6, 3, 0, 1762, 1763, 5, 94, 0, 0,
		1763, 1765, 3, 6, 3, 0, 1764, 1762, 1, 0, 0, 0, 1764, 1765, 1, 0, 0, 0,
		1765, 175, 1, 0, 0, 0, 1766, 1767, 5, 353, 0, 0, 1767, 1768, 5, 134, 0,
		0, 1768, 1769, 3, 382, 191, 0, 1769, 1770, 5, 290, 0, 0, 1770, 1771, 3,
		6, 3, 0, 1771, 177, 1, 0, 0, 0, 1772, 1773, 7, 26, 0, 0, 1773, 1774, 3,
		382, 191, 0, 1774, 1775, 5, 290, 0, 0, 1775, 1776, 3, 2, 1, 0, 1776, 179,
		1, 0, 0, 0, 1777, 1778, 5, 94, 0, 0, 1778, 1779, 3, 2, 1, 0, 1779, 181,
		1, 0, 0, 0, 1780, 1783, 5, 138, 0, 0, 1781, 1784, 3, 454, 227, 0, 1782,
		1784, 3, 398, 199, 0, 1783, 1781, 1, 0, 0, 0, 1783, 1782, 1, 0, 0, 0, 1784,
		183, 1, 0, 0, 0, 1785, 1792, 5, 143, 0, 0, 1786, 1787, 5, 210, 0, 0, 1787,
		1793, 5, 285, 0, 0, 1788, 1790, 5, 151, 0, 0, 1789, 1791, 5, 285, 0, 0,
		1790, 1789, 1, 0, 0, 0, 1790, 1791, 1, 0, 0, 0, 1791, 1793, 1, 0, 0, 0,
		1792, 1786, 1, 0, 0, 0, 1792, 1788, 1, 0, 0, 0, 1793, 1794, 1, 0, 0, 0,
		1794, 1796, 3, 344, 172, 0, 1795, 1797, 3, 186, 93, 0, 1796, 1795, 1, 0,
		0, 0, 1796, 1797, 1, 0, 0, 0, 1797, 1800, 1, 0, 0, 0, 1798, 1801, 3, 292,
		146, 0, 1799, 1801, 3, 188, 94, 0, 1800, 1798, 1, 0, 0, 0, 1800, 1799,
		1, 0, 0, 0, 1801, 185, 1, 0, 0, 0, 1802, 1803, 5, 365, 0, 0, 1803, 1808,
		3, 462, 231, 0, 1804, 1805, 5, 350, 0, 0, 1805, 1807, 3, 462, 231, 0, 1806,
		1804, 1, 0, 0, 0, 1807, 1810, 1, 0, 0, 0, 1808, 1806, 1, 0, 0, 0, 1808,
		1809, 1, 0, 0, 0, 1809, 1811, 1, 0, 0, 0, 1810, 1808, 1, 0, 0, 0, 1811,
		1812, 5, 368, 0, 0, 1812, 187, 1, 0, 0, 0, 1813, 1814, 5, 308, 0, 0, 1814,
		1819, 3, 190, 95, 0, 1815, 1816, 5, 350, 0, 0, 1816, 1818, 3, 190, 95,
		0, 1817, 1815, 1, 0, 0, 0, 1818, 1821, 1, 0, 0, 0, 1819, 1817, 1, 0, 0,
		0, 1819, 1820, 1, 0, 0, 0, 1820, 189, 1, 0, 0, 0, 1821, 1819, 1, 0, 0,
		0, 1822, 1823, 5, 365, 0, 0, 1823, 1828, 3, 398, 199, 0, 1824, 1825, 5,
		350, 0, 0, 1825, 1827, 3, 398, 199, 0, 1826, 1824, 1, 0, 0, 0, 1827, 1830,
		1, 0, 0, 0, 1828, 1826, 1, 0, 0, 0, 1828, 1829, 1, 0, 0, 0, 1829, 1831,
		1, 0, 0, 0, 1830, 1828, 1, 0, 0, 0, 1831, 1832, 5, 368, 0, 0, 1832, 191,
		1, 0, 0, 0, 1833, 1834, 5, 143, 0, 0, 1834, 1836, 5, 210, 0, 0, 1835, 1837,
		5, 166, 0, 0, 1836, 1835, 1, 0, 0, 0, 1836, 1837, 1, 0, 0, 0, 1837, 1838,
		1, 0, 0, 0, 1838, 1839, 5, 87, 0, 0, 1839, 1840, 3, 442, 221, 0, 1840,
		1841, 3, 440, 220, 0, 1841, 193, 1, 0, 0, 0, 1842, 1844, 5, 107, 0, 0,
		1843, 1845, 5, 372, 0, 0, 1844, 1843, 1, 0, 0, 0, 1844, 1845, 1, 0, 0,
		0, 1845, 1848, 1, 0, 0, 0, 1846, 1847, 5, 314, 0, 0, 1847, 1849, 3, 382,
		191, 0, 1848, 1846, 1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849, 195, 1, 0,
		0, 0, 1850, 1851, 5, 122, 0, 0, 1851, 1852, 5, 85, 0, 0, 1852, 1853, 3,
		198, 99, 0, 1853, 197, 1, 0, 0, 0, 1854, 1857, 3, 200, 100, 0, 1855, 1857,
		3, 202, 101, 0, 1856, 1854, 1, 0, 0, 0, 1856, 1855, 1, 0, 0, 0, 1857, 199,
		1, 0, 0, 0, 1858, 1859, 5, 104, 0, 0, 1859, 1860, 5, 375, 0, 0, 1860, 1861,
		3, 462, 231, 0, 1861, 1862, 5, 355, 0, 0, 1862, 1863, 5, 180, 0, 0, 1863,
		201, 1, 0, 0, 0, 1864, 1865, 3, 462, 231, 0, 1865, 1866, 5, 355, 0, 0,
		1866, 1867, 5, 246, 0, 0, 1867, 203, 1, 0, 0, 0, 1868, 1869, 5, 125, 0,
		0, 1869, 1874, 3, 206, 103, 0, 1870, 1871, 5, 350, 0, 0, 1871, 1873, 3,
		206, 103, 0, 1872, 1870, 1, 0, 0, 0, 1873, 1876, 1, 0, 0, 0, 1874, 1872,
		1, 0, 0, 0, 1874, 1875, 1, 0, 0, 0, 1875, 1877, 1, 0, 0, 0, 1876, 1874,
		1, 0, 0, 0, 1877, 1878, 5, 295, 0, 0, 1878, 1879, 5, 241, 0, 0, 1879, 1880,
		3, 462, 231, 0, 1880, 205, 1, 0, 0, 0, 1881, 1882, 5, 103, 0, 0, 1882,
		1883, 5, 202, 0, 0, 1883, 1884, 5, 222, 0, 0, 1884, 1885, 3, 462, 231,
		0, 1885, 207, 1, 0, 0, 0, 1886, 1888, 5, 161, 0, 0, 1887, 1889, 5, 372,
		0, 0, 1888, 1887, 1, 0, 0, 0, 1888, 1889, 1, 0, 0, 0, 1889, 209, 1, 0,
		0, 0, 1890, 1891, 5, 175, 0, 0, 1891, 1892, 5, 199, 0, 0, 1892, 1895, 3,
		460, 230, 0, 1893, 1894, 5, 295, 0, 0, 1894, 1896, 3, 460, 230, 0, 1895,
		1893, 1, 0, 0, 0, 1895, 1896, 1, 0, 0, 0, 1896, 1899, 1, 0, 0, 0, 1897,
		1898, 5, 16, 0, 0, 1898, 1900, 3, 460, 230, 0, 1899, 1897, 1, 0, 0, 0,
		1899, 1900, 1, 0, 0, 0, 1900, 211, 1, 0, 0, 0, 1901, 1902, 5, 204, 0, 0,
		1902, 1908, 3, 460, 230, 0, 1903, 1906, 5, 115, 0, 0, 1904, 1907, 3, 292,
		146, 0, 1905, 1907, 3, 398, 199, 0, 1906, 1904, 1, 0, 0, 0, 1906, 1905,
		1, 0, 0, 0, 1907, 1909, 1, 0, 0, 0, 1908, 1903, 1, 0, 0, 0, 1908, 1909,
		1, 0, 0, 0, 1909, 213, 1, 0, 0, 0, 1910, 1912, 5, 110, 0, 0, 1911, 1913,
		5, 119, 0, 0, 1912, 1911, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1914,
		1, 0, 0, 0, 1914, 1916, 3, 460, 230, 0, 1915, 1917, 3, 324, 162, 0, 1916,
		1915, 1, 0, 0, 0, 1916, 1917, 1, 0, 0, 0, 1917, 1918, 1, 0, 0, 0, 1918,
		1919, 5, 151, 0, 0, 1919, 1924, 3, 460, 230, 0, 1920, 1921, 5, 350, 0,
		0, 1921, 1923, 3, 460, 230, 0, 1922, 1920, 1, 0, 0, 0, 1923, 1926, 1, 0,
		0, 0, 1924, 1922, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 1928, 1, 0,
		0, 0, 1926, 1924, 1, 0, 0, 0, 1927, 1929, 3, 216, 108, 0, 1928, 1927, 1,
		0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 215, 1, 0, 0, 0, 1930, 1931, 5,
		164, 0, 0, 1931, 1932, 3, 398, 199, 0, 1932, 217, 1, 0, 0, 0, 1933, 1934,
		5, 45, 0, 0, 1934, 1935, 7, 27, 0, 0, 1935, 1936, 5, 202, 0, 0, 1936, 1938,
		3, 344, 172, 0, 1937, 1939, 3, 220, 110, 0, 1938, 1937, 1, 0, 0, 0, 1938,
		1939, 1, 0, 0, 0, 1939, 219, 1, 0, 0, 0, 1940, 1941, 5, 47, 0, 0, 1941,
		1942, 5, 365, 0, 0, 1942, 1947, 3, 462, 231, 0, 1943, 1944, 5, 350, 0,
		0, 1944, 1946, 3, 462, 231, 0, 1945, 1943, 1, 0, 0, 0, 1946, 1949, 1, 0,
		0, 0, 1947, 1945, 1, 0, 0, 0, 1947, 1948, 1, 0, 0, 0, 1948, 1950, 1, 0,
		0, 0, 1949, 1947, 1, 0, 0, 0, 1950, 1951, 5, 368, 0, 0, 1951, 221, 1, 0,
		0, 0, 1952, 1953, 5, 42, 0, 0, 1953, 1954, 5, 372, 0, 0, 1954, 223, 1,
		0, 0, 0, 1955, 1956, 5, 44, 0, 0, 1956, 1957, 7, 28, 0, 0, 1957, 1958,
		3, 226, 113, 0, 1958, 1959, 5, 350, 0, 0, 1959, 1960, 3, 226, 113, 0, 1960,
		225, 1, 0, 0, 0, 1961, 1963, 3, 344, 172, 0, 1962, 1964, 3, 346, 173, 0,
		1963, 1962, 1, 0, 0, 0, 1963, 1964, 1, 0, 0, 0, 1964, 1970, 1, 0, 0, 0,
		1965, 1966, 5, 365, 0, 0, 1966, 1967, 3, 292, 146, 0, 1967, 1968, 5, 368,
		0, 0, 1968, 1970, 1, 0, 0, 0, 1969, 1961, 1, 0, 0, 0, 1969, 1965, 1, 0,
		0, 0, 1970, 1973, 1, 0, 0, 0, 1971, 1972, 5, 16, 0, 0, 1972, 1974, 3, 462,
		231, 0, 1973, 1971, 1, 0, 0, 0, 1973, 1974, 1, 0, 0, 0, 1974, 227, 1, 0,
		0, 0, 1975, 1976, 5, 56, 0, 0, 1976, 1977, 5, 119, 0, 0, 1977, 1978, 5,
		166, 0, 0, 1978, 1983, 3, 232, 116, 0, 1979, 1980, 5, 350, 0, 0, 1980,
		1982, 3, 232, 116, 0, 1981, 1979, 1, 0, 0, 0, 1982, 1985, 1, 0, 0, 0, 1983,
		1981, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 1986, 1, 0, 0, 0, 1985,
		1983, 1, 0, 0, 0, 1986, 1987, 5, 295, 0, 0, 1987, 1991, 3, 234, 117, 0,
		1988, 1990, 3, 238, 119, 0, 1989, 1988, 1, 0, 0, 0, 1990, 1993, 1, 0, 0,
		0, 1991, 1989, 1, 0, 0, 0, 1991, 1992, 1, 0, 0, 0, 1992, 229, 1, 0, 0,
		0, 1993, 1991, 1, 0, 0, 0, 1994, 2000, 5, 56, 0, 0, 1995, 2001, 3, 344,
		172, 0, 1996, 1997, 5, 365, 0, 0, 1997, 1998, 3, 292, 146, 0, 1998, 1999,
		5, 368, 0, 0, 1999, 2001, 1, 0, 0, 0, 2000, 1995, 1, 0, 0, 0, 2000, 1996,
		1, 0, 0, 0, 2001, 2002, 1, 0, 0, 0, 2002, 2004, 5, 295, 0, 0, 2003, 2005,
		5, 130, 0, 0, 2004, 2003, 1, 0, 0, 0, 2004, 2005, 1, 0, 0, 0, 2005, 2006,
		1, 0, 0, 0, 2006, 2010, 3, 234, 117, 0, 2007, 2009, 3, 236, 118, 0, 2008,
		2007, 1, 0, 0, 0, 2009, 2012, 1, 0, 0, 0, 2010, 2008, 1, 0, 0, 0, 2010,
		2011, 1, 0, 0, 0, 2011, 231, 1, 0, 0, 0, 2012, 2010, 1, 0, 0, 0, 2013,
		2016, 3, 454, 227, 0, 2014, 2016, 3, 398, 199, 0, 2015, 2013, 1, 0, 0,
		0, 2015, 2014, 1, 0, 0, 0, 2016, 233, 1, 0, 0, 0, 2017, 2020, 3, 454, 227,
		0, 2018, 2020, 3, 398, 199, 0, 2019, 2017, 1, 0, 0, 0, 2019, 2018, 1, 0,
		0, 0, 2020, 235, 1, 0, 0, 0, 2021, 2022, 5, 16, 0, 0, 2022, 2030, 3, 462,
		231, 0, 2023, 2024, 5, 19, 0, 0, 2024, 2030, 3, 398, 199, 0, 2025, 2026,
		5, 82, 0, 0, 2026, 2030, 3, 398, 199, 0, 2027, 2028, 5, 271, 0, 0, 2028,
		2030, 3, 462, 231, 0, 2029, 2021, 1, 0, 0, 0, 2029, 2023, 1, 0, 0, 0, 2029,
		2025, 1, 0, 0, 0, 2029, 2027, 1, 0, 0, 0, 2030, 237, 1, 0, 0, 0, 2031,
		2032, 7, 29, 0, 0, 2032, 239, 1, 0, 0, 0, 2033, 2035, 5, 50, 0, 0, 2034,
		2036, 5, 319, 0, 0, 2035, 2034, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036,
		241, 1, 0, 0, 0, 2037, 2039, 5, 59, 0, 0, 2038, 2040, 5, 302, 0, 0, 2039,
		2038, 1, 0, 0, 0, 2039, 2040, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041,
		2042, 5, 139, 0, 0, 2042, 2043, 3, 462, 231, 0, 2043, 2044, 5, 202, 0,
		0, 2044, 2045, 3, 344, 172, 0, 2045, 2046, 5, 365, 0, 0, 2046, 2051, 3,
		244, 122, 0, 2047, 2048, 5, 350, 0, 0, 2048, 2050, 3, 244, 122, 0, 2049,
		2047, 1, 0, 0, 0, 2050, 2053, 1, 0, 0, 0, 2051, 2049, 1, 0, 0, 0, 2051,
		2052, 1, 0, 0, 0, 2052, 2054, 1, 0, 0, 0, 2053, 2051, 1, 0, 0, 0, 2054,
		2055, 5, 368, 0, 0, 2055, 243, 1, 0, 0, 0, 2056, 2058, 3, 462, 231, 0,
		2057, 2059, 7, 8, 0, 0, 2058, 2057, 1, 0, 0, 0, 2058, 2059, 1, 0, 0, 0,
		2059, 245, 1, 0, 0, 0, 2060, 2061, 3, 248, 124, 0, 2061, 247, 1, 0, 0,
		0, 2062, 2063, 5, 317, 0, 0, 2063, 2064, 5, 365, 0, 0, 2064, 2065, 3, 462,
		231, 0, 2065, 2066, 5, 355, 0, 0, 2066, 2074, 3, 462, 231, 0, 2067, 2068,
		5, 350, 0, 0, 2068, 2069, 3, 462, 231, 0, 2069, 2070, 5, 355, 0, 0, 2070,
		2071, 3, 462, 231, 0, 2071, 2073, 1, 0, 0, 0, 2072, 2067, 1, 0, 0, 0, 2073,
		2076, 1, 0, 0, 0, 2074, 2072, 1, 0, 0, 0, 2074, 2075, 1, 0, 0, 0, 2075,
		2077, 1, 0, 0, 0, 2076, 2074, 1, 0, 0, 0, 2077, 2081, 5, 368, 0, 0, 2078,
		2080, 3, 114, 57, 0, 2079, 2078, 1, 0, 0, 0, 2080, 2083, 1, 0, 0, 0, 2081,
		2079, 1, 0, 0, 0, 2081, 2082, 1, 0, 0, 0, 2082, 249, 1, 0, 0, 0, 2083,
		2081, 1, 0, 0, 0, 2084, 2085, 5, 220, 0, 0, 2085, 2092, 3, 398, 199, 0,
		2086, 2087, 5, 220, 0, 0, 2087, 2088, 5, 365, 0, 0, 2088, 2089, 3, 398,
		199, 0, 2089, 2090, 5, 368, 0, 0, 2090, 2092, 1, 0, 0, 0, 2091, 2084, 1,
		0, 0, 0, 2091, 2086, 1, 0, 0, 0, 2092, 251, 1, 0, 0, 0, 2093, 2095, 5,
		353, 0, 0, 2094, 2093, 1, 0, 0, 0, 2094, 2095, 1, 0, 0, 0, 2095, 2096,
		1, 0, 0, 0, 2096, 2098, 5, 225, 0, 0, 2097, 2099, 3, 398, 199, 0, 2098,
		2097, 1, 0, 0, 0, 2098, 2099, 1, 0, 0, 0, 2099, 253, 1, 0, 0, 0, 2100,
		2101, 5, 227, 0, 0, 2101, 255, 1, 0, 0, 0, 2102, 2114, 5, 232, 0, 0, 2103,
		2105, 5, 272, 0, 0, 2104, 2106, 5, 307, 0, 0, 2105, 2104, 1, 0, 0, 0, 2105,
		2106, 1, 0, 0, 0, 2106, 2107, 1, 0, 0, 0, 2107, 2112, 3, 398, 199, 0, 2108,
		2109, 5, 258, 0, 0, 2109, 2110, 5, 180, 0, 0, 2110, 2111, 5, 355, 0, 0,
		2111, 2113, 3, 398, 199, 0, 2112, 2108, 1, 0, 0, 0, 2112, 2113, 1, 0, 0,
		0, 2113, 2115, 1, 0, 0, 0, 2114, 2103, 1, 0, 0, 0, 2114, 2115, 1, 0, 0,
		0, 2115, 257, 1, 0, 0, 0, 2116, 2118, 5, 236, 0, 0, 2117, 2119, 3, 398,
		199, 0, 2118, 2117, 1, 0, 0, 0, 2118, 2119, 1, 0, 0, 0, 2119, 259, 1, 0,
		0, 0, 2120, 2122, 5, 242, 0, 0, 2121, 2123, 5, 319, 0, 0, 2122, 2121, 1,
		0, 0, 0, 2122, 2123, 1, 0, 0, 0, 2123, 261, 1, 0, 0, 0, 2124, 2128, 3,
		264, 132, 0, 2125, 2128, 3, 266, 133, 0, 2126, 2128, 3, 268, 134, 0, 2127,
		2124, 1, 0, 0, 0, 2127, 2125, 1, 0, 0, 0, 2127, 2126, 1, 0, 0, 0, 2128,
		263, 1, 0, 0, 0, 2129, 2131, 5, 63, 0, 0, 2130, 2129, 1, 0, 0, 0, 2130,
		2131, 1, 0, 0, 0, 2131, 2132, 1, 0, 0, 0, 2132, 2135, 5, 251, 0, 0, 2133,
		2135, 5, 64, 0, 0, 2134, 2130, 1, 0, 0, 0, 2134, 2133, 1, 0, 0, 0, 2135,
		2137, 1, 0, 0, 0, 2136, 2138, 5, 355, 0, 0, 2137, 2136, 1, 0, 0, 0, 2137,
		2138, 1, 0, 0, 0, 2138, 2139, 1, 0, 0, 0, 2139, 2140, 3, 398, 199, 0, 2140,
		265, 1, 0, 0, 0, 2141, 2142, 7, 30, 0, 0, 2142, 2143, 7, 31, 0, 0, 2143,
		267, 1, 0, 0, 0, 2144, 2145, 5, 224, 0, 0, 2145, 2148, 5, 355, 0, 0, 2146,
		2149, 3, 398, 199, 0, 2147, 2149, 5, 193, 0, 0, 2148, 2146, 1, 0, 0, 0,
		2148, 2147, 1, 0, 0, 0, 2149, 2151, 1, 0, 0, 0, 2150, 2152, 5, 303, 0,
		0, 2151, 2150, 1, 0, 0, 0, 2151, 2152, 1, 0, 0, 0, 2152, 2153, 1, 0, 0,
		0, 2153, 2154, 5, 115, 0, 0, 2154, 2155, 7, 32, 0, 0, 2155, 269, 1, 0,
		0, 0, 2156, 2157, 5, 263, 0, 0, 2157, 2158, 3, 460, 230, 0, 2158, 271,
		1, 0, 0, 0, 2159, 2162, 5, 283, 0, 0, 2160, 2161, 5, 296, 0, 0, 2161, 2163,
		3, 398, 199, 0, 2162, 2160, 1, 0, 0, 0, 2162, 2163, 1, 0, 0, 0, 2163, 2164,
		1, 0, 0, 0, 2164, 2174, 5, 115, 0, 0, 2165, 2175, 3, 292, 146, 0, 2166,
		2168, 3, 344, 172, 0, 2167, 2169, 3, 346, 173, 0, 2168, 2167, 1, 0, 0,
		0, 2168, 2169, 1, 0, 0, 0, 2169, 2172, 1, 0, 0, 0, 2170, 2171, 5, 164,
		0, 0, 2171, 2173, 3, 398, 199, 0, 2172, 2170, 1, 0, 0, 0, 2172, 2173, 1,
		0, 0, 0, 2173, 2175, 1, 0, 0, 0, 2174, 2165, 1, 0, 0, 0, 2174, 2166, 1,
		0, 0, 0, 2175, 273, 1, 0, 0, 0, 2176, 2178, 5, 299, 0, 0, 2177, 2179, 5,
		285, 0, 0, 2178, 2177, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0, 2179, 2180,
		1, 0, 0, 0, 2180, 2181, 3, 344, 172, 0, 2181, 275, 1, 0, 0, 0, 2182, 2183,
		5, 305, 0, 0, 2183, 2184, 3, 398, 199, 0, 2184, 277, 1, 0, 0, 0, 2185,
		2187, 5, 308, 0, 0, 2186, 2188, 5, 365, 0, 0, 2187, 2186, 1, 0, 0, 0, 2187,
		2188, 1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189, 2194, 3, 398, 199, 0, 2190,
		2191, 5, 350, 0, 0, 2191, 2193, 3, 398, 199, 0, 2192, 2190, 1, 0, 0, 0,
		2193, 2196, 1, 0, 0, 0, 2194, 2192, 1, 0, 0, 0, 2194, 2195, 1, 0, 0, 0,
		2195, 2198, 1, 0, 0, 0, 2196, 2194, 1, 0, 0, 0, 2197, 2199, 5, 368, 0,
		0, 2198, 2197, 1, 0, 0, 0, 2198, 2199, 1, 0, 0, 0, 2199, 2200, 1, 0, 0,
		0, 2200, 2202, 5, 151, 0, 0, 2201, 2203, 5, 365, 0, 0, 2202, 2201, 1, 0,
		0, 0, 2202, 2203, 1, 0, 0, 0, 2203, 2204, 1, 0, 0, 0, 2204, 2209, 3, 460,
		230, 0, 2205, 2206, 5, 350, 0, 0, 2206, 2208, 3, 460, 230, 0, 2207, 2205,
		1, 0, 0, 0, 2208, 2211, 1, 0, 0, 0, 2209, 2207, 1, 0, 0, 0, 2209, 2210,
		1, 0, 0, 0, 2210, 2213, 1, 0, 0, 0, 2211, 2209, 1, 0, 0, 0, 2212, 2214,
		5, 368, 0, 0, 2213, 2212, 1, 0, 0, 0, 2213, 2214, 1, 0, 0, 0, 2214, 279,
		1, 0, 0, 0, 2215, 2216, 5, 316, 0, 0, 2216, 2217, 3, 382, 191, 0, 2217,
		2218, 7, 33, 0, 0, 2218, 2219, 3, 2, 1, 0, 2219, 2221, 5, 98, 0, 0, 2220,
		2222, 7, 34, 0, 0, 2221, 2220, 1, 0, 0, 0, 2221, 2222, 1, 0, 0, 0, 2222,
		281, 1, 0, 0, 0, 2223, 2224, 5, 174, 0, 0, 2224, 2225, 3, 2, 1, 0, 2225,
		2226, 5, 98, 0, 0, 2226, 2227, 5, 174, 0, 0, 2227, 283, 1, 0, 0, 0, 2228,
		2229, 5, 115, 0, 0, 2229, 2230, 5, 372, 0, 0, 2230, 2232, 5, 137, 0, 0,
		2231, 2233, 5, 365, 0, 0, 2232, 2231, 1, 0, 0, 0, 2232, 2233, 1, 0, 0,
		0, 2233, 2234, 1, 0, 0, 0, 2234, 2236, 3, 292, 146, 0, 2235, 2237, 5, 368,
		0, 0, 2236, 2235, 1, 0, 0, 0, 2236, 2237, 1, 0, 0, 0, 2237, 2238, 1, 0,
		0, 0, 2238, 2239, 5, 174, 0, 0, 2239, 2240, 3, 2, 1, 0, 2240, 2241, 5,
		98, 0, 0, 2241, 2242, 5, 174, 0, 0, 2242, 285, 1, 0, 0, 0, 2243, 2244,
		5, 115, 0, 0, 2244, 2245, 5, 372, 0, 0, 2245, 2247, 5, 137, 0, 0, 2246,
		2248, 5, 238, 0, 0, 2247, 2246, 1, 0, 0, 0, 2247, 2248, 1, 0, 0, 0, 2248,
		2249, 1, 0, 0, 0, 2249, 2250, 3, 398, 199, 0, 2250, 2251, 5, 354, 0, 0,
		2251, 2254, 3, 398, 199, 0, 2252, 2253, 7, 35, 0, 0, 2253, 2255, 3, 398,
		199, 0, 2254, 2252, 1, 0, 0, 0, 2254, 2255, 1, 0, 0, 0, 2255, 2256, 1,
		0, 0, 0, 2256, 2257, 5, 174, 0, 0, 2257, 2258, 3, 2, 1, 0, 2258, 2259,
		5, 98, 0, 0, 2259, 2260, 5, 174, 0, 0, 2260, 287, 1, 0, 0, 0, 2261, 2268,
		5, 381, 0, 0, 2262, 2263, 5, 361, 0, 0, 2263, 2264, 5, 361, 0, 0, 2264,
		2265, 5, 372, 0, 0, 2265, 2266, 5, 359, 0, 0, 2266, 2268, 5, 359, 0, 0,
		2267, 2261, 1, 0, 0, 0, 2267, 2262, 1, 0, 0, 0, 2268, 289, 1, 0, 0, 0,
		2269, 2270, 5, 306, 0, 0, 2270, 2275, 3, 398, 199, 0, 2271, 2272, 5, 350,
		0, 0, 2272, 2274, 3, 398, 199, 0, 2273, 2271, 1, 0, 0, 0, 2274, 2277, 1,
		0, 0, 0, 2275, 2273, 1, 0, 0, 0, 2275, 2276, 1, 0, 0, 0, 2276, 291, 1,
		0, 0, 0, 2277, 2275, 1, 0, 0, 0, 2278, 2280, 3, 294, 147, 0, 2279, 2278,
		1, 0, 0, 0, 2279, 2280, 1, 0, 0, 0, 2280, 2281, 1, 0, 0, 0, 2281, 2282,
		3, 300, 150, 0, 2282, 293, 1, 0, 0, 0, 2283, 2284, 5, 317, 0, 0, 2284,
		2289, 3, 296, 148, 0, 2285, 2286, 5, 350, 0, 0, 2286, 2288, 3, 296, 148,
		0, 2287, 2285, 1, 0, 0, 0, 2288, 2291, 1, 0, 0, 0, 2289, 2287, 1, 0, 0,
		0, 2289, 2290, 1, 0, 0, 0, 2290, 295, 1, 0, 0, 0, 2291, 2289, 1, 0, 0,
		0, 2292, 2294, 3, 462, 231, 0, 2293, 2295, 3, 298, 149, 0, 2294, 2293,
		1, 0, 0, 0, 2294, 2295, 1, 0, 0, 0, 2295, 2296, 1, 0, 0, 0, 2296, 2297,
		5, 13, 0, 0, 2297, 2298, 5, 365, 0, 0, 2298, 2299, 3, 300, 150, 0, 2299,
		2300, 5, 368, 0, 0, 2300, 297, 1, 0, 0, 0, 2301, 2302, 5, 365, 0, 0, 2302,
		2307, 3, 462, 231, 0, 2303, 2304, 5, 350, 0, 0, 2304, 2306, 3, 462, 231,
		0, 2305, 2303, 1, 0, 0, 0, 2306, 2309, 1, 0, 0, 0, 2307, 2305, 1, 0, 0,
		0, 2307, 2308, 1, 0, 0, 0, 2308, 2310, 1, 0, 0, 0, 2309, 2307, 1, 0, 0,
		0, 2310, 2311, 5, 368, 0, 0, 2311, 299, 1, 0, 0, 0, 2312, 2318, 3, 302,
		151, 0, 2313, 2314, 3, 304, 152, 0, 2314, 2315, 3, 302, 151, 0, 2315, 2317,
		1, 0, 0, 0, 2316, 2313, 1, 0, 0, 0, 2317, 2320, 1, 0, 0, 0, 2318, 2316,
		1, 0, 0, 0, 2318, 2319, 1, 0, 0, 0, 2319, 301, 1, 0, 0, 0, 2320, 2318,
		1, 0, 0, 0, 2321, 2327, 3, 306, 153, 0, 2322, 2323, 5, 365, 0, 0, 2323,
		2324, 3, 300, 150, 0, 2324, 2325, 5, 368, 0, 0, 2325, 2327, 1, 0, 0, 0,
		2326, 2321, 1, 0, 0, 0, 2326, 2322, 1, 0, 0, 0, 2327, 303, 1, 0, 0, 0,
		2328, 2330, 5, 301, 0, 0, 2329, 2331, 5, 7, 0, 0, 2330, 2329, 1, 0, 0,
		0, 2330, 2331, 1, 0, 0, 0, 2331, 2341, 1, 0, 0, 0, 2332, 2334, 5, 101,
		0, 0, 2333, 2335, 5, 7, 0, 0, 2334, 2333, 1, 0, 0, 0, 2334, 2335, 1, 0,
		0, 0, 2335, 2341, 1, 0, 0, 0, 2336, 2338, 5, 149, 0, 0, 2337, 2339, 5,
		7, 0, 0, 2338, 2337, 1, 0, 0, 0, 2338, 2339, 1, 0, 0, 0, 2339, 2341, 1,
		0, 0, 0, 2340, 2328, 1, 0, 0, 0, 2340, 2332, 1, 0, 0, 0, 2340, 2336, 1,
		0, 0, 0, 2341, 305, 1, 0, 0, 0, 2342, 2343, 7, 36, 0, 0, 2343, 2345, 3,
		308, 154, 0, 2344, 2346, 3, 322, 161, 0, 2345, 2344, 1, 0, 0, 0, 2345,
		2346, 1, 0, 0, 0, 2346, 2348, 1, 0, 0, 0, 2347, 2349, 3, 326, 163, 0, 2348,
		2347, 1, 0, 0, 0, 2348, 2349, 1, 0, 0, 0, 2349, 2351, 1, 0, 0, 0, 2350,
		2352, 3, 346, 173, 0, 2351, 2350, 1, 0, 0, 0, 2351, 2352, 1, 0, 0, 0, 2352,
		2354, 1, 0, 0, 0, 2353, 2355, 3, 348, 174, 0, 2354, 2353, 1, 0, 0, 0, 2354,
		2355, 1, 0, 0, 0, 2355, 2358, 1, 0, 0, 0, 2356, 2359, 3, 350, 175, 0, 2357,
		2359, 3, 352, 176, 0, 2358, 2356, 1, 0, 0, 0, 2358, 2357, 1, 0, 0, 0, 2358,
		2359, 1, 0, 0, 0, 2359, 2361, 1, 0, 0, 0, 2360, 2362, 3, 354, 177, 0, 2361,
		2360, 1, 0, 0, 0, 2361, 2362, 1, 0, 0, 0, 2362, 2364, 1, 0, 0, 0, 2363,
		2365, 3, 356, 178, 0, 2364, 2363, 1, 0, 0, 0, 2364, 2365, 1, 0, 0, 0, 2365,
		307, 1, 0, 0, 0, 2366, 2368, 3, 310, 155, 0, 2367, 2366, 1, 0, 0, 0, 2367,
		2368, 1, 0, 0, 0, 2368, 2370, 1, 0, 0, 0, 2369, 2371, 3, 312, 156, 0, 2370,
		2369, 1, 0, 0, 0, 2370, 2371, 1, 0, 0, 0, 2371, 2372, 1, 0, 0, 0, 2372,
		2377, 3, 314, 157, 0, 2373, 2374, 5, 350, 0, 0, 2374, 2376, 3, 314, 157,
		0, 2375, 2373, 1, 0, 0, 0, 2376, 2379, 1, 0, 0, 0, 2377, 2375, 1, 0, 0,
		0, 2377, 2378, 1, 0, 0, 0, 2378, 309, 1, 0, 0, 0, 2379, 2377, 1, 0, 0,
		0, 2380, 2381, 7, 37, 0, 0, 2381, 311, 1, 0, 0, 0, 2382, 2383, 5, 296,
		0, 0, 2383, 2384, 3, 398, 199, 0, 2384, 313, 1, 0, 0, 0, 2385, 2386, 3,
		462, 231, 0, 2386, 2387, 5, 355, 0, 0, 2387, 2389, 1, 0, 0, 0, 2388, 2385,
		1, 0, 0, 0, 2388, 2389, 1, 0, 0, 0, 2389, 2390, 1, 0, 0, 0, 2390, 2392,
		3, 398, 199, 0, 2391, 2393, 3, 316, 158, 0, 2392, 2391, 1, 0, 0, 0, 2392,
		2393, 1, 0, 0, 0, 2393, 2396, 1, 0, 0, 0, 2394, 2396, 3, 318, 159, 0, 2395,
		2388, 1, 0, 0, 0, 2395, 2394, 1, 0, 0, 0, 2396, 315, 1, 0, 0, 0, 2397,
		2399, 4, 158, 3, 0, 2398, 2400, 5, 13, 0, 0, 2399, 2398, 1, 0, 0, 0, 2399,
		2400, 1, 0, 0, 0, 2400, 2401, 1, 0, 0, 0, 2401, 2407, 3, 462, 231, 0, 2402,
		2403, 5, 365, 0, 0, 2403, 2404, 5, 294, 0, 0, 2404, 2405, 5, 373, 0, 0,
		2405, 2407, 5, 368, 0, 0, 2406, 2397, 1, 0, 0, 0, 2406, 2402, 1, 0, 0,
		0, 2407, 317, 1, 0, 0, 0, 2408, 2409, 5, 372, 0, 0, 2409, 2411, 5, 353,
		0, 0, 2410, 2408, 1, 0, 0, 0, 2410, 2411, 1, 0, 0, 0, 2411, 2412, 1, 0,
		0, 0, 2412, 2413, 5, 363, 0, 0, 2413, 319, 1, 0, 0, 0, 2414, 2415, 3, 460,
		230, 0, 2415, 2416, 5, 365, 0, 0, 2416, 2417, 5, 375, 0, 0, 2417, 2418,
		5, 368, 0, 0, 2418, 321, 1, 0, 0, 0, 2419, 2421, 3, 324, 162, 0, 2420,
		2419, 1, 0, 0, 0, 2420, 2421, 1, 0, 0, 0, 2421, 2422, 1, 0, 0, 0, 2422,
		2425, 5, 151, 0, 0, 2423, 2426, 3, 320, 160, 0, 2424, 2426, 3, 460, 230,
		0, 2425, 2423, 1, 0, 0, 0, 2425, 2424, 1, 0, 0, 0, 2426, 2434, 1, 0, 0,
		0, 2427, 2430, 5, 350, 0, 0, 2428, 2431, 3, 320, 160, 0, 2429, 2431, 3,
		460, 230, 0, 2430, 2428, 1, 0, 0, 0, 2430, 2429, 1, 0, 0, 0, 2431, 2433,
		1, 0, 0, 0, 2432, 2427, 1, 0, 0, 0, 2433, 2436, 1, 0, 0, 0, 2434, 2432,
		1, 0, 0, 0, 2434, 2435, 1, 0, 0, 0, 2435, 323, 1, 0, 0, 0, 2436, 2434,
		1, 0, 0, 0, 2437, 2438, 5, 29, 0, 0, 2438, 2439, 5, 45, 0, 0, 2439, 325,
		1, 0, 0, 0, 2440, 2441, 5, 119, 0, 0, 2441, 2445, 3, 328, 164, 0, 2442,
		2444, 3, 334, 167, 0, 2443, 2442, 1, 0, 0, 0, 2444, 2447, 1, 0, 0, 0, 2445,
		2443, 1, 0, 0, 0, 2445, 2446, 1, 0, 0, 0, 2446, 327, 1, 0, 0, 0, 2447,
		2445, 1, 0, 0, 0, 2448, 2452, 3, 330, 165, 0, 2449, 2452, 3, 332, 166,
		0, 2450, 2452, 3, 338, 169, 0, 2451, 2448, 1, 0, 0, 0, 2451, 2449, 1, 0,
		0, 0, 2451, 2450, 1, 0, 0, 0, 2452, 329, 1, 0, 0, 0, 2453, 2455, 3, 344,
		172, 0, 2454, 2456, 3, 342, 171, 0, 2455, 2454, 1, 0, 0, 0, 2455, 2456,
		1, 0, 0, 0, 2456, 331, 1, 0, 0, 0, 2457, 2458, 5, 365, 0, 0, 2458, 2459,
		3, 292, 146, 0, 2459, 2461, 5, 368, 0, 0, 2460, 2462, 3, 342, 171, 0, 2461,
		2460, 1, 0, 0, 0, 2461, 2462, 1, 0, 0, 0, 2462, 333, 1, 0, 0, 0, 2463,
		2464, 5, 350, 0, 0, 2464, 2471, 3, 328, 164, 0, 2465, 2466, 3, 336, 168,
		0, 2466, 2467, 3, 328, 164, 0, 2467, 2468, 5, 202, 0, 0, 2468, 2469, 3,
		382, 191, 0, 2469, 2471, 1, 0, 0, 0, 2470, 2463, 1, 0, 0, 0, 2470, 2465,
		1, 0, 0, 0, 2471, 335, 1, 0, 0, 0, 2472, 2474, 5, 141, 0, 0, 2473, 2472,
		1, 0, 0, 0, 2473, 2474, 1, 0, 0, 0, 2474, 2475, 1, 0, 0, 0, 2475, 2482,
		5, 156, 0, 0, 2476, 2478, 7, 38, 0, 0, 2477, 2479, 5, 208, 0, 0, 2478,
		2477, 1, 0, 0, 0, 2478, 2479, 1, 0, 0, 0, 2479, 2480, 1, 0, 0, 0, 2480,
		2482, 5, 156, 0, 0, 2481, 2473, 1, 0, 0, 0, 2481, 2476, 1, 0, 0, 0, 2482,
		337, 1, 0, 0, 0, 2483, 2484, 5, 285, 0, 0, 2484, 2485, 5, 365, 0, 0, 2485,
		2486, 5, 308, 0, 0, 2486, 2491, 3, 340, 170, 0, 2487, 2488, 5, 350, 0,
		0, 2488, 2490, 3, 340, 170, 0, 2489, 2487, 1, 0, 0, 0, 2490, 2493, 1, 0,
		0, 0, 2491, 2489, 1, 0, 0, 0, 2491, 2492, 1, 0, 0, 0, 2492, 2494, 1, 0,
		0, 0, 2493, 2491, 1, 0, 0, 0, 2494, 2496, 5, 368, 0, 0, 2495, 2497, 3,
		342, 171, 0, 2496, 2495, 1, 0, 0, 0, 2496, 2497, 1, 0, 0, 0, 2497, 339,
		1, 0, 0, 0, 2498, 2511, 3, 398, 199, 0, 2499, 2500, 5, 365, 0, 0, 2500,
		2505, 3, 398, 199, 0, 2501, 2502, 5, 350, 0, 0, 2502, 2504, 3, 398, 199,
		0, 2503, 2501, 1, 0, 0, 0, 2504, 2507, 1, 0, 0, 0, 2505, 2503, 1, 0, 0,
		0, 2505, 2506, 1, 0, 0, 0, 2506, 2508, 1, 0, 0, 0, 2507, 2505, 1, 0, 0,
		0, 2508, 2509, 5, 368, 0, 0, 2509, 2511, 1, 0, 0, 0, 2510, 2498, 1, 0,
		0, 0, 2510, 2499, 1, 0, 0, 0, 2511, 341, 1, 0, 0, 0, 2512, 2514, 4, 171,
		4, 0, 2513, 2515, 5, 13, 0, 0, 2514, 2513, 1, 0, 0, 0, 2514, 2515, 1, 0,
		0, 0, 2515, 2516, 1, 0, 0, 0, 2516, 2527, 3, 462, 231, 0, 2517, 2518, 5,
		365, 0, 0, 2518, 2523, 5, 372, 0, 0, 2519, 2520, 5, 350, 0, 0, 2520, 2522,
		5, 372, 0, 0, 2521, 2519, 1, 0, 0, 0, 2522, 2525, 1, 0, 0, 0, 2523, 2521,
		1, 0, 0, 0, 2523, 2524, 1, 0, 0, 0, 2524, 2526, 1, 0, 0, 0, 2525, 2523,
		1, 0, 0, 0, 2526, 2528, 5, 368, 0, 0, 2527, 2517, 1, 0, 0, 0, 2527, 2528,
		1, 0, 0, 0, 2528, 343, 1, 0, 0, 0, 2529, 2530, 3, 462, 231, 0, 2530, 345,
		1, 0, 0, 0, 2531, 2532, 5, 315, 0, 0, 2532, 2533, 3, 382, 191, 0, 2533,
		347, 1, 0, 0, 0, 2534, 2535, 5, 126, 0, 0, 2535, 2536, 5, 30, 0, 0, 2536,
		2541, 3, 398, 199, 0, 2537, 2538, 5, 350, 0, 0, 2538, 2540, 3, 398, 199,
		0, 2539, 2537, 1, 0, 0, 0, 2540, 2543, 1, 0, 0, 0, 2541, 2539, 1, 0, 0,
		0, 2541, 2542, 1, 0, 0, 0, 2542, 349, 1, 0, 0, 0, 2543, 2541, 1, 0, 0,
		0, 2544, 2545, 5, 129, 0, 0, 2545, 2546, 3, 382, 191, 0, 2546, 351, 1,
		0, 0, 0, 2547, 2548, 5, 223, 0, 0, 2548, 2549, 3, 382, 191, 0, 2549, 353,
		1, 0, 0, 0, 2550, 2551, 5, 206, 0, 0, 2551, 2552, 5, 30, 0, 0, 2552, 2554,
		3, 398, 199, 0, 2553, 2555, 7, 8, 0, 0, 2554, 2553, 1, 0, 0, 0, 2554, 2555,
		1, 0, 0, 0, 2555, 2563, 1, 0, 0, 0, 2556, 2557, 5, 350, 0, 0, 2557, 2559,
		3, 398, 199, 0, 2558, 2560, 7, 8, 0, 0, 2559, 2558, 1, 0, 0, 0, 2559, 2560,
		1, 0, 0, 0, 2560, 2562, 1, 0, 0, 0, 2561, 2556, 1, 0, 0, 0, 2562, 2565,
		1, 0, 0, 0, 2563, 2561, 1, 0, 0, 0, 2563, 2564, 1, 0, 0, 0, 2564, 355,
		1, 0, 0, 0, 2565, 2563, 1, 0, 0, 0, 2566, 2568, 3, 358, 179, 0, 2567, 2566,
		1, 0, 0, 0, 2568, 2569, 1, 0, 0, 0, 2569, 2567, 1, 0, 0, 0, 2569, 2570,
		1, 0, 0, 0, 2570, 357, 1, 0, 0, 0, 2571, 2572, 5, 164, 0, 0, 2572, 2583,
		3, 398, 199, 0, 2573, 2574, 5, 317, 0, 0, 2574, 2580, 7, 39, 0, 0, 2575,
		2576, 5, 305, 0, 0, 2576, 2577, 5, 10, 0, 0, 2577, 2578, 5, 157, 0, 0,
		2578, 2579, 7, 40, 0, 0, 2579, 2581, 5, 170, 0, 0, 2580, 2575, 1, 0, 0,
		0, 2580, 2581, 1, 0, 0, 0, 2581, 2583, 1, 0, 0, 0, 2582, 2571, 1, 0, 0,
		0, 2582, 2573, 1, 0, 0, 0, 2583, 359, 1, 0, 0, 0, 2584, 2585, 5, 303, 0,
		0, 2585, 2586, 3, 364, 182, 0, 2586, 2587, 5, 258, 0, 0, 2587, 2589, 3,
		362, 181, 0, 2588, 2590, 3, 346, 173, 0, 2589, 2588, 1, 0, 0, 0, 2589,
		2590, 1, 0, 0, 0, 2590, 2592, 1, 0, 0, 0, 2591, 2593, 3, 366, 183, 0, 2592,
		2591, 1, 0, 0, 0, 2592, 2593, 1, 0, 0, 0, 2593, 361, 1, 0, 0, 0, 2594,
		2599, 3, 26, 13, 0, 2595, 2596, 5, 350, 0, 0, 2596, 2598, 3, 26, 13, 0,
		2597, 2595, 1, 0, 0, 0, 2598, 2601, 1, 0, 0, 0, 2599, 2597, 1, 0, 0, 0,
		2599, 2600, 1, 0, 0, 0, 2600, 363, 1, 0, 0, 0, 2601, 2599, 1, 0, 0, 0,
		2602, 2604, 3, 344, 172, 0, 2603, 2605, 3, 326, 163, 0, 2604, 2603, 1,
		0, 0, 0, 2604, 2605, 1, 0, 0, 0, 2605, 2611, 1, 0, 0, 0, 2606, 2607, 5,
		365, 0, 0, 2607, 2608, 3, 292, 146, 0, 2608, 2609, 5, 368, 0, 0, 2609,
		2611, 1, 0, 0, 0, 2610, 2602, 1, 0, 0, 0, 2610, 2606, 1, 0, 0, 0, 2611,
		2616, 1, 0, 0, 0, 2612, 2614, 5, 13, 0, 0, 2613, 2612, 1, 0, 0, 0, 2613,
		2614, 1, 0, 0, 0, 2614, 2615, 1, 0, 0, 0, 2615, 2617, 3, 462, 231, 0, 2616,
		2613, 1, 0, 0, 0, 2616, 2617, 1, 0, 0, 0, 2617, 365, 1, 0, 0, 0, 2618,
		2619, 5, 94, 0, 0, 2619, 2620, 3, 184, 92, 0, 2620, 367, 1, 0, 0, 0, 2621,
		2622, 5, 179, 0, 0, 2622, 2623, 5, 151, 0, 0, 2623, 2624, 3, 370, 185,
		0, 2624, 2625, 5, 306, 0, 0, 2625, 2626, 3, 370, 185, 0, 2626, 2627, 5,
		202, 0, 0, 2627, 2629, 3, 382, 191, 0, 2628, 2630, 3, 372, 186, 0, 2629,
		2628, 1, 0, 0, 0, 2630, 2631, 1, 0, 0, 0, 2631, 2629, 1, 0, 0, 0, 2631,
		2632, 1, 0, 0, 0, 2632, 369, 1, 0, 0, 0, 2633, 2639, 3, 344, 172, 0, 2634,
		2635, 5, 365, 0, 0, 2635, 2636, 3, 292, 146, 0, 2636, 2637, 5, 368, 0,
		0, 2637, 2639, 1, 0, 0, 0, 2638, 2633, 1, 0, 0, 0, 2638, 2634, 1, 0, 0,
		0, 2639, 2644, 1, 0, 0, 0, 2640, 2642, 5, 13, 0, 0, 2641, 2640, 1, 0, 0,
		0, 2641, 2642, 1, 0, 0, 0, 2642, 2643, 1, 0, 0, 0, 2643, 2645, 3, 462,
		231, 0, 2644, 2641, 1, 0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645, 371, 1, 0,
		0, 0, 2646, 2648, 5, 314, 0, 0, 2647, 2649, 5, 194, 0, 0, 2648, 2647, 1,
		0, 0, 0, 2648, 2649, 1, 0, 0, 0, 2649, 2650, 1, 0, 0, 0, 2650, 2653, 5,
		176, 0, 0, 2651, 2652, 5, 10, 0, 0, 2652, 2654, 3, 382, 191, 0, 2653, 2651,
		1, 0, 0, 0, 2653, 2654, 1, 0, 0, 0, 2654, 2655, 1, 0, 0, 0, 2655, 2656,
		5, 290, 0, 0, 2656, 2660, 3, 374, 187, 0, 2657, 2658, 5, 94, 0, 0, 2658,
		2660, 5, 135, 0, 0, 2659, 2646, 1, 0, 0, 0, 2659, 2657, 1, 0, 0, 0, 2660,
		373, 1, 0, 0, 0, 2661, 2663, 5, 143, 0, 0, 2662, 2664, 3, 186, 93, 0, 2663,
		2662, 1, 0, 0, 0, 2663, 2664, 1, 0, 0, 0, 2664, 2665, 1, 0, 0, 0, 2665,
		2666, 5, 308, 0, 0, 2666, 2682, 3, 190, 95, 0, 2667, 2668, 5, 303, 0, 0,
		2668, 2669, 5, 258, 0, 0, 2669, 2674, 3, 26, 13, 0, 2670, 2671, 5, 350,
		0, 0, 2671, 2673, 3, 26, 13, 0, 2672, 2670, 1, 0, 0, 0, 2673, 2676, 1,
		0, 0, 0, 2674, 2672, 1, 0, 0, 0, 2674, 2675, 1, 0, 0, 0, 2675, 2678, 1,
		0, 0, 0, 2676, 2674, 1, 0, 0, 0, 2677, 2679, 3, 346, 173, 0, 2678, 2677,
		1, 0, 0, 0, 2678, 2679, 1, 0, 0, 0, 2679, 2682, 1, 0, 0, 0, 2680, 2682,
		5, 80, 0, 0, 2681, 2661, 1, 0, 0, 0, 2681, 2667, 1, 0, 0, 0, 2681, 2680,
		1, 0, 0, 0, 2682, 375, 1, 0, 0, 0, 2683, 2685, 5, 80, 0, 0, 2684, 2686,
		5, 119, 0, 0, 2685, 2684, 1, 0, 0, 0, 2685, 2686, 1, 0, 0, 0, 2686, 2687,
		1, 0, 0, 0, 2687, 2689, 3, 344, 172, 0, 2688, 2690, 3, 378, 189, 0, 2689,
		2688, 1, 0, 0, 0, 2689, 2690, 1, 0, 0, 0, 2690, 2693, 1, 0, 0, 0, 2691,
		2694, 3, 346, 173, 0, 2692, 2694, 5, 7, 0, 0, 2693, 2691, 1, 0, 0, 0, 2693,
		2692, 1, 0, 0, 0, 2693, 2694, 1, 0, 0, 0, 2694, 377, 1, 0, 0, 0, 2695,
		2697, 4, 189, 5, 0, 2696, 2698, 5, 13, 0, 0, 2697, 2696, 1, 0, 0, 0, 2697,
		2698, 1, 0, 0, 0, 2698, 2699, 1, 0, 0, 0, 2699, 2700, 3, 462, 231, 0, 2700,
		379, 1, 0, 0, 0, 2701, 2703, 7, 41, 0, 0, 2702, 2704, 5, 285, 0, 0, 2703,
		2702, 1, 0, 0, 0, 2703, 2704, 1, 0, 0, 0, 2704, 2705, 1, 0, 0, 0, 2705,
		2706, 3, 344, 172, 0, 2706, 381, 1, 0, 0, 0, 2707, 2709, 6, 191, -1, 0,
		2708, 2710, 5, 194, 0, 0, 2709, 2708, 1, 0, 0, 0, 2709, 2710, 1, 0, 0,
		0, 2710, 2711, 1, 0, 0, 0, 2711, 2712, 5, 365, 0, 0, 2712, 2713, 3, 382,
		191, 0, 2713, 2714, 5, 368, 0, 0, 2714, 2717, 1, 0, 0, 0, 2715, 2717, 3,
		384, 192, 0, 2716, 2707, 1, 0, 0, 0, 2716, 2715, 1, 0, 0, 0, 2717, 2724,
		1, 0, 0, 0, 2718, 2719, 10, 2, 0, 0, 2719, 2720, 3, 394, 197, 0, 2720,
		2721, 3, 382, 191, 3, 2721, 2723, 1, 0, 0, 0, 2722, 2718, 1, 0, 0, 0, 2723,
		2726, 1, 0, 0, 0, 2724, 2722, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725,
		383, 1, 0, 0, 0, 2726, 2724, 1, 0, 0, 0, 2727, 2731, 3, 386, 193, 0, 2728,
		2731, 3, 392, 196, 0, 2729, 2731, 3, 398, 199, 0, 2730, 2727, 1, 0, 0,
		0, 2730, 2728, 1, 0, 0, 0, 2730, 2729, 1, 0, 0, 0, 2731, 385, 1, 0, 0,
		0, 2732, 2733, 3, 398, 199, 0, 2733, 2735, 5, 153, 0, 0, 2734, 2736, 5,
		194, 0, 0, 2735, 2734, 1, 0, 0, 0, 2735, 2736, 1, 0, 0, 0, 2736, 2737,
		1, 0, 0, 0, 2737, 2738, 5, 196, 0, 0, 2738, 2756, 1, 0, 0, 0, 2739, 2740,
		3, 398, 199, 0, 2740, 2741, 5, 21, 0, 0, 2741, 2742, 3, 398, 199, 0, 2742,
		2743, 5, 10, 0, 0, 2743, 2744, 3, 398, 199, 0, 2744, 2756, 1, 0, 0, 0,
		2745, 2747, 5, 194, 0, 0, 2746, 2745, 1, 0, 0, 0, 2746, 2747, 1, 0, 0,
		0, 2747, 2748, 1, 0, 0, 0, 2748, 2749, 5, 106, 0, 0, 2749, 2750, 5, 365,
		0, 0, 2750, 2751, 3, 292, 146, 0, 2751, 2752, 5, 368, 0, 0, 2752, 2756,
		1, 0, 0, 0, 2753, 2756, 3, 388, 194, 0, 2754, 2756, 3, 390, 195, 0, 2755,
		2732, 1, 0, 0, 0, 2755, 2739, 1, 0, 0, 0, 2755, 2746, 1, 0, 0, 0, 2755,
		2753, 1, 0, 0, 0, 2755, 2754, 1, 0, 0, 0, 2756, 387, 1, 0, 0, 0, 2757,
		2759, 3, 398, 199, 0, 2758, 2760, 5, 194, 0, 0, 2759, 2758, 1, 0, 0, 0,
		2759, 2760, 1, 0, 0, 0, 2760, 2761, 1, 0, 0, 0, 2761, 2762, 5, 137, 0,
		0, 2762, 2772, 5, 365, 0, 0, 2763, 2768, 3, 398, 199, 0, 2764, 2765, 5,
		350, 0, 0, 2765, 2767, 3, 398, 199, 0, 2766, 2764, 1, 0, 0, 0, 2767, 2770,
		1, 0, 0, 0, 2768, 2766, 1, 0, 0, 0, 2768, 2769, 1, 0, 0, 0, 2769, 2773,
		1, 0, 0, 0, 2770, 2768, 1, 0, 0, 0, 2771, 2773, 3, 292, 146, 0, 2772, 2763,
		1, 0, 0, 0, 2772, 2771, 1, 0, 0, 0, 2773, 2774, 1, 0, 0, 0, 2774, 2775,
		5, 368, 0, 0, 2775, 389, 1, 0, 0, 0, 2776, 2777, 5, 365, 0, 0, 2777, 2782,
		3, 398, 199, 0, 2778, 2779, 5, 350, 0, 0, 2779, 2781, 3, 398, 199, 0, 2780,
		2778, 1, 0, 0, 0, 2781, 2784, 1, 0, 0, 0, 2782, 2780, 1, 0, 0, 0, 2782,
		2783, 1, 0, 0, 0, 2783, 2785, 1, 0, 0, 0, 2784, 2782, 1, 0, 0, 0, 2785,
		2787, 5, 368, 0, 0, 2786, 2788, 5, 194, 0, 0, 2787, 2786, 1, 0, 0, 0, 2787,
		2788, 1, 0, 0, 0, 2788, 2789, 1, 0, 0, 0, 2789, 2790, 5, 137, 0, 0, 2790,
		2791, 5, 365, 0, 0, 2791, 2792, 3, 292, 146, 0, 2792, 2793, 5, 368, 0,
		0, 2793, 391, 1, 0, 0, 0, 2794, 2795, 3, 398, 199, 0, 2795, 2796, 3, 396,
		198, 0, 2796, 2797, 3, 398, 199, 0, 2797, 393, 1, 0, 0, 0, 2798, 2799,
		7, 42, 0, 0, 2799, 395, 1, 0, 0, 0, 2800, 2813, 5, 355, 0, 0, 2801, 2813,
		5, 356, 0, 0, 2802, 2813, 5, 357, 0, 0, 2803, 2813, 5, 358, 0, 0, 2804,
		2813, 5, 361, 0, 0, 2805, 2813, 5, 362, 0, 0, 2806, 2813, 5, 359, 0, 0,
		2807, 2813, 5, 360, 0, 0, 2808, 2810, 5, 194, 0, 0, 2809, 2808, 1, 0, 0,
		0, 2809, 2810, 1, 0, 0, 0, 2810, 2811, 1, 0, 0, 0, 2811, 2813, 7, 43, 0,
		0, 2812, 2800, 1, 0, 0, 0, 2812, 2801, 1, 0, 0, 0, 2812, 2802, 1, 0, 0,
		0, 2812, 2803, 1, 0, 0, 0, 2812, 2804, 1, 0, 0, 0, 2812, 2805, 1, 0, 0,
		0, 2812, 2806, 1, 0, 0, 0, 2812, 2807, 1, 0, 0, 0, 2812, 2809, 1, 0, 0,
		0, 2813, 397, 1, 0, 0, 0, 2814, 2815, 6, 199, -1, 0, 2815, 2816, 5, 365,
		0, 0, 2816, 2817, 3, 292, 146, 0, 2817, 2818, 5, 368, 0, 0, 2818, 2833,
		1, 0, 0, 0, 2819, 2820, 5, 365, 0, 0, 2820, 2821, 3, 398, 199, 0, 2821,
		2822, 5, 368, 0, 0, 2822, 2833, 1, 0, 0, 0, 2823, 2833, 3, 402, 201, 0,
		2824, 2833, 3, 406, 203, 0, 2825, 2833, 3, 430, 215, 0, 2826, 2833, 3,
		410, 205, 0, 2827, 2833, 3, 416, 208, 0, 2828, 2833, 3, 418, 209, 0, 2829,
		2833, 3, 426, 213, 0, 2830, 2833, 3, 428, 214, 0, 2831, 2833, 3, 400, 200,
		0, 2832, 2814, 1, 0, 0, 0, 2832, 2819, 1, 0, 0, 0, 2832, 2823, 1, 0, 0,
		0, 2832, 2824, 1, 0, 0, 0, 2832, 2825, 1, 0, 0, 0, 2832, 2826, 1, 0, 0,
		0, 2832, 2827, 1, 0, 0, 0, 2832, 2828, 1, 0, 0, 0, 2832, 2829, 1, 0, 0,
		0, 2832, 2830, 1, 0, 0, 0, 2832, 2831, 1, 0, 0, 0, 2833, 2844, 1, 0, 0,
		0, 2834, 2835, 10, 13, 0, 0, 2835, 2836, 7, 44, 0, 0, 2836, 2843, 3, 398,
		199, 14, 2837, 2838, 10, 12, 0, 0, 2838, 2839, 7, 45, 0, 0, 2839, 2843,
		3, 398, 199, 13, 2840, 2841, 10, 14, 0, 0, 2841, 2843, 3, 404, 202, 0,
		2842, 2834, 1, 0, 0, 0, 2842, 2837, 1, 0, 0, 0, 2842, 2840, 1, 0, 0, 0,
		2843, 2846, 1, 0, 0, 0, 2844, 2842, 1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0,
		2845, 399, 1, 0, 0, 0, 2846, 2844, 1, 0, 0, 0, 2847, 2856, 3, 456, 228,
		0, 2848, 2856, 3, 458, 229, 0, 2849, 2856, 3, 470, 235, 0, 2850, 2856,
		3, 462, 231, 0, 2851, 2856, 3, 464, 232, 0, 2852, 2856, 3, 468, 234, 0,
		2853, 2856, 3, 466, 233, 0, 2854, 2856, 3, 472, 236, 0, 2855, 2847, 1,
		0, 0, 0, 2855, 2848, 1, 0, 0, 0, 2855, 2849, 1, 0, 0, 0, 2855, 2850, 1,
		0, 0, 0, 2855, 2851, 1, 0, 0, 0, 2855, 2852, 1, 0, 0, 0, 2855, 2853, 1,
		0, 0, 0, 2855, 2854, 1, 0, 0, 0, 2856, 401, 1, 0, 0, 0, 2857, 2858, 5,
		150, 0, 0, 2858, 2859, 3, 398, 199, 0, 2859, 2860, 3, 404, 202, 0, 2860,
		403, 1, 0, 0, 0, 2861, 2862, 7, 46, 0, 0, 2862, 405, 1, 0, 0, 0, 2863,
		2864, 3, 408, 204, 0, 2864, 2865, 7, 47, 0, 0, 2865, 2870, 3, 408, 204,
		0, 2866, 2867, 7, 47, 0, 0, 2867, 2869, 3, 408, 204, 0, 2868, 2866, 1,
		0, 0, 0, 2869, 2872, 1, 0, 0, 0, 2870, 2868, 1, 0, 0, 0, 2870, 2871, 1,
		0, 0, 0, 2871, 407, 1, 0, 0, 0, 2872, 2870, 1, 0, 0, 0, 2873, 2874, 5,
		365, 0, 0, 2874, 2875, 3, 398, 199, 0, 2875, 2876, 5, 368, 0, 0, 2876,
		2884, 1, 0, 0, 0, 2877, 2884, 3, 410, 205, 0, 2878, 2884, 3, 418, 209,
		0, 2879, 2884, 3, 426, 213, 0, 2880, 2884, 3, 430, 215, 0, 2881, 2884,
		3, 428, 214, 0, 2882, 2884, 3, 400, 200, 0, 2883, 2873, 1, 0, 0, 0, 2883,
		2877, 1, 0, 0, 0, 2883, 2878, 1, 0, 0, 0, 2883, 2879, 1, 0, 0, 0, 2883,
		2880, 1, 0, 0, 0, 2883, 2881, 1, 0, 0, 0, 2883, 2882, 1, 0, 0, 0, 2884,
		409, 1, 0, 0, 0, 2885, 2888, 3, 412, 206, 0, 2886, 2888, 3, 414, 207, 0,
		2887, 2885, 1, 0, 0, 0, 2887, 2886, 1, 0, 0, 0, 2888, 411, 1, 0, 0, 0,
		2889, 2890, 5, 35, 0, 0, 2890, 2896, 3, 398, 199, 0, 2891, 2892, 5, 314,
		0, 0, 2892, 2893, 3, 398, 199, 0, 2893, 2894, 5, 290, 0, 0, 2894, 2895,
		3, 398, 199, 0, 2895, 2897, 1, 0, 0, 0, 2896, 2891, 1, 0, 0, 0, 2897, 2898,
		1, 0, 0, 0, 2898, 2896, 1, 0, 0, 0, 2898, 2899, 1, 0, 0, 0, 2899, 2902,
		1, 0, 0, 0, 2900, 2901, 5, 94, 0, 0, 2901, 2903, 3, 398, 199, 0, 2902,
		2900, 1, 0, 0, 0, 2902, 2903, 1, 0, 0, 0, 2903, 2904, 1, 0, 0, 0, 2904,
		2905, 5, 98, 0, 0, 2905, 413, 1, 0, 0, 0, 2906, 2912, 5, 35, 0, 0, 2907,
		2908, 5, 314, 0, 0, 2908, 2909, 3, 382, 191, 0, 2909, 2910, 5, 290, 0,
		0, 2910, 2911, 3, 398, 199, 0, 2911, 2913, 1, 0, 0, 0, 2912, 2907, 1, 0,
		0, 0, 2913, 2914, 1, 0, 0, 0, 2914, 2912, 1, 0, 0, 0, 2914, 2915, 1, 0,
		0, 0, 2915, 2918, 1, 0, 0, 0, 2916, 2917, 5, 94, 0, 0, 2917, 2919, 3, 398,
		199, 0, 2918, 2916, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919, 2920, 1,
		0, 0, 0, 2920, 2921, 5, 98, 0, 0, 2921, 415, 1, 0, 0, 0, 2922, 2923, 3,
		460, 230, 0, 2923, 2924, 5, 3, 0, 0, 2924, 2925, 7, 48, 0, 0, 2925, 417,
		1, 0, 0, 0, 2926, 2927, 5, 18, 0, 0, 2927, 2929, 5, 365, 0, 0, 2928, 2930,
		3, 420, 210, 0, 2929, 2928, 1, 0, 0, 0, 2929, 2930, 1, 0, 0, 0, 2930, 2931,
		1, 0, 0, 0, 2931, 2932, 3, 398, 199, 0, 2932, 2934, 5, 368, 0, 0, 2933,
		2935, 3, 422, 211, 0, 2934, 2933, 1, 0, 0, 0, 2934, 2935, 1, 0, 0, 0, 2935,
		3079, 1, 0, 0, 0, 2936, 2937, 5, 57, 0, 0, 2937, 2943, 5, 365, 0, 0, 2938,
		2940, 3, 420, 210, 0, 2939, 2938, 1, 0, 0, 0, 2939, 2940, 1, 0, 0, 0, 2940,
		2941, 1, 0, 0, 0, 2941, 2944, 3, 398, 199, 0, 2942, 2944, 5, 363, 0, 0,
		2943, 2939, 1, 0, 0, 0, 2943, 2942, 1, 0, 0, 0, 2944, 2945, 1, 0, 0, 0,
		2945, 2947, 5, 368, 0, 0, 2946, 2948, 3, 422, 211, 0, 2947, 2946, 1, 0,
		0, 0, 2947, 2948, 1, 0, 0, 0, 2948, 3079, 1, 0, 0, 0, 2949, 2950, 5, 58,
		0, 0, 2950, 2956, 5, 365, 0, 0, 2951, 2953, 3, 420, 210, 0, 2952, 2951,
		1, 0, 0, 0, 2952, 2953, 1, 0, 0, 0, 2953, 2954, 1, 0, 0, 0, 2954, 2957,
		3, 398, 199, 0, 2955, 2957, 5, 363, 0, 0, 2956, 2952, 1, 0, 0, 0, 2956,
		2955, 1, 0, 0, 0, 2957, 2958, 1, 0, 0, 0, 2958, 2960, 5, 368, 0, 0, 2959,
		2961, 3, 422, 211, 0, 2960, 2959, 1, 0, 0, 0, 2960, 2961, 1, 0, 0, 0, 2961,
		3079, 1, 0, 0, 0, 2962, 2963, 5, 324, 0, 0, 2963, 2964, 5, 365, 0, 0, 2964,
		2965, 5, 368, 0, 0, 2965, 3079, 3, 422, 211, 0, 2966, 2967, 5, 329, 0,
		0, 2967, 2968, 5, 365, 0, 0, 2968, 2969, 5, 368, 0, 0, 2969, 3079, 3, 422,
		211, 0, 2970, 2971, 5, 330, 0, 0, 2971, 2972, 5, 365, 0, 0, 2972, 2973,
		3, 398, 199, 0, 2973, 2974, 5, 368, 0, 0, 2974, 2975, 3, 422, 211, 0, 2975,
		3079, 1, 0, 0, 0, 2976, 2977, 5, 331, 0, 0, 2977, 2978, 5, 365, 0, 0, 2978,
		2985, 3, 398, 199, 0, 2979, 2980, 5, 350, 0, 0, 2980, 2983, 3, 398, 199,
		0, 2981, 2982, 5, 350, 0, 0, 2982, 2984, 3, 398, 199, 0, 2983, 2981, 1,
		0, 0, 0, 2983, 2984, 1, 0, 0, 0, 2984, 2986, 1, 0, 0, 0, 2985, 2979, 1,
		0, 0, 0, 2985, 2986, 1, 0, 0, 0, 2986, 2987, 1, 0, 0, 0, 2987, 2988, 5,
		368, 0, 0, 2988, 2989, 3, 422, 211, 0, 2989, 3079, 1, 0, 0, 0, 2990, 2991,
		5, 332, 0, 0, 2991, 2992, 5, 365, 0, 0, 2992, 2993, 3, 398, 199, 0, 2993,
		2994, 5, 368, 0, 0, 2994, 2995, 3, 422, 211, 0, 2995, 3079, 1, 0, 0, 0,
		2996, 2997, 5, 333, 0, 0, 2997, 2998, 5, 365, 0, 0, 2998, 3005, 3, 398,
		199, 0, 2999, 3000, 5, 350, 0, 0, 3000, 3003, 3, 398, 199, 0, 3001, 3002,
		5, 350, 0, 0, 3002, 3004, 3, 398, 199, 0, 3003, 3001, 1, 0, 0, 0, 3003,
		3004, 1, 0, 0, 0, 3004, 3006, 1, 0, 0, 0, 3005, 2999, 1, 0, 0, 0, 3005,
		3006, 1, 0, 0, 0, 3006, 3007, 1, 0, 0, 0, 3007, 3008, 5, 368, 0, 0, 3008,
		3009, 3, 422, 211, 0, 3009, 3079, 1, 0, 0, 0, 3010, 3011, 5, 177, 0, 0,
		3011, 3013, 5, 365, 0, 0, 3012, 3014, 3, 420, 210, 0, 3013, 3012, 1, 0,
		0, 0, 3013, 3014, 1, 0, 0, 0, 3014, 3015, 1, 0, 0, 0, 3015, 3016, 3, 398,
		199, 0, 3016, 3018, 5, 368, 0, 0, 3017, 3019, 3, 422, 211, 0, 3018, 3017,
		1, 0, 0, 0, 3018, 3019, 1, 0, 0, 0, 3019, 3079, 1, 0, 0, 0, 3020, 3021,
		5, 184, 0, 0, 3021, 3023, 5, 365, 0, 0, 3022, 3024, 3, 420, 210, 0, 3023,
		3022, 1, 0, 0, 0, 3023, 3024, 1, 0, 0, 0, 3024, 3025, 1, 0, 0, 0, 3025,
		3026, 3, 398, 199, 0, 3026, 3028, 5, 368, 0, 0, 3027, 3029, 3, 422, 211,
		0, 3028, 3027, 1, 0, 0, 0, 3028, 3029, 1, 0, 0, 0, 3029, 3079, 1, 0, 0,
		0, 3030, 3031, 5, 342, 0, 0, 3031, 3032, 5, 365, 0, 0, 3032, 3033, 5, 368,
		0, 0, 3033, 3079, 3, 422, 211, 0, 3034, 3035, 5, 343, 0, 0, 3035, 3036,
		5, 365, 0, 0, 3036, 3037, 5, 368, 0, 0, 3037, 3079, 3, 422, 211, 0, 3038,
		3039, 5, 344, 0, 0, 3039, 3041, 5, 365, 0, 0, 3040, 3042, 3, 420, 210,
		0, 3041, 3040, 1, 0, 0, 0, 3041, 3042, 1, 0, 0, 0, 3042, 3043, 1, 0, 0,
		0, 3043, 3044, 3, 398, 199, 0, 3044, 3046, 5, 368, 0, 0, 3045, 3047, 3,
		422, 211, 0, 3046, 3045, 1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 3079,
		1, 0, 0, 0, 3048, 3049, 5, 282, 0, 0, 3049, 3051, 5, 365, 0, 0, 3050, 3052,
		3, 420, 210, 0, 3051, 3050, 1, 0, 0, 0, 3051, 3052, 1, 0, 0, 0, 3052, 3053,
		1, 0, 0, 0, 3053, 3054, 3, 398, 199, 0, 3054, 3056, 5, 368, 0, 0, 3055,
		3057, 3, 422, 211, 0, 3056, 3055, 1, 0, 0, 0, 3056, 3057, 1, 0, 0, 0, 3057,
		3079, 1, 0, 0, 0, 3058, 3059, 5, 309, 0, 0, 3059, 3061, 5, 365, 0, 0, 3060,
		3062, 3, 420, 210, 0, 3061, 3060, 1, 0, 0, 0, 3061, 3062, 1, 0, 0, 0, 3062,
		3063, 1, 0, 0, 0, 3063, 3064, 3, 398, 199, 0, 3064, 3066, 5, 368, 0, 0,
		3065, 3067, 3, 422, 211, 0, 3066, 3065, 1, 0, 0, 0, 3066, 3067, 1, 0, 0,
		0, 3067, 3079, 1, 0, 0, 0, 3068, 3069, 5, 346, 0, 0, 3069, 3071, 5, 365,
		0, 0, 3070, 3072, 3, 420, 210, 0, 3071, 3070, 1, 0, 0, 0, 3071, 3072, 1,
		0, 0, 0, 3072, 3073, 1, 0, 0, 0, 3073, 3074, 3, 398, 199, 0, 3074, 3076,
		5, 368, 0, 0, 3075, 3077, 3, 422, 211, 0, 3076, 3075, 1, 0, 0, 0, 3076,
		3077, 1, 0, 0, 0, 3077, 3079, 1, 0, 0, 0, 3078, 2926, 1, 0, 0, 0, 3078,
		2936, 1, 0, 0, 0, 3078, 2949, 1, 0, 0, 0, 3078, 2962, 1, 0, 0, 0, 3078,
		2966, 1, 0, 0, 0, 3078, 2970, 1, 0, 0, 0, 3078, 2976, 1, 0, 0, 0, 3078,
		2990, 1, 0, 0, 0, 3078, 2996, 1, 0, 0, 0, 3078, 3010, 1, 0, 0, 0, 3078,
		3020, 1, 0, 0, 0, 3078, 3030, 1, 0, 0, 0, 3078, 3034, 1, 0, 0, 0, 3078,
		3038, 1, 0, 0, 0, 3078, 3048, 1, 0, 0, 0, 3078, 3058, 1, 0, 0, 0, 3078,
		3068, 1, 0, 0, 0, 3079, 419, 1, 0, 0, 0, 3080, 3081, 7, 37, 0, 0, 3081,
		421, 1, 0, 0, 0, 3082, 3083, 5, 209, 0, 0, 3083, 3085, 5, 365, 0, 0, 3084,
		3086, 3, 424, 212, 0, 3085, 3084, 1, 0, 0, 0, 3085, 3086, 1, 0, 0, 0, 3086,
		3088, 1, 0, 0, 0, 3087, 3089, 3, 354, 177, 0, 3088, 3087, 1, 0, 0, 0, 3088,
		3089, 1, 0, 0, 0, 3089, 3090, 1, 0, 0, 0, 3090, 3091, 5, 368, 0, 0, 3091,
		423, 1, 0, 0, 0, 3092, 3093, 5, 213, 0, 0, 3093, 3094, 5, 30, 0, 0, 3094,
		3099, 3, 398, 199, 0, 3095, 3096, 5, 350, 0, 0, 3096, 3098, 3, 398, 199,
		0, 3097, 3095, 1, 0, 0, 0, 3098, 3101, 1, 0, 0, 0, 3099, 3097, 1, 0, 0,
		0, 3099, 3100, 1, 0, 0, 0, 3100, 425, 1, 0, 0, 0, 3101, 3099, 1, 0, 0,
		0, 3102, 3303, 5, 323, 0, 0, 3103, 3104, 5, 37, 0, 0, 3104, 3105, 5, 365,
		0, 0, 3105, 3106, 3, 398, 199, 0, 3106, 3107, 5, 13, 0, 0, 3107, 3109,
		3, 126, 63, 0, 3108, 3110, 3, 128, 64, 0, 3109, 3108, 1, 0, 0, 0, 3109,
		3110, 1, 0, 0, 0, 3110, 3111, 1, 0, 0, 0, 3111, 3112, 5, 368, 0, 0, 3112,
		3303, 1, 0, 0, 0, 3113, 3114, 5, 57, 0, 0, 3114, 3117, 5, 365, 0, 0, 3115,
		3118, 3, 398, 199, 0, 3116, 3118, 5, 363, 0, 0, 3117, 3115, 1, 0, 0, 0,
		3117, 3116, 1, 0, 0, 0, 3118, 3119, 1, 0, 0, 0, 3119, 3303, 5, 368, 0,
		0, 3120, 3303, 5, 325, 0, 0, 3121, 3122, 5, 63, 0, 0, 3122, 3303, 5, 68,
		0, 0, 3123, 3127, 5, 327, 0, 0, 3124, 3125, 5, 63, 0, 0, 3125, 3127, 5,
		292, 0, 0, 3126, 3123, 1, 0, 0, 0, 3126, 3124, 1, 0, 0, 0, 3127, 3132,
		1, 0, 0, 0, 3128, 3129, 5, 365, 0, 0, 3129, 3130, 3, 398, 199, 0, 3130,
		3131, 5, 368, 0, 0, 3131, 3133, 1, 0, 0, 0, 3132, 3128, 1, 0, 0, 0, 3132,
		3133, 1, 0, 0, 0, 3133, 3303, 1, 0, 0, 0, 3134, 3303, 5, 328, 0, 0, 3135,
		3136, 5, 63, 0, 0, 3136, 3303, 5, 347, 0, 0, 3137, 3138, 5, 334, 0, 0,
		3138, 3139, 5, 365, 0, 0, 3139, 3152, 3, 398, 199, 0, 3140, 3141, 5, 350,
		0, 0, 3141, 3149, 3, 398, 199, 0, 3142, 3143, 5, 350, 0, 0, 3143, 3144,
		3, 398, 199, 0, 3144, 3145, 5, 355, 0, 0, 3145, 3146, 3, 398, 199, 0, 3146,
		3148, 1, 0, 0, 0, 3147, 3142, 1, 0, 0, 0, 3148, 3151, 1, 0, 0, 0, 3149,
		3147, 1, 0, 0, 0, 3149, 3150, 1, 0, 0, 0, 3150, 3153, 1, 0, 0, 0, 3151,
		3149, 1, 0, 0, 0, 3152, 3140, 1, 0, 0, 0, 3152, 3153, 1, 0, 0, 0, 3153,
		3154, 1, 0, 0, 0, 3154, 3155, 5, 368, 0, 0, 3155, 3303, 1, 0, 0, 0, 3156,
		3157, 5, 335, 0, 0, 3157, 3158, 5, 365, 0, 0, 3158, 3171, 3, 398, 199,
		0, 3159, 3160, 5, 350, 0, 0, 3160, 3168, 3, 398, 199, 0, 3161, 3162, 5,
		350, 0, 0, 3162, 3163, 3, 398, 199, 0, 3163, 3164, 5, 355, 0, 0, 3164,
		3165, 3, 398, 199, 0, 3165, 3167, 1, 0, 0, 0, 3166, 3161, 1, 0, 0, 0, 3167,
		3170, 1, 0, 0, 0, 3168, 3166, 1, 0, 0, 0, 3168, 3169, 1, 0, 0, 0, 3169,
		3172, 1, 0, 0, 0, 3170, 3168, 1, 0, 0, 0, 3171, 3159, 1, 0, 0, 0, 3171,
		3172, 1, 0, 0, 0, 3172, 3173, 1, 0, 0, 0, 3173, 3174, 5, 368, 0, 0, 3174,
		3303, 1, 0, 0, 0, 3175, 3176, 5, 336, 0, 0, 3176, 3177, 5, 365, 0, 0, 3177,
		3190, 3, 398, 199, 0, 3178, 3179, 5, 350, 0, 0, 3179, 3187, 3, 398, 199,
		0, 3180, 3181, 5, 350, 0, 0, 3181, 3182, 3, 398, 199, 0, 3182, 3183, 5,
		355, 0, 0, 3183, 3184, 3, 398, 199, 0, 3184, 3186, 1, 0, 0, 0, 3185, 3180,
		1, 0, 0, 0, 3186, 3189, 1, 0, 0, 0, 3187, 3185, 1, 0, 0, 0, 3187, 3188,
		1, 0, 0, 0, 3188, 3191, 1, 0, 0, 0, 3189, 3187, 1, 0, 0, 0, 3190, 3178,
		1, 0, 0, 0, 3190, 3191, 1, 0, 0, 0, 3191, 3192, 1, 0, 0, 0, 3192, 3193,
		5, 368, 0, 0, 3193, 3303, 1, 0, 0, 0, 3194, 3195, 5, 337, 0, 0, 3195, 3196,
		5, 365, 0, 0, 3196, 3209, 3, 398, 199, 0, 3197, 3198, 5, 350, 0, 0, 3198,
		3206, 3, 398, 199, 0, 3199, 3200, 5, 350, 0, 0, 3200, 3201, 3, 398, 199,
		0, 3201, 3202, 5, 355, 0, 0, 3202, 3203, 3, 398, 199, 0, 3203, 3205, 1,
		0, 0, 0, 3204, 3199, 1, 0, 0, 0, 3205, 3208, 1, 0, 0, 0, 3206, 3204, 1,
		0, 0, 0, 3206, 3207, 1, 0, 0, 0, 3207, 3210, 1, 0, 0, 0, 3208, 3206, 1,
		0, 0, 0, 3209, 3197, 1, 0, 0, 0, 3209, 3210, 1, 0, 0, 0, 3210, 3211, 1,
		0, 0, 0, 3211, 3212, 5, 368, 0, 0, 3212, 3303, 1, 0, 0, 0, 3213, 3214,
		5, 338, 0, 0, 3214, 3215, 5, 365, 0, 0, 3215, 3228, 3, 398, 199, 0, 3216,
		3217, 5, 350, 0, 0, 3217, 3225, 3, 398, 199, 0, 3218, 3219, 5, 350, 0,
		0, 3219, 3220, 3, 398, 199, 0, 3220, 3221, 5, 355, 0, 0, 3221, 3222, 3,
		398, 199, 0, 3222, 3224, 1, 0, 0, 0, 3223, 3218, 1, 0, 0, 0, 3224, 3227,
		1, 0, 0, 0, 3225, 3223, 1, 0, 0, 0, 3225, 3226, 1, 0, 0, 0, 3226, 3229,
		1, 0, 0, 0, 3227, 3225, 1, 0, 0, 0, 3228, 3216, 1, 0, 0, 0, 3228, 3229,
		1, 0, 0, 0, 3229, 3230, 1, 0, 0, 0, 3230, 3231, 5, 368, 0, 0, 3231, 3303,
		1, 0, 0, 0, 3232, 3233, 5, 339, 0, 0, 3233, 3234, 5, 365, 0, 0, 3234, 3247,
		3, 398, 199, 0, 3235, 3236, 5, 350, 0, 0, 3236, 3244, 3, 398, 199, 0, 3237,
		3238, 5, 350, 0, 0, 3238, 3239, 3, 398, 199, 0, 3239, 3240, 5, 355, 0,
		0, 3240, 3241, 3, 398, 199, 0, 3241, 3243, 1, 0, 0, 0, 3242, 3237, 1, 0,
		0, 0, 3243, 3246, 1, 0, 0, 0, 3244, 3242, 1, 0, 0, 0, 3244, 3245, 1, 0,
		0, 0, 3245, 3248, 1, 0, 0, 0, 3246, 3244, 1, 0, 0, 0, 3247, 3235, 1, 0,
		0, 0, 3247, 3248, 1, 0, 0, 0, 3248, 3249, 1, 0, 0, 0, 3249, 3250, 5, 368,
		0, 0, 3250, 3303, 1, 0, 0, 0, 3251, 3252, 5, 340, 0, 0, 3252, 3253, 5,
		365, 0, 0, 3253, 3261, 3, 398, 199, 0, 3254, 3255, 5, 350, 0, 0, 3255,
		3256, 3, 398, 199, 0, 3256, 3257, 5, 355, 0, 0, 3257, 3258, 3, 398, 199,
		0, 3258, 3260, 1, 0, 0, 0, 3259, 3254, 1, 0, 0, 0, 3260, 3263, 1, 0, 0,
		0, 3261, 3259, 1, 0, 0, 0, 3261, 3262, 1, 0, 0, 0, 3262, 3264, 1, 0, 0,
		0, 3263, 3261, 1, 0, 0, 0, 3264, 3265, 5, 368, 0, 0, 3265, 3303, 1, 0,
		0, 0, 3266, 3267, 5, 341, 0, 0, 3267, 3268, 5, 365, 0, 0, 3268, 3274, 3,
		398, 199, 0, 3269, 3270, 5, 350, 0, 0, 3270, 3271, 3, 398, 199, 0, 3271,
		3272, 5, 355, 0, 0, 3272, 3273, 3, 398, 199, 0, 3273, 3275, 1, 0, 0, 0,
		3274, 3269, 1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3274, 1, 0, 0, 0,
		3276, 3277, 1, 0, 0, 0, 3277, 3280, 1, 0, 0, 0, 3278, 3279, 5, 350, 0,
		0, 3279, 3281, 3, 398, 199, 0, 3280, 3278, 1, 0, 0, 0, 3280, 3281, 1, 0,
		0, 0, 3281, 3282, 1, 0, 0, 0, 3282, 3283, 5, 368, 0, 0, 3283, 3303, 1,
		0, 0, 0, 3284, 3285, 5, 250, 0, 0, 3285, 3286, 5, 365, 0, 0, 3286, 3287,
		3, 398, 199, 0, 3287, 3288, 5, 368, 0, 0, 3288, 3303, 1, 0, 0, 0, 3289,
		3290, 5, 281, 0, 0, 3290, 3291, 5, 365, 0, 0, 3291, 3292, 3, 398, 199,
		0, 3292, 3293, 5, 119, 0, 0, 3293, 3296, 3, 398, 199, 0, 3294, 3295, 5,
		115, 0, 0, 3295, 3297, 3, 398, 199, 0, 3296, 3294, 1, 0, 0, 0, 3296, 3297,
		1, 0, 0, 0, 3297, 3298, 1, 0, 0, 0, 3298, 3299, 5, 368, 0, 0, 3299, 3303,
		1, 0, 0, 0, 3300, 3303, 5, 345, 0, 0, 3301, 3303, 5, 347, 0, 0, 3302, 3102,
		1, 0, 0, 0, 3302, 3103, 1, 0, 0, 0, 3302, 3113, 1, 0, 0, 0, 3302, 3120,
		1, 0, 0, 0, 3302, 3121, 1, 0, 0, 0, 3302, 3126, 1, 0, 0, 0, 3302, 3134,
		1, 0, 0, 0, 3302, 3135, 1, 0, 0, 0, 3302, 3137, 1, 0, 0, 0, 3302, 3156,
		1, 0, 0, 0, 3302, 3175, 1, 0, 0, 0, 3302, 3194, 1, 0, 0, 0, 3302, 3213,
		1, 0, 0, 0, 3302, 3232, 1, 0, 0, 0, 3302, 3251, 1, 0, 0, 0, 3302, 3266,
		1, 0, 0, 0, 3302, 3284, 1, 0, 0, 0, 3302, 3289, 1, 0, 0, 0, 3302, 3300,
		1, 0, 0, 0, 3302, 3301, 1, 0, 0, 0, 3303, 427, 1, 0, 0, 0, 3304, 3305,
		3, 460, 230, 0, 3305, 3307, 5, 365, 0, 0, 3306, 3308, 3, 436, 218, 0, 3307,
		3306, 1, 0, 0, 0, 3307, 3308, 1, 0, 0, 0, 3308, 3309, 1, 0, 0, 0, 3309,
		3310, 5, 368, 0, 0, 3310, 429, 1, 0, 0, 0, 3311, 3314, 3, 432, 216, 0,
		3312, 3314, 3, 434, 217, 0, 3313, 3311, 1, 0, 0, 0, 3313, 3312, 1, 0, 0,
		0, 3314, 431, 1, 0, 0, 0, 3315, 3318, 3, 460, 230, 0, 3316, 3318, 3, 428,
		214, 0, 3317, 3315, 1, 0, 0, 0, 3317, 3316, 1, 0, 0, 0, 3318, 3319, 1,
		0, 0, 0, 3319, 3320, 5, 353, 0, 0, 3320, 3321, 3, 428, 214, 0, 3321, 433,
		1, 0, 0, 0, 3322, 3325, 3, 460, 230, 0, 3323, 3325, 3, 428, 214, 0, 3324,
		3322, 1, 0, 0, 0, 3324, 3323, 1, 0, 0, 0, 3325, 3326, 1, 0, 0, 0, 3326,
		3327, 5, 353, 0, 0, 3327, 3328, 3, 460, 230, 0, 3328, 435, 1, 0, 0, 0,
		3329, 3334, 3, 438, 219, 0, 3330, 3331, 5, 350, 0, 0, 3331, 3333, 3, 438,
		219, 0, 3332, 3330, 1, 0, 0, 0, 3333, 3336, 1, 0, 0, 0, 3334, 3332, 1,
		0, 0, 0, 3334, 3335, 1, 0, 0, 0, 3335, 437, 1, 0, 0, 0, 3336, 3334, 1,
		0, 0, 0, 3337, 3343, 4, 219, 10, 0, 3338, 3339, 3, 460, 230, 0, 3339, 3341,
		5, 355, 0, 0, 3340, 3342, 5, 359, 0, 0, 3341, 3340, 1, 0, 0, 0, 3341, 3342,
		1, 0, 0, 0, 3342, 3344, 1, 0, 0, 0, 3343, 3338, 1, 0, 0, 0, 3343, 3344,
		1, 0, 0, 0, 3344, 3345, 1, 0, 0, 0, 3345, 3346, 3, 398, 199, 0, 3346, 439,
		1, 0, 0, 0, 3347, 3350, 3, 292, 146, 0, 3348, 3350, 3, 398, 199, 0, 3349,
		3347, 1, 0, 0, 0, 3349, 3348, 1, 0, 0, 0, 3350, 441, 1, 0, 0, 0, 3351,
		3354, 3, 454, 227, 0, 3352, 3354, 3, 398, 199, 0, 3353, 3351, 1, 0, 0,
		0, 3353, 3352, 1, 0, 0, 0, 3354, 443, 1, 0, 0, 0, 3355, 3359, 5, 131, 0,
		0, 3356, 3358, 3, 446, 223, 0, 3357, 3356, 1, 0, 0, 0, 3358, 3361, 1, 0,
		0, 0, 3359, 3357, 1, 0, 0, 0, 3359, 3360, 1, 0, 0, 0, 3360, 445, 1, 0,
		0, 0, 3361, 3359, 1, 0, 0, 0, 3362, 3363, 5, 371, 0, 0, 3363, 3364, 3,
		462, 231, 0, 3364, 3365, 3, 398, 199, 0, 3365, 3375, 1, 0, 0, 0, 3366,
		3367, 5, 371, 0, 0, 3367, 3368, 3, 462, 231, 0, 3368, 3369, 5, 372, 0,
		0, 3369, 3370, 5, 355, 0, 0, 3370, 3371, 3, 398, 199, 0, 3371, 3375, 1,
		0, 0, 0, 3372, 3373, 5, 371, 0, 0, 3373, 3375, 3, 462, 231, 0, 3374, 3362,
		1, 0, 0, 0, 3374, 3366, 1, 0, 0, 0, 3374, 3372, 1, 0, 0, 0, 3375, 447,
		1, 0, 0, 0, 3376, 3377, 5, 4, 0, 0, 3377, 3378, 3, 450, 225, 0, 3378, 3379,
		5, 370, 0, 0, 3379, 3382, 1, 0, 0, 0, 3380, 3382, 3, 452, 226, 0, 3381,
		3376, 1, 0, 0, 0, 3381, 3380, 1, 0, 0, 0, 3382, 449, 1, 0, 0, 0, 3383,
		3385, 9, 0, 0, 0, 3384, 3383, 1, 0, 0, 0, 3385, 3388, 1, 0, 0, 0, 3386,
		3387, 1, 0, 0, 0, 3386, 3384, 1, 0, 0, 0, 3387, 451, 1, 0, 0, 0, 3388,
		3386, 1, 0, 0, 0, 3389, 3390, 5, 132, 0, 0, 3390, 3391, 3, 398, 199, 0,
		3391, 453, 1, 0, 0, 0, 3392, 3407, 5, 380, 0, 0, 3393, 3397, 5, 352, 0,
		0, 3394, 3395, 5, 353, 0, 0, 3395, 3397, 5, 352, 0, 0, 3396, 3393, 1, 0,
		0, 0, 3396, 3394, 1, 0, 0, 0, 3396, 3397, 1, 0, 0, 0, 3397, 3398, 1, 0,
		0, 0, 3398, 3403, 3, 462, 231, 0, 3399, 3400, 5, 352, 0, 0, 3400, 3402,
		3, 462, 231, 0, 3401, 3399, 1, 0, 0, 0, 3402, 3405, 1, 0, 0, 0, 3403, 3401,
		1, 0, 0, 0, 3403, 3404, 1, 0, 0, 0, 3404, 3407, 1, 0, 0, 0, 3405, 3403,
		1, 0, 0, 0, 3406, 3392, 1, 0, 0, 0, 3406, 3396, 1, 0, 0, 0, 3407, 455,
		1, 0, 0, 0, 3408, 3409, 5, 68, 0, 0, 3409, 3410, 3, 464, 232, 0, 3410,
		457, 1, 0, 0, 0, 3411, 3412, 5, 292, 0, 0, 3412, 3413, 3, 464, 232, 0,
		3413, 459, 1, 0, 0, 0, 3414, 3416, 5, 371, 0, 0, 3415, 3414, 1, 0, 0, 0,
		3415, 3416, 1, 0, 0, 0, 3416, 3419, 1, 0, 0, 0, 3417, 3420, 5, 372, 0,
		0, 3418, 3420, 3, 474, 237, 0, 3419, 3417, 1, 0, 0, 0, 3419, 3418, 1, 0,
		0, 0, 3420, 461, 1, 0, 0, 0, 3421, 3426, 3, 460, 230, 0, 3422, 3423, 5,
		353, 0, 0, 3423, 3425, 3, 460, 230, 0, 3424, 3422, 1, 0, 0, 0, 3425, 3428,
		1, 0, 0, 0, 3426, 3424, 1, 0, 0, 0, 3426, 3427, 1, 0, 0, 0, 3427, 463,
		1, 0, 0, 0, 3428, 3426, 1, 0, 0, 0, 3429, 3432, 5, 373, 0, 0, 3430, 3432,
		5, 374, 0, 0, 3431, 3429, 1, 0, 0, 0, 3431, 3430, 1, 0, 0, 0, 3432, 465,
		1, 0, 0, 0, 3433, 3435, 7, 45, 0, 0, 3434, 3433, 1, 0, 0, 0, 3434, 3435,
		1, 0, 0, 0, 3435, 3436, 1, 0, 0, 0, 3436, 3437, 5, 375, 0, 0, 3437, 467,
		1, 0, 0, 0, 3438, 3440, 7, 45, 0, 0, 3439, 3438, 1, 0, 0, 0, 3439, 3440,
		1, 0, 0, 0, 3440, 3441, 1, 0, 0, 0, 3441, 3442, 5, 376, 0, 0, 3442, 469,
		1, 0, 0, 0, 3443, 3444, 7, 49, 0, 0, 3444, 471, 1, 0, 0, 0, 3445, 3446,
		5, 196, 0, 0, 3446, 473, 1, 0, 0, 0, 3447, 3448, 7, 50, 0, 0, 3448, 475,
		1, 0, 0, 0, 434, 481, 484, 488, 491, 496, 503, 509, 511, 520, 523, 525,
		590, 598, 614, 621, 624, 630, 634, 643, 648, 661, 666, 675, 687, 692, 695,
		709, 716, 725, 742, 750, 761, 771, 779, 786, 790, 794, 799, 803, 808, 812,
		816, 826, 830, 835, 840, 844, 857, 862, 868, 877, 881, 889, 892, 897, 902,
		909, 918, 921, 928, 934, 939, 945, 950, 953, 963, 971, 981, 995, 1005,
		1011, 1016, 1021, 1026, 1030, 1035, 1038, 1048, 1060, 1067, 1070, 1082,
		1087, 1092, 1095, 1102, 1114, 1127, 1129, 1134, 1137, 1152, 1158, 1169,
		1172, 1182, 1189, 1195, 1203, 1213, 1233, 1239, 1243, 1248, 1252, 1257,
		1260, 1265, 1268, 1280, 1287, 1292, 1297, 1301, 1306, 1309, 1319, 1331,
		1338, 1346, 1361, 1392, 1394, 1399, 1403, 1408, 1415, 1418, 1421, 1426,
		1430, 1432, 1439, 1445, 1452, 1458, 1461, 1466, 1470, 1473, 1480, 1486,
		1489, 1499, 1508, 1515, 1522, 1524, 1530, 1533, 1544, 1553, 1559, 1565,
		1568, 1573, 1576, 1579, 1582, 1585, 1591, 1601, 1612, 1615, 1622, 1627,
		1632, 1636, 1644, 1648, 1653, 1657, 1659, 1664, 1672, 1677, 1683, 1690,
		1697, 1704, 1707, 1714, 1722, 1730, 1733, 1736, 1741, 1750, 1754, 1764,
		1783, 1790, 1792, 1796, 1800, 1808, 1819, 1828, 1836, 1844, 1848, 1856,
		1874, 1888, 1895, 1899, 1906, 1908, 1912, 1916, 1924, 1928, 1938, 1947,
		1963, 1969, 1973, 1983, 1991, 2000, 2004, 2010, 2015, 2019, 2029, 2035,
		2039, 2051, 2058, 2074, 2081, 2091, 2094, 2098, 2105, 2112, 2114, 2118,
		2122, 2127, 2130, 2134, 2137, 2148, 2151, 2162, 2168, 2172, 2174, 2178,
		2187, 2194, 2198, 2202, 2209, 2213, 2221, 2232, 2236, 2247, 2254, 2267,
		2275, 2279, 2289, 2294, 2307, 2318, 2326, 2330, 2334, 2338, 2340, 2345,
		2348, 2351, 2354, 2358, 2361, 2364, 2367, 2370, 2377, 2388, 2392, 2395,
		2399, 2406, 2410, 2420, 2425, 2430, 2434, 2445, 2451, 2455, 2461, 2470,
		2473, 2478, 2481, 2491, 2496, 2505, 2510, 2514, 2523, 2527, 2541, 2554,
		2559, 2563, 2569, 2580, 2582, 2589, 2592, 2599, 2604, 2610, 2613, 2616,
		2631, 2638, 2641, 2644, 2648, 2653, 2659, 2663, 2674, 2678, 2681, 2685,
		2689, 2693, 2697, 2703, 2709, 2716, 2724, 2730, 2735, 2746, 2755, 2759,
		2768, 2772, 2782, 2787, 2809, 2812, 2832, 2842, 2844, 2855, 2870, 2883,
		2887, 2898, 2902, 2914, 2918, 2929, 2934, 2939, 2943, 2947, 2952, 2956,
		2960, 2983, 2985, 3003, 3005, 3013, 3018, 3023, 3028, 3041, 3046, 3051,
		3056, 3061, 3066, 3071, 3076, 3078, 3085, 3088, 3099, 3109, 3117, 3126,
		3132, 3149, 3152, 3168, 3171, 3187, 3190, 3206, 3209, 3225, 3228, 3244,
		3247, 3261, 3276, 3280, 3296, 3302, 3307, 3313, 3317, 3324, 3334, 3341,
		3343, 3349, 3353, 3359, 3374, 3381, 3386, 3396, 3403, 3406, 3415, 3419,
		3426, 3431, 3434, 3439,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// HplsqlParserInit initializes any static state used to implement HplsqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewHplsqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func HplsqlParserInit() {
	staticData := &HplsqlParserStaticData
	staticData.once.Do(hplsqlParserInit)
}

// NewHplsqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewHplsqlParser(input antlr.TokenStream) *HplsqlParser {
	HplsqlParserInit()
	this := new(HplsqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &HplsqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Hplsql.g4"

	return this
}

// HplsqlParser tokens.
const (
	HplsqlParserEOF                   = antlr.TokenEOF
	HplsqlParserT__0                  = 1
	HplsqlParserT__1                  = 2
	HplsqlParserT__2                  = 3
	HplsqlParserT__3                  = 4
	HplsqlParserT_ACTION              = 5
	HplsqlParserT_ADD2                = 6
	HplsqlParserT_ALL                 = 7
	HplsqlParserT_ALLOCATE            = 8
	HplsqlParserT_ALTER               = 9
	HplsqlParserT_AND                 = 10
	HplsqlParserT_ANSI_NULLS          = 11
	HplsqlParserT_ANSI_PADDING        = 12
	HplsqlParserT_AS                  = 13
	HplsqlParserT_ASC                 = 14
	HplsqlParserT_ASSOCIATE           = 15
	HplsqlParserT_AT                  = 16
	HplsqlParserT_AUTO_INCREMENT      = 17
	HplsqlParserT_AVG                 = 18
	HplsqlParserT_BATCHSIZE           = 19
	HplsqlParserT_BEGIN               = 20
	HplsqlParserT_BETWEEN             = 21
	HplsqlParserT_BIGINT              = 22
	HplsqlParserT_BINARY_DOUBLE       = 23
	HplsqlParserT_BINARY_FLOAT        = 24
	HplsqlParserT_BINARY_INTEGER      = 25
	HplsqlParserT_BIT                 = 26
	HplsqlParserT_BODY                = 27
	HplsqlParserT_BREAK               = 28
	HplsqlParserT_BULK                = 29
	HplsqlParserT_BY                  = 30
	HplsqlParserT_BYTE                = 31
	HplsqlParserT_CALL                = 32
	HplsqlParserT_CALLER              = 33
	HplsqlParserT_CASCADE             = 34
	HplsqlParserT_CASE                = 35
	HplsqlParserT_CASESPECIFIC        = 36
	HplsqlParserT_CAST                = 37
	HplsqlParserT_CHAR                = 38
	HplsqlParserT_CHARACTER           = 39
	HplsqlParserT_CHARSET             = 40
	HplsqlParserT_CLIENT              = 41
	HplsqlParserT_CLOSE               = 42
	HplsqlParserT_CLUSTERED           = 43
	HplsqlParserT_CMP                 = 44
	HplsqlParserT_COLLECT             = 45
	HplsqlParserT_COLLECTION          = 46
	HplsqlParserT_COLUMN              = 47
	HplsqlParserT_COMMENT             = 48
	HplsqlParserT_CONSTANT            = 49
	HplsqlParserT_COMMIT              = 50
	HplsqlParserT_COMPRESS            = 51
	HplsqlParserT_CONCAT              = 52
	HplsqlParserT_CONDITION           = 53
	HplsqlParserT_CONSTRAINT          = 54
	HplsqlParserT_CONTINUE            = 55
	HplsqlParserT_COPY                = 56
	HplsqlParserT_COUNT               = 57
	HplsqlParserT_COUNT_BIG           = 58
	HplsqlParserT_CREATE              = 59
	HplsqlParserT_CREATION            = 60
	HplsqlParserT_CREATOR             = 61
	HplsqlParserT_CS                  = 62
	HplsqlParserT_CURRENT             = 63
	HplsqlParserT_CURRENT_SCHEMA      = 64
	HplsqlParserT_CURSOR              = 65
	HplsqlParserT_DATABASE            = 66
	HplsqlParserT_DATA                = 67
	HplsqlParserT_DATE                = 68
	HplsqlParserT_DATETIME            = 69
	HplsqlParserT_DAY                 = 70
	HplsqlParserT_DAYS                = 71
	HplsqlParserT_DEC                 = 72
	HplsqlParserT_DECIMAL             = 73
	HplsqlParserT_DECLARE             = 74
	HplsqlParserT_DEFAULT             = 75
	HplsqlParserT_DEFERRED            = 76
	HplsqlParserT_DEFINED             = 77
	HplsqlParserT_DEFINER             = 78
	HplsqlParserT_DEFINITION          = 79
	HplsqlParserT_DELETE              = 80
	HplsqlParserT_DELIMITED           = 81
	HplsqlParserT_DELIMITER           = 82
	HplsqlParserT_DESC                = 83
	HplsqlParserT_DESCRIBE            = 84
	HplsqlParserT_DIAGNOSTICS         = 85
	HplsqlParserT_DIR                 = 86
	HplsqlParserT_DIRECTORY           = 87
	HplsqlParserT_DISTINCT            = 88
	HplsqlParserT_DISTRIBUTE          = 89
	HplsqlParserT_DO                  = 90
	HplsqlParserT_DOUBLE              = 91
	HplsqlParserT_DROP                = 92
	HplsqlParserT_DYNAMIC             = 93
	HplsqlParserT_ELSE                = 94
	HplsqlParserT_ELSEIF              = 95
	HplsqlParserT_ELSIF               = 96
	HplsqlParserT_ENABLE              = 97
	HplsqlParserT_END                 = 98
	HplsqlParserT_ENGINE              = 99
	HplsqlParserT_ESCAPED             = 100
	HplsqlParserT_EXCEPT              = 101
	HplsqlParserT_EXEC                = 102
	HplsqlParserT_EXECUTE             = 103
	HplsqlParserT_EXCEPTION           = 104
	HplsqlParserT_EXCLUSIVE           = 105
	HplsqlParserT_EXISTS              = 106
	HplsqlParserT_EXIT                = 107
	HplsqlParserT_FALLBACK            = 108
	HplsqlParserT_FALSE               = 109
	HplsqlParserT_FETCH               = 110
	HplsqlParserT_FIELDS              = 111
	HplsqlParserT_FILE                = 112
	HplsqlParserT_FILES               = 113
	HplsqlParserT_FLOAT               = 114
	HplsqlParserT_FOR                 = 115
	HplsqlParserT_FOREIGN             = 116
	HplsqlParserT_FORMAT              = 117
	HplsqlParserT_FOUND               = 118
	HplsqlParserT_FROM                = 119
	HplsqlParserT_FULL                = 120
	HplsqlParserT_FUNCTION            = 121
	HplsqlParserT_GET                 = 122
	HplsqlParserT_GLOBAL              = 123
	HplsqlParserT_GO                  = 124
	HplsqlParserT_GRANT               = 125
	HplsqlParserT_GROUP               = 126
	HplsqlParserT_HANDLER             = 127
	HplsqlParserT_HASH                = 128
	HplsqlParserT_HAVING              = 129
	HplsqlParserT_HDFS                = 130
	HplsqlParserT_HIVE                = 131
	HplsqlParserT_HOST                = 132
	HplsqlParserT_IDENTITY            = 133
	HplsqlParserT_IF                  = 134
	HplsqlParserT_IGNORE              = 135
	HplsqlParserT_IMMEDIATE           = 136
	HplsqlParserT_IN                  = 137
	HplsqlParserT_INCLUDE             = 138
	HplsqlParserT_INDEX               = 139
	HplsqlParserT_INITRANS            = 140
	HplsqlParserT_INNER               = 141
	HplsqlParserT_INOUT               = 142
	HplsqlParserT_INSERT              = 143
	HplsqlParserT_INT                 = 144
	HplsqlParserT_INT2                = 145
	HplsqlParserT_INT4                = 146
	HplsqlParserT_INT8                = 147
	HplsqlParserT_INTEGER             = 148
	HplsqlParserT_INTERSECT           = 149
	HplsqlParserT_INTERVAL            = 150
	HplsqlParserT_INTO                = 151
	HplsqlParserT_INVOKER             = 152
	HplsqlParserT_IS                  = 153
	HplsqlParserT_ISOPEN              = 154
	HplsqlParserT_ITEMS               = 155
	HplsqlParserT_JOIN                = 156
	HplsqlParserT_KEEP                = 157
	HplsqlParserT_KEY                 = 158
	HplsqlParserT_KEYS                = 159
	HplsqlParserT_LANGUAGE            = 160
	HplsqlParserT_LEAVE               = 161
	HplsqlParserT_LEFT                = 162
	HplsqlParserT_LIKE                = 163
	HplsqlParserT_LIMIT               = 164
	HplsqlParserT_LINES               = 165
	HplsqlParserT_LOCAL               = 166
	HplsqlParserT_LOCATION            = 167
	HplsqlParserT_LOCATOR             = 168
	HplsqlParserT_LOCATORS            = 169
	HplsqlParserT_LOCKS               = 170
	HplsqlParserT_LOG                 = 171
	HplsqlParserT_LOGGED              = 172
	HplsqlParserT_LOGGING             = 173
	HplsqlParserT_LOOP                = 174
	HplsqlParserT_MAP                 = 175
	HplsqlParserT_MATCHED             = 176
	HplsqlParserT_MAX                 = 177
	HplsqlParserT_MAXTRANS            = 178
	HplsqlParserT_MERGE               = 179
	HplsqlParserT_MESSAGE_TEXT        = 180
	HplsqlParserT_MICROSECOND         = 181
	HplsqlParserT_MICROSECONDS        = 182
	HplsqlParserT_MILLIS              = 183
	HplsqlParserT_MIN                 = 184
	HplsqlParserT_MULTISET            = 185
	HplsqlParserT_NCHAR               = 186
	HplsqlParserT_NEW                 = 187
	HplsqlParserT_NVARCHAR            = 188
	HplsqlParserT_NO                  = 189
	HplsqlParserT_NOCOUNT             = 190
	HplsqlParserT_NOCOMPRESS          = 191
	HplsqlParserT_NOLOGGING           = 192
	HplsqlParserT_NONE                = 193
	HplsqlParserT_NOT                 = 194
	HplsqlParserT_NOTFOUND            = 195
	HplsqlParserT_NULL                = 196
	HplsqlParserT_NUMERIC             = 197
	HplsqlParserT_NUMBER              = 198
	HplsqlParserT_OBJECT              = 199
	HplsqlParserT_OFF                 = 200
	HplsqlParserT_OF                  = 201
	HplsqlParserT_ON                  = 202
	HplsqlParserT_ONLY                = 203
	HplsqlParserT_OPEN                = 204
	HplsqlParserT_OR                  = 205
	HplsqlParserT_ORDER               = 206
	HplsqlParserT_OUT                 = 207
	HplsqlParserT_OUTER               = 208
	HplsqlParserT_OVER                = 209
	HplsqlParserT_OVERWRITE           = 210
	HplsqlParserT_OWNER               = 211
	HplsqlParserT_PACKAGE             = 212
	HplsqlParserT_PARTITION           = 213
	HplsqlParserT_PCTFREE             = 214
	HplsqlParserT_PCTUSED             = 215
	HplsqlParserT_PLS_INTEGER         = 216
	HplsqlParserT_PRECISION           = 217
	HplsqlParserT_PRESERVE            = 218
	HplsqlParserT_PRIMARY             = 219
	HplsqlParserT_PRINT               = 220
	HplsqlParserT_PROC                = 221
	HplsqlParserT_PROCEDURE           = 222
	HplsqlParserT_QUALIFY             = 223
	HplsqlParserT_QUERY_BAND          = 224
	HplsqlParserT_QUIT                = 225
	HplsqlParserT_QUOTED_IDENTIFIER   = 226
	HplsqlParserT_RAISE               = 227
	HplsqlParserT_REAL                = 228
	HplsqlParserT_REFERENCES          = 229
	HplsqlParserT_REGEXP              = 230
	HplsqlParserT_REPLACE             = 231
	HplsqlParserT_RESIGNAL            = 232
	HplsqlParserT_RESTRICT            = 233
	HplsqlParserT_RESULT              = 234
	HplsqlParserT_RESULT_SET_LOCATOR  = 235
	HplsqlParserT_RETURN              = 236
	HplsqlParserT_RETURNS             = 237
	HplsqlParserT_REVERSE             = 238
	HplsqlParserT_RIGHT               = 239
	HplsqlParserT_RLIKE               = 240
	HplsqlParserT_ROLE                = 241
	HplsqlParserT_ROLLBACK            = 242
	HplsqlParserT_ROW                 = 243
	HplsqlParserT_ROWS                = 244
	HplsqlParserT_ROWTYPE             = 245
	HplsqlParserT_ROW_COUNT           = 246
	HplsqlParserT_RR                  = 247
	HplsqlParserT_RS                  = 248
	HplsqlParserT_PWD                 = 249
	HplsqlParserT_TRIM                = 250
	HplsqlParserT_SCHEMA              = 251
	HplsqlParserT_SECOND              = 252
	HplsqlParserT_SECONDS             = 253
	HplsqlParserT_SECURITY            = 254
	HplsqlParserT_SEGMENT             = 255
	HplsqlParserT_SEL                 = 256
	HplsqlParserT_SELECT              = 257
	HplsqlParserT_SET                 = 258
	HplsqlParserT_SESSION             = 259
	HplsqlParserT_SESSIONS            = 260
	HplsqlParserT_SETS                = 261
	HplsqlParserT_SHARE               = 262
	HplsqlParserT_SIGNAL              = 263
	HplsqlParserT_SIMPLE_DOUBLE       = 264
	HplsqlParserT_SIMPLE_FLOAT        = 265
	HplsqlParserT_SIMPLE_INTEGER      = 266
	HplsqlParserT_SMALLDATETIME       = 267
	HplsqlParserT_SMALLINT            = 268
	HplsqlParserT_SQL                 = 269
	HplsqlParserT_SQLEXCEPTION        = 270
	HplsqlParserT_SQLINSERT           = 271
	HplsqlParserT_SQLSTATE            = 272
	HplsqlParserT_SQLWARNING          = 273
	HplsqlParserT_STATS               = 274
	HplsqlParserT_STATISTICS          = 275
	HplsqlParserT_STEP                = 276
	HplsqlParserT_STORAGE             = 277
	HplsqlParserT_STORED              = 278
	HplsqlParserT_STRING              = 279
	HplsqlParserT_SUBDIR              = 280
	HplsqlParserT_SUBSTRING           = 281
	HplsqlParserT_SUM                 = 282
	HplsqlParserT_SUMMARY             = 283
	HplsqlParserT_SYS_REFCURSOR       = 284
	HplsqlParserT_TABLE               = 285
	HplsqlParserT_TABLESPACE          = 286
	HplsqlParserT_TEMPORARY           = 287
	HplsqlParserT_TERMINATED          = 288
	HplsqlParserT_TEXTIMAGE_ON        = 289
	HplsqlParserT_THEN                = 290
	HplsqlParserT_TIME                = 291
	HplsqlParserT_TIMESTAMP           = 292
	HplsqlParserT_TINYINT             = 293
	HplsqlParserT_TITLE               = 294
	HplsqlParserT_TO                  = 295
	HplsqlParserT_TOP                 = 296
	HplsqlParserT_TRANSACTION         = 297
	HplsqlParserT_TRUE                = 298
	HplsqlParserT_TRUNCATE            = 299
	HplsqlParserT_TYPE                = 300
	HplsqlParserT_UNION               = 301
	HplsqlParserT_UNIQUE              = 302
	HplsqlParserT_UPDATE              = 303
	HplsqlParserT_UR                  = 304
	HplsqlParserT_USE                 = 305
	HplsqlParserT_USING               = 306
	HplsqlParserT_VALUE               = 307
	HplsqlParserT_VALUES              = 308
	HplsqlParserT_VAR                 = 309
	HplsqlParserT_VARCHAR             = 310
	HplsqlParserT_VARCHAR2            = 311
	HplsqlParserT_VARYING             = 312
	HplsqlParserT_VOLATILE            = 313
	HplsqlParserT_WHEN                = 314
	HplsqlParserT_WHERE               = 315
	HplsqlParserT_WHILE               = 316
	HplsqlParserT_WITH                = 317
	HplsqlParserT_WITHOUT             = 318
	HplsqlParserT_WORK                = 319
	HplsqlParserT_XACT_ABORT          = 320
	HplsqlParserT_XML                 = 321
	HplsqlParserT_YES                 = 322
	HplsqlParserT_ACTIVITY_COUNT      = 323
	HplsqlParserT_CUME_DIST           = 324
	HplsqlParserT_CURRENT_DATE        = 325
	HplsqlParserT_CURRENT_TIME_MILLIS = 326
	HplsqlParserT_CURRENT_TIMESTAMP   = 327
	HplsqlParserT_CURRENT_USER        = 328
	HplsqlParserT_DENSE_RANK          = 329
	HplsqlParserT_FIRST_VALUE         = 330
	HplsqlParserT_LAG                 = 331
	HplsqlParserT_LAST_VALUE          = 332
	HplsqlParserT_LEAD                = 333
	HplsqlParserT_MAX_PART_STRING     = 334
	HplsqlParserT_MIN_PART_STRING     = 335
	HplsqlParserT_MAX_PART_INT        = 336
	HplsqlParserT_MIN_PART_INT        = 337
	HplsqlParserT_MAX_PART_DATE       = 338
	HplsqlParserT_MIN_PART_DATE       = 339
	HplsqlParserT_PART_COUNT          = 340
	HplsqlParserT_PART_LOC            = 341
	HplsqlParserT_RANK                = 342
	HplsqlParserT_ROW_NUMBER          = 343
	HplsqlParserT_STDEV               = 344
	HplsqlParserT_SYSDATE             = 345
	HplsqlParserT_VARIANCE            = 346
	HplsqlParserT_USER                = 347
	HplsqlParserT_ADD                 = 348
	HplsqlParserT_COLON               = 349
	HplsqlParserT_COMMA               = 350
	HplsqlParserT_PIPE                = 351
	HplsqlParserT_DIV                 = 352
	HplsqlParserT_DOT                 = 353
	HplsqlParserT_DOT2                = 354
	HplsqlParserT_EQUAL               = 355
	HplsqlParserT_EQUAL2              = 356
	HplsqlParserT_NOTEQUAL            = 357
	HplsqlParserT_NOTEQUAL2           = 358
	HplsqlParserT_GREATER             = 359
	HplsqlParserT_GREATEREQUAL        = 360
	HplsqlParserT_LESS                = 361
	HplsqlParserT_LESSEQUAL           = 362
	HplsqlParserT_MUL                 = 363
	HplsqlParserT_OPEN_B              = 364
	HplsqlParserT_OPEN_P              = 365
	HplsqlParserT_OPEN_SB             = 366
	HplsqlParserT_CLOSE_B             = 367
	HplsqlParserT_CLOSE_P             = 368
	HplsqlParserT_CLOSE_SB            = 369
	HplsqlParserT_SEMICOLON           = 370
	HplsqlParserT_SUB                 = 371
	HplsqlParserL_ID                  = 372
	HplsqlParserL_S_STRING            = 373
	HplsqlParserL_D_STRING            = 374
	HplsqlParserL_INT                 = 375
	HplsqlParserL_DEC                 = 376
	HplsqlParserL_WS                  = 377
	HplsqlParserL_M_COMMENT           = 378
	HplsqlParserL_S_COMMENT           = 379
	HplsqlParserL_FILE                = 380
	HplsqlParserL_LABEL               = 381
)

// HplsqlParser rules.
const (
	HplsqlParserRULE_program                             = 0
	HplsqlParserRULE_block                               = 1
	HplsqlParserRULE_begin_end_block                     = 2
	HplsqlParserRULE_single_block_stmt                   = 3
	HplsqlParserRULE_block_end                           = 4
	HplsqlParserRULE_proc_block                          = 5
	HplsqlParserRULE_stmt                                = 6
	HplsqlParserRULE_semicolon_stmt                      = 7
	HplsqlParserRULE_exception_block                     = 8
	HplsqlParserRULE_exception_block_item                = 9
	HplsqlParserRULE_null_stmt                           = 10
	HplsqlParserRULE_expr_stmt                           = 11
	HplsqlParserRULE_assignment_stmt                     = 12
	HplsqlParserRULE_assignment_stmt_item                = 13
	HplsqlParserRULE_assignment_stmt_single_item         = 14
	HplsqlParserRULE_assignment_stmt_collection_item     = 15
	HplsqlParserRULE_assignment_stmt_multiple_item       = 16
	HplsqlParserRULE_assignment_stmt_select_item         = 17
	HplsqlParserRULE_allocate_cursor_stmt                = 18
	HplsqlParserRULE_associate_locator_stmt              = 19
	HplsqlParserRULE_begin_transaction_stmt              = 20
	HplsqlParserRULE_break_stmt                          = 21
	HplsqlParserRULE_call_stmt                           = 22
	HplsqlParserRULE_declare_stmt                        = 23
	HplsqlParserRULE_declare_block                       = 24
	HplsqlParserRULE_declare_block_inplace               = 25
	HplsqlParserRULE_declare_stmt_item                   = 26
	HplsqlParserRULE_declare_var_item                    = 27
	HplsqlParserRULE_declare_condition_item              = 28
	HplsqlParserRULE_declare_cursor_item                 = 29
	HplsqlParserRULE_cursor_with_return                  = 30
	HplsqlParserRULE_cursor_without_return               = 31
	HplsqlParserRULE_declare_handler_item                = 32
	HplsqlParserRULE_declare_temporary_table_item        = 33
	HplsqlParserRULE_create_table_stmt                   = 34
	HplsqlParserRULE_create_local_temp_table_stmt        = 35
	HplsqlParserRULE_create_table_definition             = 36
	HplsqlParserRULE_create_table_columns                = 37
	HplsqlParserRULE_create_table_columns_item           = 38
	HplsqlParserRULE_create_table_type_stmt              = 39
	HplsqlParserRULE_tbl_type                            = 40
	HplsqlParserRULE_sql_type                            = 41
	HplsqlParserRULE_column_name                         = 42
	HplsqlParserRULE_create_table_column_inline_cons     = 43
	HplsqlParserRULE_create_table_column_cons            = 44
	HplsqlParserRULE_create_table_fk_action              = 45
	HplsqlParserRULE_create_table_preoptions             = 46
	HplsqlParserRULE_create_table_preoptions_item        = 47
	HplsqlParserRULE_create_table_preoptions_td_item     = 48
	HplsqlParserRULE_create_table_options                = 49
	HplsqlParserRULE_create_table_options_item           = 50
	HplsqlParserRULE_create_table_options_ora_item       = 51
	HplsqlParserRULE_create_table_options_db2_item       = 52
	HplsqlParserRULE_create_table_options_td_item        = 53
	HplsqlParserRULE_create_table_options_hive_item      = 54
	HplsqlParserRULE_create_table_hive_row_format        = 55
	HplsqlParserRULE_create_table_hive_row_format_fields = 56
	HplsqlParserRULE_create_table_options_mssql_item     = 57
	HplsqlParserRULE_create_table_options_mysql_item     = 58
	HplsqlParserRULE_alter_table_stmt                    = 59
	HplsqlParserRULE_alter_table_item                    = 60
	HplsqlParserRULE_alter_table_add_constraint          = 61
	HplsqlParserRULE_alter_table_add_constraint_item     = 62
	HplsqlParserRULE_dtype                               = 63
	HplsqlParserRULE_dtype_len                           = 64
	HplsqlParserRULE_dtype_attr                          = 65
	HplsqlParserRULE_dtype_default                       = 66
	HplsqlParserRULE_create_database_stmt                = 67
	HplsqlParserRULE_create_database_option              = 68
	HplsqlParserRULE_create_function_stmt                = 69
	HplsqlParserRULE_create_function_return              = 70
	HplsqlParserRULE_create_package_stmt                 = 71
	HplsqlParserRULE_package_spec                        = 72
	HplsqlParserRULE_package_spec_item                   = 73
	HplsqlParserRULE_create_package_body_stmt            = 74
	HplsqlParserRULE_package_body                        = 75
	HplsqlParserRULE_package_body_item                   = 76
	HplsqlParserRULE_create_procedure_stmt               = 77
	HplsqlParserRULE_create_routine_params               = 78
	HplsqlParserRULE_create_routine_param_item           = 79
	HplsqlParserRULE_create_routine_options              = 80
	HplsqlParserRULE_create_routine_option               = 81
	HplsqlParserRULE_drop_stmt                           = 82
	HplsqlParserRULE_end_transaction_stmt                = 83
	HplsqlParserRULE_exec_stmt                           = 84
	HplsqlParserRULE_if_stmt                             = 85
	HplsqlParserRULE_if_plsql_stmt                       = 86
	HplsqlParserRULE_if_tsql_stmt                        = 87
	HplsqlParserRULE_if_bteq_stmt                        = 88
	HplsqlParserRULE_elseif_block                        = 89
	HplsqlParserRULE_else_block                          = 90
	HplsqlParserRULE_include_stmt                        = 91
	HplsqlParserRULE_insert_stmt                         = 92
	HplsqlParserRULE_insert_stmt_cols                    = 93
	HplsqlParserRULE_insert_stmt_rows                    = 94
	HplsqlParserRULE_insert_stmt_row                     = 95
	HplsqlParserRULE_insert_directory_stmt               = 96
	HplsqlParserRULE_exit_stmt                           = 97
	HplsqlParserRULE_get_diag_stmt                       = 98
	HplsqlParserRULE_get_diag_stmt_item                  = 99
	HplsqlParserRULE_get_diag_stmt_exception_item        = 100
	HplsqlParserRULE_get_diag_stmt_rowcount_item         = 101
	HplsqlParserRULE_grant_stmt                          = 102
	HplsqlParserRULE_grant_stmt_item                     = 103
	HplsqlParserRULE_leave_stmt                          = 104
	HplsqlParserRULE_map_object_stmt                     = 105
	HplsqlParserRULE_open_stmt                           = 106
	HplsqlParserRULE_fetch_stmt                          = 107
	HplsqlParserRULE_fetch_limit                         = 108
	HplsqlParserRULE_collect_stats_stmt                  = 109
	HplsqlParserRULE_collect_stats_clause                = 110
	HplsqlParserRULE_close_stmt                          = 111
	HplsqlParserRULE_cmp_stmt                            = 112
	HplsqlParserRULE_cmp_source                          = 113
	HplsqlParserRULE_copy_from_local_stmt                = 114
	HplsqlParserRULE_copy_stmt                           = 115
	HplsqlParserRULE_copy_source                         = 116
	HplsqlParserRULE_copy_target                         = 117
	HplsqlParserRULE_copy_option                         = 118
	HplsqlParserRULE_copy_file_option                    = 119
	HplsqlParserRULE_commit_stmt                         = 120
	HplsqlParserRULE_create_index_stmt                   = 121
	HplsqlParserRULE_create_index_col                    = 122
	HplsqlParserRULE_index_storage_clause                = 123
	HplsqlParserRULE_index_mssql_storage_clause          = 124
	HplsqlParserRULE_print_stmt                          = 125
	HplsqlParserRULE_quit_stmt                           = 126
	HplsqlParserRULE_raise_stmt                          = 127
	HplsqlParserRULE_resignal_stmt                       = 128
	HplsqlParserRULE_return_stmt                         = 129
	HplsqlParserRULE_rollback_stmt                       = 130
	HplsqlParserRULE_set_session_option                  = 131
	HplsqlParserRULE_set_current_schema_option           = 132
	HplsqlParserRULE_set_mssql_session_option            = 133
	HplsqlParserRULE_set_teradata_session_option         = 134
	HplsqlParserRULE_signal_stmt                         = 135
	HplsqlParserRULE_summary_stmt                        = 136
	HplsqlParserRULE_truncate_stmt                       = 137
	HplsqlParserRULE_use_stmt                            = 138
	HplsqlParserRULE_values_into_stmt                    = 139
	HplsqlParserRULE_while_stmt                          = 140
	HplsqlParserRULE_unconditional_loop_stmt             = 141
	HplsqlParserRULE_for_cursor_stmt                     = 142
	HplsqlParserRULE_for_range_stmt                      = 143
	HplsqlParserRULE_label                               = 144
	HplsqlParserRULE_using_clause                        = 145
	HplsqlParserRULE_select_stmt                         = 146
	HplsqlParserRULE_cte_select_stmt                     = 147
	HplsqlParserRULE_cte_select_stmt_item                = 148
	HplsqlParserRULE_cte_select_cols                     = 149
	HplsqlParserRULE_fullselect_stmt                     = 150
	HplsqlParserRULE_fullselect_stmt_item                = 151
	HplsqlParserRULE_fullselect_set_clause               = 152
	HplsqlParserRULE_subselect_stmt                      = 153
	HplsqlParserRULE_select_list                         = 154
	HplsqlParserRULE_select_list_set                     = 155
	HplsqlParserRULE_select_list_limit                   = 156
	HplsqlParserRULE_select_list_item                    = 157
	HplsqlParserRULE_select_list_alias                   = 158
	HplsqlParserRULE_select_list_asterisk                = 159
	HplsqlParserRULE_table_row                           = 160
	HplsqlParserRULE_into_clause                         = 161
	HplsqlParserRULE_bulk_collect_clause                 = 162
	HplsqlParserRULE_from_clause                         = 163
	HplsqlParserRULE_from_table_clause                   = 164
	HplsqlParserRULE_from_table_name_clause              = 165
	HplsqlParserRULE_from_subselect_clause               = 166
	HplsqlParserRULE_from_join_clause                    = 167
	HplsqlParserRULE_from_join_type_clause               = 168
	HplsqlParserRULE_from_table_values_clause            = 169
	HplsqlParserRULE_from_table_values_row               = 170
	HplsqlParserRULE_from_alias_clause                   = 171
	HplsqlParserRULE_table_name                          = 172
	HplsqlParserRULE_where_clause                        = 173
	HplsqlParserRULE_group_by_clause                     = 174
	HplsqlParserRULE_having_clause                       = 175
	HplsqlParserRULE_qualify_clause                      = 176
	HplsqlParserRULE_order_by_clause                     = 177
	HplsqlParserRULE_select_options                      = 178
	HplsqlParserRULE_select_options_item                 = 179
	HplsqlParserRULE_update_stmt                         = 180
	HplsqlParserRULE_update_assignment                   = 181
	HplsqlParserRULE_update_table                        = 182
	HplsqlParserRULE_update_upsert                       = 183
	HplsqlParserRULE_merge_stmt                          = 184
	HplsqlParserRULE_merge_table                         = 185
	HplsqlParserRULE_merge_condition                     = 186
	HplsqlParserRULE_merge_action                        = 187
	HplsqlParserRULE_delete_stmt                         = 188
	HplsqlParserRULE_delete_alias                        = 189
	HplsqlParserRULE_describe_stmt                       = 190
	HplsqlParserRULE_bool_expr                           = 191
	HplsqlParserRULE_bool_expr_atom                      = 192
	HplsqlParserRULE_bool_expr_unary                     = 193
	HplsqlParserRULE_bool_expr_single_in                 = 194
	HplsqlParserRULE_bool_expr_multi_in                  = 195
	HplsqlParserRULE_bool_expr_binary                    = 196
	HplsqlParserRULE_bool_expr_logical_operator          = 197
	HplsqlParserRULE_bool_expr_binary_operator           = 198
	HplsqlParserRULE_expr                                = 199
	HplsqlParserRULE_expr_atom                           = 200
	HplsqlParserRULE_expr_interval                       = 201
	HplsqlParserRULE_interval_item                       = 202
	HplsqlParserRULE_expr_concat                         = 203
	HplsqlParserRULE_expr_concat_item                    = 204
	HplsqlParserRULE_expr_case                           = 205
	HplsqlParserRULE_expr_case_simple                    = 206
	HplsqlParserRULE_expr_case_searched                  = 207
	HplsqlParserRULE_expr_cursor_attribute               = 208
	HplsqlParserRULE_expr_agg_window_func                = 209
	HplsqlParserRULE_expr_func_all_distinct              = 210
	HplsqlParserRULE_expr_func_over_clause               = 211
	HplsqlParserRULE_expr_func_partition_by_clause       = 212
	HplsqlParserRULE_expr_spec_func                      = 213
	HplsqlParserRULE_expr_func                           = 214
	HplsqlParserRULE_expr_dot                            = 215
	HplsqlParserRULE_expr_dot_method_call                = 216
	HplsqlParserRULE_expr_dot_property_access            = 217
	HplsqlParserRULE_expr_func_params                    = 218
	HplsqlParserRULE_func_param                          = 219
	HplsqlParserRULE_expr_select                         = 220
	HplsqlParserRULE_expr_file                           = 221
	HplsqlParserRULE_hive                                = 222
	HplsqlParserRULE_hive_item                           = 223
	HplsqlParserRULE_host                                = 224
	HplsqlParserRULE_host_cmd                            = 225
	HplsqlParserRULE_host_stmt                           = 226
	HplsqlParserRULE_file_name                           = 227
	HplsqlParserRULE_date_literal                        = 228
	HplsqlParserRULE_timestamp_literal                   = 229
	HplsqlParserRULE_ident                               = 230
	HplsqlParserRULE_qident                              = 231
	HplsqlParserRULE_string                              = 232
	HplsqlParserRULE_int_number                          = 233
	HplsqlParserRULE_dec_number                          = 234
	HplsqlParserRULE_bool_literal                        = 235
	HplsqlParserRULE_null_const                          = 236
	HplsqlParserRULE_non_reserved_words                  = 237
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	EOF() antlr.TerminalNode

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserEOF, 0)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *HplsqlParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, HplsqlParserRULE_program)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Block()
	}
	{
		p.SetState(477)
		p.Match(HplsqlParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBegin_end_block() []IBegin_end_blockContext
	Begin_end_block(i int) IBegin_end_blockContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllT_GO() []antlr.TerminalNode
	T_GO(i int) antlr.TerminalNode

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllBegin_end_block() []IBegin_end_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			len++
		}
	}

	tst := make([]IBegin_end_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBegin_end_blockContext); ok {
			tst[i] = t.(IBegin_end_blockContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Begin_end_block(i int) IBegin_end_blockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_end_blockContext)
}

func (s *BlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *BlockContext) AllT_GO() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_GO)
}

func (s *BlockContext) T_GO(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *HplsqlParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, HplsqlParserRULE_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(481)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(479)
					p.Begin_end_block()
				}

			case 2:
				{
					p.SetState(480)
					p.Stmt()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			p.SetState(484)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(483)
					p.Match(HplsqlParserT_GO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBegin_end_blockContext is an interface to support dynamic dispatch.
type IBegin_end_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	Block() IBlockContext
	Block_end() IBlock_endContext
	Declare_block() IDeclare_blockContext
	Exception_block() IException_blockContext

	// IsBegin_end_blockContext differentiates from other interfaces.
	IsBegin_end_blockContext()
}

type Begin_end_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBegin_end_blockContext() *Begin_end_blockContext {
	var p = new(Begin_end_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_end_block
	return p
}

func InitEmptyBegin_end_blockContext(p *Begin_end_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_end_block
}

func (*Begin_end_blockContext) IsBegin_end_blockContext() {}

func NewBegin_end_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Begin_end_blockContext {
	var p = new(Begin_end_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_begin_end_block

	return p
}

func (s *Begin_end_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Begin_end_blockContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Begin_end_blockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Begin_end_blockContext) Block_end() IBlock_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlock_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlock_endContext)
}

func (s *Begin_end_blockContext) Declare_block() IDeclare_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_blockContext)
}

func (s *Begin_end_blockContext) Exception_block() IException_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_blockContext)
}

func (s *Begin_end_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Begin_end_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Begin_end_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBegin_end_block(s)
	}
}

func (s *Begin_end_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBegin_end_block(s)
	}
}

func (p *HplsqlParser) Begin_end_block() (localctx IBegin_end_blockContext) {
	localctx = NewBegin_end_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, HplsqlParserRULE_begin_end_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_DECLARE {
		{
			p.SetState(490)
			p.Declare_block()
		}

	}
	{
		p.SetState(493)
		p.Match(HplsqlParserT_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(494)
		p.Block()
	}
	p.SetState(496)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(495)
			p.Exception_block()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(498)
		p.Block_end()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingle_block_stmtContext is an interface to support dynamic dispatch.
type ISingle_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	Block() IBlockContext
	Block_end() IBlock_endContext
	Exception_block() IException_blockContext
	Stmt() IStmtContext
	T_SEMICOLON() antlr.TerminalNode

	// IsSingle_block_stmtContext differentiates from other interfaces.
	IsSingle_block_stmtContext()
}

type Single_block_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_block_stmtContext() *Single_block_stmtContext {
	var p = new(Single_block_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_single_block_stmt
	return p
}

func InitEmptySingle_block_stmtContext(p *Single_block_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_single_block_stmt
}

func (*Single_block_stmtContext) IsSingle_block_stmtContext() {}

func NewSingle_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_block_stmtContext {
	var p = new(Single_block_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_single_block_stmt

	return p
}

func (s *Single_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_block_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Single_block_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Single_block_stmtContext) Block_end() IBlock_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlock_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlock_endContext)
}

func (s *Single_block_stmtContext) Exception_block() IException_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_blockContext)
}

func (s *Single_block_stmtContext) Stmt() IStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Single_block_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Single_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSingle_block_stmt(s)
	}
}

func (s *Single_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSingle_block_stmt(s)
	}
}

func (p *HplsqlParser) Single_block_stmt() (localctx ISingle_block_stmtContext) {
	localctx = NewSingle_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, HplsqlParserRULE_single_block_stmt)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(500)
			p.Match(HplsqlParserT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Block()
		}
		p.SetState(503)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(502)
				p.Exception_block()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(505)
			p.Block_end()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(507)
			p.Stmt()
		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(508)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlock_endContext is an interface to support dynamic dispatch.
type IBlock_endContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_END() antlr.TerminalNode

	// IsBlock_endContext differentiates from other interfaces.
	IsBlock_endContext()
}

type Block_endContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_endContext() *Block_endContext {
	var p = new(Block_endContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block_end
	return p
}

func InitEmptyBlock_endContext(p *Block_endContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block_end
}

func (*Block_endContext) IsBlock_endContext() {}

func NewBlock_endContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_endContext {
	var p = new(Block_endContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_block_end

	return p
}

func (s *Block_endContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_endContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Block_endContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_endContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_endContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBlock_end(s)
	}
}

func (s *Block_endContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBlock_end(s)
	}
}

func (p *HplsqlParser) Block_end() (localctx IBlock_endContext) {
	localctx = NewBlock_endContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, HplsqlParserRULE_block_end)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(513)

	if !(!strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "TRANSACTION")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(2).GetText(), \"TRANSACTION\")", ""))
		goto errorExit
	}
	{
		p.SetState(514)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProc_blockContext is an interface to support dynamic dispatch.
type IProc_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Begin_end_block() IBegin_end_blockContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	T_GO() antlr.TerminalNode

	// IsProc_blockContext differentiates from other interfaces.
	IsProc_blockContext()
}

type Proc_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProc_blockContext() *Proc_blockContext {
	var p = new(Proc_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_proc_block
	return p
}

func InitEmptyProc_blockContext(p *Proc_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_proc_block
}

func (*Proc_blockContext) IsProc_blockContext() {}

func NewProc_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Proc_blockContext {
	var p = new(Proc_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_proc_block

	return p
}

func (s *Proc_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Proc_blockContext) Begin_end_block() IBegin_end_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_end_blockContext)
}

func (s *Proc_blockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *Proc_blockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Proc_blockContext) T_GO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, 0)
}

func (s *Proc_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Proc_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Proc_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterProc_block(s)
	}
}

func (s *Proc_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitProc_block(s)
	}
}

func (p *HplsqlParser) Proc_block() (localctx IProc_blockContext) {
	localctx = NewProc_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, HplsqlParserRULE_proc_block)
	var _alt int

	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(516)
			p.Begin_end_block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(517)
					p.Stmt()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(520)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(522)
				p.Match(HplsqlParserT_GO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment_stmt() IAssignment_stmtContext
	Allocate_cursor_stmt() IAllocate_cursor_stmtContext
	Alter_table_stmt() IAlter_table_stmtContext
	Associate_locator_stmt() IAssociate_locator_stmtContext
	Begin_transaction_stmt() IBegin_transaction_stmtContext
	Break_stmt() IBreak_stmtContext
	Call_stmt() ICall_stmtContext
	Collect_stats_stmt() ICollect_stats_stmtContext
	Close_stmt() IClose_stmtContext
	Cmp_stmt() ICmp_stmtContext
	Copy_from_local_stmt() ICopy_from_local_stmtContext
	Copy_stmt() ICopy_stmtContext
	Commit_stmt() ICommit_stmtContext
	Create_database_stmt() ICreate_database_stmtContext
	Create_function_stmt() ICreate_function_stmtContext
	Create_index_stmt() ICreate_index_stmtContext
	Create_local_temp_table_stmt() ICreate_local_temp_table_stmtContext
	Create_package_stmt() ICreate_package_stmtContext
	Create_package_body_stmt() ICreate_package_body_stmtContext
	Create_procedure_stmt() ICreate_procedure_stmtContext
	Create_table_stmt() ICreate_table_stmtContext
	Create_table_type_stmt() ICreate_table_type_stmtContext
	Declare_stmt() IDeclare_stmtContext
	Delete_stmt() IDelete_stmtContext
	Describe_stmt() IDescribe_stmtContext
	Drop_stmt() IDrop_stmtContext
	End_transaction_stmt() IEnd_transaction_stmtContext
	Exec_stmt() IExec_stmtContext
	Exit_stmt() IExit_stmtContext
	Fetch_stmt() IFetch_stmtContext
	For_cursor_stmt() IFor_cursor_stmtContext
	For_range_stmt() IFor_range_stmtContext
	If_stmt() IIf_stmtContext
	Include_stmt() IInclude_stmtContext
	Insert_stmt() IInsert_stmtContext
	Insert_directory_stmt() IInsert_directory_stmtContext
	Get_diag_stmt() IGet_diag_stmtContext
	Grant_stmt() IGrant_stmtContext
	Leave_stmt() ILeave_stmtContext
	Map_object_stmt() IMap_object_stmtContext
	Merge_stmt() IMerge_stmtContext
	Open_stmt() IOpen_stmtContext
	Print_stmt() IPrint_stmtContext
	Quit_stmt() IQuit_stmtContext
	Raise_stmt() IRaise_stmtContext
	Resignal_stmt() IResignal_stmtContext
	Return_stmt() IReturn_stmtContext
	Rollback_stmt() IRollback_stmtContext
	Select_stmt() ISelect_stmtContext
	Signal_stmt() ISignal_stmtContext
	Summary_stmt() ISummary_stmtContext
	Update_stmt() IUpdate_stmtContext
	Use_stmt() IUse_stmtContext
	Truncate_stmt() ITruncate_stmtContext
	Values_into_stmt() IValues_into_stmtContext
	While_stmt() IWhile_stmtContext
	Unconditional_loop_stmt() IUnconditional_loop_stmtContext
	Label() ILabelContext
	Hive() IHiveContext
	Host() IHostContext
	Null_stmt() INull_stmtContext
	Expr_stmt() IExpr_stmtContext
	Semicolon_stmt() ISemicolon_stmtContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Assignment_stmt() IAssignment_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmtContext)
}

func (s *StmtContext) Allocate_cursor_stmt() IAllocate_cursor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllocate_cursor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllocate_cursor_stmtContext)
}

func (s *StmtContext) Alter_table_stmt() IAlter_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_stmtContext)
}

func (s *StmtContext) Associate_locator_stmt() IAssociate_locator_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssociate_locator_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssociate_locator_stmtContext)
}

func (s *StmtContext) Begin_transaction_stmt() IBegin_transaction_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_transaction_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_transaction_stmtContext)
}

func (s *StmtContext) Break_stmt() IBreak_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreak_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *StmtContext) Call_stmt() ICall_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICall_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StmtContext) Collect_stats_stmt() ICollect_stats_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollect_stats_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollect_stats_stmtContext)
}

func (s *StmtContext) Close_stmt() IClose_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClose_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClose_stmtContext)
}

func (s *StmtContext) Cmp_stmt() ICmp_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmp_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmp_stmtContext)
}

func (s *StmtContext) Copy_from_local_stmt() ICopy_from_local_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_from_local_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_from_local_stmtContext)
}

func (s *StmtContext) Copy_stmt() ICopy_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_stmtContext)
}

func (s *StmtContext) Commit_stmt() ICommit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommit_stmtContext)
}

func (s *StmtContext) Create_database_stmt() ICreate_database_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_database_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_database_stmtContext)
}

func (s *StmtContext) Create_function_stmt() ICreate_function_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_stmtContext)
}

func (s *StmtContext) Create_index_stmt() ICreate_index_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_stmtContext)
}

func (s *StmtContext) Create_local_temp_table_stmt() ICreate_local_temp_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_local_temp_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_local_temp_table_stmtContext)
}

func (s *StmtContext) Create_package_stmt() ICreate_package_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_package_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_package_stmtContext)
}

func (s *StmtContext) Create_package_body_stmt() ICreate_package_body_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_package_body_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_package_body_stmtContext)
}

func (s *StmtContext) Create_procedure_stmt() ICreate_procedure_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_procedure_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_procedure_stmtContext)
}

func (s *StmtContext) Create_table_stmt() ICreate_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_stmtContext)
}

func (s *StmtContext) Create_table_type_stmt() ICreate_table_type_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_type_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_type_stmtContext)
}

func (s *StmtContext) Declare_stmt() IDeclare_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmtContext)
}

func (s *StmtContext) Delete_stmt() IDelete_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_stmtContext)
}

func (s *StmtContext) Describe_stmt() IDescribe_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribe_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribe_stmtContext)
}

func (s *StmtContext) Drop_stmt() IDrop_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_stmtContext)
}

func (s *StmtContext) End_transaction_stmt() IEnd_transaction_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnd_transaction_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnd_transaction_stmtContext)
}

func (s *StmtContext) Exec_stmt() IExec_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExec_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExec_stmtContext)
}

func (s *StmtContext) Exit_stmt() IExit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExit_stmtContext)
}

func (s *StmtContext) Fetch_stmt() IFetch_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFetch_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFetch_stmtContext)
}

func (s *StmtContext) For_cursor_stmt() IFor_cursor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_cursor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_cursor_stmtContext)
}

func (s *StmtContext) For_range_stmt() IFor_range_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_range_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_range_stmtContext)
}

func (s *StmtContext) If_stmt() IIf_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *StmtContext) Include_stmt() IInclude_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInclude_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInclude_stmtContext)
}

func (s *StmtContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *StmtContext) Insert_directory_stmt() IInsert_directory_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_directory_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_directory_stmtContext)
}

func (s *StmtContext) Get_diag_stmt() IGet_diag_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmtContext)
}

func (s *StmtContext) Grant_stmt() IGrant_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_stmtContext)
}

func (s *StmtContext) Leave_stmt() ILeave_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeave_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeave_stmtContext)
}

func (s *StmtContext) Map_object_stmt() IMap_object_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMap_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMap_object_stmtContext)
}

func (s *StmtContext) Merge_stmt() IMerge_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_stmtContext)
}

func (s *StmtContext) Open_stmt() IOpen_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpen_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpen_stmtContext)
}

func (s *StmtContext) Print_stmt() IPrint_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrint_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrint_stmtContext)
}

func (s *StmtContext) Quit_stmt() IQuit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuit_stmtContext)
}

func (s *StmtContext) Raise_stmt() IRaise_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaise_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *StmtContext) Resignal_stmt() IResignal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignal_stmtContext)
}

func (s *StmtContext) Return_stmt() IReturn_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturn_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *StmtContext) Rollback_stmt() IRollback_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollback_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollback_stmtContext)
}

func (s *StmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *StmtContext) Signal_stmt() ISignal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignal_stmtContext)
}

func (s *StmtContext) Summary_stmt() ISummary_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISummary_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISummary_stmtContext)
}

func (s *StmtContext) Update_stmt() IUpdate_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_stmtContext)
}

func (s *StmtContext) Use_stmt() IUse_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_stmtContext)
}

func (s *StmtContext) Truncate_stmt() ITruncate_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncate_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncate_stmtContext)
}

func (s *StmtContext) Values_into_stmt() IValues_into_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_into_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_into_stmtContext)
}

func (s *StmtContext) While_stmt() IWhile_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *StmtContext) Unconditional_loop_stmt() IUnconditional_loop_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnconditional_loop_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnconditional_loop_stmtContext)
}

func (s *StmtContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StmtContext) Hive() IHiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHiveContext)
}

func (s *StmtContext) Host() IHostContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostContext)
}

func (s *StmtContext) Null_stmt() INull_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_stmtContext)
}

func (s *StmtContext) Expr_stmt() IExpr_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *StmtContext) Semicolon_stmt() ISemicolon_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemicolon_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemicolon_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (p *HplsqlParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, HplsqlParserRULE_stmt)
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(527)
			p.Assignment_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(528)
			p.Allocate_cursor_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(529)
			p.Alter_table_stmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(530)
			p.Associate_locator_stmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(531)
			p.Begin_transaction_stmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(532)
			p.Break_stmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(533)
			p.Call_stmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(534)
			p.Collect_stats_stmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(535)
			p.Close_stmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(536)
			p.Cmp_stmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(537)
			p.Copy_from_local_stmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(538)
			p.Copy_stmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(539)
			p.Commit_stmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(540)
			p.Create_database_stmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(541)
			p.Create_function_stmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(542)
			p.Create_index_stmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(543)
			p.Create_local_temp_table_stmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(544)
			p.Create_package_stmt()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(545)
			p.Create_package_body_stmt()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(546)
			p.Create_procedure_stmt()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(547)
			p.Create_table_stmt()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(548)
			p.Create_table_type_stmt()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(549)
			p.Declare_stmt()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(550)
			p.Delete_stmt()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(551)
			p.Describe_stmt()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(552)
			p.Drop_stmt()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(553)
			p.End_transaction_stmt()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(554)
			p.Exec_stmt()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(555)
			p.Exit_stmt()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(556)
			p.Fetch_stmt()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(557)
			p.For_cursor_stmt()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(558)
			p.For_range_stmt()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(559)
			p.If_stmt()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(560)
			p.Include_stmt()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(561)
			p.Insert_stmt()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(562)
			p.Insert_directory_stmt()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(563)
			p.Get_diag_stmt()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(564)
			p.Grant_stmt()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(565)
			p.Leave_stmt()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(566)
			p.Map_object_stmt()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(567)
			p.Merge_stmt()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(568)
			p.Open_stmt()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(569)
			p.Print_stmt()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(570)
			p.Quit_stmt()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(571)
			p.Raise_stmt()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(572)
			p.Resignal_stmt()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(573)
			p.Return_stmt()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(574)
			p.Rollback_stmt()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(575)
			p.Select_stmt()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(576)
			p.Signal_stmt()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(577)
			p.Summary_stmt()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(578)
			p.Update_stmt()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(579)
			p.Use_stmt()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(580)
			p.Truncate_stmt()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(581)
			p.Values_into_stmt()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(582)
			p.While_stmt()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(583)
			p.Unconditional_loop_stmt()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(584)
			p.Label()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(585)
			p.Hive()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(586)
			p.Host()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(587)
			p.Null_stmt()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(588)
			p.Expr_stmt()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(589)
			p.Semicolon_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISemicolon_stmtContext is an interface to support dynamic dispatch.
type ISemicolon_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SEMICOLON() antlr.TerminalNode
	T_DIV() antlr.TerminalNode

	// IsSemicolon_stmtContext differentiates from other interfaces.
	IsSemicolon_stmtContext()
}

type Semicolon_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemicolon_stmtContext() *Semicolon_stmtContext {
	var p = new(Semicolon_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt
	return p
}

func InitEmptySemicolon_stmtContext(p *Semicolon_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt
}

func (*Semicolon_stmtContext) IsSemicolon_stmtContext() {}

func NewSemicolon_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Semicolon_stmtContext {
	var p = new(Semicolon_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt

	return p
}

func (s *Semicolon_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Semicolon_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Semicolon_stmtContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, 0)
}

func (s *Semicolon_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Semicolon_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Semicolon_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSemicolon_stmt(s)
	}
}

func (s *Semicolon_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSemicolon_stmt(s)
	}
}

func (p *HplsqlParser) Semicolon_stmt() (localctx ISemicolon_stmtContext) {
	localctx = NewSemicolon_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, HplsqlParserRULE_semicolon_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT__0 || _la == HplsqlParserT__1 || _la == HplsqlParserT_DIV || _la == HplsqlParserT_SEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IException_blockContext is an interface to support dynamic dispatch.
type IException_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXCEPTION() antlr.TerminalNode
	AllException_block_item() []IException_block_itemContext
	Exception_block_item(i int) IException_block_itemContext

	// IsException_blockContext differentiates from other interfaces.
	IsException_blockContext()
}

type Exception_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_blockContext() *Exception_blockContext {
	var p = new(Exception_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block
	return p
}

func InitEmptyException_blockContext(p *Exception_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block
}

func (*Exception_blockContext) IsException_blockContext() {}

func NewException_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_blockContext {
	var p = new(Exception_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exception_block

	return p
}

func (s *Exception_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_blockContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Exception_blockContext) AllException_block_item() []IException_block_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IException_block_itemContext); ok {
			len++
		}
	}

	tst := make([]IException_block_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IException_block_itemContext); ok {
			tst[i] = t.(IException_block_itemContext)
			i++
		}
	}

	return tst
}

func (s *Exception_blockContext) Exception_block_item(i int) IException_block_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_block_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_block_itemContext)
}

func (s *Exception_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterException_block(s)
	}
}

func (s *Exception_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitException_block(s)
	}
}

func (p *HplsqlParser) Exception_block() (localctx IException_blockContext) {
	localctx = NewException_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, HplsqlParserRULE_exception_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.Match(HplsqlParserT_EXCEPTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(595)
				p.Exception_block_item()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IException_block_itemContext is an interface to support dynamic dispatch.
type IException_block_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode

	// IsException_block_itemContext differentiates from other interfaces.
	IsException_block_itemContext()
}

type Exception_block_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_block_itemContext() *Exception_block_itemContext {
	var p = new(Exception_block_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block_item
	return p
}

func InitEmptyException_block_itemContext(p *Exception_block_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block_item
}

func (*Exception_block_itemContext) IsException_block_itemContext() {}

func NewException_block_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_block_itemContext {
	var p = new(Exception_block_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exception_block_item

	return p
}

func (s *Exception_block_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_block_itemContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Exception_block_itemContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Exception_block_itemContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Exception_block_itemContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Exception_block_itemContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Exception_block_itemContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Exception_block_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_block_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_block_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterException_block_item(s)
	}
}

func (s *Exception_block_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitException_block_item(s)
	}
}

func (p *HplsqlParser) Exception_block_item() (localctx IException_block_itemContext) {
	localctx = NewException_block_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, HplsqlParserRULE_exception_block_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.Match(HplsqlParserT_WHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(601)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(602)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(603)
		p.Block()
	}
	{
		p.SetState(604)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == HplsqlParserT_END || _la == HplsqlParserT_WHEN {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INull_stmtContext is an interface to support dynamic dispatch.
type INull_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode

	// IsNull_stmtContext differentiates from other interfaces.
	IsNull_stmtContext()
}

type Null_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_stmtContext() *Null_stmtContext {
	var p = new(Null_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_stmt
	return p
}

func InitEmptyNull_stmtContext(p *Null_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_stmt
}

func (*Null_stmtContext) IsNull_stmtContext() {}

func NewNull_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_stmtContext {
	var p = new(Null_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_null_stmt

	return p
}

func (s *Null_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_stmtContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Null_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNull_stmt(s)
	}
}

func (s *Null_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNull_stmt(s)
	}
}

func (p *HplsqlParser) Null_stmt() (localctx INull_stmtContext) {
	localctx = NewNull_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, HplsqlParserRULE_null_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(HplsqlParserT_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_stmt
	return p
}

func InitEmptyExpr_stmtContext(p *Expr_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_stmt
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *HplsqlParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, HplsqlParserRULE_expr_stmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(608)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GO")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"GO\")", ""))
		goto errorExit
	}
	{
		p.SetState(609)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmtContext is an interface to support dynamic dispatch.
type IAssignment_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SET() antlr.TerminalNode
	Set_session_option() ISet_session_optionContext
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssignment_stmtContext differentiates from other interfaces.
	IsAssignment_stmtContext()
}

type Assignment_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmtContext() *Assignment_stmtContext {
	var p = new(Assignment_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt
	return p
}

func InitEmptyAssignment_stmtContext(p *Assignment_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt
}

func (*Assignment_stmtContext) IsAssignment_stmtContext() {}

func NewAssignment_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmtContext {
	var p = new(Assignment_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt

	return p
}

func (s *Assignment_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Assignment_stmtContext) Set_session_option() ISet_session_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_session_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_session_optionContext)
}

func (s *Assignment_stmtContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmtContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Assignment_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt(s)
	}
}

func (s *Assignment_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt(s)
	}
}

func (p *HplsqlParser) Assignment_stmt() (localctx IAssignment_stmtContext) {
	localctx = NewAssignment_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, HplsqlParserRULE_assignment_stmt)
	var _alt int

	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(611)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Set_session_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(614)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(613)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(616)
			p.Assignment_stmt_item()
		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(617)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(618)
					p.Assignment_stmt_item()
				}

			}
			p.SetState(623)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment_stmt_single_item() IAssignment_stmt_single_itemContext
	Assignment_stmt_multiple_item() IAssignment_stmt_multiple_itemContext
	Assignment_stmt_select_item() IAssignment_stmt_select_itemContext
	Assignment_stmt_collection_item() IAssignment_stmt_collection_itemContext

	// IsAssignment_stmt_itemContext differentiates from other interfaces.
	IsAssignment_stmt_itemContext()
}

type Assignment_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_itemContext() *Assignment_stmt_itemContext {
	var p = new(Assignment_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item
	return p
}

func InitEmptyAssignment_stmt_itemContext(p *Assignment_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item
}

func (*Assignment_stmt_itemContext) IsAssignment_stmt_itemContext() {}

func NewAssignment_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_itemContext {
	var p = new(Assignment_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item

	return p
}

func (s *Assignment_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_itemContext) Assignment_stmt_single_item() IAssignment_stmt_single_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_single_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_single_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_multiple_item() IAssignment_stmt_multiple_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_multiple_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_multiple_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_select_item() IAssignment_stmt_select_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_select_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_select_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_collection_item() IAssignment_stmt_collection_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_collection_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_collection_itemContext)
}

func (s *Assignment_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_item(s)
	}
}

func (s *Assignment_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_item() (localctx IAssignment_stmt_itemContext) {
	localctx = NewAssignment_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, HplsqlParserRULE_assignment_stmt_item)
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(626)
			p.Assignment_stmt_single_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(627)
			p.Assignment_stmt_multiple_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(628)
			p.Assignment_stmt_select_item()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(629)
			p.Assignment_stmt_collection_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_single_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_single_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext
	T_COLON() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsAssignment_stmt_single_itemContext differentiates from other interfaces.
	IsAssignment_stmt_single_itemContext()
}

type Assignment_stmt_single_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_single_itemContext() *Assignment_stmt_single_itemContext {
	var p = new(Assignment_stmt_single_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item
	return p
}

func InitEmptyAssignment_stmt_single_itemContext(p *Assignment_stmt_single_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item
}

func (*Assignment_stmt_single_itemContext) IsAssignment_stmt_single_itemContext() {}

func NewAssignment_stmt_single_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_single_itemContext {
	var p = new(Assignment_stmt_single_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item

	return p
}

func (s *Assignment_stmt_single_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_single_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Assignment_stmt_single_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_single_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_single_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_single_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Assignment_stmt_single_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Assignment_stmt_single_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_single_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_single_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_single_item(s)
	}
}

func (s *Assignment_stmt_single_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_single_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_single_item() (localctx IAssignment_stmt_single_itemContext) {
	localctx = NewAssignment_stmt_single_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, HplsqlParserRULE_assignment_stmt_single_item)
	var _la int

	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(632)
			p.Qident()
		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COLON {
			{
				p.SetState(633)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(636)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(637)
			p.expr(0)
		}

	case HplsqlParserT_OPEN_P:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(639)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)
			p.Qident()
		}
		{
			p.SetState(641)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COLON {
			{
				p.SetState(642)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(645)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(646)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_collection_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_collection_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_func() IExpr_funcContext
	T_COLON() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext

	// IsAssignment_stmt_collection_itemContext differentiates from other interfaces.
	IsAssignment_stmt_collection_itemContext()
}

type Assignment_stmt_collection_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_collection_itemContext() *Assignment_stmt_collection_itemContext {
	var p = new(Assignment_stmt_collection_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item
	return p
}

func InitEmptyAssignment_stmt_collection_itemContext(p *Assignment_stmt_collection_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item
}

func (*Assignment_stmt_collection_itemContext) IsAssignment_stmt_collection_itemContext() {}

func NewAssignment_stmt_collection_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_collection_itemContext {
	var p = new(Assignment_stmt_collection_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item

	return p
}

func (s *Assignment_stmt_collection_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_collection_itemContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Assignment_stmt_collection_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_collection_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_collection_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_collection_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_collection_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_collection_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_collection_item(s)
	}
}

func (s *Assignment_stmt_collection_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_collection_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_collection_item() (localctx IAssignment_stmt_collection_itemContext) {
	localctx = NewAssignment_stmt_collection_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, HplsqlParserRULE_assignment_stmt_collection_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Expr_func()
	}
	{
		p.SetState(651)
		p.Match(HplsqlParserT_COLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_multiple_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_multiple_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_COLON() antlr.TerminalNode

	// IsAssignment_stmt_multiple_itemContext differentiates from other interfaces.
	IsAssignment_stmt_multiple_itemContext()
}

type Assignment_stmt_multiple_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_multiple_itemContext() *Assignment_stmt_multiple_itemContext {
	var p = new(Assignment_stmt_multiple_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item
	return p
}

func InitEmptyAssignment_stmt_multiple_itemContext(p *Assignment_stmt_multiple_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item
}

func (*Assignment_stmt_multiple_itemContext) IsAssignment_stmt_multiple_itemContext() {}

func NewAssignment_stmt_multiple_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_multiple_itemContext {
	var p = new(Assignment_stmt_multiple_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item

	return p
}

func (s *Assignment_stmt_multiple_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_multiple_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Assignment_stmt_multiple_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Assignment_stmt_multiple_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_multiple_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Assignment_stmt_multiple_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Assignment_stmt_multiple_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Assignment_stmt_multiple_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_multiple_itemContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_multiple_itemContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_multiple_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmt_multiple_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmt_multiple_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_multiple_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_multiple_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_multiple_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_multiple_item(s)
	}
}

func (s *Assignment_stmt_multiple_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_multiple_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_multiple_item() (localctx IAssignment_stmt_multiple_itemContext) {
	localctx = NewAssignment_stmt_multiple_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, HplsqlParserRULE_assignment_stmt_multiple_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(656)
		p.Ident()
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(657)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(658)
			p.Ident()
		}

		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(664)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COLON {
		{
			p.SetState(665)
			p.Match(HplsqlParserT_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(668)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(669)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(670)
		p.expr(0)
	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(671)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(672)
			p.expr(0)
		}

		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(678)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_select_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_select_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_COLON() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssignment_stmt_select_itemContext differentiates from other interfaces.
	IsAssignment_stmt_select_itemContext()
}

type Assignment_stmt_select_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_select_itemContext() *Assignment_stmt_select_itemContext {
	var p = new(Assignment_stmt_select_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item
	return p
}

func InitEmptyAssignment_stmt_select_itemContext(p *Assignment_stmt_select_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item
}

func (*Assignment_stmt_select_itemContext) IsAssignment_stmt_select_itemContext() {}

func NewAssignment_stmt_select_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_select_itemContext {
	var p = new(Assignment_stmt_select_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item

	return p
}

func (s *Assignment_stmt_select_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_select_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_select_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Assignment_stmt_select_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Assignment_stmt_select_itemContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Assignment_stmt_select_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Assignment_stmt_select_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Assignment_stmt_select_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_select_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Assignment_stmt_select_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_select_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmt_select_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmt_select_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_select_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_select_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_select_item(s)
	}
}

func (s *Assignment_stmt_select_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_select_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_select_item() (localctx IAssignment_stmt_select_itemContext) {
	localctx = NewAssignment_stmt_select_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, HplsqlParserRULE_assignment_stmt_select_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(680)
			p.Ident()
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(681)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Ident()
		}
		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(683)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(684)
				p.Ident()
			}

			p.SetState(689)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(690)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COLON {
		{
			p.SetState(694)
			p.Match(HplsqlParserT_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(697)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(698)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(699)
		p.Select_stmt()
	}
	{
		p.SetState(700)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllocate_cursor_stmtContext is an interface to support dynamic dispatch.
type IAllocate_cursor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALLOCATE() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_CURSOR() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SET() antlr.TerminalNode

	// IsAllocate_cursor_stmtContext differentiates from other interfaces.
	IsAllocate_cursor_stmtContext()
}

type Allocate_cursor_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllocate_cursor_stmtContext() *Allocate_cursor_stmtContext {
	var p = new(Allocate_cursor_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt
	return p
}

func InitEmptyAllocate_cursor_stmtContext(p *Allocate_cursor_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt
}

func (*Allocate_cursor_stmtContext) IsAllocate_cursor_stmtContext() {}

func NewAllocate_cursor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Allocate_cursor_stmtContext {
	var p = new(Allocate_cursor_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt

	return p
}

func (s *Allocate_cursor_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Allocate_cursor_stmtContext) T_ALLOCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALLOCATE, 0)
}

func (s *Allocate_cursor_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Allocate_cursor_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Allocate_cursor_stmtContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Allocate_cursor_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Allocate_cursor_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Allocate_cursor_stmtContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Allocate_cursor_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Allocate_cursor_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Allocate_cursor_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Allocate_cursor_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAllocate_cursor_stmt(s)
	}
}

func (s *Allocate_cursor_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAllocate_cursor_stmt(s)
	}
}

func (p *HplsqlParser) Allocate_cursor_stmt() (localctx IAllocate_cursor_stmtContext) {
	localctx = NewAllocate_cursor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, HplsqlParserRULE_allocate_cursor_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(HplsqlParserT_ALLOCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(703)
		p.Ident()
	}
	{
		p.SetState(704)
		p.Match(HplsqlParserT_CURSOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(705)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_RESULT:
		{
			p.SetState(706)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(707)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PROCEDURE:
		{
			p.SetState(708)
			p.Match(HplsqlParserT_PROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(711)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssociate_locator_stmtContext is an interface to support dynamic dispatch.
type IAssociate_locator_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ASSOCIATE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_CLOSE_P() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_LOCATOR() antlr.TerminalNode
	T_LOCATORS() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssociate_locator_stmtContext differentiates from other interfaces.
	IsAssociate_locator_stmtContext()
}

type Associate_locator_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociate_locator_stmtContext() *Associate_locator_stmtContext {
	var p = new(Associate_locator_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt
	return p
}

func InitEmptyAssociate_locator_stmtContext(p *Associate_locator_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt
}

func (*Associate_locator_stmtContext) IsAssociate_locator_stmtContext() {}

func NewAssociate_locator_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Associate_locator_stmtContext {
	var p = new(Associate_locator_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt

	return p
}

func (s *Associate_locator_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Associate_locator_stmtContext) T_ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASSOCIATE, 0)
}

func (s *Associate_locator_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Associate_locator_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Associate_locator_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Associate_locator_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Associate_locator_stmtContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Associate_locator_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Associate_locator_stmtContext) T_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATOR, 0)
}

func (s *Associate_locator_stmtContext) T_LOCATORS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATORS, 0)
}

func (s *Associate_locator_stmtContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Associate_locator_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Associate_locator_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Associate_locator_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Associate_locator_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Associate_locator_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Associate_locator_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssociate_locator_stmt(s)
	}
}

func (s *Associate_locator_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssociate_locator_stmt(s)
	}
}

func (p *HplsqlParser) Associate_locator_stmt() (localctx IAssociate_locator_stmtContext) {
	localctx = NewAssociate_locator_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, HplsqlParserRULE_associate_locator_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.Match(HplsqlParserT_ASSOCIATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_RESULT {
		{
			p.SetState(714)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(715)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(718)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_LOCATOR || _la == HplsqlParserT_LOCATORS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(719)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(720)
		p.Ident()
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(721)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(722)
			p.Ident()
		}

		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(728)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(729)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(730)
		p.Match(HplsqlParserT_PROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(731)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBegin_transaction_stmtContext is an interface to support dynamic dispatch.
type IBegin_transaction_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode

	// IsBegin_transaction_stmtContext differentiates from other interfaces.
	IsBegin_transaction_stmtContext()
}

type Begin_transaction_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBegin_transaction_stmtContext() *Begin_transaction_stmtContext {
	var p = new(Begin_transaction_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt
	return p
}

func InitEmptyBegin_transaction_stmtContext(p *Begin_transaction_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt
}

func (*Begin_transaction_stmtContext) IsBegin_transaction_stmtContext() {}

func NewBegin_transaction_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Begin_transaction_stmtContext {
	var p = new(Begin_transaction_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt

	return p
}

func (s *Begin_transaction_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Begin_transaction_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Begin_transaction_stmtContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Begin_transaction_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Begin_transaction_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Begin_transaction_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBegin_transaction_stmt(s)
	}
}

func (s *Begin_transaction_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBegin_transaction_stmt(s)
	}
}

func (p *HplsqlParser) Begin_transaction_stmt() (localctx IBegin_transaction_stmtContext) {
	localctx = NewBegin_transaction_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, HplsqlParserRULE_begin_transaction_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(733)
		p.Match(HplsqlParserT_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(734)
		p.Match(HplsqlParserT_TRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BREAK() antlr.TerminalNode

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_break_stmt
	return p
}

func InitEmptyBreak_stmtContext(p *Break_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_break_stmt
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) T_BREAK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (p *HplsqlParser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, HplsqlParserRULE_break_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.Match(HplsqlParserT_BREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CALL() antlr.TerminalNode
	Expr_dot() IExpr_dotContext
	Expr_func() IExpr_funcContext
	Ident() IIdentContext

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_call_stmt
	return p
}

func InitEmptyCall_stmtContext(p *Call_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_call_stmt
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) T_CALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALL, 0)
}

func (s *Call_stmtContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *Call_stmtContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Call_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}

func (p *HplsqlParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, HplsqlParserRULE_call_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(HplsqlParserT_CALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(739)
			p.Expr_dot()
		}

	case 2:
		{
			p.SetState(740)
			p.Expr_func()
		}

	case 3:
		{
			p.SetState(741)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_stmtContext is an interface to support dynamic dispatch.
type IDeclare_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DECLARE() antlr.TerminalNode
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsDeclare_stmtContext differentiates from other interfaces.
	IsDeclare_stmtContext()
}

type Declare_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmtContext() *Declare_stmtContext {
	var p = new(Declare_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt
	return p
}

func InitEmptyDeclare_stmtContext(p *Declare_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt
}

func (*Declare_stmtContext) IsDeclare_stmtContext() {}

func NewDeclare_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmtContext {
	var p = new(Declare_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_stmt

	return p
}

func (s *Declare_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmtContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Declare_stmtContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_stmtContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Declare_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Declare_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_stmt(s)
	}
}

func (s *Declare_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_stmt(s)
	}
}

func (p *HplsqlParser) Declare_stmt() (localctx IDeclare_stmtContext) {
	localctx = NewDeclare_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, HplsqlParserRULE_declare_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(HplsqlParserT_DECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(745)
		p.Declare_stmt_item()
	}
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(746)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(747)
				p.Declare_stmt_item()
			}

		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_blockContext is an interface to support dynamic dispatch.
type IDeclare_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DECLARE() antlr.TerminalNode
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsDeclare_blockContext differentiates from other interfaces.
	IsDeclare_blockContext()
}

type Declare_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_blockContext() *Declare_blockContext {
	var p = new(Declare_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block
	return p
}

func InitEmptyDeclare_blockContext(p *Declare_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block
}

func (*Declare_blockContext) IsDeclare_blockContext() {}

func NewDeclare_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_blockContext {
	var p = new(Declare_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_block

	return p
}

func (s *Declare_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_blockContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Declare_blockContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_blockContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_blockContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Declare_blockContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Declare_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_block(s)
	}
}

func (s *Declare_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_block(s)
	}
}

func (p *HplsqlParser) Declare_block() (localctx IDeclare_blockContext) {
	localctx = NewDeclare_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, HplsqlParserRULE_declare_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.Match(HplsqlParserT_DECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(754)
		p.Declare_stmt_item()
	}
	{
		p.SetState(755)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(756)
				p.Declare_stmt_item()
			}
			{
				p.SetState(757)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_block_inplaceContext is an interface to support dynamic dispatch.
type IDeclare_block_inplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsDeclare_block_inplaceContext differentiates from other interfaces.
	IsDeclare_block_inplaceContext()
}

type Declare_block_inplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_block_inplaceContext() *Declare_block_inplaceContext {
	var p = new(Declare_block_inplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace
	return p
}

func InitEmptyDeclare_block_inplaceContext(p *Declare_block_inplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace
}

func (*Declare_block_inplaceContext) IsDeclare_block_inplaceContext() {}

func NewDeclare_block_inplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_block_inplaceContext {
	var p = new(Declare_block_inplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace

	return p
}

func (s *Declare_block_inplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_block_inplaceContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_block_inplaceContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_block_inplaceContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Declare_block_inplaceContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Declare_block_inplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_block_inplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_block_inplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_block_inplace(s)
	}
}

func (s *Declare_block_inplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_block_inplace(s)
	}
}

func (p *HplsqlParser) Declare_block_inplace() (localctx IDeclare_block_inplaceContext) {
	localctx = NewDeclare_block_inplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, HplsqlParserRULE_declare_block_inplace)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Declare_stmt_item()
	}
	{
		p.SetState(765)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(766)
				p.Declare_stmt_item()
			}
			{
				p.SetState(767)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_stmt_itemContext is an interface to support dynamic dispatch.
type IDeclare_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_cursor_item() IDeclare_cursor_itemContext
	Declare_condition_item() IDeclare_condition_itemContext
	Declare_handler_item() IDeclare_handler_itemContext
	Declare_var_item() IDeclare_var_itemContext
	Declare_temporary_table_item() IDeclare_temporary_table_itemContext

	// IsDeclare_stmt_itemContext differentiates from other interfaces.
	IsDeclare_stmt_itemContext()
}

type Declare_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmt_itemContext() *Declare_stmt_itemContext {
	var p = new(Declare_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item
	return p
}

func InitEmptyDeclare_stmt_itemContext(p *Declare_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item
}

func (*Declare_stmt_itemContext) IsDeclare_stmt_itemContext() {}

func NewDeclare_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmt_itemContext {
	var p = new(Declare_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item

	return p
}

func (s *Declare_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmt_itemContext) Declare_cursor_item() IDeclare_cursor_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_cursor_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_cursor_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_condition_item() IDeclare_condition_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_condition_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_condition_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_handler_item() IDeclare_handler_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_handler_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_handler_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_var_item() IDeclare_var_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_var_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_var_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_temporary_table_item() IDeclare_temporary_table_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_temporary_table_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_temporary_table_itemContext)
}

func (s *Declare_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_stmt_item(s)
	}
}

func (s *Declare_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_stmt_item(s)
	}
}

func (p *HplsqlParser) Declare_stmt_item() (localctx IDeclare_stmt_itemContext) {
	localctx = NewDeclare_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, HplsqlParserRULE_declare_stmt_item)
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(774)
			p.Declare_cursor_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(775)
			p.Declare_condition_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(776)
			p.Declare_handler_item()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(777)
			p.Declare_var_item()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(778)
			p.Declare_temporary_table_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_var_itemContext is an interface to support dynamic dispatch.
type IDeclare_var_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Dtype() IDtypeContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_AS() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	Dtype_default() IDtype_defaultContext
	T_CONSTANT() antlr.TerminalNode

	// IsDeclare_var_itemContext differentiates from other interfaces.
	IsDeclare_var_itemContext()
}

type Declare_var_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_var_itemContext() *Declare_var_itemContext {
	var p = new(Declare_var_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_var_item
	return p
}

func InitEmptyDeclare_var_itemContext(p *Declare_var_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_var_item
}

func (*Declare_var_itemContext) IsDeclare_var_itemContext() {}

func NewDeclare_var_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_var_itemContext {
	var p = new(Declare_var_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_var_item

	return p
}

func (s *Declare_var_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_var_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Declare_var_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_var_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Declare_var_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Declare_var_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Declare_var_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Declare_var_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Declare_var_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Declare_var_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Declare_var_itemContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Declare_var_itemContext) T_CONSTANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTANT, 0)
}

func (s *Declare_var_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_var_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_var_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_var_item(s)
	}
}

func (s *Declare_var_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_var_item(s)
	}
}

func (p *HplsqlParser) Declare_var_item() (localctx IDeclare_var_itemContext) {
	localctx = NewDeclare_var_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, HplsqlParserRULE_declare_var_item)
	var _la int

	var _alt int

	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(781)
			p.Ident()
		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(782)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(783)
				p.Ident()
			}

			p.SetState(788)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(790)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(789)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(792)
			p.Dtype()
		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(793)
				p.Dtype_len()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(796)
					p.Dtype_attr()
				}

			}
			p.SetState(801)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(802)
				p.Dtype_default()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(805)
			p.Ident()
		}
		{
			p.SetState(806)
			p.Match(HplsqlParserT_CONSTANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(808)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(807)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(810)
			p.Dtype()
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(811)
				p.Dtype_len()
			}

		}
		{
			p.SetState(814)
			p.Dtype_default()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_condition_itemContext is an interface to support dynamic dispatch.
type IDeclare_condition_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_CONDITION() antlr.TerminalNode

	// IsDeclare_condition_itemContext differentiates from other interfaces.
	IsDeclare_condition_itemContext()
}

type Declare_condition_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_condition_itemContext() *Declare_condition_itemContext {
	var p = new(Declare_condition_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_condition_item
	return p
}

func InitEmptyDeclare_condition_itemContext(p *Declare_condition_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_condition_item
}

func (*Declare_condition_itemContext) IsDeclare_condition_itemContext() {}

func NewDeclare_condition_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_condition_itemContext {
	var p = new(Declare_condition_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_condition_item

	return p
}

func (s *Declare_condition_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_condition_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_condition_itemContext) T_CONDITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONDITION, 0)
}

func (s *Declare_condition_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_condition_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_condition_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_condition_item(s)
	}
}

func (s *Declare_condition_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_condition_item(s)
	}
}

func (p *HplsqlParser) Declare_condition_item() (localctx IDeclare_condition_itemContext) {
	localctx = NewDeclare_condition_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, HplsqlParserRULE_declare_condition_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.Ident()
	}
	{
		p.SetState(819)
		p.Match(HplsqlParserT_CONDITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_cursor_itemContext is an interface to support dynamic dispatch.
type IDeclare_cursor_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IS() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_CURSOR() antlr.TerminalNode
	Ident() IIdentContext
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext
	Cursor_with_return() ICursor_with_returnContext
	Cursor_without_return() ICursor_without_returnContext

	// IsDeclare_cursor_itemContext differentiates from other interfaces.
	IsDeclare_cursor_itemContext()
}

type Declare_cursor_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_cursor_itemContext() *Declare_cursor_itemContext {
	var p = new(Declare_cursor_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item
	return p
}

func InitEmptyDeclare_cursor_itemContext(p *Declare_cursor_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item
}

func (*Declare_cursor_itemContext) IsDeclare_cursor_itemContext() {}

func NewDeclare_cursor_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_cursor_itemContext {
	var p = new(Declare_cursor_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item

	return p
}

func (s *Declare_cursor_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_cursor_itemContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Declare_cursor_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Declare_cursor_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Declare_cursor_itemContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Declare_cursor_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_cursor_itemContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Declare_cursor_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Declare_cursor_itemContext) Cursor_with_return() ICursor_with_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursor_with_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursor_with_returnContext)
}

func (s *Declare_cursor_itemContext) Cursor_without_return() ICursor_without_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursor_without_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursor_without_returnContext)
}

func (s *Declare_cursor_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_cursor_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_cursor_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_cursor_item(s)
	}
}

func (s *Declare_cursor_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_cursor_item(s)
	}
}

func (p *HplsqlParser) Declare_cursor_item() (localctx IDeclare_cursor_itemContext) {
	localctx = NewDeclare_cursor_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, HplsqlParserRULE_declare_cursor_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(821)
			p.Match(HplsqlParserT_CURSOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.Ident()
		}

	case 2:
		{
			p.SetState(823)
			p.Ident()
		}
		{
			p.SetState(824)
			p.Match(HplsqlParserT_CURSOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_WITH:
		{
			p.SetState(828)
			p.Cursor_with_return()
		}

	case HplsqlParserT_WITHOUT:
		{
			p.SetState(829)
			p.Cursor_without_return()
		}

	case HplsqlParserT_AS, HplsqlParserT_FOR, HplsqlParserT_IS:

	default:
	}
	{
		p.SetState(832)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_FOR || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(833)
			p.Select_stmt()
		}

	case 2:
		{
			p.SetState(834)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursor_with_returnContext is an interface to support dynamic dispatch.
type ICursor_with_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_CALLER() antlr.TerminalNode
	T_CLIENT() antlr.TerminalNode

	// IsCursor_with_returnContext differentiates from other interfaces.
	IsCursor_with_returnContext()
}

type Cursor_with_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_with_returnContext() *Cursor_with_returnContext {
	var p = new(Cursor_with_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_with_return
	return p
}

func InitEmptyCursor_with_returnContext(p *Cursor_with_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_with_return
}

func (*Cursor_with_returnContext) IsCursor_with_returnContext() {}

func NewCursor_with_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_with_returnContext {
	var p = new(Cursor_with_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cursor_with_return

	return p
}

func (s *Cursor_with_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_with_returnContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Cursor_with_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Cursor_with_returnContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Cursor_with_returnContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Cursor_with_returnContext) T_CALLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALLER, 0)
}

func (s *Cursor_with_returnContext) T_CLIENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLIENT, 0)
}

func (s *Cursor_with_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_with_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_with_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCursor_with_return(s)
	}
}

func (s *Cursor_with_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCursor_with_return(s)
	}
}

func (p *HplsqlParser) Cursor_with_return() (localctx ICursor_with_returnContext) {
	localctx = NewCursor_with_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, HplsqlParserRULE_cursor_with_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(837)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(838)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ONLY {
		{
			p.SetState(839)
			p.Match(HplsqlParserT_ONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_TO {
		{
			p.SetState(842)
			p.Match(HplsqlParserT_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(843)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CALLER || _la == HplsqlParserT_CLIENT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursor_without_returnContext is an interface to support dynamic dispatch.
type ICursor_without_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITHOUT() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode

	// IsCursor_without_returnContext differentiates from other interfaces.
	IsCursor_without_returnContext()
}

type Cursor_without_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_without_returnContext() *Cursor_without_returnContext {
	var p = new(Cursor_without_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_without_return
	return p
}

func InitEmptyCursor_without_returnContext(p *Cursor_without_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_without_return
}

func (*Cursor_without_returnContext) IsCursor_without_returnContext() {}

func NewCursor_without_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_without_returnContext {
	var p = new(Cursor_without_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cursor_without_return

	return p
}

func (s *Cursor_without_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_without_returnContext) T_WITHOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITHOUT, 0)
}

func (s *Cursor_without_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Cursor_without_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_without_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_without_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCursor_without_return(s)
	}
}

func (s *Cursor_without_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCursor_without_return(s)
	}
}

func (p *HplsqlParser) Cursor_without_return() (localctx ICursor_without_returnContext) {
	localctx = NewCursor_without_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, HplsqlParserRULE_cursor_without_return)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Match(HplsqlParserT_WITHOUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(847)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_handler_itemContext is an interface to support dynamic dispatch.
type IDeclare_handler_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HANDLER() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	Single_block_stmt() ISingle_block_stmtContext
	T_CONTINUE() antlr.TerminalNode
	T_EXIT() antlr.TerminalNode
	T_SQLEXCEPTION() antlr.TerminalNode
	T_SQLWARNING() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	Ident() IIdentContext

	// IsDeclare_handler_itemContext differentiates from other interfaces.
	IsDeclare_handler_itemContext()
}

type Declare_handler_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_handler_itemContext() *Declare_handler_itemContext {
	var p = new(Declare_handler_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_handler_item
	return p
}

func InitEmptyDeclare_handler_itemContext(p *Declare_handler_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_handler_item
}

func (*Declare_handler_itemContext) IsDeclare_handler_itemContext() {}

func NewDeclare_handler_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_handler_itemContext {
	var p = new(Declare_handler_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_handler_item

	return p
}

func (s *Declare_handler_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_handler_itemContext) T_HANDLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HANDLER, 0)
}

func (s *Declare_handler_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Declare_handler_itemContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *Declare_handler_itemContext) T_CONTINUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONTINUE, 0)
}

func (s *Declare_handler_itemContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Declare_handler_itemContext) T_SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLEXCEPTION, 0)
}

func (s *Declare_handler_itemContext) T_SQLWARNING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLWARNING, 0)
}

func (s *Declare_handler_itemContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Declare_handler_itemContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Declare_handler_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_handler_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_handler_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_handler_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_handler_item(s)
	}
}

func (s *Declare_handler_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_handler_item(s)
	}
}

func (p *HplsqlParser) Declare_handler_item() (localctx IDeclare_handler_itemContext) {
	localctx = NewDeclare_handler_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, HplsqlParserRULE_declare_handler_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_CONTINUE || _la == HplsqlParserT_EXIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(850)
		p.Match(HplsqlParserT_HANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(851)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(852)
			p.Match(HplsqlParserT_SQLEXCEPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(853)
			p.Match(HplsqlParserT_SQLWARNING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(854)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(855)
			p.Match(HplsqlParserT_FOUND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(856)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(859)
		p.Single_block_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_temporary_table_itemContext is an interface to support dynamic dispatch.
type IDeclare_temporary_table_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TEMPORARY() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Qident() IQidentContext
	Create_table_definition() ICreate_table_definitionContext
	T_GLOBAL() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext

	// IsDeclare_temporary_table_itemContext differentiates from other interfaces.
	IsDeclare_temporary_table_itemContext()
}

type Declare_temporary_table_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_temporary_table_itemContext() *Declare_temporary_table_itemContext {
	var p = new(Declare_temporary_table_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item
	return p
}

func InitEmptyDeclare_temporary_table_itemContext(p *Declare_temporary_table_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item
}

func (*Declare_temporary_table_itemContext) IsDeclare_temporary_table_itemContext() {}

func NewDeclare_temporary_table_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_temporary_table_itemContext {
	var p = new(Declare_temporary_table_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item

	return p
}

func (s *Declare_temporary_table_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_temporary_table_itemContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Declare_temporary_table_itemContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Declare_temporary_table_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Declare_temporary_table_itemContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Declare_temporary_table_itemContext) T_GLOBAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GLOBAL, 0)
}

func (s *Declare_temporary_table_itemContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Declare_temporary_table_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_temporary_table_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_temporary_table_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_temporary_table_item(s)
	}
}

func (s *Declare_temporary_table_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_temporary_table_item(s)
	}
}

func (p *HplsqlParser) Declare_temporary_table_item() (localctx IDeclare_temporary_table_itemContext) {
	localctx = NewDeclare_temporary_table_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, HplsqlParserRULE_declare_temporary_table_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_GLOBAL {
		{
			p.SetState(861)
			p.Match(HplsqlParserT_GLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(864)
		p.Match(HplsqlParserT_TEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(865)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(866)
		p.Qident()
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(867)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(870)
		p.Create_table_definition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Create_table_definition() ICreate_table_definitionContext
	T_IF() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext

	// IsCreate_table_stmtContext differentiates from other interfaces.
	IsCreate_table_stmtContext()
}

type Create_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_stmtContext() *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_stmt
	return p
}

func InitEmptyCreate_table_stmtContext(p *Create_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_stmt
}

func (*Create_table_stmtContext) IsCreate_table_stmtContext() {}

func NewCreate_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_stmt

	return p
}

func (s *Create_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_table_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_stmtContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Create_table_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Create_table_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Create_table_stmtContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Create_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_stmt(s)
	}
}

func (s *Create_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_stmt(s)
	}
}

func (p *HplsqlParser) Create_table_stmt() (localctx ICreate_table_stmtContext) {
	localctx = NewCreate_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, HplsqlParserRULE_create_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(873)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(877)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(874)
			p.Match(HplsqlParserT_IF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(879)
		p.Table_name()
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(880)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(883)
		p.Create_table_definition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_local_temp_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_local_temp_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Qident() IQidentContext
	Create_table_definition() ICreate_table_definitionContext
	T_LOCAL() antlr.TerminalNode
	T_TEMPORARY() antlr.TerminalNode
	T_VOLATILE() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext
	T_SET() antlr.TerminalNode
	T_MULTISET() antlr.TerminalNode

	// IsCreate_local_temp_table_stmtContext differentiates from other interfaces.
	IsCreate_local_temp_table_stmtContext()
}

type Create_local_temp_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_local_temp_table_stmtContext() *Create_local_temp_table_stmtContext {
	var p = new(Create_local_temp_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt
	return p
}

func InitEmptyCreate_local_temp_table_stmtContext(p *Create_local_temp_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt
}

func (*Create_local_temp_table_stmtContext) IsCreate_local_temp_table_stmtContext() {}

func NewCreate_local_temp_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_local_temp_table_stmtContext {
	var p = new(Create_local_temp_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt

	return p
}

func (s *Create_local_temp_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_local_temp_table_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_local_temp_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_local_temp_table_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_local_temp_table_stmtContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Create_local_temp_table_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Create_local_temp_table_stmtContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Create_local_temp_table_stmtContext) T_VOLATILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VOLATILE, 0)
}

func (s *Create_local_temp_table_stmtContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Create_local_temp_table_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_local_temp_table_stmtContext) T_MULTISET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MULTISET, 0)
}

func (s *Create_local_temp_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_local_temp_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_local_temp_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_local_temp_table_stmt(s)
	}
}

func (s *Create_local_temp_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_local_temp_table_stmt(s)
	}
}

func (p *HplsqlParser) Create_local_temp_table_stmt() (localctx ICreate_local_temp_table_stmtContext) {
	localctx = NewCreate_local_temp_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, HplsqlParserRULE_create_local_temp_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LOCAL:
		{
			p.SetState(886)
			p.Match(HplsqlParserT_LOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(887)
			p.Match(HplsqlParserT_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_MULTISET, HplsqlParserT_SET, HplsqlParserT_VOLATILE:
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_MULTISET || _la == HplsqlParserT_SET {
			{
				p.SetState(888)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_MULTISET || _la == HplsqlParserT_SET) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(891)
			p.Match(HplsqlParserT_VOLATILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(894)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(895)
		p.Qident()
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(896)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(899)
		p.Create_table_definition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_definitionContext is an interface to support dynamic dispatch.
type ICreate_table_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Create_table_columns() ICreate_table_columnsContext
	T_LIKE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Create_table_options() ICreate_table_optionsContext
	T_AS() antlr.TerminalNode

	// IsCreate_table_definitionContext differentiates from other interfaces.
	IsCreate_table_definitionContext()
}

type Create_table_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_definitionContext() *Create_table_definitionContext {
	var p = new(Create_table_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_definition
	return p
}

func InitEmptyCreate_table_definitionContext(p *Create_table_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_definition
}

func (*Create_table_definitionContext) IsCreate_table_definitionContext() {}

func NewCreate_table_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_definitionContext {
	var p = new(Create_table_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_definition

	return p
}

func (s *Create_table_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_definitionContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_definitionContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Create_table_definitionContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_definitionContext) Create_table_columns() ICreate_table_columnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_columnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_columnsContext)
}

func (s *Create_table_definitionContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Create_table_definitionContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_definitionContext) Create_table_options() ICreate_table_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_optionsContext)
}

func (s *Create_table_definitionContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_definition(s)
	}
}

func (s *Create_table_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_definition(s)
	}
}

func (p *HplsqlParser) Create_table_definition() (localctx ICreate_table_definitionContext) {
	localctx = NewCreate_table_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, HplsqlParserRULE_create_table_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.SetState(902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AS {
			{
				p.SetState(901)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(904)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(905)
			p.Select_stmt()
		}
		{
			p.SetState(906)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AS {
			{
				p.SetState(908)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(911)
			p.Select_stmt()
		}

	case 3:
		{
			p.SetState(912)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(913)
			p.Create_table_columns()
		}
		{
			p.SetState(914)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(916)
			p.Match(HplsqlParserT_LIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(917)
			p.Table_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(920)
			p.Create_table_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_columnsContext is an interface to support dynamic dispatch.
type ICreate_table_columnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_columns_item() []ICreate_table_columns_itemContext
	Create_table_columns_item(i int) ICreate_table_columns_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_table_columnsContext differentiates from other interfaces.
	IsCreate_table_columnsContext()
}

type Create_table_columnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_columnsContext() *Create_table_columnsContext {
	var p = new(Create_table_columnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns
	return p
}

func InitEmptyCreate_table_columnsContext(p *Create_table_columnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns
}

func (*Create_table_columnsContext) IsCreate_table_columnsContext() {}

func NewCreate_table_columnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_columnsContext {
	var p = new(Create_table_columnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_columns

	return p
}

func (s *Create_table_columnsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_columnsContext) AllCreate_table_columns_item() []ICreate_table_columns_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_columns_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_columns_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_columns_itemContext); ok {
			tst[i] = t.(ICreate_table_columns_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columnsContext) Create_table_columns_item(i int) ICreate_table_columns_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_columns_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_columns_itemContext)
}

func (s *Create_table_columnsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_columnsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_columnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_columnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_columnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_columns(s)
	}
}

func (s *Create_table_columnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_columns(s)
	}
}

func (p *HplsqlParser) Create_table_columns() (localctx ICreate_table_columnsContext) {
	localctx = NewCreate_table_columnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, HplsqlParserRULE_create_table_columns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.Create_table_columns_item()
	}
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(924)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(925)
			p.Create_table_columns_item()
		}

		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_columns_itemContext is an interface to support dynamic dispatch.
type ICreate_table_columns_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	Dtype() IDtypeContext
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	AllCreate_table_column_inline_cons() []ICreate_table_column_inline_consContext
	Create_table_column_inline_cons(i int) ICreate_table_column_inline_consContext
	Create_table_column_cons() ICreate_table_column_consContext
	T_CONSTRAINT() antlr.TerminalNode
	Qident() IQidentContext

	// IsCreate_table_columns_itemContext differentiates from other interfaces.
	IsCreate_table_columns_itemContext()
}

type Create_table_columns_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_columns_itemContext() *Create_table_columns_itemContext {
	var p = new(Create_table_columns_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item
	return p
}

func InitEmptyCreate_table_columns_itemContext(p *Create_table_columns_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item
}

func (*Create_table_columns_itemContext) IsCreate_table_columns_itemContext() {}

func NewCreate_table_columns_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_columns_itemContext {
	var p = new(Create_table_columns_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item

	return p
}

func (s *Create_table_columns_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_columns_itemContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Create_table_columns_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_table_columns_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_table_columns_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columns_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Create_table_columns_itemContext) AllCreate_table_column_inline_cons() []ICreate_table_column_inline_consContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_column_inline_consContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			tst[i] = t.(ICreate_table_column_inline_consContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columns_itemContext) Create_table_column_inline_cons(i int) ICreate_table_column_inline_consContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_inline_consContext)
}

func (s *Create_table_columns_itemContext) Create_table_column_cons() ICreate_table_column_consContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_consContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_consContext)
}

func (s *Create_table_columns_itemContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Create_table_columns_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_columns_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_columns_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_columns_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_columns_item(s)
	}
}

func (s *Create_table_columns_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_columns_item(s)
	}
}

func (p *HplsqlParser) Create_table_columns_item() (localctx ICreate_table_columns_itemContext) {
	localctx = NewCreate_table_columns_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, HplsqlParserRULE_create_table_columns_item)
	var _la int

	var _alt int

	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(931)
			p.Column_name()
		}
		{
			p.SetState(932)
			p.Dtype()
		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(933)
				p.Dtype_len()
			}

		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(936)
					p.Dtype_attr()
				}

			}
			p.SetState(941)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_AUTO_INCREMENT || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&288230376155906049) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&34393292805) != 0) || ((int64((_la-302)) & ^0x3f) == 0 && ((int64(1)<<(_la-302))&9147936743129089) != 0) {
			{
				p.SetState(942)
				p.Create_table_column_inline_cons()
			}

			p.SetState(947)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CONSTRAINT {
			{
				p.SetState(948)
				p.Match(HplsqlParserT_CONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(949)
				p.Qident()
			}

		}
		{
			p.SetState(952)
			p.Create_table_column_cons()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_type_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_type_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TYPE() antlr.TerminalNode
	Ident() IIdentContext
	T_IS() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_OF() antlr.TerminalNode
	Tbl_type() ITbl_typeContext
	T_INDEX() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	Dtype() IDtypeContext
	T_NOT() antlr.TerminalNode
	T_NULL() antlr.TerminalNode

	// IsCreate_table_type_stmtContext differentiates from other interfaces.
	IsCreate_table_type_stmtContext()
}

type Create_table_type_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_type_stmtContext() *Create_table_type_stmtContext {
	var p = new(Create_table_type_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_type_stmt
	return p
}

func InitEmptyCreate_table_type_stmtContext(p *Create_table_type_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_type_stmt
}

func (*Create_table_type_stmtContext) IsCreate_table_type_stmtContext() {}

func NewCreate_table_type_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_type_stmtContext {
	var p = new(Create_table_type_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_type_stmt

	return p
}

func (s *Create_table_type_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_type_stmtContext) T_TYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TYPE, 0)
}

func (s *Create_table_type_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_table_type_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_table_type_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_table_type_stmtContext) T_OF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OF, 0)
}

func (s *Create_table_type_stmtContext) Tbl_type() ITbl_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITbl_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITbl_typeContext)
}

func (s *Create_table_type_stmtContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_type_stmtContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Create_table_type_stmtContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_table_type_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_type_stmtContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_type_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_type_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_type_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_type_stmt(s)
	}
}

func (s *Create_table_type_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_type_stmt(s)
	}
}

func (p *HplsqlParser) Create_table_type_stmt() (localctx ICreate_table_type_stmtContext) {
	localctx = NewCreate_table_type_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, HplsqlParserRULE_create_table_type_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Match(HplsqlParserT_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(956)
		p.Ident()
	}
	{
		p.SetState(957)
		p.Match(HplsqlParserT_IS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(958)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(959)
		p.Match(HplsqlParserT_OF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(960)
		p.Tbl_type()
	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_NOT {
		{
			p.SetState(961)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(962)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(965)
		p.Match(HplsqlParserT_INDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(966)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(967)
		p.Dtype()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITbl_typeContext is an interface to support dynamic dispatch.
type ITbl_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_type() ISql_typeContext
	Dtype() IDtypeContext

	// IsTbl_typeContext differentiates from other interfaces.
	IsTbl_typeContext()
}

type Tbl_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTbl_typeContext() *Tbl_typeContext {
	var p = new(Tbl_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_tbl_type
	return p
}

func InitEmptyTbl_typeContext(p *Tbl_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_tbl_type
}

func (*Tbl_typeContext) IsTbl_typeContext() {}

func NewTbl_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tbl_typeContext {
	var p = new(Tbl_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_tbl_type

	return p
}

func (s *Tbl_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tbl_typeContext) Sql_type() ISql_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_typeContext)
}

func (s *Tbl_typeContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Tbl_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tbl_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tbl_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTbl_type(s)
	}
}

func (s *Tbl_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTbl_type(s)
	}
}

func (p *HplsqlParser) Tbl_type() (localctx ITbl_typeContext) {
	localctx = NewTbl_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, HplsqlParserRULE_tbl_type)
	p.SetState(971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(969)
			p.Sql_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(970)
			p.Dtype()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_typeContext is an interface to support dynamic dispatch.
type ISql_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_TYPE() antlr.TerminalNode
	T_ROWTYPE() antlr.TerminalNode

	// IsSql_typeContext differentiates from other interfaces.
	IsSql_typeContext()
}

type Sql_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_typeContext() *Sql_typeContext {
	var p = new(Sql_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_sql_type
	return p
}

func InitEmptySql_typeContext(p *Sql_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_sql_type
}

func (*Sql_typeContext) IsSql_typeContext() {}

func NewSql_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_typeContext {
	var p = new(Sql_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_sql_type

	return p
}

func (s *Sql_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_typeContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Sql_typeContext) T_TYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TYPE, 0)
}

func (s *Sql_typeContext) T_ROWTYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWTYPE, 0)
}

func (s *Sql_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSql_type(s)
	}
}

func (s *Sql_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSql_type(s)
	}
}

func (p *HplsqlParser) Sql_type() (localctx ISql_typeContext) {
	localctx = NewSql_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, HplsqlParserRULE_sql_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(973)
		p.Qident()
	}
	{
		p.SetState(974)
		p.Match(HplsqlParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(975)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ROWTYPE || _la == HplsqlParserT_TYPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (p *HplsqlParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, HplsqlParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(977)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_column_inline_consContext is an interface to support dynamic dispatch.
type ICreate_table_column_inline_consContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dtype_default() IDtype_defaultContext
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Qident() IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext
	T_IDENTITY() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_AUTO_INCREMENT() antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode

	// IsCreate_table_column_inline_consContext differentiates from other interfaces.
	IsCreate_table_column_inline_consContext()
}

type Create_table_column_inline_consContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_inline_consContext() *Create_table_column_inline_consContext {
	var p = new(Create_table_column_inline_consContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons
	return p
}

func InitEmptyCreate_table_column_inline_consContext(p *Create_table_column_inline_consContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons
}

func (*Create_table_column_inline_consContext) IsCreate_table_column_inline_consContext() {}

func NewCreate_table_column_inline_consContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_inline_consContext {
	var p = new(Create_table_column_inline_consContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons

	return p
}

func (s *Create_table_column_inline_consContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_inline_consContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Create_table_column_inline_consContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_column_inline_consContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_column_inline_consContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_column_inline_consContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Create_table_column_inline_consContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_table_column_inline_consContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Create_table_column_inline_consContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_column_inline_consContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_column_inline_consContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_column_inline_consContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_column_inline_consContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_inline_consContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Create_table_column_inline_consContext) T_IDENTITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IDENTITY, 0)
}

func (s *Create_table_column_inline_consContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Create_table_column_inline_consContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Create_table_column_inline_consContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_column_inline_consContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_column_inline_consContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Create_table_column_inline_consContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Create_table_column_inline_consContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_inline_consContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_column_inline_consContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_inline_cons(s)
	}
}

func (s *Create_table_column_inline_consContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_inline_cons(s)
	}
}

func (p *HplsqlParser) Create_table_column_inline_cons() (localctx ICreate_table_column_inline_consContext) {
	localctx = NewCreate_table_column_inline_consContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, HplsqlParserRULE_create_table_column_inline_cons)
	var _la int

	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_DEFAULT, HplsqlParserT_WITH, HplsqlParserT_COLON, HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(979)
			p.Dtype_default()
		}

	case HplsqlParserT_NOT, HplsqlParserT_NULL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(980)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(983)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(984)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(985)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_UNIQUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(986)
			p.Match(HplsqlParserT_UNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_REFERENCES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(987)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.Table_name()
		}
		{
			p.SetState(989)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(990)
			p.Qident()
		}
		{
			p.SetState(991)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_ON {
			{
				p.SetState(992)
				p.Create_table_fk_action()
			}

			p.SetState(997)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case HplsqlParserT_IDENTITY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(998)
			p.Match(HplsqlParserT_IDENTITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(999)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1000)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1001)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1002)
				p.Match(HplsqlParserL_INT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1007)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1008)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_AUTO_INCREMENT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1009)
			p.Match(HplsqlParserT_AUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_ENABLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1010)
			p.Match(HplsqlParserT_ENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_column_consContext is an interface to support dynamic dispatch.
type ICreate_table_column_consContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	Index_storage_clause() IIndex_storage_clauseContext
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext

	// IsCreate_table_column_consContext differentiates from other interfaces.
	IsCreate_table_column_consContext()
}

type Create_table_column_consContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_consContext() *Create_table_column_consContext {
	var p = new(Create_table_column_consContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons
	return p
}

func InitEmptyCreate_table_column_consContext(p *Create_table_column_consContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons
}

func (*Create_table_column_consContext) IsCreate_table_column_consContext() {}

func NewCreate_table_column_consContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_consContext {
	var p = new(Create_table_column_consContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons

	return p
}

func (s *Create_table_column_consContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_consContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_column_consContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Create_table_column_consContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Create_table_column_consContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Create_table_column_consContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_consContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_column_consContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Create_table_column_consContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Create_table_column_consContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Create_table_column_consContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_column_consContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_column_consContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Create_table_column_consContext) Index_storage_clause() IIndex_storage_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_storage_clauseContext)
}

func (s *Create_table_column_consContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Create_table_column_consContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Create_table_column_consContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Create_table_column_consContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Create_table_column_consContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Create_table_column_consContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Create_table_column_consContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_column_consContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_consContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Create_table_column_consContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_consContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_column_consContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_cons(s)
	}
}

func (s *Create_table_column_consContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_cons(s)
	}
}

func (p *HplsqlParser) Create_table_column_cons() (localctx ICreate_table_column_consContext) {
	localctx = NewCreate_table_column_consContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, HplsqlParserRULE_create_table_column_cons)
	var _la int

	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1013)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1014)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CLUSTERED {
			{
				p.SetState(1015)
				p.Match(HplsqlParserT_CLUSTERED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1018)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1019)
			p.Qident()
		}
		p.SetState(1021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
			{
				p.SetState(1020)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1023)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1024)
				p.Qident()
			}
			p.SetState(1026)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
				{
					p.SetState(1025)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

			p.SetState(1032)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1033)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ENABLE {
			{
				p.SetState(1034)
				p.Match(HplsqlParserT_ENABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_WITH {
			{
				p.SetState(1037)
				p.Index_storage_clause()
			}

		}

	case HplsqlParserT_FOREIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1040)
			p.Match(HplsqlParserT_FOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1042)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)
			p.Qident()
		}
		p.SetState(1048)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1044)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1045)
				p.Qident()
			}

			p.SetState(1050)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1051)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1052)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Table_name()
		}
		{
			p.SetState(1054)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1055)
			p.Qident()
		}
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1056)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1057)
				p.Qident()
			}

			p.SetState(1062)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1063)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_ON {
			{
				p.SetState(1064)
				p.Create_table_fk_action()
			}

			p.SetState(1069)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_fk_actionContext is an interface to support dynamic dispatch.
type ICreate_table_fk_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_ACTION() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_CASCADE() antlr.TerminalNode

	// IsCreate_table_fk_actionContext differentiates from other interfaces.
	IsCreate_table_fk_actionContext()
}

type Create_table_fk_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_fk_actionContext() *Create_table_fk_actionContext {
	var p = new(Create_table_fk_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action
	return p
}

func InitEmptyCreate_table_fk_actionContext(p *Create_table_fk_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action
}

func (*Create_table_fk_actionContext) IsCreate_table_fk_actionContext() {}

func NewCreate_table_fk_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_fk_actionContext {
	var p = new(Create_table_fk_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action

	return p
}

func (s *Create_table_fk_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_fk_actionContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_fk_actionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Create_table_fk_actionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Create_table_fk_actionContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_fk_actionContext) T_ACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTION, 0)
}

func (s *Create_table_fk_actionContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Create_table_fk_actionContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_table_fk_actionContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_fk_actionContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Create_table_fk_actionContext) T_CASCADE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASCADE, 0)
}

func (s *Create_table_fk_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_fk_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_fk_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_fk_action(s)
	}
}

func (s *Create_table_fk_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_fk_action(s)
	}
}

func (p *HplsqlParser) Create_table_fk_action() (localctx ICreate_table_fk_actionContext) {
	localctx = NewCreate_table_fk_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, HplsqlParserRULE_create_table_fk_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1072)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1073)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_UPDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1074)
			p.Match(HplsqlParserT_NO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1075)
			p.Match(HplsqlParserT_ACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1076)
			p.Match(HplsqlParserT_RESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(1077)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1078)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1079)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1081)
			p.Match(HplsqlParserT_CASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_preoptionsContext is an interface to support dynamic dispatch.
type ICreate_table_preoptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_preoptions_item() []ICreate_table_preoptions_itemContext
	Create_table_preoptions_item(i int) ICreate_table_preoptions_itemContext

	// IsCreate_table_preoptionsContext differentiates from other interfaces.
	IsCreate_table_preoptionsContext()
}

type Create_table_preoptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptionsContext() *Create_table_preoptionsContext {
	var p = new(Create_table_preoptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions
	return p
}

func InitEmptyCreate_table_preoptionsContext(p *Create_table_preoptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions
}

func (*Create_table_preoptionsContext) IsCreate_table_preoptionsContext() {}

func NewCreate_table_preoptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptionsContext {
	var p = new(Create_table_preoptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions

	return p
}

func (s *Create_table_preoptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptionsContext) AllCreate_table_preoptions_item() []ICreate_table_preoptions_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_preoptions_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			tst[i] = t.(ICreate_table_preoptions_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_preoptionsContext) Create_table_preoptions_item(i int) ICreate_table_preoptions_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptions_itemContext)
}

func (s *Create_table_preoptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_preoptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions(s)
	}
}

func (s *Create_table_preoptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions(s)
	}
}

func (p *HplsqlParser) Create_table_preoptions() (localctx ICreate_table_preoptionsContext) {
	localctx = NewCreate_table_preoptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, HplsqlParserRULE_create_table_preoptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(1084)
			p.Create_table_preoptions_item()
		}

		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_preoptions_itemContext is an interface to support dynamic dispatch.
type ICreate_table_preoptions_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMA() antlr.TerminalNode
	Create_table_preoptions_td_item() ICreate_table_preoptions_td_itemContext
	Create_table_options_hive_item() ICreate_table_options_hive_itemContext

	// IsCreate_table_preoptions_itemContext differentiates from other interfaces.
	IsCreate_table_preoptions_itemContext()
}

type Create_table_preoptions_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptions_itemContext() *Create_table_preoptions_itemContext {
	var p = new(Create_table_preoptions_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item
	return p
}

func InitEmptyCreate_table_preoptions_itemContext(p *Create_table_preoptions_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item
}

func (*Create_table_preoptions_itemContext) IsCreate_table_preoptions_itemContext() {}

func NewCreate_table_preoptions_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptions_itemContext {
	var p = new(Create_table_preoptions_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item

	return p
}

func (s *Create_table_preoptions_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptions_itemContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Create_table_preoptions_itemContext) Create_table_preoptions_td_item() ICreate_table_preoptions_td_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptions_td_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptions_td_itemContext)
}

func (s *Create_table_preoptions_itemContext) Create_table_options_hive_item() ICreate_table_options_hive_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_hive_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_hive_itemContext)
}

func (s *Create_table_preoptions_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptions_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_preoptions_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions_item(s)
	}
}

func (s *Create_table_preoptions_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions_item(s)
	}
}

func (p *HplsqlParser) Create_table_preoptions_item() (localctx ICreate_table_preoptions_itemContext) {
	localctx = NewCreate_table_preoptions_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, HplsqlParserRULE_create_table_preoptions_item)
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1089)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1090)
			p.Create_table_preoptions_td_item()
		}

	case HplsqlParserT_ROW, HplsqlParserT_STORED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1091)
			p.Create_table_options_hive_item()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_preoptions_td_itemContext is an interface to support dynamic dispatch.
type ICreate_table_preoptions_td_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LOG() antlr.TerminalNode
	T_FALLBACK() antlr.TerminalNode
	T_NO() antlr.TerminalNode

	// IsCreate_table_preoptions_td_itemContext differentiates from other interfaces.
	IsCreate_table_preoptions_td_itemContext()
}

type Create_table_preoptions_td_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptions_td_itemContext() *Create_table_preoptions_td_itemContext {
	var p = new(Create_table_preoptions_td_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item
	return p
}

func InitEmptyCreate_table_preoptions_td_itemContext(p *Create_table_preoptions_td_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item
}

func (*Create_table_preoptions_td_itemContext) IsCreate_table_preoptions_td_itemContext() {}

func NewCreate_table_preoptions_td_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptions_td_itemContext {
	var p = new(Create_table_preoptions_td_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item

	return p
}

func (s *Create_table_preoptions_td_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptions_td_itemContext) T_LOG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOG, 0)
}

func (s *Create_table_preoptions_td_itemContext) T_FALLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALLBACK, 0)
}

func (s *Create_table_preoptions_td_itemContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_preoptions_td_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptions_td_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_preoptions_td_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions_td_item(s)
	}
}

func (s *Create_table_preoptions_td_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions_td_item(s)
	}
}

func (p *HplsqlParser) Create_table_preoptions_td_item() (localctx ICreate_table_preoptions_td_itemContext) {
	localctx = NewCreate_table_preoptions_td_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, HplsqlParserRULE_create_table_preoptions_td_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_NO {
		{
			p.SetState(1094)
			p.Match(HplsqlParserT_NO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1097)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FALLBACK || _la == HplsqlParserT_LOG) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_optionsContext is an interface to support dynamic dispatch.
type ICreate_table_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_options_item() []ICreate_table_options_itemContext
	Create_table_options_item(i int) ICreate_table_options_itemContext

	// IsCreate_table_optionsContext differentiates from other interfaces.
	IsCreate_table_optionsContext()
}

type Create_table_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_optionsContext() *Create_table_optionsContext {
	var p = new(Create_table_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options
	return p
}

func InitEmptyCreate_table_optionsContext(p *Create_table_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options
}

func (*Create_table_optionsContext) IsCreate_table_optionsContext() {}

func NewCreate_table_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_optionsContext {
	var p = new(Create_table_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options

	return p
}

func (s *Create_table_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_optionsContext) AllCreate_table_options_item() []ICreate_table_options_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_options_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_options_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_options_itemContext); ok {
			tst[i] = t.(ICreate_table_options_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_optionsContext) Create_table_options_item(i int) ICreate_table_options_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_itemContext)
}

func (s *Create_table_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options(s)
	}
}

func (s *Create_table_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options(s)
	}
}

func (p *HplsqlParser) Create_table_options() (localctx ICreate_table_optionsContext) {
	localctx = NewCreate_table_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, HplsqlParserRULE_create_table_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1099)
				p.Create_table_options_item()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	T_COMMIT() antlr.TerminalNode
	T_ROWS() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_PRESERVE() antlr.TerminalNode
	Create_table_options_ora_item() ICreate_table_options_ora_itemContext
	Create_table_options_db2_item() ICreate_table_options_db2_itemContext
	Create_table_options_td_item() ICreate_table_options_td_itemContext
	Create_table_options_hive_item() ICreate_table_options_hive_itemContext
	Create_table_options_mssql_item() ICreate_table_options_mssql_itemContext
	Create_table_options_mysql_item() ICreate_table_options_mysql_itemContext

	// IsCreate_table_options_itemContext differentiates from other interfaces.
	IsCreate_table_options_itemContext()
}

type Create_table_options_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_itemContext() *Create_table_options_itemContext {
	var p = new(Create_table_options_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_item
	return p
}

func InitEmptyCreate_table_options_itemContext(p *Create_table_options_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_item
}

func (*Create_table_options_itemContext) IsCreate_table_options_itemContext() {}

func NewCreate_table_options_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_itemContext {
	var p = new(Create_table_options_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_item

	return p
}

func (s *Create_table_options_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_itemContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Create_table_options_itemContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWS, 0)
}

func (s *Create_table_options_itemContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Create_table_options_itemContext) T_PRESERVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRESERVE, 0)
}

func (s *Create_table_options_itemContext) Create_table_options_ora_item() ICreate_table_options_ora_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_ora_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_ora_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_db2_item() ICreate_table_options_db2_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_db2_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_db2_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_td_item() ICreate_table_options_td_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_td_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_td_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_hive_item() ICreate_table_options_hive_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_hive_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_hive_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_mssql_item() ICreate_table_options_mssql_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mssql_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_mysql_item() ICreate_table_options_mysql_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mysql_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mysql_itemContext)
}

func (s *Create_table_options_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_item(s)
	}
}

func (s *Create_table_options_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_item() (localctx ICreate_table_options_itemContext) {
	localctx = NewCreate_table_options_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, HplsqlParserRULE_create_table_options_item)
	var _la int

	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1104)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1105)
			p.Match(HplsqlParserT_COMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1106)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_PRESERVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1107)
			p.Match(HplsqlParserT_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)
			p.Create_table_options_ora_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1109)
			p.Create_table_options_db2_item()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1110)
			p.Create_table_options_td_item()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1111)
			p.Create_table_options_hive_item()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1112)
			p.Create_table_options_mssql_item()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1113)
			p.Create_table_options_mysql_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_ora_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_ora_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SEGMENT() antlr.TerminalNode
	T_CREATION() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	T_PCTFREE() antlr.TerminalNode
	T_PCTUSED() antlr.TerminalNode
	T_INITRANS() antlr.TerminalNode
	T_MAXTRANS() antlr.TerminalNode
	T_NOCOMPRESS() antlr.TerminalNode
	T_LOGGING() antlr.TerminalNode
	T_NOLOGGING() antlr.TerminalNode
	T_STORAGE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_TABLESPACE() antlr.TerminalNode

	// IsCreate_table_options_ora_itemContext differentiates from other interfaces.
	IsCreate_table_options_ora_itemContext()
}

type Create_table_options_ora_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_ora_itemContext() *Create_table_options_ora_itemContext {
	var p = new(Create_table_options_ora_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item
	return p
}

func InitEmptyCreate_table_options_ora_itemContext(p *Create_table_options_ora_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item
}

func (*Create_table_options_ora_itemContext) IsCreate_table_options_ora_itemContext() {}

func NewCreate_table_options_ora_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_ora_itemContext {
	var p = new(Create_table_options_ora_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item

	return p
}

func (s *Create_table_options_ora_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_ora_itemContext) T_SEGMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEGMENT, 0)
}

func (s *Create_table_options_ora_itemContext) T_CREATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATION, 0)
}

func (s *Create_table_options_ora_itemContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Create_table_options_ora_itemContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFERRED, 0)
}

func (s *Create_table_options_ora_itemContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Create_table_options_ora_itemContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Create_table_options_ora_itemContext) T_PCTFREE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTFREE, 0)
}

func (s *Create_table_options_ora_itemContext) T_PCTUSED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTUSED, 0)
}

func (s *Create_table_options_ora_itemContext) T_INITRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INITRANS, 0)
}

func (s *Create_table_options_ora_itemContext) T_MAXTRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAXTRANS, 0)
}

func (s *Create_table_options_ora_itemContext) T_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOMPRESS, 0)
}

func (s *Create_table_options_ora_itemContext) T_LOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGING, 0)
}

func (s *Create_table_options_ora_itemContext) T_NOLOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOLOGGING, 0)
}

func (s *Create_table_options_ora_itemContext) T_STORAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORAGE, 0)
}

func (s *Create_table_options_ora_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_ora_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_ora_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_ora_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_ora_itemContext) T_TABLESPACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLESPACE, 0)
}

func (s *Create_table_options_ora_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_ora_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_ora_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_ora_item(s)
	}
}

func (s *Create_table_options_ora_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_ora_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_ora_item() (localctx ICreate_table_options_ora_itemContext) {
	localctx = NewCreate_table_options_ora_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, HplsqlParserRULE_create_table_options_ora_item)
	var _la int

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEGMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1116)
			p.Match(HplsqlParserT_SEGMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1117)
			p.Match(HplsqlParserT_CREATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1118)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DEFERRED || _la == HplsqlParserT_IMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case HplsqlParserT_INITRANS, HplsqlParserT_MAXTRANS, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1119)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_INITRANS || _la == HplsqlParserT_MAXTRANS || _la == HplsqlParserT_PCTFREE || _la == HplsqlParserT_PCTUSED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1120)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NOCOMPRESS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1121)
			p.Match(HplsqlParserT_NOCOMPRESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LOGGING, HplsqlParserT_NOLOGGING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1122)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LOGGING || _la == HplsqlParserT_NOLOGGING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case HplsqlParserT_STORAGE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1123)
			p.Match(HplsqlParserT_STORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1124)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-33554464) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-24696061953) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-36028797018963969) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-9007199271518737) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-864744042452222977) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&42784196727422975) != 0) {
			p.SetState(1127)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
				{
					p.SetState(1125)
					p.Qident()
				}

			case HplsqlParserL_INT:
				{
					p.SetState(1126)
					p.Match(HplsqlParserL_INT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1129)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1131)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_TABLESPACE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1132)
			p.Match(HplsqlParserT_TABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1133)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_db2_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_db2_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IN() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_INDEX() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_DISTRIBUTE() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_HASH() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_LOGGED() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_COMPRESS() antlr.TerminalNode
	T_YES() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_DEFINITION() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_DROP() antlr.TerminalNode

	// IsCreate_table_options_db2_itemContext differentiates from other interfaces.
	IsCreate_table_options_db2_itemContext()
}

type Create_table_options_db2_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_db2_itemContext() *Create_table_options_db2_itemContext {
	var p = new(Create_table_options_db2_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item
	return p
}

func InitEmptyCreate_table_options_db2_itemContext(p *Create_table_options_db2_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item
}

func (*Create_table_options_db2_itemContext) IsCreate_table_options_db2_itemContext() {}

func NewCreate_table_options_db2_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_db2_itemContext {
	var p = new(Create_table_options_db2_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item

	return p
}

func (s *Create_table_options_db2_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_db2_itemContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Create_table_options_db2_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_db2_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_db2_itemContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_options_db2_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Create_table_options_db2_itemContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_table_options_db2_itemContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTRIBUTE, 0)
}

func (s *Create_table_options_db2_itemContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Create_table_options_db2_itemContext) T_HASH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HASH, 0)
}

func (s *Create_table_options_db2_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_db2_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_db2_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_options_db2_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_options_db2_itemContext) T_LOGGED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGED, 0)
}

func (s *Create_table_options_db2_itemContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_options_db2_itemContext) T_COMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMPRESS, 0)
}

func (s *Create_table_options_db2_itemContext) T_YES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_YES, 0)
}

func (s *Create_table_options_db2_itemContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_options_db2_itemContext) T_DEFINITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINITION, 0)
}

func (s *Create_table_options_db2_itemContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Create_table_options_db2_itemContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Create_table_options_db2_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_db2_itemContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Create_table_options_db2_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_db2_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_db2_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_db2_item(s)
	}
}

func (s *Create_table_options_db2_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_db2_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_db2_item() (localctx ICreate_table_options_db2_itemContext) {
	localctx = NewCreate_table_options_db2_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, HplsqlParserRULE_create_table_options_db2_item)
	var _la int

	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_INDEX {
			{
				p.SetState(1136)
				p.Match(HplsqlParserT_INDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1139)
			p.Match(HplsqlParserT_IN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1140)
			p.Qident()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1141)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1142)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1143)
			p.Match(HplsqlParserT_DISTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1144)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1145)
			p.Match(HplsqlParserT_HASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1146)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1147)
			p.Qident()
		}
		p.SetState(1152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1148)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1149)
				p.Qident()
			}

			p.SetState(1154)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1155)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1157)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1160)
			p.Match(HplsqlParserT_LOGGED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1161)
			p.Match(HplsqlParserT_COMPRESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1162)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_NO || _la == HplsqlParserT_YES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1163)
			p.Match(HplsqlParserT_DEFINITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1164)
			p.Match(HplsqlParserT_ONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1165)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1166)
			p.Match(HplsqlParserT_RESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1167)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1168)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_td_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_td_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_DATA() antlr.TerminalNode

	// IsCreate_table_options_td_itemContext differentiates from other interfaces.
	IsCreate_table_options_td_itemContext()
}

type Create_table_options_td_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_td_itemContext() *Create_table_options_td_itemContext {
	var p = new(Create_table_options_td_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item
	return p
}

func InitEmptyCreate_table_options_td_itemContext(p *Create_table_options_td_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item
}

func (*Create_table_options_td_itemContext) IsCreate_table_options_td_itemContext() {}

func NewCreate_table_options_td_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_td_itemContext {
	var p = new(Create_table_options_td_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item

	return p
}

func (s *Create_table_options_td_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_td_itemContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_options_td_itemContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_options_td_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_td_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_td_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_td_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_td_itemContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_table_options_td_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_options_td_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_options_td_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Create_table_options_td_itemContext) T_DATA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATA, 0)
}

func (s *Create_table_options_td_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_td_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_td_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_td_item(s)
	}
}

func (s *Create_table_options_td_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_td_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_td_item() (localctx ICreate_table_options_td_itemContext) {
	localctx = NewCreate_table_options_td_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, HplsqlParserRULE_create_table_options_td_item)
	var _la int

	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY, HplsqlParserT_UNIQUE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_UNIQUE {
			{
				p.SetState(1171)
				p.Match(HplsqlParserT_UNIQUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1174)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1175)
			p.Match(HplsqlParserT_INDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1176)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1177)
			p.Qident()
		}
		p.SetState(1182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1178)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1179)
				p.Qident()
			}

			p.SetState(1184)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1185)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1187)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1188)
			p.Match(HplsqlParserT_DATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_hive_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_hive_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Create_table_hive_row_format() ICreate_table_hive_row_formatContext
	T_STORED() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	Qident() IQidentContext

	// IsCreate_table_options_hive_itemContext differentiates from other interfaces.
	IsCreate_table_options_hive_itemContext()
}

type Create_table_options_hive_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_hive_itemContext() *Create_table_options_hive_itemContext {
	var p = new(Create_table_options_hive_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item
	return p
}

func InitEmptyCreate_table_options_hive_itemContext(p *Create_table_options_hive_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item
}

func (*Create_table_options_hive_itemContext) IsCreate_table_options_hive_itemContext() {}

func NewCreate_table_options_hive_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_hive_itemContext {
	var p = new(Create_table_options_hive_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item

	return p
}

func (s *Create_table_options_hive_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_hive_itemContext) Create_table_hive_row_format() ICreate_table_hive_row_formatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_row_formatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_row_formatContext)
}

func (s *Create_table_options_hive_itemContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORED, 0)
}

func (s *Create_table_options_hive_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_options_hive_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_hive_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_hive_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_hive_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_hive_item(s)
	}
}

func (s *Create_table_options_hive_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_hive_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_hive_item() (localctx ICreate_table_options_hive_itemContext) {
	localctx = NewCreate_table_options_hive_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, HplsqlParserRULE_create_table_options_hive_item)
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1191)
			p.Create_table_hive_row_format()
		}

	case HplsqlParserT_STORED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1192)
			p.Match(HplsqlParserT_STORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1193)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1194)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_row_formatContext is an interface to support dynamic dispatch.
type ICreate_table_hive_row_formatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ROW() antlr.TerminalNode
	T_FORMAT() antlr.TerminalNode
	T_DELIMITED() antlr.TerminalNode
	AllCreate_table_hive_row_format_fields() []ICreate_table_hive_row_format_fieldsContext
	Create_table_hive_row_format_fields(i int) ICreate_table_hive_row_format_fieldsContext

	// IsCreate_table_hive_row_formatContext differentiates from other interfaces.
	IsCreate_table_hive_row_formatContext()
}

type Create_table_hive_row_formatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_row_formatContext() *Create_table_hive_row_formatContext {
	var p = new(Create_table_hive_row_formatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format
	return p
}

func InitEmptyCreate_table_hive_row_formatContext(p *Create_table_hive_row_formatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format
}

func (*Create_table_hive_row_formatContext) IsCreate_table_hive_row_formatContext() {}

func NewCreate_table_hive_row_formatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_row_formatContext {
	var p = new(Create_table_hive_row_formatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format

	return p
}

func (s *Create_table_hive_row_formatContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_row_formatContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW, 0)
}

func (s *Create_table_hive_row_formatContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FORMAT, 0)
}

func (s *Create_table_hive_row_formatContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITED, 0)
}

func (s *Create_table_hive_row_formatContext) AllCreate_table_hive_row_format_fields() []ICreate_table_hive_row_format_fieldsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_hive_row_format_fieldsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			tst[i] = t.(ICreate_table_hive_row_format_fieldsContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_row_formatContext) Create_table_hive_row_format_fields(i int) ICreate_table_hive_row_format_fieldsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_row_format_fieldsContext)
}

func (s *Create_table_hive_row_formatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_row_formatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_row_formatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_row_format(s)
	}
}

func (s *Create_table_hive_row_formatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_row_format(s)
	}
}

func (p *HplsqlParser) Create_table_hive_row_format() (localctx ICreate_table_hive_row_formatContext) {
	localctx = NewCreate_table_hive_row_formatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, HplsqlParserRULE_create_table_hive_row_format)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1197)
		p.Match(HplsqlParserT_ROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1198)
		p.Match(HplsqlParserT_FORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1199)
		p.Match(HplsqlParserT_DELIMITED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1200)
				p.Create_table_hive_row_format_fields()
			}

		}
		p.SetState(1205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_row_format_fieldsContext is an interface to support dynamic dispatch.
type ICreate_table_hive_row_format_fieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FIELDS() antlr.TerminalNode
	T_TERMINATED() antlr.TerminalNode
	AllT_BY() []antlr.TerminalNode
	T_BY(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_ESCAPED() antlr.TerminalNode
	T_COLLECTION() antlr.TerminalNode
	T_ITEMS() antlr.TerminalNode
	T_MAP() antlr.TerminalNode
	T_KEYS() antlr.TerminalNode
	T_LINES() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_DEFINED() antlr.TerminalNode
	T_AS() antlr.TerminalNode

	// IsCreate_table_hive_row_format_fieldsContext differentiates from other interfaces.
	IsCreate_table_hive_row_format_fieldsContext()
}

type Create_table_hive_row_format_fieldsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_row_format_fieldsContext() *Create_table_hive_row_format_fieldsContext {
	var p = new(Create_table_hive_row_format_fieldsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields
	return p
}

func InitEmptyCreate_table_hive_row_format_fieldsContext(p *Create_table_hive_row_format_fieldsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields
}

func (*Create_table_hive_row_format_fieldsContext) IsCreate_table_hive_row_format_fieldsContext() {}

func NewCreate_table_hive_row_format_fieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_row_format_fieldsContext {
	var p = new(Create_table_hive_row_format_fieldsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields

	return p
}

func (s *Create_table_hive_row_format_fieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_row_format_fieldsContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIELDS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TERMINATED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) AllT_BY() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_BY)
}

func (s *Create_table_hive_row_format_fieldsContext) T_BY(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, i)
}

func (s *Create_table_hive_row_format_fieldsContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_row_format_fieldsContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_hive_row_format_fieldsContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ESCAPED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECTION, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ITEMS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEYS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LINES, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_row_format_fieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_row_format_fieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_row_format_fields(s)
	}
}

func (s *Create_table_hive_row_format_fieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_row_format_fields(s)
	}
}

func (p *HplsqlParser) Create_table_hive_row_format_fields() (localctx ICreate_table_hive_row_format_fieldsContext) {
	localctx = NewCreate_table_hive_row_format_fieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, HplsqlParserRULE_create_table_hive_row_format_fields)
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_FIELDS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1206)
			p.Match(HplsqlParserT_FIELDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1207)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1208)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1209)
			p.expr(0)
		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1210)
				p.Match(HplsqlParserT_ESCAPED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1211)
				p.Match(HplsqlParserT_BY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1212)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_COLLECTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1215)
			p.Match(HplsqlParserT_COLLECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1216)
			p.Match(HplsqlParserT_ITEMS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1217)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1218)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1219)
			p.expr(0)
		}

	case HplsqlParserT_MAP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1220)
			p.Match(HplsqlParserT_MAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1221)
			p.Match(HplsqlParserT_KEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1222)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1223)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1224)
			p.expr(0)
		}

	case HplsqlParserT_LINES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1225)
			p.Match(HplsqlParserT_LINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1226)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1228)
			p.expr(0)
		}

	case HplsqlParserT_NULL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1229)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1230)
			p.Match(HplsqlParserT_DEFINED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1231)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1232)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_mssql_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_mssql_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	Qident() IQidentContext
	T_TEXTIMAGE_ON() antlr.TerminalNode

	// IsCreate_table_options_mssql_itemContext differentiates from other interfaces.
	IsCreate_table_options_mssql_itemContext()
}

type Create_table_options_mssql_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_mssql_itemContext() *Create_table_options_mssql_itemContext {
	var p = new(Create_table_options_mssql_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item
	return p
}

func InitEmptyCreate_table_options_mssql_itemContext(p *Create_table_options_mssql_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item
}

func (*Create_table_options_mssql_itemContext) IsCreate_table_options_mssql_itemContext() {}

func NewCreate_table_options_mssql_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_mssql_itemContext {
	var p = new(Create_table_options_mssql_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item

	return p
}

func (s *Create_table_options_mssql_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_mssql_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_mssql_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_mssql_itemContext) T_TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEXTIMAGE_ON, 0)
}

func (s *Create_table_options_mssql_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_mssql_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_mssql_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_mssql_item(s)
	}
}

func (s *Create_table_options_mssql_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_mssql_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_mssql_item() (localctx ICreate_table_options_mssql_itemContext) {
	localctx = NewCreate_table_options_mssql_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, HplsqlParserRULE_create_table_options_mssql_item)
	p.SetState(1239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1235)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1236)
			p.Qident()
		}

	case HplsqlParserT_TEXTIMAGE_ON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1237)
			p.Match(HplsqlParserT_TEXTIMAGE_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1238)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_mysql_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_mysql_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AUTO_INCREMENT() antlr.TerminalNode
	Expr() IExprContext
	T_EQUAL() antlr.TerminalNode
	T_COMMENT() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_CHARSET() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_ENGINE() antlr.TerminalNode

	// IsCreate_table_options_mysql_itemContext differentiates from other interfaces.
	IsCreate_table_options_mysql_itemContext()
}

type Create_table_options_mysql_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_mysql_itemContext() *Create_table_options_mysql_itemContext {
	var p = new(Create_table_options_mysql_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item
	return p
}

func InitEmptyCreate_table_options_mysql_itemContext(p *Create_table_options_mysql_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item
}

func (*Create_table_options_mysql_itemContext) IsCreate_table_options_mysql_itemContext() {}

func NewCreate_table_options_mysql_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_mysql_itemContext {
	var p = new(Create_table_options_mysql_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item

	return p
}

func (s *Create_table_options_mysql_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_mysql_itemContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Create_table_options_mysql_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_options_mysql_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Create_table_options_mysql_itemContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_table_options_mysql_itemContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Create_table_options_mysql_itemContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_table_options_mysql_itemContext) T_CHARSET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARSET, 0)
}

func (s *Create_table_options_mysql_itemContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Create_table_options_mysql_itemContext) T_ENGINE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENGINE, 0)
}

func (s *Create_table_options_mysql_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_mysql_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_mysql_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_mysql_item(s)
	}
}

func (s *Create_table_options_mysql_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_mysql_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_mysql_item() (localctx ICreate_table_options_mysql_itemContext) {
	localctx = NewCreate_table_options_mysql_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, HplsqlParserRULE_create_table_options_mysql_item)
	var _la int

	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AUTO_INCREMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1241)
			p.Match(HplsqlParserT_AUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1242)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1245)
			p.expr(0)
		}

	case HplsqlParserT_COMMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1246)
			p.Match(HplsqlParserT_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1247)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1250)
			p.expr(0)
		}

	case HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_DEFAULT:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1252)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_DEFAULT {
			{
				p.SetState(1251)
				p.Match(HplsqlParserT_DEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_CHARACTER:
			{
				p.SetState(1254)
				p.Match(HplsqlParserT_CHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1255)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_CHARSET:
			{
				p.SetState(1256)
				p.Match(HplsqlParserT_CHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1259)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1262)
			p.expr(0)
		}

	case HplsqlParserT_ENGINE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1263)
			p.Match(HplsqlParserT_ENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1264)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1267)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Alter_table_item() IAlter_table_itemContext

	// IsAlter_table_stmtContext differentiates from other interfaces.
	IsAlter_table_stmtContext()
}

type Alter_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_stmtContext() *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt
	return p
}

func InitEmptyAlter_table_stmtContext(p *Alter_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt
}

func (*Alter_table_stmtContext) IsAlter_table_stmtContext() {}

func NewAlter_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt

	return p
}

func (s *Alter_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Alter_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Alter_table_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Alter_table_stmtContext) Alter_table_item() IAlter_table_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_itemContext)
}

func (s *Alter_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_stmt(s)
	}
}

func (s *Alter_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_stmt(s)
	}
}

func (p *HplsqlParser) Alter_table_stmt() (localctx IAlter_table_stmtContext) {
	localctx = NewAlter_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, HplsqlParserRULE_alter_table_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Match(HplsqlParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1271)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1272)
		p.Table_name()
	}
	{
		p.SetState(1273)
		p.Alter_table_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_itemContext is an interface to support dynamic dispatch.
type IAlter_table_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_constraint() IAlter_table_add_constraintContext

	// IsAlter_table_itemContext differentiates from other interfaces.
	IsAlter_table_itemContext()
}

type Alter_table_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_itemContext() *Alter_table_itemContext {
	var p = new(Alter_table_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_item
	return p
}

func InitEmptyAlter_table_itemContext(p *Alter_table_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_item
}

func (*Alter_table_itemContext) IsAlter_table_itemContext() {}

func NewAlter_table_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_itemContext {
	var p = new(Alter_table_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_item

	return p
}

func (s *Alter_table_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_itemContext) Alter_table_add_constraint() IAlter_table_add_constraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_constraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_constraintContext)
}

func (s *Alter_table_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_item(s)
	}
}

func (s *Alter_table_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_item(s)
	}
}

func (p *HplsqlParser) Alter_table_item() (localctx IAlter_table_itemContext) {
	localctx = NewAlter_table_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, HplsqlParserRULE_alter_table_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1275)
		p.Alter_table_add_constraint()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_constraintContext is an interface to support dynamic dispatch.
type IAlter_table_add_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ADD2() antlr.TerminalNode
	Alter_table_add_constraint_item() IAlter_table_add_constraint_itemContext
	T_CONSTRAINT() antlr.TerminalNode
	Qident() IQidentContext

	// IsAlter_table_add_constraintContext differentiates from other interfaces.
	IsAlter_table_add_constraintContext()
}

type Alter_table_add_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_constraintContext() *Alter_table_add_constraintContext {
	var p = new(Alter_table_add_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint
	return p
}

func InitEmptyAlter_table_add_constraintContext(p *Alter_table_add_constraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint
}

func (*Alter_table_add_constraintContext) IsAlter_table_add_constraintContext() {}

func NewAlter_table_add_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_constraintContext {
	var p = new(Alter_table_add_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint

	return p
}

func (s *Alter_table_add_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_constraintContext) T_ADD2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD2, 0)
}

func (s *Alter_table_add_constraintContext) Alter_table_add_constraint_item() IAlter_table_add_constraint_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_constraint_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_constraint_itemContext)
}

func (s *Alter_table_add_constraintContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Alter_table_add_constraintContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Alter_table_add_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_add_constraint(s)
	}
}

func (s *Alter_table_add_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_add_constraint(s)
	}
}

func (p *HplsqlParser) Alter_table_add_constraint() (localctx IAlter_table_add_constraintContext) {
	localctx = NewAlter_table_add_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, HplsqlParserRULE_alter_table_add_constraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1277)
		p.Match(HplsqlParserT_ADD2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_CONSTRAINT {
		{
			p.SetState(1278)
			p.Match(HplsqlParserT_CONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1279)
			p.Qident()
		}

	}
	{
		p.SetState(1282)
		p.Alter_table_add_constraint_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_constraint_itemContext is an interface to support dynamic dispatch.
type IAlter_table_add_constraint_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	Index_storage_clause() IIndex_storage_clauseContext
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext
	T_DEFAULT() antlr.TerminalNode
	Expr() IExprContext
	T_FOR() antlr.TerminalNode

	// IsAlter_table_add_constraint_itemContext differentiates from other interfaces.
	IsAlter_table_add_constraint_itemContext()
}

type Alter_table_add_constraint_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_constraint_itemContext() *Alter_table_add_constraint_itemContext {
	var p = new(Alter_table_add_constraint_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item
	return p
}

func InitEmptyAlter_table_add_constraint_itemContext(p *Alter_table_add_constraint_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item
}

func (*Alter_table_add_constraint_itemContext) IsAlter_table_add_constraint_itemContext() {}

func NewAlter_table_add_constraint_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_constraint_itemContext {
	var p = new(Alter_table_add_constraint_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item

	return p
}

func (s *Alter_table_add_constraint_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_constraint_itemContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Alter_table_add_constraint_itemContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Alter_table_add_constraint_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Alter_table_add_constraint_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Alter_table_add_constraint_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_add_constraint_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Alter_table_add_constraint_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Alter_table_add_constraint_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Alter_table_add_constraint_itemContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Alter_table_add_constraint_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Alter_table_add_constraint_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Alter_table_add_constraint_itemContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Alter_table_add_constraint_itemContext) Index_storage_clause() IIndex_storage_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_storage_clauseContext)
}

func (s *Alter_table_add_constraint_itemContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Alter_table_add_constraint_itemContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Alter_table_add_constraint_itemContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Alter_table_add_constraint_itemContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Alter_table_add_constraint_itemContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Alter_table_add_constraint_itemContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Alter_table_add_constraint_itemContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Alter_table_add_constraint_itemContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_add_constraint_itemContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Alter_table_add_constraint_itemContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Alter_table_add_constraint_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Alter_table_add_constraint_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Alter_table_add_constraint_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_constraint_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_constraint_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_add_constraint_item(s)
	}
}

func (s *Alter_table_add_constraint_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_add_constraint_item(s)
	}
}

func (p *HplsqlParser) Alter_table_add_constraint_item() (localctx IAlter_table_add_constraint_itemContext) {
	localctx = NewAlter_table_add_constraint_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, HplsqlParserRULE_alter_table_add_constraint_item)
	var _la int

	var _alt int

	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1284)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1285)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CLUSTERED {
			{
				p.SetState(1286)
				p.Match(HplsqlParserT_CLUSTERED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1289)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1290)
			p.Qident()
		}
		p.SetState(1292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
			{
				p.SetState(1291)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1294)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1295)
				p.Qident()
			}
			p.SetState(1297)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
				{
					p.SetState(1296)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

			p.SetState(1303)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1304)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1306)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1305)
				p.Match(HplsqlParserT_ENABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1308)
				p.Index_storage_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_FOREIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1311)
			p.Match(HplsqlParserT_FOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1313)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.Qident()
		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1315)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1316)
				p.Qident()
			}

			p.SetState(1321)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1322)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1323)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1324)
			p.Table_name()
		}
		{
			p.SetState(1325)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)
			p.Qident()
		}
		p.SetState(1331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1327)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1328)
				p.Qident()
			}

			p.SetState(1333)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1334)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1335)
					p.Create_table_fk_action()
				}

			}
			p.SetState(1340)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case HplsqlParserT_DEFAULT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1341)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1342)
			p.expr(0)
		}
		{
			p.SetState(1343)
			p.Match(HplsqlParserT_FOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1344)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtypeContext is an interface to support dynamic dispatch.
type IDtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BINARY_INTEGER() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_PLS_INTEGER() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_INTEGER() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TINYINT() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	Qident() IQidentContext
	T_TYPE() antlr.TerminalNode
	T_ROWTYPE() antlr.TerminalNode

	// IsDtypeContext differentiates from other interfaces.
	IsDtypeContext()
}

type DtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtypeContext() *DtypeContext {
	var p = new(DtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype
	return p
}

func InitEmptyDtypeContext(p *DtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype
}

func (*DtypeContext) IsDtypeContext() {}

func NewDtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtypeContext {
	var p = new(DtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype

	return p
}

func (s *DtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DtypeContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *DtypeContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *DtypeContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIGINT, 0)
}

func (s *DtypeContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_DOUBLE, 0)
}

func (s *DtypeContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_FLOAT, 0)
}

func (s *DtypeContext) T_BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_INTEGER, 0)
}

func (s *DtypeContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIT, 0)
}

func (s *DtypeContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *DtypeContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATETIME, 0)
}

func (s *DtypeContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEC, 0)
}

func (s *DtypeContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECIMAL, 0)
}

func (s *DtypeContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOUBLE, 0)
}

func (s *DtypeContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRECISION, 0)
}

func (s *DtypeContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FLOAT, 0)
}

func (s *DtypeContext) T_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT, 0)
}

func (s *DtypeContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT2, 0)
}

func (s *DtypeContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT4, 0)
}

func (s *DtypeContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT8, 0)
}

func (s *DtypeContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTEGER, 0)
}

func (s *DtypeContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NCHAR, 0)
}

func (s *DtypeContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NVARCHAR, 0)
}

func (s *DtypeContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMBER, 0)
}

func (s *DtypeContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMERIC, 0)
}

func (s *DtypeContext) T_PLS_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PLS_INTEGER, 0)
}

func (s *DtypeContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REAL, 0)
}

func (s *DtypeContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT_SET_LOCATOR, 0)
}

func (s *DtypeContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARYING, 0)
}

func (s *DtypeContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_FLOAT, 0)
}

func (s *DtypeContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_DOUBLE, 0)
}

func (s *DtypeContext) T_SIMPLE_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_INTEGER, 0)
}

func (s *DtypeContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLINT, 0)
}

func (s *DtypeContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLDATETIME, 0)
}

func (s *DtypeContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STRING, 0)
}

func (s *DtypeContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYS_REFCURSOR, 0)
}

func (s *DtypeContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *DtypeContext) T_TINYINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TINYINT, 0)
}

func (s *DtypeContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR, 0)
}

func (s *DtypeContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR2, 0)
}

func (s *DtypeContext) T_XML() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XML, 0)
}

func (s *DtypeContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *DtypeContext) T_TYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TYPE, 0)
}

func (s *DtypeContext) T_ROWTYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWTYPE, 0)
}

func (s *DtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype(s)
	}
}

func (s *DtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype(s)
	}
}

func (p *HplsqlParser) Dtype() (localctx IDtypeContext) {
	localctx = NewDtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, HplsqlParserRULE_dtype)
	var _la int

	p.SetState(1394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1348)
			p.Match(HplsqlParserT_CHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1349)
			p.Match(HplsqlParserT_CHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1350)
			p.Match(HplsqlParserT_BIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1351)
			p.Match(HplsqlParserT_BINARY_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1352)
			p.Match(HplsqlParserT_BINARY_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1353)
			p.Match(HplsqlParserT_BINARY_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1354)
			p.Match(HplsqlParserT_BIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1355)
			p.Match(HplsqlParserT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1356)
			p.Match(HplsqlParserT_DATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1357)
			p.Match(HplsqlParserT_DEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1358)
			p.Match(HplsqlParserT_DECIMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1359)
			p.Match(HplsqlParserT_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1361)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1360)
				p.Match(HplsqlParserT_PRECISION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1363)
			p.Match(HplsqlParserT_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1364)
			p.Match(HplsqlParserT_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1365)
			p.Match(HplsqlParserT_INT2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1366)
			p.Match(HplsqlParserT_INT4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1367)
			p.Match(HplsqlParserT_INT8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1368)
			p.Match(HplsqlParserT_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1369)
			p.Match(HplsqlParserT_NCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1370)
			p.Match(HplsqlParserT_NVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1371)
			p.Match(HplsqlParserT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1372)
			p.Match(HplsqlParserT_NUMERIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1373)
			p.Match(HplsqlParserT_PLS_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1374)
			p.Match(HplsqlParserT_REAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1375)
			p.Match(HplsqlParserT_RESULT_SET_LOCATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1376)
			p.Match(HplsqlParserT_VARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1377)
			p.Match(HplsqlParserT_SIMPLE_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1378)
			p.Match(HplsqlParserT_SIMPLE_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1379)
			p.Match(HplsqlParserT_SIMPLE_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1380)
			p.Match(HplsqlParserT_SMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1381)
			p.Match(HplsqlParserT_SMALLDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1382)
			p.Match(HplsqlParserT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1383)
			p.Match(HplsqlParserT_SYS_REFCURSOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1384)
			p.Match(HplsqlParserT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1385)
			p.Match(HplsqlParserT_TINYINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1386)
			p.Match(HplsqlParserT_VARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1387)
			p.Match(HplsqlParserT_VARCHAR2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1388)
			p.Match(HplsqlParserT_XML)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1389)
			p.Qident()
		}
		p.SetState(1392)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1390)
				p.Match(HplsqlParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1391)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ROWTYPE || _la == HplsqlParserT_TYPE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtype_lenContext is an interface to support dynamic dispatch.
type IDtype_lenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_COMMA() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode

	// IsDtype_lenContext differentiates from other interfaces.
	IsDtype_lenContext()
}

type Dtype_lenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_lenContext() *Dtype_lenContext {
	var p = new(Dtype_lenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_len
	return p
}

func InitEmptyDtype_lenContext(p *Dtype_lenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_len
}

func (*Dtype_lenContext) IsDtype_lenContext() {}

func NewDtype_lenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_lenContext {
	var p = new(Dtype_lenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_len

	return p
}

func (s *Dtype_lenContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_lenContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Dtype_lenContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Dtype_lenContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Dtype_lenContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Dtype_lenContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Dtype_lenContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Dtype_lenContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Dtype_lenContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BYTE, 0)
}

func (s *Dtype_lenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_lenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dtype_lenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_len(s)
	}
}

func (s *Dtype_lenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_len(s)
	}
}

func (p *HplsqlParser) Dtype_len() (localctx IDtype_lenContext) {
	localctx = NewDtype_lenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, HplsqlParserRULE_dtype_len)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1396)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1397)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_MAX || _la == HplsqlParserL_INT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR {
		{
			p.SetState(1398)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMA {
		{
			p.SetState(1401)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1405)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtype_attrContext is an interface to support dynamic dispatch.
type IDtype_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	Ident() IIdentContext
	T_CASESPECIFIC() antlr.TerminalNode
	T_CS() antlr.TerminalNode

	// IsDtype_attrContext differentiates from other interfaces.
	IsDtype_attrContext()
}

type Dtype_attrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_attrContext() *Dtype_attrContext {
	var p = new(Dtype_attrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_attr
	return p
}

func InitEmptyDtype_attrContext(p *Dtype_attrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_attr
}

func (*Dtype_attrContext) IsDtype_attrContext() {}

func NewDtype_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_attrContext {
	var p = new(Dtype_attrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_attr

	return p
}

func (s *Dtype_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_attrContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Dtype_attrContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Dtype_attrContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Dtype_attrContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Dtype_attrContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Dtype_attrContext) T_CASESPECIFIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASESPECIFIC, 0)
}

func (s *Dtype_attrContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Dtype_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dtype_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_attr(s)
	}
}

func (s *Dtype_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_attr(s)
	}
}

func (p *HplsqlParser) Dtype_attr() (localctx IDtype_attrContext) {
	localctx = NewDtype_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, HplsqlParserRULE_dtype_attr)
	var _la int

	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1407)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1410)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1411)
			p.Match(HplsqlParserT_CHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1413)
			p.Ident()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1415)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1414)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1417)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CASESPECIFIC || _la == HplsqlParserT_CS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtype_defaultContext is an interface to support dynamic dispatch.
type IDtype_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext
	T_COLON() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_WITH() antlr.TerminalNode

	// IsDtype_defaultContext differentiates from other interfaces.
	IsDtype_defaultContext()
}

type Dtype_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_defaultContext() *Dtype_defaultContext {
	var p = new(Dtype_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_default
	return p
}

func InitEmptyDtype_defaultContext(p *Dtype_defaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_default
}

func (*Dtype_defaultContext) IsDtype_defaultContext() {}

func NewDtype_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_defaultContext {
	var p = new(Dtype_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_default

	return p
}

func (s *Dtype_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_defaultContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Dtype_defaultContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Dtype_defaultContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Dtype_defaultContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Dtype_defaultContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Dtype_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dtype_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_default(s)
	}
}

func (s *Dtype_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_default(s)
	}
}

func (p *HplsqlParser) Dtype_default() (localctx IDtype_defaultContext) {
	localctx = NewDtype_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, HplsqlParserRULE_dtype_default)
	var _la int

	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COLON, HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COLON {
			{
				p.SetState(1420)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1423)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1424)
			p.expr(0)
		}

	case HplsqlParserT_DEFAULT, HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_WITH {
			{
				p.SetState(1425)
				p.Match(HplsqlParserT_WITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1428)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1430)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1429)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_database_stmtContext is an interface to support dynamic dispatch.
type ICreate_database_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	Expr() IExprContext
	T_DATABASE() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	AllCreate_database_option() []ICreate_database_optionContext
	Create_database_option(i int) ICreate_database_optionContext

	// IsCreate_database_stmtContext differentiates from other interfaces.
	IsCreate_database_stmtContext()
}

type Create_database_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_database_stmtContext() *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_stmt
	return p
}

func InitEmptyCreate_database_stmtContext(p *Create_database_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_stmt
}

func (*Create_database_stmtContext) IsCreate_database_stmtContext() {}

func NewCreate_database_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_database_stmt

	return p
}

func (s *Create_database_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_database_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_database_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_database_stmtContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Create_database_stmtContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Create_database_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Create_database_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_database_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Create_database_stmtContext) AllCreate_database_option() []ICreate_database_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_database_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_database_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_database_optionContext); ok {
			tst[i] = t.(ICreate_database_optionContext)
			i++
		}
	}

	return tst
}

func (s *Create_database_stmtContext) Create_database_option(i int) ICreate_database_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_database_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_database_optionContext)
}

func (s *Create_database_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_database_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_database_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_database_stmt(s)
	}
}

func (s *Create_database_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_database_stmt(s)
	}
}

func (p *HplsqlParser) Create_database_stmt() (localctx ICreate_database_stmtContext) {
	localctx = NewCreate_database_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, HplsqlParserRULE_create_database_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1434)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1435)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DATABASE || _la == HplsqlParserT_SCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1436)
			p.Match(HplsqlParserT_IF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1437)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1438)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1441)
		p.expr(0)
	}
	p.SetState(1445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1442)
				p.Create_database_option()
			}

		}
		p.SetState(1447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_database_optionContext is an interface to support dynamic dispatch.
type ICreate_database_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	Expr() IExprContext
	T_LOCATION() antlr.TerminalNode

	// IsCreate_database_optionContext differentiates from other interfaces.
	IsCreate_database_optionContext()
}

type Create_database_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_database_optionContext() *Create_database_optionContext {
	var p = new(Create_database_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_option
	return p
}

func InitEmptyCreate_database_optionContext(p *Create_database_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_option
}

func (*Create_database_optionContext) IsCreate_database_optionContext() {}

func NewCreate_database_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_database_optionContext {
	var p = new(Create_database_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_database_option

	return p
}

func (s *Create_database_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_database_optionContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_database_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_database_optionContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATION, 0)
}

func (s *Create_database_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_database_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_database_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_database_option(s)
	}
}

func (s *Create_database_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_database_option(s)
	}
}

func (p *HplsqlParser) Create_database_option() (localctx ICreate_database_optionContext) {
	localctx = NewCreate_database_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, HplsqlParserRULE_create_database_option)
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1448)
			p.Match(HplsqlParserT_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1449)
			p.expr(0)
		}

	case HplsqlParserT_LOCATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1450)
			p.Match(HplsqlParserT_LOCATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1451)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_function_stmtContext is an interface to support dynamic dispatch.
type ICreate_function_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FUNCTION() antlr.TerminalNode
	Ident() IIdentContext
	Create_function_return() ICreate_function_returnContext
	Single_block_stmt() ISingle_block_stmtContext
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	Create_routine_params() ICreate_routine_paramsContext
	Declare_block_inplace() IDeclare_block_inplaceContext
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_function_stmtContext differentiates from other interfaces.
	IsCreate_function_stmtContext()
}

type Create_function_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_stmtContext() *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_stmt
	return p
}

func InitEmptyCreate_function_stmtContext(p *Create_function_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_stmt
}

func (*Create_function_stmtContext) IsCreate_function_stmtContext() {}

func NewCreate_function_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_function_stmt

	return p
}

func (s *Create_function_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_stmtContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Create_function_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_function_stmtContext) Create_function_return() ICreate_function_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_returnContext)
}

func (s *Create_function_stmtContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *Create_function_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_function_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_function_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_function_stmtContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Create_function_stmtContext) Declare_block_inplace() IDeclare_block_inplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_block_inplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_block_inplaceContext)
}

func (s *Create_function_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_function_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_function_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_function_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_function_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_function_stmt(s)
	}
}

func (s *Create_function_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_function_stmt(s)
	}
}

func (p *HplsqlParser) Create_function_stmt() (localctx ICreate_function_stmtContext) {
	localctx = NewCreate_function_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, HplsqlParserRULE_create_function_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1454)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1455)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1456)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1457)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1460)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_FUNCTION:

	default:
	}
	{
		p.SetState(1463)
		p.Match(HplsqlParserT_FUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1464)
		p.Ident()
	}
	p.SetState(1466)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1465)
			p.Create_routine_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1468)
		p.Create_function_return()
	}
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1469)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1472)
			p.Declare_block_inplace()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1475)
		p.Single_block_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_function_returnContext is an interface to support dynamic dispatch.
type ICreate_function_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dtype() IDtypeContext
	T_RETURN() antlr.TerminalNode
	T_RETURNS() antlr.TerminalNode
	Dtype_len() IDtype_lenContext

	// IsCreate_function_returnContext differentiates from other interfaces.
	IsCreate_function_returnContext()
}

type Create_function_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_returnContext() *Create_function_returnContext {
	var p = new(Create_function_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_return
	return p
}

func InitEmptyCreate_function_returnContext(p *Create_function_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_return
}

func (*Create_function_returnContext) IsCreate_function_returnContext() {}

func NewCreate_function_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_returnContext {
	var p = new(Create_function_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_function_return

	return p
}

func (s *Create_function_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_returnContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_function_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Create_function_returnContext) T_RETURNS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURNS, 0)
}

func (s *Create_function_returnContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_function_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_function_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_function_return(s)
	}
}

func (s *Create_function_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_function_return(s)
	}
}

func (p *HplsqlParser) Create_function_return() (localctx ICreate_function_returnContext) {
	localctx = NewCreate_function_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, HplsqlParserRULE_create_function_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_RETURN || _la == HplsqlParserT_RETURNS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1478)
		p.Dtype()
	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1479)
			p.Dtype_len()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_package_stmtContext is an interface to support dynamic dispatch.
type ICreate_package_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PACKAGE() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Package_spec() IPackage_specContext
	T_END() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_SEMICOLON() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_package_stmtContext differentiates from other interfaces.
	IsCreate_package_stmtContext()
}

type Create_package_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_package_stmtContext() *Create_package_stmtContext {
	var p = new(Create_package_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_stmt
	return p
}

func InitEmptyCreate_package_stmtContext(p *Create_package_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_stmt
}

func (*Create_package_stmtContext) IsCreate_package_stmtContext() {}

func NewCreate_package_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_package_stmtContext {
	var p = new(Create_package_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_package_stmt

	return p
}

func (s *Create_package_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_package_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Create_package_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_package_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_package_stmtContext) Package_spec() IPackage_specContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_specContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_specContext)
}

func (s *Create_package_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Create_package_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_package_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_package_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_package_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_package_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_package_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_package_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_package_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_package_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_package_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_package_stmt(s)
	}
}

func (s *Create_package_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_package_stmt(s)
	}
}

func (p *HplsqlParser) Create_package_stmt() (localctx ICreate_package_stmtContext) {
	localctx = NewCreate_package_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, HplsqlParserRULE_create_package_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1482)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1483)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1484)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1485)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1488)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PACKAGE:

	default:
	}
	{
		p.SetState(1491)
		p.Match(HplsqlParserT_PACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1492)
		p.Ident()
	}
	{
		p.SetState(1493)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1494)
		p.Package_spec()
	}
	{
		p.SetState(1495)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1499)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1496)
			p.Ident()
		}
		{
			p.SetState(1497)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_specContext is an interface to support dynamic dispatch.
type IPackage_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPackage_spec_item() []IPackage_spec_itemContext
	Package_spec_item(i int) IPackage_spec_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsPackage_specContext differentiates from other interfaces.
	IsPackage_specContext()
}

type Package_specContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_specContext() *Package_specContext {
	var p = new(Package_specContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec
	return p
}

func InitEmptyPackage_specContext(p *Package_specContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec
}

func (*Package_specContext) IsPackage_specContext() {}

func NewPackage_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_specContext {
	var p = new(Package_specContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_spec

	return p
}

func (s *Package_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_specContext) AllPackage_spec_item() []IPackage_spec_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackage_spec_itemContext); ok {
			len++
		}
	}

	tst := make([]IPackage_spec_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackage_spec_itemContext); ok {
			tst[i] = t.(IPackage_spec_itemContext)
			i++
		}
	}

	return tst
}

func (s *Package_specContext) Package_spec_item(i int) IPackage_spec_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_spec_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_spec_itemContext)
}

func (s *Package_specContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Package_specContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Package_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_spec(s)
	}
}

func (s *Package_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_spec(s)
	}
}

func (p *HplsqlParser) Package_spec() (localctx IPackage_specContext) {
	localctx = NewPackage_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, HplsqlParserRULE_package_spec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1501)
		p.Package_spec_item()
	}
	{
		p.SetState(1502)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-33554464) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-24696061953) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-36028797018963969) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-9007199271518737) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-864744042452222977) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&6755399708459007) != 0) {
		{
			p.SetState(1503)
			p.Package_spec_item()
		}
		{
			p.SetState(1504)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_spec_itemContext is an interface to support dynamic dispatch.
type IPackage_spec_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_stmt_item() IDeclare_stmt_itemContext
	T_FUNCTION() antlr.TerminalNode
	Ident() IIdentContext
	Create_function_return() ICreate_function_returnContext
	Create_routine_params() ICreate_routine_paramsContext
	T_PROCEDURE() antlr.TerminalNode
	T_PROC() antlr.TerminalNode

	// IsPackage_spec_itemContext differentiates from other interfaces.
	IsPackage_spec_itemContext()
}

type Package_spec_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_spec_itemContext() *Package_spec_itemContext {
	var p = new(Package_spec_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec_item
	return p
}

func InitEmptyPackage_spec_itemContext(p *Package_spec_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec_item
}

func (*Package_spec_itemContext) IsPackage_spec_itemContext() {}

func NewPackage_spec_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_spec_itemContext {
	var p = new(Package_spec_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_spec_item

	return p
}

func (s *Package_spec_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_spec_itemContext) Declare_stmt_item() IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Package_spec_itemContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Package_spec_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Package_spec_itemContext) Create_function_return() ICreate_function_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_returnContext)
}

func (s *Package_spec_itemContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Package_spec_itemContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Package_spec_itemContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Package_spec_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_spec_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_spec_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_spec_item(s)
	}
}

func (s *Package_spec_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_spec_item(s)
	}
}

func (p *HplsqlParser) Package_spec_item() (localctx IPackage_spec_itemContext) {
	localctx = NewPackage_spec_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, HplsqlParserRULE_package_spec_item)
	var _la int

	p.SetState(1524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1511)
			p.Declare_stmt_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1512)
			p.Match(HplsqlParserT_FUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1513)
			p.Ident()
		}
		p.SetState(1515)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1514)
				p.Create_routine_params()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1517)
			p.Create_function_return()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1519)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_PROC || _la == HplsqlParserT_PROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1520)
			p.Ident()
		}
		p.SetState(1522)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1521)
				p.Create_routine_params()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_package_body_stmtContext is an interface to support dynamic dispatch.
type ICreate_package_body_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PACKAGE() antlr.TerminalNode
	T_BODY() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Package_body() IPackage_bodyContext
	T_END() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_SEMICOLON() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_package_body_stmtContext differentiates from other interfaces.
	IsCreate_package_body_stmtContext()
}

type Create_package_body_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_package_body_stmtContext() *Create_package_body_stmtContext {
	var p = new(Create_package_body_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt
	return p
}

func InitEmptyCreate_package_body_stmtContext(p *Create_package_body_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt
}

func (*Create_package_body_stmtContext) IsCreate_package_body_stmtContext() {}

func NewCreate_package_body_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_package_body_stmtContext {
	var p = new(Create_package_body_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt

	return p
}

func (s *Create_package_body_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_package_body_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Create_package_body_stmtContext) T_BODY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BODY, 0)
}

func (s *Create_package_body_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_package_body_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_package_body_stmtContext) Package_body() IPackage_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_bodyContext)
}

func (s *Create_package_body_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Create_package_body_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_package_body_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_package_body_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_package_body_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_package_body_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_package_body_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_package_body_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_package_body_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_package_body_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_package_body_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_package_body_stmt(s)
	}
}

func (s *Create_package_body_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_package_body_stmt(s)
	}
}

func (p *HplsqlParser) Create_package_body_stmt() (localctx ICreate_package_body_stmtContext) {
	localctx = NewCreate_package_body_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, HplsqlParserRULE_create_package_body_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1526)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1527)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1528)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1529)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1532)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PACKAGE:

	default:
	}
	{
		p.SetState(1535)
		p.Match(HplsqlParserT_PACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1536)
		p.Match(HplsqlParserT_BODY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1537)
		p.Ident()
	}
	{
		p.SetState(1538)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1539)
		p.Package_body()
	}
	{
		p.SetState(1540)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1541)
			p.Ident()
		}
		{
			p.SetState(1542)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_bodyContext is an interface to support dynamic dispatch.
type IPackage_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPackage_body_item() []IPackage_body_itemContext
	Package_body_item(i int) IPackage_body_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsPackage_bodyContext differentiates from other interfaces.
	IsPackage_bodyContext()
}

type Package_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_bodyContext() *Package_bodyContext {
	var p = new(Package_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body
	return p
}

func InitEmptyPackage_bodyContext(p *Package_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body
}

func (*Package_bodyContext) IsPackage_bodyContext() {}

func NewPackage_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_bodyContext {
	var p = new(Package_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_body

	return p
}

func (s *Package_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_bodyContext) AllPackage_body_item() []IPackage_body_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackage_body_itemContext); ok {
			len++
		}
	}

	tst := make([]IPackage_body_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackage_body_itemContext); ok {
			tst[i] = t.(IPackage_body_itemContext)
			i++
		}
	}

	return tst
}

func (s *Package_bodyContext) Package_body_item(i int) IPackage_body_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_body_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_body_itemContext)
}

func (s *Package_bodyContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Package_bodyContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Package_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_body(s)
	}
}

func (s *Package_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_body(s)
	}
}

func (p *HplsqlParser) Package_body() (localctx IPackage_bodyContext) {
	localctx = NewPackage_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, HplsqlParserRULE_package_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1546)
		p.Package_body_item()
	}
	{
		p.SetState(1547)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-33554464) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-24696061953) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-36028797018963969) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-9007199271518737) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-864744042452222977) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&6755399708459007) != 0) {
		{
			p.SetState(1548)
			p.Package_body_item()
		}
		{
			p.SetState(1549)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_body_itemContext is an interface to support dynamic dispatch.
type IPackage_body_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_stmt_item() IDeclare_stmt_itemContext
	Create_function_stmt() ICreate_function_stmtContext
	Create_procedure_stmt() ICreate_procedure_stmtContext

	// IsPackage_body_itemContext differentiates from other interfaces.
	IsPackage_body_itemContext()
}

type Package_body_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_body_itemContext() *Package_body_itemContext {
	var p = new(Package_body_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body_item
	return p
}

func InitEmptyPackage_body_itemContext(p *Package_body_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body_item
}

func (*Package_body_itemContext) IsPackage_body_itemContext() {}

func NewPackage_body_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_body_itemContext {
	var p = new(Package_body_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_body_item

	return p
}

func (s *Package_body_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_body_itemContext) Declare_stmt_item() IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Package_body_itemContext) Create_function_stmt() ICreate_function_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_stmtContext)
}

func (s *Package_body_itemContext) Create_procedure_stmt() ICreate_procedure_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_procedure_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_procedure_stmtContext)
}

func (s *Package_body_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_body_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_body_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_body_item(s)
	}
}

func (s *Package_body_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_body_item(s)
	}
}

func (p *HplsqlParser) Package_body_item() (localctx IPackage_body_itemContext) {
	localctx = NewPackage_body_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, HplsqlParserRULE_package_body_item)
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1556)
			p.Declare_stmt_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1557)
			p.Create_function_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1558)
			p.Create_procedure_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_procedure_stmtContext is an interface to support dynamic dispatch.
type ICreate_procedure_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Proc_block() IProc_blockContext
	T_PROCEDURE() antlr.TerminalNode
	T_PROC() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	Create_routine_params() ICreate_routine_paramsContext
	Create_routine_options() ICreate_routine_optionsContext
	Declare_block_inplace() IDeclare_block_inplaceContext
	Label() ILabelContext
	T_SEMICOLON() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_procedure_stmtContext differentiates from other interfaces.
	IsCreate_procedure_stmtContext()
}

type Create_procedure_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_procedure_stmtContext() *Create_procedure_stmtContext {
	var p = new(Create_procedure_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt
	return p
}

func InitEmptyCreate_procedure_stmtContext(p *Create_procedure_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt
}

func (*Create_procedure_stmtContext) IsCreate_procedure_stmtContext() {}

func NewCreate_procedure_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_procedure_stmtContext {
	var p = new(Create_procedure_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt

	return p
}

func (s *Create_procedure_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_procedure_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_procedure_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_procedure_stmtContext) Proc_block() IProc_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProc_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProc_blockContext)
}

func (s *Create_procedure_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Create_procedure_stmtContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Create_procedure_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_procedure_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_procedure_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_procedure_stmtContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Create_procedure_stmtContext) Create_routine_options() ICreate_routine_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_optionsContext)
}

func (s *Create_procedure_stmtContext) Declare_block_inplace() IDeclare_block_inplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_block_inplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_block_inplaceContext)
}

func (s *Create_procedure_stmtContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *Create_procedure_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_procedure_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_procedure_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_procedure_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_procedure_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_procedure_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_procedure_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_procedure_stmt(s)
	}
}

func (s *Create_procedure_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_procedure_stmt(s)
	}
}

func (p *HplsqlParser) Create_procedure_stmt() (localctx ICreate_procedure_stmtContext) {
	localctx = NewCreate_procedure_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, HplsqlParserRULE_create_procedure_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1561)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1562)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1563)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1564)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1567)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PROC, HplsqlParserT_PROCEDURE:

	default:
	}
	{
		p.SetState(1570)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_PROC || _la == HplsqlParserT_PROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1571)
		p.Ident()
	}
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1572)
			p.Create_routine_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1576)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1575)
			p.Create_routine_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1578)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1581)
			p.Declare_block_inplace()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1585)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1584)
			p.Label()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1587)
		p.Proc_block()
	}
	p.SetState(1591)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1588)
			p.Ident()
		}
		{
			p.SetState(1589)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_paramsContext is an interface to support dynamic dispatch.
type ICreate_routine_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllCreate_routine_param_item() []ICreate_routine_param_itemContext
	Create_routine_param_item(i int) ICreate_routine_param_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_routine_paramsContext differentiates from other interfaces.
	IsCreate_routine_paramsContext()
}

type Create_routine_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_paramsContext() *Create_routine_paramsContext {
	var p = new(Create_routine_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_params
	return p
}

func InitEmptyCreate_routine_paramsContext(p *Create_routine_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_params
}

func (*Create_routine_paramsContext) IsCreate_routine_paramsContext() {}

func NewCreate_routine_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_paramsContext {
	var p = new(Create_routine_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_params

	return p
}

func (s *Create_routine_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_paramsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_routine_paramsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_routine_paramsContext) AllCreate_routine_param_item() []ICreate_routine_param_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_routine_param_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_routine_param_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_routine_param_itemContext); ok {
			tst[i] = t.(ICreate_routine_param_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_paramsContext) Create_routine_param_item(i int) ICreate_routine_param_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_param_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_param_itemContext)
}

func (s *Create_routine_paramsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_routine_paramsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_routine_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_params(s)
	}
}

func (s *Create_routine_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_params(s)
	}
}

func (p *HplsqlParser) Create_routine_params() (localctx ICreate_routine_paramsContext) {
	localctx = NewCreate_routine_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, HplsqlParserRULE_create_routine_params)
	var _la int

	var _alt int

	p.SetState(1615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1593)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1594)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1595)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1596)
			p.Create_routine_param_item()
		}
		p.SetState(1601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1597)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1598)
				p.Create_routine_param_item()
			}

			p.SetState(1603)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1604)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1606)

		if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "IS") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "AS") &&
			!(strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "DYNAMIC") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "RESULT"))) {
			p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"IS\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"AS\") &&\n        !(strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"DYNAMIC\") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), \"RESULT\"))\n        ", ""))
			goto errorExit
		}
		{
			p.SetState(1607)
			p.Create_routine_param_item()
		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1608)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1609)
					p.Create_routine_param_item()
				}

			}
			p.SetState(1614)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_param_itemContext is an interface to support dynamic dispatch.
type ICreate_routine_param_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	Dtype() IDtypeContext
	T_IN() antlr.TerminalNode
	T_OUT() antlr.TerminalNode
	T_INOUT() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	Dtype_default() IDtype_defaultContext

	// IsCreate_routine_param_itemContext differentiates from other interfaces.
	IsCreate_routine_param_itemContext()
}

type Create_routine_param_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_param_itemContext() *Create_routine_param_itemContext {
	var p = new(Create_routine_param_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item
	return p
}

func InitEmptyCreate_routine_param_itemContext(p *Create_routine_param_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item
}

func (*Create_routine_param_itemContext) IsCreate_routine_param_itemContext() {}

func NewCreate_routine_param_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_param_itemContext {
	var p = new(Create_routine_param_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item

	return p
}

func (s *Create_routine_param_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_param_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_routine_param_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_routine_param_itemContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Create_routine_param_itemContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUT, 0)
}

func (s *Create_routine_param_itemContext) T_INOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INOUT, 0)
}

func (s *Create_routine_param_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_routine_param_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_param_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Create_routine_param_itemContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Create_routine_param_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_param_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_param_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_param_item(s)
	}
}

func (s *Create_routine_param_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_param_item(s)
	}
}

func (p *HplsqlParser) Create_routine_param_item() (localctx ICreate_routine_param_itemContext) {
	localctx = NewCreate_routine_param_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, HplsqlParserRULE_create_routine_param_item)
	var _alt int

	p.SetState(1659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1617)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1618)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1619)
				p.Match(HplsqlParserT_INOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 4 {
			{
				p.SetState(1620)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1621)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1624)
			p.Ident()
		}
		{
			p.SetState(1625)
			p.Dtype()
		}
		p.SetState(1627)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1626)
				p.Dtype_len()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1629)
					p.Dtype_attr()
				}

			}
			p.SetState(1634)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1635)
				p.Dtype_default()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1638)
			p.Ident()
		}
		p.SetState(1644)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1639)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1640)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1641)
				p.Match(HplsqlParserT_INOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 4 {
			{
				p.SetState(1642)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1643)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1646)
			p.Dtype()
		}
		p.SetState(1648)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1647)
				p.Dtype_len()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1650)
					p.Dtype_attr()
				}

			}
			p.SetState(1655)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1656)
				p.Dtype_default()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_optionsContext is an interface to support dynamic dispatch.
type ICreate_routine_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_routine_option() []ICreate_routine_optionContext
	Create_routine_option(i int) ICreate_routine_optionContext

	// IsCreate_routine_optionsContext differentiates from other interfaces.
	IsCreate_routine_optionsContext()
}

type Create_routine_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_optionsContext() *Create_routine_optionsContext {
	var p = new(Create_routine_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_options
	return p
}

func InitEmptyCreate_routine_optionsContext(p *Create_routine_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_options
}

func (*Create_routine_optionsContext) IsCreate_routine_optionsContext() {}

func NewCreate_routine_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_optionsContext {
	var p = new(Create_routine_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_options

	return p
}

func (s *Create_routine_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_optionsContext) AllCreate_routine_option() []ICreate_routine_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_routine_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_routine_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_routine_optionContext); ok {
			tst[i] = t.(ICreate_routine_optionContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_optionsContext) Create_routine_option(i int) ICreate_routine_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_optionContext)
}

func (s *Create_routine_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_options(s)
	}
}

func (s *Create_routine_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_options(s)
	}
}

func (p *HplsqlParser) Create_routine_options() (localctx ICreate_routine_optionsContext) {
	localctx = NewCreate_routine_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, HplsqlParserRULE_create_routine_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1661)
				p.Create_routine_option()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_optionContext is an interface to support dynamic dispatch.
type ICreate_routine_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LANGUAGE() antlr.TerminalNode
	T_SQL() antlr.TerminalNode
	T_SECURITY() antlr.TerminalNode
	T_CREATOR() antlr.TerminalNode
	T_DEFINER() antlr.TerminalNode
	T_INVOKER() antlr.TerminalNode
	T_OWNER() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SETS() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	T_DYNAMIC() antlr.TerminalNode

	// IsCreate_routine_optionContext differentiates from other interfaces.
	IsCreate_routine_optionContext()
}

type Create_routine_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_optionContext() *Create_routine_optionContext {
	var p = new(Create_routine_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_option
	return p
}

func InitEmptyCreate_routine_optionContext(p *Create_routine_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_option
}

func (*Create_routine_optionContext) IsCreate_routine_optionContext() {}

func NewCreate_routine_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_optionContext {
	var p = new(Create_routine_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_option

	return p
}

func (s *Create_routine_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_optionContext) T_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LANGUAGE, 0)
}

func (s *Create_routine_optionContext) T_SQL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQL, 0)
}

func (s *Create_routine_optionContext) T_SECURITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECURITY, 0)
}

func (s *Create_routine_optionContext) T_CREATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATOR, 0)
}

func (s *Create_routine_optionContext) T_DEFINER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINER, 0)
}

func (s *Create_routine_optionContext) T_INVOKER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INVOKER, 0)
}

func (s *Create_routine_optionContext) T_OWNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OWNER, 0)
}

func (s *Create_routine_optionContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Create_routine_optionContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SETS, 0)
}

func (s *Create_routine_optionContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Create_routine_optionContext) T_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DYNAMIC, 0)
}

func (s *Create_routine_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_option(s)
	}
}

func (s *Create_routine_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_option(s)
	}
}

func (p *HplsqlParser) Create_routine_option() (localctx ICreate_routine_optionContext) {
	localctx = NewCreate_routine_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, HplsqlParserRULE_create_routine_option)
	var _la int

	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LANGUAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1666)
			p.Match(HplsqlParserT_LANGUAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1667)
			p.Match(HplsqlParserT_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SQL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1668)
			p.Match(HplsqlParserT_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1669)
			p.Match(HplsqlParserT_SECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1670)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CREATOR || _la == HplsqlParserT_DEFINER || _la == HplsqlParserT_INVOKER || _la == HplsqlParserT_OWNER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case HplsqlParserT_DYNAMIC, HplsqlParserT_RESULT:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_DYNAMIC {
			{
				p.SetState(1671)
				p.Match(HplsqlParserT_DYNAMIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1674)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1675)
			p.Match(HplsqlParserT_SETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_stmtContext is an interface to support dynamic dispatch.
type IDrop_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DROP() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_IF() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_PACKAGE() antlr.TerminalNode
	Ident() IIdentContext
	T_PROCEDURE() antlr.TerminalNode
	T_FUNCTION() antlr.TerminalNode
	Expr() IExprContext
	T_DATABASE() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode

	// IsDrop_stmtContext differentiates from other interfaces.
	IsDrop_stmtContext()
}

type Drop_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_stmtContext() *Drop_stmtContext {
	var p = new(Drop_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_drop_stmt
	return p
}

func InitEmptyDrop_stmtContext(p *Drop_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_drop_stmt
}

func (*Drop_stmtContext) IsDrop_stmtContext() {}

func NewDrop_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_stmtContext {
	var p = new(Drop_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_drop_stmt

	return p
}

func (s *Drop_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_stmtContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Drop_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Drop_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Drop_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Drop_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Drop_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Drop_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Drop_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Drop_stmtContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Drop_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Drop_stmtContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Drop_stmtContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Drop_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDrop_stmt(s)
	}
}

func (s *Drop_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDrop_stmt(s)
	}
}

func (p *HplsqlParser) Drop_stmt() (localctx IDrop_stmtContext) {
	localctx = NewDrop_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, HplsqlParserRULE_drop_stmt)
	var _la int

	p.SetState(1707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1679)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1680)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1683)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1681)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1682)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1685)
			p.Table_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1686)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Match(HplsqlParserT_PACKAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1690)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1688)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1689)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1692)
			p.Ident()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1693)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1694)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_FUNCTION || _la == HplsqlParserT_PROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1697)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1695)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1696)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1699)
			p.Ident()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1700)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1701)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DATABASE || _la == HplsqlParserT_SCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1704)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1702)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1703)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1706)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnd_transaction_stmtContext is an interface to support dynamic dispatch.
type IEnd_transaction_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_END() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode

	// IsEnd_transaction_stmtContext differentiates from other interfaces.
	IsEnd_transaction_stmtContext()
}

type End_transaction_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_transaction_stmtContext() *End_transaction_stmtContext {
	var p = new(End_transaction_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt
	return p
}

func InitEmptyEnd_transaction_stmtContext(p *End_transaction_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt
}

func (*End_transaction_stmtContext) IsEnd_transaction_stmtContext() {}

func NewEnd_transaction_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_transaction_stmtContext {
	var p = new(End_transaction_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt

	return p
}

func (s *End_transaction_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *End_transaction_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *End_transaction_stmtContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *End_transaction_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_transaction_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *End_transaction_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterEnd_transaction_stmt(s)
	}
}

func (s *End_transaction_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitEnd_transaction_stmt(s)
	}
}

func (p *HplsqlParser) End_transaction_stmt() (localctx IEnd_transaction_stmtContext) {
	localctx = NewEnd_transaction_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, HplsqlParserRULE_end_transaction_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1709)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1710)
		p.Match(HplsqlParserT_TRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExec_stmtContext is an interface to support dynamic dispatch.
type IExec_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	T_EXEC() antlr.TerminalNode
	T_EXECUTE() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Expr_func_params() IExpr_func_paramsContext
	T_CLOSE_P() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	AllL_ID() []antlr.TerminalNode
	L_ID(i int) antlr.TerminalNode
	Using_clause() IUsing_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExec_stmtContext differentiates from other interfaces.
	IsExec_stmtContext()
}

type Exec_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExec_stmtContext() *Exec_stmtContext {
	var p = new(Exec_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exec_stmt
	return p
}

func InitEmptyExec_stmtContext(p *Exec_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exec_stmt
}

func (*Exec_stmtContext) IsExec_stmtContext() {}

func NewExec_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exec_stmtContext {
	var p = new(Exec_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exec_stmt

	return p
}

func (s *Exec_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Exec_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Exec_stmtContext) T_EXEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXEC, 0)
}

func (s *Exec_stmtContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Exec_stmtContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Exec_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Exec_stmtContext) Expr_func_params() IExpr_func_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_paramsContext)
}

func (s *Exec_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Exec_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Exec_stmtContext) AllL_ID() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_ID)
}

func (s *Exec_stmtContext) L_ID(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, i)
}

func (s *Exec_stmtContext) Using_clause() IUsing_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *Exec_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Exec_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Exec_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exec_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exec_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExec_stmt(s)
	}
}

func (s *Exec_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExec_stmt(s)
	}
}

func (p *HplsqlParser) Exec_stmt() (localctx IExec_stmtContext) {
	localctx = NewExec_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, HplsqlParserRULE_exec_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1712)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_EXEC || _la == HplsqlParserT_EXECUTE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1713)
			p.Match(HplsqlParserT_IMMEDIATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1716)
		p.expr(0)
	}
	p.SetState(1722)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1717)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1718)
			p.Expr_func_params()
		}
		{
			p.SetState(1719)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1721)
			p.Expr_func_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1724)
			p.Match(HplsqlParserT_INTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1725)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1726)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1727)
					p.Match(HplsqlParserL_ID)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1732)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1736)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1735)
			p.Using_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If_plsql_stmt() IIf_plsql_stmtContext
	If_tsql_stmt() IIf_tsql_stmtContext
	If_bteq_stmt() IIf_bteq_stmtContext

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_stmt
	return p
}

func InitEmptyIf_stmtContext(p *If_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_stmt
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) If_plsql_stmt() IIf_plsql_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_plsql_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_plsql_stmtContext)
}

func (s *If_stmtContext) If_tsql_stmt() IIf_tsql_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_tsql_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_tsql_stmtContext)
}

func (s *If_stmtContext) If_bteq_stmt() IIf_bteq_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_bteq_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_bteq_stmtContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *HplsqlParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, HplsqlParserRULE_if_stmt)
	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1738)
			p.If_plsql_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1739)
			p.If_tsql_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1740)
			p.If_bteq_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_plsql_stmtContext is an interface to support dynamic dispatch.
type IIf_plsql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_IF() []antlr.TerminalNode
	T_IF(i int) antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	AllElseif_block() []IElseif_blockContext
	Elseif_block(i int) IElseif_blockContext
	Else_block() IElse_blockContext

	// IsIf_plsql_stmtContext differentiates from other interfaces.
	IsIf_plsql_stmtContext()
}

type If_plsql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_plsql_stmtContext() *If_plsql_stmtContext {
	var p = new(If_plsql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt
	return p
}

func InitEmptyIf_plsql_stmtContext(p *If_plsql_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt
}

func (*If_plsql_stmtContext) IsIf_plsql_stmtContext() {}

func NewIf_plsql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_plsql_stmtContext {
	var p = new(If_plsql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt

	return p
}

func (s *If_plsql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_plsql_stmtContext) AllT_IF() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_IF)
}

func (s *If_plsql_stmtContext) T_IF(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, i)
}

func (s *If_plsql_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_plsql_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *If_plsql_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *If_plsql_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *If_plsql_stmtContext) AllElseif_block() []IElseif_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseif_blockContext); ok {
			len++
		}
	}

	tst := make([]IElseif_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseif_blockContext); ok {
			tst[i] = t.(IElseif_blockContext)
			i++
		}
	}

	return tst
}

func (s *If_plsql_stmtContext) Elseif_block(i int) IElseif_blockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseif_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseif_blockContext)
}

func (s *If_plsql_stmtContext) Else_block() IElse_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_blockContext)
}

func (s *If_plsql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_plsql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_plsql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_plsql_stmt(s)
	}
}

func (s *If_plsql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_plsql_stmt(s)
	}
}

func (p *HplsqlParser) If_plsql_stmt() (localctx IIf_plsql_stmtContext) {
	localctx = NewIf_plsql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, HplsqlParserRULE_if_plsql_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1743)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1744)
		p.bool_expr(0)
	}
	{
		p.SetState(1745)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1746)
		p.Block()
	}
	p.SetState(1750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_ELSEIF || _la == HplsqlParserT_ELSIF {
		{
			p.SetState(1747)
			p.Elseif_block()
		}

		p.SetState(1752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(1753)
			p.Else_block()
		}

	}
	{
		p.SetState(1756)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1757)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_tsql_stmtContext is an interface to support dynamic dispatch.
type IIf_tsql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IF() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	AllSingle_block_stmt() []ISingle_block_stmtContext
	Single_block_stmt(i int) ISingle_block_stmtContext
	T_ELSE() antlr.TerminalNode

	// IsIf_tsql_stmtContext differentiates from other interfaces.
	IsIf_tsql_stmtContext()
}

type If_tsql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_tsql_stmtContext() *If_tsql_stmtContext {
	var p = new(If_tsql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt
	return p
}

func InitEmptyIf_tsql_stmtContext(p *If_tsql_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt
}

func (*If_tsql_stmtContext) IsIf_tsql_stmtContext() {}

func NewIf_tsql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_tsql_stmtContext {
	var p = new(If_tsql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt

	return p
}

func (s *If_tsql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_tsql_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *If_tsql_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_tsql_stmtContext) AllSingle_block_stmt() []ISingle_block_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISingle_block_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingle_block_stmtContext); ok {
			tst[i] = t.(ISingle_block_stmtContext)
			i++
		}
	}

	return tst
}

func (s *If_tsql_stmtContext) Single_block_stmt(i int) ISingle_block_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *If_tsql_stmtContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *If_tsql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_tsql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_tsql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_tsql_stmt(s)
	}
}

func (s *If_tsql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_tsql_stmt(s)
	}
}

func (p *HplsqlParser) If_tsql_stmt() (localctx IIf_tsql_stmtContext) {
	localctx = NewIf_tsql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, HplsqlParserRULE_if_tsql_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1759)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1760)
		p.bool_expr(0)
	}
	{
		p.SetState(1761)
		p.Single_block_stmt()
	}
	p.SetState(1764)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1762)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1763)
			p.Single_block_stmt()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_bteq_stmtContext is an interface to support dynamic dispatch.
type IIf_bteq_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Single_block_stmt() ISingle_block_stmtContext

	// IsIf_bteq_stmtContext differentiates from other interfaces.
	IsIf_bteq_stmtContext()
}

type If_bteq_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_bteq_stmtContext() *If_bteq_stmtContext {
	var p = new(If_bteq_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt
	return p
}

func InitEmptyIf_bteq_stmtContext(p *If_bteq_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt
}

func (*If_bteq_stmtContext) IsIf_bteq_stmtContext() {}

func NewIf_bteq_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_bteq_stmtContext {
	var p = new(If_bteq_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt

	return p
}

func (s *If_bteq_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_bteq_stmtContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *If_bteq_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *If_bteq_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_bteq_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *If_bteq_stmtContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *If_bteq_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_bteq_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_bteq_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_bteq_stmt(s)
	}
}

func (s *If_bteq_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_bteq_stmt(s)
	}
}

func (p *HplsqlParser) If_bteq_stmt() (localctx IIf_bteq_stmtContext) {
	localctx = NewIf_bteq_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, HplsqlParserRULE_if_bteq_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1766)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1767)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1768)
		p.bool_expr(0)
	}
	{
		p.SetState(1769)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1770)
		p.Single_block_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseif_blockContext is an interface to support dynamic dispatch.
type IElseif_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_ELSIF() antlr.TerminalNode
	T_ELSEIF() antlr.TerminalNode

	// IsElseif_blockContext differentiates from other interfaces.
	IsElseif_blockContext()
}

type Elseif_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseif_blockContext() *Elseif_blockContext {
	var p = new(Elseif_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_elseif_block
	return p
}

func InitEmptyElseif_blockContext(p *Elseif_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_elseif_block
}

func (*Elseif_blockContext) IsElseif_blockContext() {}

func NewElseif_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elseif_blockContext {
	var p = new(Elseif_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_elseif_block

	return p
}

func (s *Elseif_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Elseif_blockContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Elseif_blockContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Elseif_blockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Elseif_blockContext) T_ELSIF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSIF, 0)
}

func (s *Elseif_blockContext) T_ELSEIF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSEIF, 0)
}

func (s *Elseif_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elseif_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elseif_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterElseif_block(s)
	}
}

func (s *Elseif_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitElseif_block(s)
	}
}

func (p *HplsqlParser) Elseif_block() (localctx IElseif_blockContext) {
	localctx = NewElseif_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, HplsqlParserRULE_elseif_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1772)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ELSEIF || _la == HplsqlParserT_ELSIF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1773)
		p.bool_expr(0)
	}
	{
		p.SetState(1774)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1775)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElse_blockContext is an interface to support dynamic dispatch.
type IElse_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ELSE() antlr.TerminalNode
	Block() IBlockContext

	// IsElse_blockContext differentiates from other interfaces.
	IsElse_blockContext()
}

type Else_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_blockContext() *Else_blockContext {
	var p = new(Else_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_else_block
	return p
}

func InitEmptyElse_blockContext(p *Else_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_else_block
}

func (*Else_blockContext) IsElse_blockContext() {}

func NewElse_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_blockContext {
	var p = new(Else_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_else_block

	return p
}

func (s *Else_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_blockContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Else_blockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Else_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterElse_block(s)
	}
}

func (s *Else_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitElse_block(s)
	}
}

func (p *HplsqlParser) Else_block() (localctx IElse_blockContext) {
	localctx = NewElse_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, HplsqlParserRULE_else_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.Match(HplsqlParserT_ELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1778)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInclude_stmtContext is an interface to support dynamic dispatch.
type IInclude_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INCLUDE() antlr.TerminalNode
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsInclude_stmtContext differentiates from other interfaces.
	IsInclude_stmtContext()
}

type Include_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclude_stmtContext() *Include_stmtContext {
	var p = new(Include_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_include_stmt
	return p
}

func InitEmptyInclude_stmtContext(p *Include_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_include_stmt
}

func (*Include_stmtContext) IsInclude_stmtContext() {}

func NewInclude_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Include_stmtContext {
	var p = new(Include_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_include_stmt

	return p
}

func (s *Include_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Include_stmtContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INCLUDE, 0)
}

func (s *Include_stmtContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Include_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Include_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Include_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Include_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInclude_stmt(s)
	}
}

func (s *Include_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInclude_stmt(s)
	}
}

func (p *HplsqlParser) Include_stmt() (localctx IInclude_stmtContext) {
	localctx = NewInclude_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, HplsqlParserRULE_include_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1780)
		p.Match(HplsqlParserT_INCLUDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1781)
			p.File_name()
		}

	case 2:
		{
			p.SetState(1782)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmtContext is an interface to support dynamic dispatch.
type IInsert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OVERWRITE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Insert_stmt_rows() IInsert_stmt_rowsContext
	Insert_stmt_cols() IInsert_stmt_colsContext

	// IsInsert_stmtContext differentiates from other interfaces.
	IsInsert_stmtContext()
}

type Insert_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmtContext() *Insert_stmtContext {
	var p = new(Insert_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt
	return p
}

func InitEmptyInsert_stmtContext(p *Insert_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt
}

func (*Insert_stmtContext) IsInsert_stmtContext() {}

func NewInsert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmtContext {
	var p = new(Insert_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt

	return p
}

func (s *Insert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmtContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Insert_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Insert_stmtContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Insert_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Insert_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Insert_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Insert_stmtContext) Insert_stmt_rows() IInsert_stmt_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowsContext)
}

func (s *Insert_stmtContext) Insert_stmt_cols() IInsert_stmt_colsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_colsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_colsContext)
}

func (s *Insert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt(s)
	}
}

func (s *Insert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt(s)
	}
}

func (p *HplsqlParser) Insert_stmt() (localctx IInsert_stmtContext) {
	localctx = NewInsert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, HplsqlParserRULE_insert_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1785)
		p.Match(HplsqlParserT_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_OVERWRITE:
		{
			p.SetState(1786)
			p.Match(HplsqlParserT_OVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INTO:
		{
			p.SetState(1788)
			p.Match(HplsqlParserT_INTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1790)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1789)
				p.Match(HplsqlParserT_TABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1794)
		p.Table_name()
	}
	p.SetState(1796)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1795)
			p.Insert_stmt_cols()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_WITH, HplsqlParserT_OPEN_P:
		{
			p.SetState(1798)
			p.Select_stmt()
		}

	case HplsqlParserT_VALUES:
		{
			p.SetState(1799)
			p.Insert_stmt_rows()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmt_colsContext is an interface to support dynamic dispatch.
type IInsert_stmt_colsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_colsContext differentiates from other interfaces.
	IsInsert_stmt_colsContext()
}

type Insert_stmt_colsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_colsContext() *Insert_stmt_colsContext {
	var p = new(Insert_stmt_colsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols
	return p
}

func InitEmptyInsert_stmt_colsContext(p *Insert_stmt_colsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols
}

func (*Insert_stmt_colsContext) IsInsert_stmt_colsContext() {}

func NewInsert_stmt_colsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_colsContext {
	var p = new(Insert_stmt_colsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols

	return p
}

func (s *Insert_stmt_colsContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_colsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Insert_stmt_colsContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_colsContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Insert_stmt_colsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Insert_stmt_colsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_colsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_colsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_colsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmt_colsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_cols(s)
	}
}

func (s *Insert_stmt_colsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_cols(s)
	}
}

func (p *HplsqlParser) Insert_stmt_cols() (localctx IInsert_stmt_colsContext) {
	localctx = NewInsert_stmt_colsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, HplsqlParserRULE_insert_stmt_cols)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1802)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1803)
		p.Qident()
	}
	p.SetState(1808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1804)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1805)
			p.Qident()
		}

		p.SetState(1810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1811)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmt_rowsContext is an interface to support dynamic dispatch.
type IInsert_stmt_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	AllInsert_stmt_row() []IInsert_stmt_rowContext
	Insert_stmt_row(i int) IInsert_stmt_rowContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_rowsContext differentiates from other interfaces.
	IsInsert_stmt_rowsContext()
}

type Insert_stmt_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_rowsContext() *Insert_stmt_rowsContext {
	var p = new(Insert_stmt_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows
	return p
}

func InitEmptyInsert_stmt_rowsContext(p *Insert_stmt_rowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows
}

func (*Insert_stmt_rowsContext) IsInsert_stmt_rowsContext() {}

func NewInsert_stmt_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_rowsContext {
	var p = new(Insert_stmt_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows

	return p
}

func (s *Insert_stmt_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_rowsContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Insert_stmt_rowsContext) AllInsert_stmt_row() []IInsert_stmt_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			len++
		}
	}

	tst := make([]IInsert_stmt_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsert_stmt_rowContext); ok {
			tst[i] = t.(IInsert_stmt_rowContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_rowsContext) Insert_stmt_row(i int) IInsert_stmt_rowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowContext)
}

func (s *Insert_stmt_rowsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_rowsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmt_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_rows(s)
	}
}

func (s *Insert_stmt_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_rows(s)
	}
}

func (p *HplsqlParser) Insert_stmt_rows() (localctx IInsert_stmt_rowsContext) {
	localctx = NewInsert_stmt_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, HplsqlParserRULE_insert_stmt_rows)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1813)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1814)
		p.Insert_stmt_row()
	}
	p.SetState(1819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1815)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1816)
				p.Insert_stmt_row()
			}

		}
		p.SetState(1821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmt_rowContext is an interface to support dynamic dispatch.
type IInsert_stmt_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_rowContext differentiates from other interfaces.
	IsInsert_stmt_rowContext()
}

type Insert_stmt_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_rowContext() *Insert_stmt_rowContext {
	var p = new(Insert_stmt_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row
	return p
}

func InitEmptyInsert_stmt_rowContext(p *Insert_stmt_rowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row
}

func (*Insert_stmt_rowContext) IsInsert_stmt_rowContext() {}

func NewInsert_stmt_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_rowContext {
	var p = new(Insert_stmt_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row

	return p
}

func (s *Insert_stmt_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Insert_stmt_rowContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_rowContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Insert_stmt_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Insert_stmt_rowContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_rowContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmt_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_row(s)
	}
}

func (s *Insert_stmt_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_row(s)
	}
}

func (p *HplsqlParser) Insert_stmt_row() (localctx IInsert_stmt_rowContext) {
	localctx = NewInsert_stmt_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, HplsqlParserRULE_insert_stmt_row)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1822)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1823)
		p.expr(0)
	}
	p.SetState(1828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1824)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1825)
			p.expr(0)
		}

		p.SetState(1830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1831)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_directory_stmtContext is an interface to support dynamic dispatch.
type IInsert_directory_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode
	T_DIRECTORY() antlr.TerminalNode
	Expr_file() IExpr_fileContext
	Expr_select() IExpr_selectContext
	T_LOCAL() antlr.TerminalNode

	// IsInsert_directory_stmtContext differentiates from other interfaces.
	IsInsert_directory_stmtContext()
}

type Insert_directory_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_directory_stmtContext() *Insert_directory_stmtContext {
	var p = new(Insert_directory_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt
	return p
}

func InitEmptyInsert_directory_stmtContext(p *Insert_directory_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt
}

func (*Insert_directory_stmtContext) IsInsert_directory_stmtContext() {}

func NewInsert_directory_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_directory_stmtContext {
	var p = new(Insert_directory_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt

	return p
}

func (s *Insert_directory_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_directory_stmtContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Insert_directory_stmtContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Insert_directory_stmtContext) T_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIRECTORY, 0)
}

func (s *Insert_directory_stmtContext) Expr_file() IExpr_fileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_fileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_fileContext)
}

func (s *Insert_directory_stmtContext) Expr_select() IExpr_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_selectContext)
}

func (s *Insert_directory_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Insert_directory_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_directory_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_directory_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_directory_stmt(s)
	}
}

func (s *Insert_directory_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_directory_stmt(s)
	}
}

func (p *HplsqlParser) Insert_directory_stmt() (localctx IInsert_directory_stmtContext) {
	localctx = NewInsert_directory_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, HplsqlParserRULE_insert_directory_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.Match(HplsqlParserT_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1834)
		p.Match(HplsqlParserT_OVERWRITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_LOCAL {
		{
			p.SetState(1835)
			p.Match(HplsqlParserT_LOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1838)
		p.Match(HplsqlParserT_DIRECTORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1839)
		p.Expr_file()
	}
	{
		p.SetState(1840)
		p.Expr_select()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExit_stmtContext is an interface to support dynamic dispatch.
type IExit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXIT() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_WHEN() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsExit_stmtContext differentiates from other interfaces.
	IsExit_stmtContext()
}

type Exit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_stmtContext() *Exit_stmtContext {
	var p = new(Exit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exit_stmt
	return p
}

func InitEmptyExit_stmtContext(p *Exit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exit_stmt
}

func (*Exit_stmtContext) IsExit_stmtContext() {}

func NewExit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_stmtContext {
	var p = new(Exit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exit_stmt

	return p
}

func (s *Exit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_stmtContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Exit_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Exit_stmtContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, 0)
}

func (s *Exit_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Exit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExit_stmt(s)
	}
}

func (s *Exit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExit_stmt(s)
	}
}

func (p *HplsqlParser) Exit_stmt() (localctx IExit_stmtContext) {
	localctx = NewExit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, HplsqlParserRULE_exit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1842)
		p.Match(HplsqlParserT_EXIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1844)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1843)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1848)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1846)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1847)
			p.bool_expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmtContext is an interface to support dynamic dispatch.
type IGet_diag_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GET() antlr.TerminalNode
	T_DIAGNOSTICS() antlr.TerminalNode
	Get_diag_stmt_item() IGet_diag_stmt_itemContext

	// IsGet_diag_stmtContext differentiates from other interfaces.
	IsGet_diag_stmtContext()
}

type Get_diag_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmtContext() *Get_diag_stmtContext {
	var p = new(Get_diag_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt
	return p
}

func InitEmptyGet_diag_stmtContext(p *Get_diag_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt
}

func (*Get_diag_stmtContext) IsGet_diag_stmtContext() {}

func NewGet_diag_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmtContext {
	var p = new(Get_diag_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt

	return p
}

func (s *Get_diag_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmtContext) T_GET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GET, 0)
}

func (s *Get_diag_stmtContext) T_DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIAGNOSTICS, 0)
}

func (s *Get_diag_stmtContext) Get_diag_stmt_item() IGet_diag_stmt_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_itemContext)
}

func (s *Get_diag_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt(s)
	}
}

func (s *Get_diag_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt() (localctx IGet_diag_stmtContext) {
	localctx = NewGet_diag_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, HplsqlParserRULE_get_diag_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1850)
		p.Match(HplsqlParserT_GET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1851)
		p.Match(HplsqlParserT_DIAGNOSTICS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1852)
		p.Get_diag_stmt_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmt_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Get_diag_stmt_exception_item() IGet_diag_stmt_exception_itemContext
	Get_diag_stmt_rowcount_item() IGet_diag_stmt_rowcount_itemContext

	// IsGet_diag_stmt_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_itemContext()
}

type Get_diag_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_itemContext() *Get_diag_stmt_itemContext {
	var p = new(Get_diag_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item
	return p
}

func InitEmptyGet_diag_stmt_itemContext(p *Get_diag_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item
}

func (*Get_diag_stmt_itemContext) IsGet_diag_stmt_itemContext() {}

func NewGet_diag_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_itemContext {
	var p = new(Get_diag_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item

	return p
}

func (s *Get_diag_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_itemContext) Get_diag_stmt_exception_item() IGet_diag_stmt_exception_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_exception_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_exception_itemContext)
}

func (s *Get_diag_stmt_itemContext) Get_diag_stmt_rowcount_item() IGet_diag_stmt_rowcount_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_rowcount_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_rowcount_itemContext)
}

func (s *Get_diag_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_item(s)
	}
}

func (s *Get_diag_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_item(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt_item() (localctx IGet_diag_stmt_itemContext) {
	localctx = NewGet_diag_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, HplsqlParserRULE_get_diag_stmt_item)
	p.SetState(1856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1854)
			p.Get_diag_stmt_exception_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1855)
			p.Get_diag_stmt_rowcount_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmt_exception_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_exception_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXCEPTION() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode

	// IsGet_diag_stmt_exception_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_exception_itemContext()
}

type Get_diag_stmt_exception_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_exception_itemContext() *Get_diag_stmt_exception_itemContext {
	var p = new(Get_diag_stmt_exception_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item
	return p
}

func InitEmptyGet_diag_stmt_exception_itemContext(p *Get_diag_stmt_exception_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item
}

func (*Get_diag_stmt_exception_itemContext) IsGet_diag_stmt_exception_itemContext() {}

func NewGet_diag_stmt_exception_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_exception_itemContext {
	var p = new(Get_diag_stmt_exception_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item

	return p
}

func (s *Get_diag_stmt_exception_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_exception_itemContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Get_diag_stmt_exception_itemContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Get_diag_stmt_exception_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Get_diag_stmt_exception_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Get_diag_stmt_exception_itemContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Get_diag_stmt_exception_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_exception_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmt_exception_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_exception_item(s)
	}
}

func (s *Get_diag_stmt_exception_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_exception_item(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt_exception_item() (localctx IGet_diag_stmt_exception_itemContext) {
	localctx = NewGet_diag_stmt_exception_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, HplsqlParserRULE_get_diag_stmt_exception_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1858)
		p.Match(HplsqlParserT_EXCEPTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1859)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1860)
		p.Qident()
	}
	{
		p.SetState(1861)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1862)
		p.Match(HplsqlParserT_MESSAGE_TEXT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmt_rowcount_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_rowcount_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode

	// IsGet_diag_stmt_rowcount_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_rowcount_itemContext()
}

type Get_diag_stmt_rowcount_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_rowcount_itemContext() *Get_diag_stmt_rowcount_itemContext {
	var p = new(Get_diag_stmt_rowcount_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item
	return p
}

func InitEmptyGet_diag_stmt_rowcount_itemContext(p *Get_diag_stmt_rowcount_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item
}

func (*Get_diag_stmt_rowcount_itemContext) IsGet_diag_stmt_rowcount_itemContext() {}

func NewGet_diag_stmt_rowcount_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_rowcount_itemContext {
	var p = new(Get_diag_stmt_rowcount_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item

	return p
}

func (s *Get_diag_stmt_rowcount_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_rowcount_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Get_diag_stmt_rowcount_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Get_diag_stmt_rowcount_itemContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Get_diag_stmt_rowcount_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_rowcount_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmt_rowcount_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_rowcount_item(s)
	}
}

func (s *Get_diag_stmt_rowcount_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_rowcount_item(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt_rowcount_item() (localctx IGet_diag_stmt_rowcount_itemContext) {
	localctx = NewGet_diag_stmt_rowcount_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, HplsqlParserRULE_get_diag_stmt_rowcount_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1864)
		p.Qident()
	}
	{
		p.SetState(1865)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1866)
		p.Match(HplsqlParserT_ROW_COUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_stmtContext is an interface to support dynamic dispatch.
type IGrant_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GRANT() antlr.TerminalNode
	AllGrant_stmt_item() []IGrant_stmt_itemContext
	Grant_stmt_item(i int) IGrant_stmt_itemContext
	T_TO() antlr.TerminalNode
	T_ROLE() antlr.TerminalNode
	Qident() IQidentContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsGrant_stmtContext differentiates from other interfaces.
	IsGrant_stmtContext()
}

type Grant_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_stmtContext() *Grant_stmtContext {
	var p = new(Grant_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt
	return p
}

func InitEmptyGrant_stmtContext(p *Grant_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt
}

func (*Grant_stmtContext) IsGrant_stmtContext() {}

func NewGrant_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_stmtContext {
	var p = new(Grant_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_grant_stmt

	return p
}

func (s *Grant_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_stmtContext) T_GRANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GRANT, 0)
}

func (s *Grant_stmtContext) AllGrant_stmt_item() []IGrant_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrant_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IGrant_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrant_stmt_itemContext); ok {
			tst[i] = t.(IGrant_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Grant_stmtContext) Grant_stmt_item(i int) IGrant_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_stmt_itemContext)
}

func (s *Grant_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Grant_stmtContext) T_ROLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLE, 0)
}

func (s *Grant_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Grant_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Grant_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Grant_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGrant_stmt(s)
	}
}

func (s *Grant_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGrant_stmt(s)
	}
}

func (p *HplsqlParser) Grant_stmt() (localctx IGrant_stmtContext) {
	localctx = NewGrant_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, HplsqlParserRULE_grant_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		p.Match(HplsqlParserT_GRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1869)
		p.Grant_stmt_item()
	}
	p.SetState(1874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1870)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1871)
			p.Grant_stmt_item()
		}

		p.SetState(1876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1877)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1878)
		p.Match(HplsqlParserT_ROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1879)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_stmt_itemContext is an interface to support dynamic dispatch.
type IGrant_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXECUTE() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	Qident() IQidentContext

	// IsGrant_stmt_itemContext differentiates from other interfaces.
	IsGrant_stmt_itemContext()
}

type Grant_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_stmt_itemContext() *Grant_stmt_itemContext {
	var p = new(Grant_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item
	return p
}

func InitEmptyGrant_stmt_itemContext(p *Grant_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item
}

func (*Grant_stmt_itemContext) IsGrant_stmt_itemContext() {}

func NewGrant_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_stmt_itemContext {
	var p = new(Grant_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item

	return p
}

func (s *Grant_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_stmt_itemContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Grant_stmt_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Grant_stmt_itemContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Grant_stmt_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Grant_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGrant_stmt_item(s)
	}
}

func (s *Grant_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGrant_stmt_item(s)
	}
}

func (p *HplsqlParser) Grant_stmt_item() (localctx IGrant_stmt_itemContext) {
	localctx = NewGrant_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, HplsqlParserRULE_grant_stmt_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1881)
		p.Match(HplsqlParserT_EXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1882)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1883)
		p.Match(HplsqlParserT_PROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1884)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeave_stmtContext is an interface to support dynamic dispatch.
type ILeave_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LEAVE() antlr.TerminalNode
	L_ID() antlr.TerminalNode

	// IsLeave_stmtContext differentiates from other interfaces.
	IsLeave_stmtContext()
}

type Leave_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeave_stmtContext() *Leave_stmtContext {
	var p = new(Leave_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_leave_stmt
	return p
}

func InitEmptyLeave_stmtContext(p *Leave_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_leave_stmt
}

func (*Leave_stmtContext) IsLeave_stmtContext() {}

func NewLeave_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Leave_stmtContext {
	var p = new(Leave_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_leave_stmt

	return p
}

func (s *Leave_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Leave_stmtContext) T_LEAVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAVE, 0)
}

func (s *Leave_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Leave_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Leave_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Leave_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterLeave_stmt(s)
	}
}

func (s *Leave_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitLeave_stmt(s)
	}
}

func (p *HplsqlParser) Leave_stmt() (localctx ILeave_stmtContext) {
	localctx = NewLeave_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, HplsqlParserRULE_leave_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1886)
		p.Match(HplsqlParserT_LEAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1888)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1887)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMap_object_stmtContext is an interface to support dynamic dispatch.
type IMap_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MAP() antlr.TerminalNode
	T_OBJECT() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_TO() antlr.TerminalNode
	T_AT() antlr.TerminalNode

	// IsMap_object_stmtContext differentiates from other interfaces.
	IsMap_object_stmtContext()
}

type Map_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMap_object_stmtContext() *Map_object_stmtContext {
	var p = new(Map_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_map_object_stmt
	return p
}

func InitEmptyMap_object_stmtContext(p *Map_object_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_map_object_stmt
}

func (*Map_object_stmtContext) IsMap_object_stmtContext() {}

func NewMap_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_object_stmtContext {
	var p = new(Map_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_map_object_stmt

	return p
}

func (s *Map_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_object_stmtContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Map_object_stmtContext) T_OBJECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OBJECT, 0)
}

func (s *Map_object_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Map_object_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Map_object_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Map_object_stmtContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Map_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Map_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMap_object_stmt(s)
	}
}

func (s *Map_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMap_object_stmt(s)
	}
}

func (p *HplsqlParser) Map_object_stmt() (localctx IMap_object_stmtContext) {
	localctx = NewMap_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, HplsqlParserRULE_map_object_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1890)
		p.Match(HplsqlParserT_MAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1891)
		p.Match(HplsqlParserT_OBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1892)
		p.Ident()
	}
	p.SetState(1895)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1893)
			p.Match(HplsqlParserT_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1894)
			p.Ident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1899)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1897)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1898)
			p.Ident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpen_stmtContext is an interface to support dynamic dispatch.
type IOpen_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN() antlr.TerminalNode
	Ident() IIdentContext
	T_FOR() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext

	// IsOpen_stmtContext differentiates from other interfaces.
	IsOpen_stmtContext()
}

type Open_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_stmtContext() *Open_stmtContext {
	var p = new(Open_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_open_stmt
	return p
}

func InitEmptyOpen_stmtContext(p *Open_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_open_stmt
}

func (*Open_stmtContext) IsOpen_stmtContext() {}

func NewOpen_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_stmtContext {
	var p = new(Open_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_open_stmt

	return p
}

func (s *Open_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_stmtContext) T_OPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN, 0)
}

func (s *Open_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Open_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Open_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Open_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Open_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterOpen_stmt(s)
	}
}

func (s *Open_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitOpen_stmt(s)
	}
}

func (p *HplsqlParser) Open_stmt() (localctx IOpen_stmtContext) {
	localctx = NewOpen_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, HplsqlParserRULE_open_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1901)
		p.Match(HplsqlParserT_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1902)
		p.Ident()
	}
	p.SetState(1908)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1903)
			p.Match(HplsqlParserT_FOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1904)
				p.Select_stmt()
			}

		case 2:
			{
				p.SetState(1905)
				p.expr(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFetch_stmtContext is an interface to support dynamic dispatch.
type IFetch_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FETCH() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_INTO() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	Bulk_collect_clause() IBulk_collect_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	Fetch_limit() IFetch_limitContext

	// IsFetch_stmtContext differentiates from other interfaces.
	IsFetch_stmtContext()
}

type Fetch_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFetch_stmtContext() *Fetch_stmtContext {
	var p = new(Fetch_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_stmt
	return p
}

func InitEmptyFetch_stmtContext(p *Fetch_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_stmt
}

func (*Fetch_stmtContext) IsFetch_stmtContext() {}

func NewFetch_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_stmtContext {
	var p = new(Fetch_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fetch_stmt

	return p
}

func (s *Fetch_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_stmtContext) T_FETCH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FETCH, 0)
}

func (s *Fetch_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Fetch_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Fetch_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Fetch_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Fetch_stmtContext) Bulk_collect_clause() IBulk_collect_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulk_collect_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulk_collect_clauseContext)
}

func (s *Fetch_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Fetch_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Fetch_stmtContext) Fetch_limit() IFetch_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFetch_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFetch_limitContext)
}

func (s *Fetch_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fetch_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFetch_stmt(s)
	}
}

func (s *Fetch_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFetch_stmt(s)
	}
}

func (p *HplsqlParser) Fetch_stmt() (localctx IFetch_stmtContext) {
	localctx = NewFetch_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, HplsqlParserRULE_fetch_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1910)
		p.Match(HplsqlParserT_FETCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1912)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1911)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1914)
		p.Ident()
	}
	p.SetState(1916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BULK {
		{
			p.SetState(1915)
			p.Bulk_collect_clause()
		}

	}
	{
		p.SetState(1918)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1919)
		p.Ident()
	}
	p.SetState(1924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1920)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1921)
				p.Ident()
			}

		}
		p.SetState(1926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1928)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1927)
			p.Fetch_limit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFetch_limitContext is an interface to support dynamic dispatch.
type IFetch_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LIMIT() antlr.TerminalNode
	Expr() IExprContext

	// IsFetch_limitContext differentiates from other interfaces.
	IsFetch_limitContext()
}

type Fetch_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFetch_limitContext() *Fetch_limitContext {
	var p = new(Fetch_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_limit
	return p
}

func InitEmptyFetch_limitContext(p *Fetch_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_limit
}

func (*Fetch_limitContext) IsFetch_limitContext() {}

func NewFetch_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_limitContext {
	var p = new(Fetch_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fetch_limit

	return p
}

func (s *Fetch_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_limitContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Fetch_limitContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Fetch_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fetch_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFetch_limit(s)
	}
}

func (s *Fetch_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFetch_limit(s)
	}
}

func (p *HplsqlParser) Fetch_limit() (localctx IFetch_limitContext) {
	localctx = NewFetch_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, HplsqlParserRULE_fetch_limit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1930)
		p.Match(HplsqlParserT_LIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1931)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollect_stats_stmtContext is an interface to support dynamic dispatch.
type ICollect_stats_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COLLECT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_STATISTICS() antlr.TerminalNode
	T_STATS() antlr.TerminalNode
	Collect_stats_clause() ICollect_stats_clauseContext

	// IsCollect_stats_stmtContext differentiates from other interfaces.
	IsCollect_stats_stmtContext()
}

type Collect_stats_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollect_stats_stmtContext() *Collect_stats_stmtContext {
	var p = new(Collect_stats_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt
	return p
}

func InitEmptyCollect_stats_stmtContext(p *Collect_stats_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt
}

func (*Collect_stats_stmtContext) IsCollect_stats_stmtContext() {}

func NewCollect_stats_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collect_stats_stmtContext {
	var p = new(Collect_stats_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt

	return p
}

func (s *Collect_stats_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collect_stats_stmtContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Collect_stats_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Collect_stats_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Collect_stats_stmtContext) T_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATISTICS, 0)
}

func (s *Collect_stats_stmtContext) T_STATS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATS, 0)
}

func (s *Collect_stats_stmtContext) Collect_stats_clause() ICollect_stats_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollect_stats_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollect_stats_clauseContext)
}

func (s *Collect_stats_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collect_stats_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collect_stats_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCollect_stats_stmt(s)
	}
}

func (s *Collect_stats_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCollect_stats_stmt(s)
	}
}

func (p *HplsqlParser) Collect_stats_stmt() (localctx ICollect_stats_stmtContext) {
	localctx = NewCollect_stats_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, HplsqlParserRULE_collect_stats_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1933)
		p.Match(HplsqlParserT_COLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1934)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_STATS || _la == HplsqlParserT_STATISTICS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1935)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1936)
		p.Table_name()
	}
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1937)
			p.Collect_stats_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollect_stats_clauseContext is an interface to support dynamic dispatch.
type ICollect_stats_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COLUMN() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCollect_stats_clauseContext differentiates from other interfaces.
	IsCollect_stats_clauseContext()
}

type Collect_stats_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollect_stats_clauseContext() *Collect_stats_clauseContext {
	var p = new(Collect_stats_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause
	return p
}

func InitEmptyCollect_stats_clauseContext(p *Collect_stats_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause
}

func (*Collect_stats_clauseContext) IsCollect_stats_clauseContext() {}

func NewCollect_stats_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collect_stats_clauseContext {
	var p = new(Collect_stats_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause

	return p
}

func (s *Collect_stats_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Collect_stats_clauseContext) T_COLUMN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLUMN, 0)
}

func (s *Collect_stats_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Collect_stats_clauseContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Collect_stats_clauseContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Collect_stats_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Collect_stats_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Collect_stats_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Collect_stats_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collect_stats_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collect_stats_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCollect_stats_clause(s)
	}
}

func (s *Collect_stats_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCollect_stats_clause(s)
	}
}

func (p *HplsqlParser) Collect_stats_clause() (localctx ICollect_stats_clauseContext) {
	localctx = NewCollect_stats_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, HplsqlParserRULE_collect_stats_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1940)
		p.Match(HplsqlParserT_COLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1941)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1942)
		p.Qident()
	}
	p.SetState(1947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1943)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1944)
			p.Qident()
		}

		p.SetState(1949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1950)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClose_stmtContext is an interface to support dynamic dispatch.
type IClose_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CLOSE() antlr.TerminalNode
	L_ID() antlr.TerminalNode

	// IsClose_stmtContext differentiates from other interfaces.
	IsClose_stmtContext()
}

type Close_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClose_stmtContext() *Close_stmtContext {
	var p = new(Close_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_close_stmt
	return p
}

func InitEmptyClose_stmtContext(p *Close_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_close_stmt
}

func (*Close_stmtContext) IsClose_stmtContext() {}

func NewClose_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Close_stmtContext {
	var p = new(Close_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_close_stmt

	return p
}

func (s *Close_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Close_stmtContext) T_CLOSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE, 0)
}

func (s *Close_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Close_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Close_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Close_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterClose_stmt(s)
	}
}

func (s *Close_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitClose_stmt(s)
	}
}

func (p *HplsqlParser) Close_stmt() (localctx IClose_stmtContext) {
	localctx = NewClose_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, HplsqlParserRULE_close_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1952)
		p.Match(HplsqlParserT_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1953)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmp_stmtContext is an interface to support dynamic dispatch.
type ICmp_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CMP() antlr.TerminalNode
	AllCmp_source() []ICmp_sourceContext
	Cmp_source(i int) ICmp_sourceContext
	T_COMMA() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode
	T_SUM() antlr.TerminalNode

	// IsCmp_stmtContext differentiates from other interfaces.
	IsCmp_stmtContext()
}

type Cmp_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmp_stmtContext() *Cmp_stmtContext {
	var p = new(Cmp_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_stmt
	return p
}

func InitEmptyCmp_stmtContext(p *Cmp_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_stmt
}

func (*Cmp_stmtContext) IsCmp_stmtContext() {}

func NewCmp_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmp_stmtContext {
	var p = new(Cmp_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cmp_stmt

	return p
}

func (s *Cmp_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmp_stmtContext) T_CMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CMP, 0)
}

func (s *Cmp_stmtContext) AllCmp_source() []ICmp_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICmp_sourceContext); ok {
			len++
		}
	}

	tst := make([]ICmp_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICmp_sourceContext); ok {
			tst[i] = t.(ICmp_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Cmp_stmtContext) Cmp_source(i int) ICmp_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmp_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmp_sourceContext)
}

func (s *Cmp_stmtContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Cmp_stmtContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Cmp_stmtContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Cmp_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmp_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmp_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCmp_stmt(s)
	}
}

func (s *Cmp_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCmp_stmt(s)
	}
}

func (p *HplsqlParser) Cmp_stmt() (localctx ICmp_stmtContext) {
	localctx = NewCmp_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, HplsqlParserRULE_cmp_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1955)
		p.Match(HplsqlParserT_CMP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1956)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ROW_COUNT || _la == HplsqlParserT_SUM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1957)
		p.Cmp_source()
	}
	{
		p.SetState(1958)
		p.Match(HplsqlParserT_COMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1959)
		p.Cmp_source()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmp_sourceContext is an interface to support dynamic dispatch.
type ICmp_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_AT() antlr.TerminalNode
	Qident() IQidentContext
	Where_clause() IWhere_clauseContext

	// IsCmp_sourceContext differentiates from other interfaces.
	IsCmp_sourceContext()
}

type Cmp_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmp_sourceContext() *Cmp_sourceContext {
	var p = new(Cmp_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_source
	return p
}

func InitEmptyCmp_sourceContext(p *Cmp_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_source
}

func (*Cmp_sourceContext) IsCmp_sourceContext() {}

func NewCmp_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmp_sourceContext {
	var p = new(Cmp_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cmp_source

	return p
}

func (s *Cmp_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmp_sourceContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Cmp_sourceContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cmp_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Cmp_sourceContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cmp_sourceContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Cmp_sourceContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cmp_sourceContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Cmp_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmp_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmp_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCmp_source(s)
	}
}

func (s *Cmp_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCmp_source(s)
	}
}

func (p *HplsqlParser) Cmp_source() (localctx ICmp_sourceContext) {
	localctx = NewCmp_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, HplsqlParserRULE_cmp_source)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(1961)
			p.Table_name()
		}
		p.SetState(1963)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1962)
				p.Where_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(1965)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1966)
			p.Select_stmt()
		}
		{
			p.SetState(1967)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1973)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1971)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1972)
			p.Qident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_from_local_stmtContext is an interface to support dynamic dispatch.
type ICopy_from_local_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COPY() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_LOCAL() antlr.TerminalNode
	AllCopy_source() []ICopy_sourceContext
	Copy_source(i int) ICopy_sourceContext
	T_TO() antlr.TerminalNode
	Copy_target() ICopy_targetContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllCopy_file_option() []ICopy_file_optionContext
	Copy_file_option(i int) ICopy_file_optionContext

	// IsCopy_from_local_stmtContext differentiates from other interfaces.
	IsCopy_from_local_stmtContext()
}

type Copy_from_local_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_from_local_stmtContext() *Copy_from_local_stmtContext {
	var p = new(Copy_from_local_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt
	return p
}

func InitEmptyCopy_from_local_stmtContext(p *Copy_from_local_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt
}

func (*Copy_from_local_stmtContext) IsCopy_from_local_stmtContext() {}

func NewCopy_from_local_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_from_local_stmtContext {
	var p = new(Copy_from_local_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt

	return p
}

func (s *Copy_from_local_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_from_local_stmtContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Copy_from_local_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Copy_from_local_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Copy_from_local_stmtContext) AllCopy_source() []ICopy_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_sourceContext); ok {
			len++
		}
	}

	tst := make([]ICopy_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_sourceContext); ok {
			tst[i] = t.(ICopy_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Copy_from_local_stmtContext) Copy_source(i int) ICopy_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_sourceContext)
}

func (s *Copy_from_local_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Copy_from_local_stmtContext) Copy_target() ICopy_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_targetContext)
}

func (s *Copy_from_local_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Copy_from_local_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Copy_from_local_stmtContext) AllCopy_file_option() []ICopy_file_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_file_optionContext); ok {
			len++
		}
	}

	tst := make([]ICopy_file_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_file_optionContext); ok {
			tst[i] = t.(ICopy_file_optionContext)
			i++
		}
	}

	return tst
}

func (s *Copy_from_local_stmtContext) Copy_file_option(i int) ICopy_file_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_file_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_file_optionContext)
}

func (s *Copy_from_local_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_from_local_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_from_local_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_from_local_stmt(s)
	}
}

func (s *Copy_from_local_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_from_local_stmt(s)
	}
}

func (p *HplsqlParser) Copy_from_local_stmt() (localctx ICopy_from_local_stmtContext) {
	localctx = NewCopy_from_local_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, HplsqlParserRULE_copy_from_local_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1975)
		p.Match(HplsqlParserT_COPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1976)
		p.Match(HplsqlParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1977)
		p.Match(HplsqlParserT_LOCAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1978)
		p.Copy_source()
	}
	p.SetState(1983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1979)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1980)
			p.Copy_source()
		}

		p.SetState(1985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1986)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1987)
		p.Copy_target()
	}
	p.SetState(1991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1988)
				p.Copy_file_option()
			}

		}
		p.SetState(1993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_stmtContext is an interface to support dynamic dispatch.
type ICopy_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COPY() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	Copy_target() ICopy_targetContext
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_HDFS() antlr.TerminalNode
	AllCopy_option() []ICopy_optionContext
	Copy_option(i int) ICopy_optionContext

	// IsCopy_stmtContext differentiates from other interfaces.
	IsCopy_stmtContext()
}

type Copy_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_stmtContext() *Copy_stmtContext {
	var p = new(Copy_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_stmt
	return p
}

func InitEmptyCopy_stmtContext(p *Copy_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_stmt
}

func (*Copy_stmtContext) IsCopy_stmtContext() {}

func NewCopy_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_stmtContext {
	var p = new(Copy_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_stmt

	return p
}

func (s *Copy_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_stmtContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Copy_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Copy_stmtContext) Copy_target() ICopy_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_targetContext)
}

func (s *Copy_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Copy_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Copy_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Copy_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Copy_stmtContext) T_HDFS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HDFS, 0)
}

func (s *Copy_stmtContext) AllCopy_option() []ICopy_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_optionContext); ok {
			len++
		}
	}

	tst := make([]ICopy_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_optionContext); ok {
			tst[i] = t.(ICopy_optionContext)
			i++
		}
	}

	return tst
}

func (s *Copy_stmtContext) Copy_option(i int) ICopy_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_optionContext)
}

func (s *Copy_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_stmt(s)
	}
}

func (s *Copy_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_stmt(s)
	}
}

func (p *HplsqlParser) Copy_stmt() (localctx ICopy_stmtContext) {
	localctx = NewCopy_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, HplsqlParserRULE_copy_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1994)
		p.Match(HplsqlParserT_COPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(1995)
			p.Table_name()
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(1996)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1997)
			p.Select_stmt()
		}
		{
			p.SetState(1998)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2002)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2004)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2003)
			p.Match(HplsqlParserT_HDFS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2006)
		p.Copy_target()
	}
	p.SetState(2010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2007)
				p.Copy_option()
			}

		}
		p.SetState(2012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_sourceContext is an interface to support dynamic dispatch.
type ICopy_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsCopy_sourceContext differentiates from other interfaces.
	IsCopy_sourceContext()
}

type Copy_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_sourceContext() *Copy_sourceContext {
	var p = new(Copy_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_source
	return p
}

func InitEmptyCopy_sourceContext(p *Copy_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_source
}

func (*Copy_sourceContext) IsCopy_sourceContext() {}

func NewCopy_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_sourceContext {
	var p = new(Copy_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_source

	return p
}

func (s *Copy_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_sourceContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Copy_sourceContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_source(s)
	}
}

func (s *Copy_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_source(s)
	}
}

func (p *HplsqlParser) Copy_source() (localctx ICopy_sourceContext) {
	localctx = NewCopy_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, HplsqlParserRULE_copy_source)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2013)
			p.File_name()
		}

	case 2:
		{
			p.SetState(2014)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_targetContext is an interface to support dynamic dispatch.
type ICopy_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsCopy_targetContext differentiates from other interfaces.
	IsCopy_targetContext()
}

type Copy_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_targetContext() *Copy_targetContext {
	var p = new(Copy_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_target
	return p
}

func InitEmptyCopy_targetContext(p *Copy_targetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_target
}

func (*Copy_targetContext) IsCopy_targetContext() {}

func NewCopy_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_targetContext {
	var p = new(Copy_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_target

	return p
}

func (s *Copy_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_targetContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Copy_targetContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_target(s)
	}
}

func (s *Copy_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_target(s)
	}
}

func (p *HplsqlParser) Copy_target() (localctx ICopy_targetContext) {
	localctx = NewCopy_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, HplsqlParserRULE_copy_target)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2017)
			p.File_name()
		}

	case 2:
		{
			p.SetState(2018)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_optionContext is an interface to support dynamic dispatch.
type ICopy_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AT() antlr.TerminalNode
	Qident() IQidentContext
	T_BATCHSIZE() antlr.TerminalNode
	Expr() IExprContext
	T_DELIMITER() antlr.TerminalNode
	T_SQLINSERT() antlr.TerminalNode

	// IsCopy_optionContext differentiates from other interfaces.
	IsCopy_optionContext()
}

type Copy_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_optionContext() *Copy_optionContext {
	var p = new(Copy_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_option
	return p
}

func InitEmptyCopy_optionContext(p *Copy_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_option
}

func (*Copy_optionContext) IsCopy_optionContext() {}

func NewCopy_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_optionContext {
	var p = new(Copy_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_option

	return p
}

func (s *Copy_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_optionContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Copy_optionContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Copy_optionContext) T_BATCHSIZE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BATCHSIZE, 0)
}

func (s *Copy_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_optionContext) T_DELIMITER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITER, 0)
}

func (s *Copy_optionContext) T_SQLINSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLINSERT, 0)
}

func (s *Copy_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_option(s)
	}
}

func (s *Copy_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_option(s)
	}
}

func (p *HplsqlParser) Copy_option() (localctx ICopy_optionContext) {
	localctx = NewCopy_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, HplsqlParserRULE_copy_option)
	p.SetState(2029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2021)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2022)
			p.Qident()
		}

	case HplsqlParserT_BATCHSIZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2023)
			p.Match(HplsqlParserT_BATCHSIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2024)
			p.expr(0)
		}

	case HplsqlParserT_DELIMITER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2025)
			p.Match(HplsqlParserT_DELIMITER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2026)
			p.expr(0)
		}

	case HplsqlParserT_SQLINSERT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2027)
			p.Match(HplsqlParserT_SQLINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_file_optionContext is an interface to support dynamic dispatch.
type ICopy_file_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DELETE() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode

	// IsCopy_file_optionContext differentiates from other interfaces.
	IsCopy_file_optionContext()
}

type Copy_file_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_file_optionContext() *Copy_file_optionContext {
	var p = new(Copy_file_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_file_option
	return p
}

func InitEmptyCopy_file_optionContext(p *Copy_file_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_file_option
}

func (*Copy_file_optionContext) IsCopy_file_optionContext() {}

func NewCopy_file_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_file_optionContext {
	var p = new(Copy_file_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_file_option

	return p
}

func (s *Copy_file_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_file_optionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Copy_file_optionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Copy_file_optionContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Copy_file_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_file_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_file_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_file_option(s)
	}
}

func (s *Copy_file_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_file_option(s)
	}
}

func (p *HplsqlParser) Copy_file_option() (localctx ICopy_file_optionContext) {
	localctx = NewCopy_file_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, HplsqlParserRULE_copy_file_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2031)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_IGNORE || _la == HplsqlParserT_OVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommit_stmtContext is an interface to support dynamic dispatch.
type ICommit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMIT() antlr.TerminalNode
	T_WORK() antlr.TerminalNode

	// IsCommit_stmtContext differentiates from other interfaces.
	IsCommit_stmtContext()
}

type Commit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_stmtContext() *Commit_stmtContext {
	var p = new(Commit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_commit_stmt
	return p
}

func InitEmptyCommit_stmtContext(p *Commit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_commit_stmt
}

func (*Commit_stmtContext) IsCommit_stmtContext() {}

func NewCommit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_stmtContext {
	var p = new(Commit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_commit_stmt

	return p
}

func (s *Commit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_stmtContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Commit_stmtContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Commit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Commit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCommit_stmt(s)
	}
}

func (s *Commit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCommit_stmt(s)
	}
}

func (p *HplsqlParser) Commit_stmt() (localctx ICommit_stmtContext) {
	localctx = NewCommit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, HplsqlParserRULE_commit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2033)
		p.Match(HplsqlParserT_COMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2035)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2034)
			p.Match(HplsqlParserT_WORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_index_stmtContext is an interface to support dynamic dispatch.
type ICreate_index_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	Qident() IQidentContext
	T_ON() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	AllCreate_index_col() []ICreate_index_colContext
	Create_index_col(i int) ICreate_index_colContext
	T_CLOSE_P() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_index_stmtContext differentiates from other interfaces.
	IsCreate_index_stmtContext()
}

type Create_index_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_index_stmtContext() *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_stmt
	return p
}

func InitEmptyCreate_index_stmtContext(p *Create_index_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_stmt
}

func (*Create_index_stmtContext) IsCreate_index_stmtContext() {}

func NewCreate_index_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_index_stmt

	return p
}

func (s *Create_index_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_index_stmtContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_index_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_index_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_index_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_index_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_index_stmtContext) AllCreate_index_col() []ICreate_index_colContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_index_colContext); ok {
			len++
		}
	}

	tst := make([]ICreate_index_colContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_index_colContext); ok {
			tst[i] = t.(ICreate_index_colContext)
			i++
		}
	}

	return tst
}

func (s *Create_index_stmtContext) Create_index_col(i int) ICreate_index_colContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_colContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_colContext)
}

func (s *Create_index_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_index_stmtContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_index_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_index_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_index_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_index_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_index_stmt(s)
	}
}

func (s *Create_index_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_index_stmt(s)
	}
}

func (p *HplsqlParser) Create_index_stmt() (localctx ICreate_index_stmtContext) {
	localctx = NewCreate_index_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, HplsqlParserRULE_create_index_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2037)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_UNIQUE {
		{
			p.SetState(2038)
			p.Match(HplsqlParserT_UNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2041)
		p.Match(HplsqlParserT_INDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2042)
		p.Qident()
	}
	{
		p.SetState(2043)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2044)
		p.Table_name()
	}
	{
		p.SetState(2045)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2046)
		p.Create_index_col()
	}
	p.SetState(2051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2047)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2048)
			p.Create_index_col()
		}

		p.SetState(2053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2054)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_index_colContext is an interface to support dynamic dispatch.
type ICreate_index_colContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_ASC() antlr.TerminalNode
	T_DESC() antlr.TerminalNode

	// IsCreate_index_colContext differentiates from other interfaces.
	IsCreate_index_colContext()
}

type Create_index_colContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_index_colContext() *Create_index_colContext {
	var p = new(Create_index_colContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_col
	return p
}

func InitEmptyCreate_index_colContext(p *Create_index_colContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_col
}

func (*Create_index_colContext) IsCreate_index_colContext() {}

func NewCreate_index_colContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_colContext {
	var p = new(Create_index_colContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_index_col

	return p
}

func (s *Create_index_colContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_colContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_index_colContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, 0)
}

func (s *Create_index_colContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Create_index_colContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_colContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_index_colContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_index_col(s)
	}
}

func (s *Create_index_colContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_index_col(s)
	}
}

func (p *HplsqlParser) Create_index_col() (localctx ICreate_index_colContext) {
	localctx = NewCreate_index_colContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, HplsqlParserRULE_create_index_col)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2056)
		p.Qident()
	}
	p.SetState(2058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
		{
			p.SetState(2057)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_storage_clauseContext is an interface to support dynamic dispatch.
type IIndex_storage_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Index_mssql_storage_clause() IIndex_mssql_storage_clauseContext

	// IsIndex_storage_clauseContext differentiates from other interfaces.
	IsIndex_storage_clauseContext()
}

type Index_storage_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_storage_clauseContext() *Index_storage_clauseContext {
	var p = new(Index_storage_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_storage_clause
	return p
}

func InitEmptyIndex_storage_clauseContext(p *Index_storage_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_storage_clause
}

func (*Index_storage_clauseContext) IsIndex_storage_clauseContext() {}

func NewIndex_storage_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_storage_clauseContext {
	var p = new(Index_storage_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_index_storage_clause

	return p
}

func (s *Index_storage_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_storage_clauseContext) Index_mssql_storage_clause() IIndex_mssql_storage_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_mssql_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_mssql_storage_clauseContext)
}

func (s *Index_storage_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_storage_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_storage_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIndex_storage_clause(s)
	}
}

func (s *Index_storage_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIndex_storage_clause(s)
	}
}

func (p *HplsqlParser) Index_storage_clause() (localctx IIndex_storage_clauseContext) {
	localctx = NewIndex_storage_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, HplsqlParserRULE_index_storage_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2060)
		p.Index_mssql_storage_clause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_mssql_storage_clauseContext is an interface to support dynamic dispatch.
type IIndex_mssql_storage_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_EQUAL() []antlr.TerminalNode
	T_EQUAL(i int) antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllCreate_table_options_mssql_item() []ICreate_table_options_mssql_itemContext
	Create_table_options_mssql_item(i int) ICreate_table_options_mssql_itemContext

	// IsIndex_mssql_storage_clauseContext differentiates from other interfaces.
	IsIndex_mssql_storage_clauseContext()
}

type Index_mssql_storage_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_mssql_storage_clauseContext() *Index_mssql_storage_clauseContext {
	var p = new(Index_mssql_storage_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause
	return p
}

func InitEmptyIndex_mssql_storage_clauseContext(p *Index_mssql_storage_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause
}

func (*Index_mssql_storage_clauseContext) IsIndex_mssql_storage_clauseContext() {}

func NewIndex_mssql_storage_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_mssql_storage_clauseContext {
	var p = new(Index_mssql_storage_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause

	return p
}

func (s *Index_mssql_storage_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_mssql_storage_clauseContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Index_mssql_storage_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Index_mssql_storage_clauseContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Index_mssql_storage_clauseContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Index_mssql_storage_clauseContext) AllT_EQUAL() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_EQUAL)
}

func (s *Index_mssql_storage_clauseContext) T_EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, i)
}

func (s *Index_mssql_storage_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Index_mssql_storage_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Index_mssql_storage_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Index_mssql_storage_clauseContext) AllCreate_table_options_mssql_item() []ICreate_table_options_mssql_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_options_mssql_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			tst[i] = t.(ICreate_table_options_mssql_itemContext)
			i++
		}
	}

	return tst
}

func (s *Index_mssql_storage_clauseContext) Create_table_options_mssql_item(i int) ICreate_table_options_mssql_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mssql_itemContext)
}

func (s *Index_mssql_storage_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_mssql_storage_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_mssql_storage_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIndex_mssql_storage_clause(s)
	}
}

func (s *Index_mssql_storage_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIndex_mssql_storage_clause(s)
	}
}

func (p *HplsqlParser) Index_mssql_storage_clause() (localctx IIndex_mssql_storage_clauseContext) {
	localctx = NewIndex_mssql_storage_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, HplsqlParserRULE_index_mssql_storage_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2062)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2063)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2064)
		p.Qident()
	}
	{
		p.SetState(2065)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2066)
		p.Qident()
	}
	p.SetState(2074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2067)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2068)
			p.Qident()
		}
		{
			p.SetState(2069)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2070)
			p.Qident()
		}

		p.SetState(2076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2077)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2078)
				p.Create_table_options_mssql_item()
			}

		}
		p.SetState(2083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrint_stmtContext is an interface to support dynamic dispatch.
type IPrint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRINT() antlr.TerminalNode
	Expr() IExprContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsPrint_stmtContext differentiates from other interfaces.
	IsPrint_stmtContext()
}

type Print_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrint_stmtContext() *Print_stmtContext {
	var p = new(Print_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_print_stmt
	return p
}

func InitEmptyPrint_stmtContext(p *Print_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_print_stmt
}

func (*Print_stmtContext) IsPrint_stmtContext() {}

func NewPrint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Print_stmtContext {
	var p = new(Print_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_print_stmt

	return p
}

func (s *Print_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Print_stmtContext) T_PRINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRINT, 0)
}

func (s *Print_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Print_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Print_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Print_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Print_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPrint_stmt(s)
	}
}

func (s *Print_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPrint_stmt(s)
	}
}

func (p *HplsqlParser) Print_stmt() (localctx IPrint_stmtContext) {
	localctx = NewPrint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, HplsqlParserRULE_print_stmt)
	p.SetState(2091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2084)
			p.Match(HplsqlParserT_PRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2085)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2086)
			p.Match(HplsqlParserT_PRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2087)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2088)
			p.expr(0)
		}
		{
			p.SetState(2089)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuit_stmtContext is an interface to support dynamic dispatch.
type IQuit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUIT() antlr.TerminalNode
	T_DOT() antlr.TerminalNode
	Expr() IExprContext

	// IsQuit_stmtContext differentiates from other interfaces.
	IsQuit_stmtContext()
}

type Quit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuit_stmtContext() *Quit_stmtContext {
	var p = new(Quit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_quit_stmt
	return p
}

func InitEmptyQuit_stmtContext(p *Quit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_quit_stmt
}

func (*Quit_stmtContext) IsQuit_stmtContext() {}

func NewQuit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quit_stmtContext {
	var p = new(Quit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_quit_stmt

	return p
}

func (s *Quit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Quit_stmtContext) T_QUIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUIT, 0)
}

func (s *Quit_stmtContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Quit_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Quit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQuit_stmt(s)
	}
}

func (s *Quit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQuit_stmt(s)
	}
}

func (p *HplsqlParser) Quit_stmt() (localctx IQuit_stmtContext) {
	localctx = NewQuit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, HplsqlParserRULE_quit_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_DOT {
		{
			p.SetState(2093)
			p.Match(HplsqlParserT_DOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2096)
		p.Match(HplsqlParserT_QUIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2098)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2097)
			p.expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RAISE() antlr.TerminalNode

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_raise_stmt
	return p
}

func InitEmptyRaise_stmtContext(p *Raise_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_raise_stmt
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) T_RAISE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RAISE, 0)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (p *HplsqlParser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, HplsqlParserRULE_raise_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2100)
		p.Match(HplsqlParserT_RAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResignal_stmtContext is an interface to support dynamic dispatch.
type IResignal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RESIGNAL() antlr.TerminalNode
	T_SQLSTATE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_VALUE() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode

	// IsResignal_stmtContext differentiates from other interfaces.
	IsResignal_stmtContext()
}

type Resignal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignal_stmtContext() *Resignal_stmtContext {
	var p = new(Resignal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_resignal_stmt
	return p
}

func InitEmptyResignal_stmtContext(p *Resignal_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_resignal_stmt
}

func (*Resignal_stmtContext) IsResignal_stmtContext() {}

func NewResignal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Resignal_stmtContext {
	var p = new(Resignal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_resignal_stmt

	return p
}

func (s *Resignal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Resignal_stmtContext) T_RESIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESIGNAL, 0)
}

func (s *Resignal_stmtContext) T_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLSTATE, 0)
}

func (s *Resignal_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Resignal_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Resignal_stmtContext) T_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUE, 0)
}

func (s *Resignal_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Resignal_stmtContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Resignal_stmtContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Resignal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Resignal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Resignal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterResignal_stmt(s)
	}
}

func (s *Resignal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitResignal_stmt(s)
	}
}

func (p *HplsqlParser) Resignal_stmt() (localctx IResignal_stmtContext) {
	localctx = NewResignal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, HplsqlParserRULE_resignal_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2102)
		p.Match(HplsqlParserT_RESIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2114)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2103)
			p.Match(HplsqlParserT_SQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2105)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2104)
				p.Match(HplsqlParserT_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2107)
			p.expr(0)
		}
		p.SetState(2112)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2108)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2109)
				p.Match(HplsqlParserT_MESSAGE_TEXT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2110)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2111)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RETURN() antlr.TerminalNode
	Expr() IExprContext

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_return_stmt
	return p
}

func InitEmptyReturn_stmtContext(p *Return_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_return_stmt
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Return_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (p *HplsqlParser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, HplsqlParserRULE_return_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2116)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2118)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2117)
			p.expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollback_stmtContext is an interface to support dynamic dispatch.
type IRollback_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ROLLBACK() antlr.TerminalNode
	T_WORK() antlr.TerminalNode

	// IsRollback_stmtContext differentiates from other interfaces.
	IsRollback_stmtContext()
}

type Rollback_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_stmtContext() *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_rollback_stmt
	return p
}

func InitEmptyRollback_stmtContext(p *Rollback_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_rollback_stmt
}

func (*Rollback_stmtContext) IsRollback_stmtContext() {}

func NewRollback_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_rollback_stmt

	return p
}

func (s *Rollback_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_stmtContext) T_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLLBACK, 0)
}

func (s *Rollback_stmtContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Rollback_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollback_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterRollback_stmt(s)
	}
}

func (s *Rollback_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitRollback_stmt(s)
	}
}

func (p *HplsqlParser) Rollback_stmt() (localctx IRollback_stmtContext) {
	localctx = NewRollback_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, HplsqlParserRULE_rollback_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2120)
		p.Match(HplsqlParserT_ROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2122)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2121)
			p.Match(HplsqlParserT_WORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_session_optionContext is an interface to support dynamic dispatch.
type ISet_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_current_schema_option() ISet_current_schema_optionContext
	Set_mssql_session_option() ISet_mssql_session_optionContext
	Set_teradata_session_option() ISet_teradata_session_optionContext

	// IsSet_session_optionContext differentiates from other interfaces.
	IsSet_session_optionContext()
}

type Set_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_session_optionContext() *Set_session_optionContext {
	var p = new(Set_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_session_option
	return p
}

func InitEmptySet_session_optionContext(p *Set_session_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_session_option
}

func (*Set_session_optionContext) IsSet_session_optionContext() {}

func NewSet_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_session_optionContext {
	var p = new(Set_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_session_option

	return p
}

func (s *Set_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_session_optionContext) Set_current_schema_option() ISet_current_schema_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_current_schema_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_current_schema_optionContext)
}

func (s *Set_session_optionContext) Set_mssql_session_option() ISet_mssql_session_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_mssql_session_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_mssql_session_optionContext)
}

func (s *Set_session_optionContext) Set_teradata_session_option() ISet_teradata_session_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_teradata_session_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_teradata_session_optionContext)
}

func (s *Set_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_session_option(s)
	}
}

func (s *Set_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_session_option(s)
	}
}

func (p *HplsqlParser) Set_session_option() (localctx ISet_session_optionContext) {
	localctx = NewSet_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, HplsqlParserRULE_set_session_option)
	p.SetState(2127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_SCHEMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2124)
			p.Set_current_schema_option()
		}

	case HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_NOCOUNT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_XACT_ABORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2125)
			p.Set_mssql_session_option()
		}

	case HplsqlParserT_QUERY_BAND:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2126)
			p.Set_teradata_session_option()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_current_schema_optionContext is an interface to support dynamic dispatch.
type ISet_current_schema_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	T_CURRENT_SCHEMA() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode

	// IsSet_current_schema_optionContext differentiates from other interfaces.
	IsSet_current_schema_optionContext()
}

type Set_current_schema_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_current_schema_optionContext() *Set_current_schema_optionContext {
	var p = new(Set_current_schema_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option
	return p
}

func InitEmptySet_current_schema_optionContext(p *Set_current_schema_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option
}

func (*Set_current_schema_optionContext) IsSet_current_schema_optionContext() {}

func NewSet_current_schema_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_current_schema_optionContext {
	var p = new(Set_current_schema_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option

	return p
}

func (s *Set_current_schema_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_current_schema_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_current_schema_optionContext) T_CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_SCHEMA, 0)
}

func (s *Set_current_schema_optionContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Set_current_schema_optionContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Set_current_schema_optionContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Set_current_schema_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_current_schema_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_current_schema_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_current_schema_option(s)
	}
}

func (s *Set_current_schema_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_current_schema_option(s)
	}
}

func (p *HplsqlParser) Set_current_schema_option() (localctx ISet_current_schema_optionContext) {
	localctx = NewSet_current_schema_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, HplsqlParserRULE_set_current_schema_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CURRENT, HplsqlParserT_SCHEMA:
		p.SetState(2130)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CURRENT {
			{
				p.SetState(2129)
				p.Match(HplsqlParserT_CURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2132)
			p.Match(HplsqlParserT_SCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CURRENT_SCHEMA:
		{
			p.SetState(2133)
			p.Match(HplsqlParserT_CURRENT_SCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_EQUAL {
		{
			p.SetState(2136)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2139)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_mssql_session_optionContext is an interface to support dynamic dispatch.
type ISet_mssql_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ANSI_NULLS() antlr.TerminalNode
	T_ANSI_PADDING() antlr.TerminalNode
	T_NOCOUNT() antlr.TerminalNode
	T_QUOTED_IDENTIFIER() antlr.TerminalNode
	T_XACT_ABORT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_OFF() antlr.TerminalNode

	// IsSet_mssql_session_optionContext differentiates from other interfaces.
	IsSet_mssql_session_optionContext()
}

type Set_mssql_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_mssql_session_optionContext() *Set_mssql_session_optionContext {
	var p = new(Set_mssql_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option
	return p
}

func InitEmptySet_mssql_session_optionContext(p *Set_mssql_session_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option
}

func (*Set_mssql_session_optionContext) IsSet_mssql_session_optionContext() {}

func NewSet_mssql_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_mssql_session_optionContext {
	var p = new(Set_mssql_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option

	return p
}

func (s *Set_mssql_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_mssql_session_optionContext) T_ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_NULLS, 0)
}

func (s *Set_mssql_session_optionContext) T_ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_PADDING, 0)
}

func (s *Set_mssql_session_optionContext) T_NOCOUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOUNT, 0)
}

func (s *Set_mssql_session_optionContext) T_QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUOTED_IDENTIFIER, 0)
}

func (s *Set_mssql_session_optionContext) T_XACT_ABORT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XACT_ABORT, 0)
}

func (s *Set_mssql_session_optionContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Set_mssql_session_optionContext) T_OFF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OFF, 0)
}

func (s *Set_mssql_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_mssql_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_mssql_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_mssql_session_option(s)
	}
}

func (s *Set_mssql_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_mssql_session_option(s)
	}
}

func (p *HplsqlParser) Set_mssql_session_option() (localctx ISet_mssql_session_optionContext) {
	localctx = NewSet_mssql_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, HplsqlParserRULE_set_mssql_session_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2141)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ANSI_NULLS || _la == HplsqlParserT_ANSI_PADDING || _la == HplsqlParserT_NOCOUNT || _la == HplsqlParserT_QUOTED_IDENTIFIER || _la == HplsqlParserT_XACT_ABORT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2142)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_OFF || _la == HplsqlParserT_ON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_teradata_session_optionContext is an interface to support dynamic dispatch.
type ISet_teradata_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUERY_BAND() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode
	T_SESSION() antlr.TerminalNode
	Expr() IExprContext
	T_NONE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode

	// IsSet_teradata_session_optionContext differentiates from other interfaces.
	IsSet_teradata_session_optionContext()
}

type Set_teradata_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_teradata_session_optionContext() *Set_teradata_session_optionContext {
	var p = new(Set_teradata_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option
	return p
}

func InitEmptySet_teradata_session_optionContext(p *Set_teradata_session_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option
}

func (*Set_teradata_session_optionContext) IsSet_teradata_session_optionContext() {}

func NewSet_teradata_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_teradata_session_optionContext {
	var p = new(Set_teradata_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option

	return p
}

func (s *Set_teradata_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_teradata_session_optionContext) T_QUERY_BAND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUERY_BAND, 0)
}

func (s *Set_teradata_session_optionContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Set_teradata_session_optionContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Set_teradata_session_optionContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Set_teradata_session_optionContext) T_SESSION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSION, 0)
}

func (s *Set_teradata_session_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_teradata_session_optionContext) T_NONE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NONE, 0)
}

func (s *Set_teradata_session_optionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Set_teradata_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_teradata_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_teradata_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_teradata_session_option(s)
	}
}

func (s *Set_teradata_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_teradata_session_option(s)
	}
}

func (p *HplsqlParser) Set_teradata_session_option() (localctx ISet_teradata_session_optionContext) {
	localctx = NewSet_teradata_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, HplsqlParserRULE_set_teradata_session_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2144)
		p.Match(HplsqlParserT_QUERY_BAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2145)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2146)
			p.expr(0)
		}

	case 2:
		{
			p.SetState(2147)
			p.Match(HplsqlParserT_NONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_UPDATE {
		{
			p.SetState(2150)
			p.Match(HplsqlParserT_UPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2153)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2154)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_SESSION || _la == HplsqlParserT_TRANSACTION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignal_stmtContext is an interface to support dynamic dispatch.
type ISignal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SIGNAL() antlr.TerminalNode
	Ident() IIdentContext

	// IsSignal_stmtContext differentiates from other interfaces.
	IsSignal_stmtContext()
}

type Signal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_stmtContext() *Signal_stmtContext {
	var p = new(Signal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_signal_stmt
	return p
}

func InitEmptySignal_stmtContext(p *Signal_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_signal_stmt
}

func (*Signal_stmtContext) IsSignal_stmtContext() {}

func NewSignal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_stmtContext {
	var p = new(Signal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_signal_stmt

	return p
}

func (s *Signal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_stmtContext) T_SIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIGNAL, 0)
}

func (s *Signal_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Signal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSignal_stmt(s)
	}
}

func (s *Signal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSignal_stmt(s)
	}
}

func (p *HplsqlParser) Signal_stmt() (localctx ISignal_stmtContext) {
	localctx = NewSignal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, HplsqlParserRULE_signal_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2156)
		p.Match(HplsqlParserT_SIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2157)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISummary_stmtContext is an interface to support dynamic dispatch.
type ISummary_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SUMMARY() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Table_name() ITable_nameContext
	T_TOP() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Where_clause() IWhere_clauseContext
	T_LIMIT() antlr.TerminalNode

	// IsSummary_stmtContext differentiates from other interfaces.
	IsSummary_stmtContext()
}

type Summary_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySummary_stmtContext() *Summary_stmtContext {
	var p = new(Summary_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_summary_stmt
	return p
}

func InitEmptySummary_stmtContext(p *Summary_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_summary_stmt
}

func (*Summary_stmtContext) IsSummary_stmtContext() {}

func NewSummary_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Summary_stmtContext {
	var p = new(Summary_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_summary_stmt

	return p
}

func (s *Summary_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Summary_stmtContext) T_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUMMARY, 0)
}

func (s *Summary_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Summary_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Summary_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Summary_stmtContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Summary_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Summary_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Summary_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Summary_stmtContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Summary_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Summary_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Summary_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSummary_stmt(s)
	}
}

func (s *Summary_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSummary_stmt(s)
	}
}

func (p *HplsqlParser) Summary_stmt() (localctx ISummary_stmtContext) {
	localctx = NewSummary_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, HplsqlParserRULE_summary_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2159)
		p.Match(HplsqlParserT_SUMMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_TOP {
		{
			p.SetState(2160)
			p.Match(HplsqlParserT_TOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2161)
			p.expr(0)
		}

	}
	{
		p.SetState(2164)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2165)
			p.Select_stmt()
		}

	case 2:
		{
			p.SetState(2166)
			p.Table_name()
		}
		p.SetState(2168)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2167)
				p.Where_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2172)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2170)
				p.Match(HplsqlParserT_LIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2171)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncate_stmtContext is an interface to support dynamic dispatch.
type ITruncate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRUNCATE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_TABLE() antlr.TerminalNode

	// IsTruncate_stmtContext differentiates from other interfaces.
	IsTruncate_stmtContext()
}

type Truncate_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncate_stmtContext() *Truncate_stmtContext {
	var p = new(Truncate_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_truncate_stmt
	return p
}

func InitEmptyTruncate_stmtContext(p *Truncate_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_truncate_stmt
}

func (*Truncate_stmtContext) IsTruncate_stmtContext() {}

func NewTruncate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Truncate_stmtContext {
	var p = new(Truncate_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_truncate_stmt

	return p
}

func (s *Truncate_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Truncate_stmtContext) T_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUNCATE, 0)
}

func (s *Truncate_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Truncate_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Truncate_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Truncate_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Truncate_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTruncate_stmt(s)
	}
}

func (s *Truncate_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTruncate_stmt(s)
	}
}

func (p *HplsqlParser) Truncate_stmt() (localctx ITruncate_stmtContext) {
	localctx = NewTruncate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, HplsqlParserRULE_truncate_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2176)
		p.Match(HplsqlParserT_TRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2178)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2177)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2180)
		p.Table_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_stmtContext is an interface to support dynamic dispatch.
type IUse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_USE() antlr.TerminalNode
	Expr() IExprContext

	// IsUse_stmtContext differentiates from other interfaces.
	IsUse_stmtContext()
}

type Use_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_stmtContext() *Use_stmtContext {
	var p = new(Use_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_use_stmt
	return p
}

func InitEmptyUse_stmtContext(p *Use_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_use_stmt
}

func (*Use_stmtContext) IsUse_stmtContext() {}

func NewUse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_stmtContext {
	var p = new(Use_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_use_stmt

	return p
}

func (s *Use_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_stmtContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Use_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Use_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUse_stmt(s)
	}
}

func (s *Use_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUse_stmt(s)
	}
}

func (p *HplsqlParser) Use_stmt() (localctx IUse_stmtContext) {
	localctx = NewUse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, HplsqlParserRULE_use_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2182)
		p.Match(HplsqlParserT_USE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2183)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValues_into_stmtContext is an interface to support dynamic dispatch.
type IValues_into_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_INTO() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode

	// IsValues_into_stmtContext differentiates from other interfaces.
	IsValues_into_stmtContext()
}

type Values_into_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_into_stmtContext() *Values_into_stmtContext {
	var p = new(Values_into_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_values_into_stmt
	return p
}

func InitEmptyValues_into_stmtContext(p *Values_into_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_values_into_stmt
}

func (*Values_into_stmtContext) IsValues_into_stmtContext() {}

func NewValues_into_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_into_stmtContext {
	var p = new(Values_into_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_values_into_stmt

	return p
}

func (s *Values_into_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_into_stmtContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Values_into_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Values_into_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Values_into_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Values_into_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Values_into_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Values_into_stmtContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Values_into_stmtContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Values_into_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Values_into_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Values_into_stmtContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Values_into_stmtContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Values_into_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_into_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_into_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterValues_into_stmt(s)
	}
}

func (s *Values_into_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitValues_into_stmt(s)
	}
}

func (p *HplsqlParser) Values_into_stmt() (localctx IValues_into_stmtContext) {
	localctx = NewValues_into_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, HplsqlParserRULE_values_into_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2185)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2187)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2186)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2189)
		p.expr(0)
	}
	p.SetState(2194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2190)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2191)
			p.expr(0)
		}

		p.SetState(2196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_CLOSE_P {
		{
			p.SetState(2197)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2200)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_OPEN_P {
		{
			p.SetState(2201)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2204)
		p.Ident()
	}
	p.SetState(2209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2205)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2206)
				p.Ident()
			}

		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2213)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2212)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_WHILE() []antlr.TerminalNode
	T_WHILE(i int) antlr.TerminalNode
	Bool_expr() IBool_exprContext
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_DO() antlr.TerminalNode
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	T_BEGIN() antlr.TerminalNode

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_while_stmt
	return p
}

func InitEmptyWhile_stmtContext(p *While_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_while_stmt
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) AllT_WHILE() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHILE)
}

func (s *While_stmtContext) T_WHILE(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHILE, i)
}

func (s *While_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *While_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *While_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *While_stmtContext) T_DO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DO, 0)
}

func (s *While_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *While_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *While_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *While_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (p *HplsqlParser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, HplsqlParserRULE_while_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2215)
		p.Match(HplsqlParserT_WHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2216)
		p.bool_expr(0)
	}
	{
		p.SetState(2217)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_BEGIN || _la == HplsqlParserT_DO || _la == HplsqlParserT_LOOP || _la == HplsqlParserT_THEN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2218)
		p.Block()
	}
	{
		p.SetState(2219)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2221)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2220)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LOOP || _la == HplsqlParserT_WHILE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnconditional_loop_stmtContext is an interface to support dynamic dispatch.
type IUnconditional_loop_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode

	// IsUnconditional_loop_stmtContext differentiates from other interfaces.
	IsUnconditional_loop_stmtContext()
}

type Unconditional_loop_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconditional_loop_stmtContext() *Unconditional_loop_stmtContext {
	var p = new(Unconditional_loop_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt
	return p
}

func InitEmptyUnconditional_loop_stmtContext(p *Unconditional_loop_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt
}

func (*Unconditional_loop_stmtContext) IsUnconditional_loop_stmtContext() {}

func NewUnconditional_loop_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unconditional_loop_stmtContext {
	var p = new(Unconditional_loop_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt

	return p
}

func (s *Unconditional_loop_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Unconditional_loop_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *Unconditional_loop_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *Unconditional_loop_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Unconditional_loop_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Unconditional_loop_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unconditional_loop_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unconditional_loop_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUnconditional_loop_stmt(s)
	}
}

func (s *Unconditional_loop_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUnconditional_loop_stmt(s)
	}
}

func (p *HplsqlParser) Unconditional_loop_stmt() (localctx IUnconditional_loop_stmtContext) {
	localctx = NewUnconditional_loop_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, HplsqlParserRULE_unconditional_loop_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2223)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2224)
		p.Block()
	}
	{
		p.SetState(2225)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2226)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_cursor_stmtContext is an interface to support dynamic dispatch.
type IFor_cursor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FOR() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsFor_cursor_stmtContext differentiates from other interfaces.
	IsFor_cursor_stmtContext()
}

type For_cursor_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_cursor_stmtContext() *For_cursor_stmtContext {
	var p = new(For_cursor_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt
	return p
}

func InitEmptyFor_cursor_stmtContext(p *For_cursor_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt
}

func (*For_cursor_stmtContext) IsFor_cursor_stmtContext() {}

func NewFor_cursor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_cursor_stmtContext {
	var p = new(For_cursor_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt

	return p
}

func (s *For_cursor_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_cursor_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *For_cursor_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *For_cursor_stmtContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *For_cursor_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *For_cursor_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *For_cursor_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *For_cursor_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *For_cursor_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *For_cursor_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *For_cursor_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *For_cursor_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_cursor_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_cursor_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFor_cursor_stmt(s)
	}
}

func (s *For_cursor_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFor_cursor_stmt(s)
	}
}

func (p *HplsqlParser) For_cursor_stmt() (localctx IFor_cursor_stmtContext) {
	localctx = NewFor_cursor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, HplsqlParserRULE_for_cursor_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2228)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2229)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2230)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2232)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2231)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2234)
		p.Select_stmt()
	}
	p.SetState(2236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_CLOSE_P {
		{
			p.SetState(2235)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2238)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2239)
		p.Block()
	}
	{
		p.SetState(2240)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2241)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_range_stmtContext is an interface to support dynamic dispatch.
type IFor_range_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FOR() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_DOT2() antlr.TerminalNode
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_REVERSE() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_STEP() antlr.TerminalNode

	// IsFor_range_stmtContext differentiates from other interfaces.
	IsFor_range_stmtContext()
}

type For_range_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_range_stmtContext() *For_range_stmtContext {
	var p = new(For_range_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_range_stmt
	return p
}

func InitEmptyFor_range_stmtContext(p *For_range_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_range_stmt
}

func (*For_range_stmtContext) IsFor_range_stmtContext() {}

func NewFor_range_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_range_stmtContext {
	var p = new(For_range_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_for_range_stmt

	return p
}

func (s *For_range_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_range_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *For_range_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *For_range_stmtContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *For_range_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *For_range_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *For_range_stmtContext) T_DOT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT2, 0)
}

func (s *For_range_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *For_range_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *For_range_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *For_range_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *For_range_stmtContext) T_REVERSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REVERSE, 0)
}

func (s *For_range_stmtContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *For_range_stmtContext) T_STEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STEP, 0)
}

func (s *For_range_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_range_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_range_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFor_range_stmt(s)
	}
}

func (s *For_range_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFor_range_stmt(s)
	}
}

func (p *HplsqlParser) For_range_stmt() (localctx IFor_range_stmtContext) {
	localctx = NewFor_range_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, HplsqlParserRULE_for_range_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2243)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2244)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2245)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2246)
			p.Match(HplsqlParserT_REVERSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2249)
		p.expr(0)
	}
	{
		p.SetState(2250)
		p.Match(HplsqlParserT_DOT2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2251)
		p.expr(0)
	}
	p.SetState(2254)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BY || _la == HplsqlParserT_STEP {
		{
			p.SetState(2252)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_BY || _la == HplsqlParserT_STEP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2253)
			p.expr(0)
		}

	}
	{
		p.SetState(2256)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2257)
		p.Block()
	}
	{
		p.SetState(2258)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2259)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_LABEL() antlr.TerminalNode
	AllT_LESS() []antlr.TerminalNode
	T_LESS(i int) antlr.TerminalNode
	L_ID() antlr.TerminalNode
	AllT_GREATER() []antlr.TerminalNode
	T_GREATER(i int) antlr.TerminalNode

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) L_LABEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_LABEL, 0)
}

func (s *LabelContext) AllT_LESS() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LESS)
}

func (s *LabelContext) T_LESS(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESS, i)
}

func (s *LabelContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *LabelContext) AllT_GREATER() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_GREATER)
}

func (s *LabelContext) T_GREATER(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, i)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *HplsqlParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, HplsqlParserRULE_label)
	p.SetState(2267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_LABEL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2261)
			p.Match(HplsqlParserL_LABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LESS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2262)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2263)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2264)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2265)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2266)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsing_clauseContext is an interface to support dynamic dispatch.
type IUsing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_USING() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsUsing_clauseContext differentiates from other interfaces.
	IsUsing_clauseContext()
}

type Using_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_clauseContext() *Using_clauseContext {
	var p = new(Using_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_using_clause
	return p
}

func InitEmptyUsing_clauseContext(p *Using_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_using_clause
}

func (*Using_clauseContext) IsUsing_clauseContext() {}

func NewUsing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_clauseContext {
	var p = new(Using_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_using_clause

	return p
}

func (s *Using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_clauseContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Using_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Using_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Using_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Using_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUsing_clause(s)
	}
}

func (s *Using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUsing_clause(s)
	}
}

func (p *HplsqlParser) Using_clause() (localctx IUsing_clauseContext) {
	localctx = NewUsing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, HplsqlParserRULE_using_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2269)
		p.Match(HplsqlParserT_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2270)
		p.expr(0)
	}
	p.SetState(2275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2271)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2272)
				p.expr(0)
			}

		}
		p.SetState(2277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_stmtContext is an interface to support dynamic dispatch.
type ISelect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Fullselect_stmt() IFullselect_stmtContext
	Cte_select_stmt() ICte_select_stmtContext

	// IsSelect_stmtContext differentiates from other interfaces.
	IsSelect_stmtContext()
}

type Select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_stmtContext() *Select_stmtContext {
	var p = new(Select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_stmt
	return p
}

func InitEmptySelect_stmtContext(p *Select_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_stmt
}

func (*Select_stmtContext) IsSelect_stmtContext() {}

func NewSelect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_stmtContext {
	var p = new(Select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_stmt

	return p
}

func (s *Select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_stmtContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Select_stmtContext) Cte_select_stmt() ICte_select_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_stmtContext)
}

func (s *Select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_stmt(s)
	}
}

func (s *Select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_stmt(s)
	}
}

func (p *HplsqlParser) Select_stmt() (localctx ISelect_stmtContext) {
	localctx = NewSelect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, HplsqlParserRULE_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_WITH {
		{
			p.SetState(2278)
			p.Cte_select_stmt()
		}

	}
	{
		p.SetState(2281)
		p.Fullselect_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_select_stmtContext is an interface to support dynamic dispatch.
type ICte_select_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	AllCte_select_stmt_item() []ICte_select_stmt_itemContext
	Cte_select_stmt_item(i int) ICte_select_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCte_select_stmtContext differentiates from other interfaces.
	IsCte_select_stmtContext()
}

type Cte_select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_stmtContext() *Cte_select_stmtContext {
	var p = new(Cte_select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt
	return p
}

func InitEmptyCte_select_stmtContext(p *Cte_select_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt
}

func (*Cte_select_stmtContext) IsCte_select_stmtContext() {}

func NewCte_select_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_stmtContext {
	var p = new(Cte_select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt

	return p
}

func (s *Cte_select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_stmtContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Cte_select_stmtContext) AllCte_select_stmt_item() []ICte_select_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICte_select_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]ICte_select_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICte_select_stmt_itemContext); ok {
			tst[i] = t.(ICte_select_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Cte_select_stmtContext) Cte_select_stmt_item(i int) ICte_select_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_stmt_itemContext)
}

func (s *Cte_select_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Cte_select_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Cte_select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_stmt(s)
	}
}

func (s *Cte_select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_stmt(s)
	}
}

func (p *HplsqlParser) Cte_select_stmt() (localctx ICte_select_stmtContext) {
	localctx = NewCte_select_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, HplsqlParserRULE_cte_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2283)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2284)
		p.Cte_select_stmt_item()
	}
	p.SetState(2289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2285)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2286)
			p.Cte_select_stmt_item()
		}

		p.SetState(2291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_select_stmt_itemContext is an interface to support dynamic dispatch.
type ICte_select_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Fullselect_stmt() IFullselect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Cte_select_cols() ICte_select_colsContext

	// IsCte_select_stmt_itemContext differentiates from other interfaces.
	IsCte_select_stmt_itemContext()
}

type Cte_select_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_stmt_itemContext() *Cte_select_stmt_itemContext {
	var p = new(Cte_select_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item
	return p
}

func InitEmptyCte_select_stmt_itemContext(p *Cte_select_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item
}

func (*Cte_select_stmt_itemContext) IsCte_select_stmt_itemContext() {}

func NewCte_select_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_stmt_itemContext {
	var p = new(Cte_select_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item

	return p
}

func (s *Cte_select_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_stmt_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cte_select_stmt_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Cte_select_stmt_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cte_select_stmt_itemContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Cte_select_stmt_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cte_select_stmt_itemContext) Cte_select_cols() ICte_select_colsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_colsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_colsContext)
}

func (s *Cte_select_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_select_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_stmt_item(s)
	}
}

func (s *Cte_select_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_stmt_item(s)
	}
}

func (p *HplsqlParser) Cte_select_stmt_item() (localctx ICte_select_stmt_itemContext) {
	localctx = NewCte_select_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, HplsqlParserRULE_cte_select_stmt_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2292)
		p.Qident()
	}
	p.SetState(2294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_OPEN_P {
		{
			p.SetState(2293)
			p.Cte_select_cols()
		}

	}
	{
		p.SetState(2296)
		p.Match(HplsqlParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2297)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2298)
		p.Fullselect_stmt()
	}
	{
		p.SetState(2299)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_select_colsContext is an interface to support dynamic dispatch.
type ICte_select_colsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCte_select_colsContext differentiates from other interfaces.
	IsCte_select_colsContext()
}

type Cte_select_colsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_colsContext() *Cte_select_colsContext {
	var p = new(Cte_select_colsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_cols
	return p
}

func InitEmptyCte_select_colsContext(p *Cte_select_colsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_cols
}

func (*Cte_select_colsContext) IsCte_select_colsContext() {}

func NewCte_select_colsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_colsContext {
	var p = new(Cte_select_colsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_cols

	return p
}

func (s *Cte_select_colsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_colsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cte_select_colsContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Cte_select_colsContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cte_select_colsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cte_select_colsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Cte_select_colsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Cte_select_colsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_colsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_select_colsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_cols(s)
	}
}

func (s *Cte_select_colsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_cols(s)
	}
}

func (p *HplsqlParser) Cte_select_cols() (localctx ICte_select_colsContext) {
	localctx = NewCte_select_colsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, HplsqlParserRULE_cte_select_cols)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2301)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2302)
		p.Qident()
	}
	p.SetState(2307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2303)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2304)
			p.Qident()
		}

		p.SetState(2309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2310)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullselect_stmtContext is an interface to support dynamic dispatch.
type IFullselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFullselect_stmt_item() []IFullselect_stmt_itemContext
	Fullselect_stmt_item(i int) IFullselect_stmt_itemContext
	AllFullselect_set_clause() []IFullselect_set_clauseContext
	Fullselect_set_clause(i int) IFullselect_set_clauseContext

	// IsFullselect_stmtContext differentiates from other interfaces.
	IsFullselect_stmtContext()
}

type Fullselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_stmtContext() *Fullselect_stmtContext {
	var p = new(Fullselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt
	return p
}

func InitEmptyFullselect_stmtContext(p *Fullselect_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt
}

func (*Fullselect_stmtContext) IsFullselect_stmtContext() {}

func NewFullselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_stmtContext {
	var p = new(Fullselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt

	return p
}

func (s *Fullselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_stmtContext) AllFullselect_stmt_item() []IFullselect_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullselect_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IFullselect_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullselect_stmt_itemContext); ok {
			tst[i] = t.(IFullselect_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Fullselect_stmtContext) Fullselect_stmt_item(i int) IFullselect_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmt_itemContext)
}

func (s *Fullselect_stmtContext) AllFullselect_set_clause() []IFullselect_set_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullselect_set_clauseContext); ok {
			len++
		}
	}

	tst := make([]IFullselect_set_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullselect_set_clauseContext); ok {
			tst[i] = t.(IFullselect_set_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Fullselect_stmtContext) Fullselect_set_clause(i int) IFullselect_set_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_set_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_set_clauseContext)
}

func (s *Fullselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fullselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_stmt(s)
	}
}

func (s *Fullselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_stmt(s)
	}
}

func (p *HplsqlParser) Fullselect_stmt() (localctx IFullselect_stmtContext) {
	localctx = NewFullselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, HplsqlParserRULE_fullselect_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2312)
		p.Fullselect_stmt_item()
	}
	p.SetState(2318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2313)
				p.Fullselect_set_clause()
			}
			{
				p.SetState(2314)
				p.Fullselect_stmt_item()
			}

		}
		p.SetState(2320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullselect_stmt_itemContext is an interface to support dynamic dispatch.
type IFullselect_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Subselect_stmt() ISubselect_stmtContext
	T_OPEN_P() antlr.TerminalNode
	Fullselect_stmt() IFullselect_stmtContext
	T_CLOSE_P() antlr.TerminalNode

	// IsFullselect_stmt_itemContext differentiates from other interfaces.
	IsFullselect_stmt_itemContext()
}

type Fullselect_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_stmt_itemContext() *Fullselect_stmt_itemContext {
	var p = new(Fullselect_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item
	return p
}

func InitEmptyFullselect_stmt_itemContext(p *Fullselect_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item
}

func (*Fullselect_stmt_itemContext) IsFullselect_stmt_itemContext() {}

func NewFullselect_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_stmt_itemContext {
	var p = new(Fullselect_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item

	return p
}

func (s *Fullselect_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_stmt_itemContext) Subselect_stmt() ISubselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubselect_stmtContext)
}

func (s *Fullselect_stmt_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Fullselect_stmt_itemContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Fullselect_stmt_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Fullselect_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fullselect_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_stmt_item(s)
	}
}

func (s *Fullselect_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_stmt_item(s)
	}
}

func (p *HplsqlParser) Fullselect_stmt_item() (localctx IFullselect_stmt_itemContext) {
	localctx = NewFullselect_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, HplsqlParserRULE_fullselect_stmt_item)
	p.SetState(2326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEL, HplsqlParserT_SELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2321)
			p.Subselect_stmt()
		}

	case HplsqlParserT_OPEN_P:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2322)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2323)
			p.Fullselect_stmt()
		}
		{
			p.SetState(2324)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullselect_set_clauseContext is an interface to support dynamic dispatch.
type IFullselect_set_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_UNION() antlr.TerminalNode
	T_ALL() antlr.TerminalNode
	T_EXCEPT() antlr.TerminalNode
	T_INTERSECT() antlr.TerminalNode

	// IsFullselect_set_clauseContext differentiates from other interfaces.
	IsFullselect_set_clauseContext()
}

type Fullselect_set_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_set_clauseContext() *Fullselect_set_clauseContext {
	var p = new(Fullselect_set_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause
	return p
}

func InitEmptyFullselect_set_clauseContext(p *Fullselect_set_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause
}

func (*Fullselect_set_clauseContext) IsFullselect_set_clauseContext() {}

func NewFullselect_set_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_set_clauseContext {
	var p = new(Fullselect_set_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause

	return p
}

func (s *Fullselect_set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_set_clauseContext) T_UNION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNION, 0)
}

func (s *Fullselect_set_clauseContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Fullselect_set_clauseContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPT, 0)
}

func (s *Fullselect_set_clauseContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERSECT, 0)
}

func (s *Fullselect_set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fullselect_set_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_set_clause(s)
	}
}

func (s *Fullselect_set_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_set_clause(s)
	}
}

func (p *HplsqlParser) Fullselect_set_clause() (localctx IFullselect_set_clauseContext) {
	localctx = NewFullselect_set_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, HplsqlParserRULE_fullselect_set_clause)
	var _la int

	p.SetState(2340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_UNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2328)
			p.Match(HplsqlParserT_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2329)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_EXCEPT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2332)
			p.Match(HplsqlParserT_EXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2334)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2333)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_INTERSECT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2336)
			p.Match(HplsqlParserT_INTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2337)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubselect_stmtContext is an interface to support dynamic dispatch.
type ISubselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_list() ISelect_listContext
	T_SELECT() antlr.TerminalNode
	T_SEL() antlr.TerminalNode
	Into_clause() IInto_clauseContext
	From_clause() IFrom_clauseContext
	Where_clause() IWhere_clauseContext
	Group_by_clause() IGroup_by_clauseContext
	Having_clause() IHaving_clauseContext
	Qualify_clause() IQualify_clauseContext
	Order_by_clause() IOrder_by_clauseContext
	Select_options() ISelect_optionsContext

	// IsSubselect_stmtContext differentiates from other interfaces.
	IsSubselect_stmtContext()
}

type Subselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubselect_stmtContext() *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_subselect_stmt
	return p
}

func InitEmptySubselect_stmtContext(p *Subselect_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_subselect_stmt
}

func (*Subselect_stmtContext) IsSubselect_stmtContext() {}

func NewSubselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_subselect_stmt

	return p
}

func (s *Subselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Subselect_stmtContext) Select_list() ISelect_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_listContext)
}

func (s *Subselect_stmtContext) T_SELECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SELECT, 0)
}

func (s *Subselect_stmtContext) T_SEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEL, 0)
}

func (s *Subselect_stmtContext) Into_clause() IInto_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Subselect_stmtContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Subselect_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Subselect_stmtContext) Group_by_clause() IGroup_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Subselect_stmtContext) Having_clause() IHaving_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Subselect_stmtContext) Qualify_clause() IQualify_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clauseContext)
}

func (s *Subselect_stmtContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Subselect_stmtContext) Select_options() ISelect_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_optionsContext)
}

func (s *Subselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSubselect_stmt(s)
	}
}

func (s *Subselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSubselect_stmt(s)
	}
}

func (p *HplsqlParser) Subselect_stmt() (localctx ISubselect_stmtContext) {
	localctx = NewSubselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, HplsqlParserRULE_subselect_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2342)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_SEL || _la == HplsqlParserT_SELECT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2343)
		p.Select_list()
	}
	p.SetState(2345)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2344)
			p.Into_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2348)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2347)
			p.From_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2351)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2350)
			p.Where_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2354)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2353)
			p.Group_by_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2356)
			p.Having_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2357)
			p.Qualify_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2361)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2360)
			p.Order_by_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2364)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2363)
			p.Select_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_listContext is an interface to support dynamic dispatch.
type ISelect_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_list_item() []ISelect_list_itemContext
	Select_list_item(i int) ISelect_list_itemContext
	Select_list_set() ISelect_list_setContext
	Select_list_limit() ISelect_list_limitContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsSelect_listContext differentiates from other interfaces.
	IsSelect_listContext()
}

type Select_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_listContext() *Select_listContext {
	var p = new(Select_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list
	return p
}

func InitEmptySelect_listContext(p *Select_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list
}

func (*Select_listContext) IsSelect_listContext() {}

func NewSelect_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_listContext {
	var p = new(Select_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list

	return p
}

func (s *Select_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_listContext) AllSelect_list_item() []ISelect_list_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			len++
		}
	}

	tst := make([]ISelect_list_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_list_itemContext); ok {
			tst[i] = t.(ISelect_list_itemContext)
			i++
		}
	}

	return tst
}

func (s *Select_listContext) Select_list_item(i int) ISelect_list_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_itemContext)
}

func (s *Select_listContext) Select_list_set() ISelect_list_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_setContext)
}

func (s *Select_listContext) Select_list_limit() ISelect_list_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_limitContext)
}

func (s *Select_listContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Select_listContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Select_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list(s)
	}
}

func (s *Select_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list(s)
	}
}

func (p *HplsqlParser) Select_list() (localctx ISelect_listContext) {
	localctx = NewSelect_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, HplsqlParserRULE_select_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2367)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2366)
			p.Select_list_set()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2370)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2369)
			p.Select_list_limit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2372)
		p.Select_list_item()
	}
	p.SetState(2377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2373)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2374)
				p.Select_list_item()
			}

		}
		p.SetState(2379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_setContext is an interface to support dynamic dispatch.
type ISelect_list_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALL() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode

	// IsSelect_list_setContext differentiates from other interfaces.
	IsSelect_list_setContext()
}

type Select_list_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_setContext() *Select_list_setContext {
	var p = new(Select_list_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_set
	return p
}

func InitEmptySelect_list_setContext(p *Select_list_setContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_set
}

func (*Select_list_setContext) IsSelect_list_setContext() {}

func NewSelect_list_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_setContext {
	var p = new(Select_list_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_set

	return p
}

func (s *Select_list_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_setContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Select_list_setContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Select_list_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_set(s)
	}
}

func (s *Select_list_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_set(s)
	}
}

func (p *HplsqlParser) Select_list_set() (localctx ISelect_list_setContext) {
	localctx = NewSelect_list_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, HplsqlParserRULE_select_list_set)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2380)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ALL || _la == HplsqlParserT_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_limitContext is an interface to support dynamic dispatch.
type ISelect_list_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TOP() antlr.TerminalNode
	Expr() IExprContext

	// IsSelect_list_limitContext differentiates from other interfaces.
	IsSelect_list_limitContext()
}

type Select_list_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_limitContext() *Select_list_limitContext {
	var p = new(Select_list_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_limit
	return p
}

func InitEmptySelect_list_limitContext(p *Select_list_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_limit
}

func (*Select_list_limitContext) IsSelect_list_limitContext() {}

func NewSelect_list_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_limitContext {
	var p = new(Select_list_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_limit

	return p
}

func (s *Select_list_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_limitContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Select_list_limitContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_list_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_limit(s)
	}
}

func (s *Select_list_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_limit(s)
	}
}

func (p *HplsqlParser) Select_list_limit() (localctx ISelect_list_limitContext) {
	localctx = NewSelect_list_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, HplsqlParserRULE_select_list_limit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2382)
		p.Match(HplsqlParserT_TOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2383)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_itemContext is an interface to support dynamic dispatch.
type ISelect_list_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Select_list_asterisk() ISelect_list_asteriskContext
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	Select_list_alias() ISelect_list_aliasContext

	// IsSelect_list_itemContext differentiates from other interfaces.
	IsSelect_list_itemContext()
}

type Select_list_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_itemContext() *Select_list_itemContext {
	var p = new(Select_list_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_item
	return p
}

func InitEmptySelect_list_itemContext(p *Select_list_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_item
}

func (*Select_list_itemContext) IsSelect_list_itemContext() {}

func NewSelect_list_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_itemContext {
	var p = new(Select_list_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_item

	return p
}

func (s *Select_list_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_list_itemContext) Select_list_asterisk() ISelect_list_asteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_asteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_asteriskContext)
}

func (s *Select_list_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Select_list_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Select_list_itemContext) Select_list_alias() ISelect_list_aliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_aliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_aliasContext)
}

func (s *Select_list_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_item(s)
	}
}

func (s *Select_list_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_item(s)
	}
}

func (p *HplsqlParser) Select_list_item() (localctx ISelect_list_itemContext) {
	localctx = NewSelect_list_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, HplsqlParserRULE_select_list_item)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2388)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2385)
				p.Qident()
			}
			{
				p.SetState(2386)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2390)
			p.expr(0)
		}
		p.SetState(2392)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2391)
				p.Select_list_alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(2394)
			p.Select_list_asterisk()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_aliasContext is an interface to support dynamic dispatch.
type ISelect_list_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_TITLE() antlr.TerminalNode
	L_S_STRING() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsSelect_list_aliasContext differentiates from other interfaces.
	IsSelect_list_aliasContext()
}

type Select_list_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_aliasContext() *Select_list_aliasContext {
	var p = new(Select_list_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_alias
	return p
}

func InitEmptySelect_list_aliasContext(p *Select_list_aliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_alias
}

func (*Select_list_aliasContext) IsSelect_list_aliasContext() {}

func NewSelect_list_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_aliasContext {
	var p = new(Select_list_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_alias

	return p
}

func (s *Select_list_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_aliasContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Select_list_aliasContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Select_list_aliasContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Select_list_aliasContext) T_TITLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TITLE, 0)
}

func (s *Select_list_aliasContext) L_S_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_S_STRING, 0)
}

func (s *Select_list_aliasContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Select_list_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_alias(s)
	}
}

func (s *Select_list_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_alias(s)
	}
}

func (p *HplsqlParser) Select_list_alias() (localctx ISelect_list_aliasContext) {
	localctx = NewSelect_list_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, HplsqlParserRULE_select_list_alias)
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2397)

		if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "FROM")) {
			p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INTO\") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"FROM\")", ""))
			goto errorExit
		}
		p.SetState(2399)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2398)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2401)
			p.Qident()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2402)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2403)
			p.Match(HplsqlParserT_TITLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2404)
			p.Match(HplsqlParserL_S_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2405)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_asteriskContext is an interface to support dynamic dispatch.
type ISelect_list_asteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MUL() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_DOT() antlr.TerminalNode

	// IsSelect_list_asteriskContext differentiates from other interfaces.
	IsSelect_list_asteriskContext()
}

type Select_list_asteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_asteriskContext() *Select_list_asteriskContext {
	var p = new(Select_list_asteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk
	return p
}

func InitEmptySelect_list_asteriskContext(p *Select_list_asteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk
}

func (*Select_list_asteriskContext) IsSelect_list_asteriskContext() {}

func NewSelect_list_asteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_asteriskContext {
	var p = new(Select_list_asteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk

	return p
}

func (s *Select_list_asteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_asteriskContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Select_list_asteriskContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Select_list_asteriskContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Select_list_asteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_asteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_asteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_asterisk(s)
	}
}

func (s *Select_list_asteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_asterisk(s)
	}
}

func (p *HplsqlParser) Select_list_asterisk() (localctx ISelect_list_asteriskContext) {
	localctx = NewSelect_list_asteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, HplsqlParserRULE_select_list_asterisk)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserL_ID {
		{
			p.SetState(2408)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2409)
			p.Match(HplsqlParserT_DOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2412)
		p.Match(HplsqlParserT_MUL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_rowContext is an interface to support dynamic dispatch.
type ITable_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_OPEN_P() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsTable_rowContext differentiates from other interfaces.
	IsTable_rowContext()
}

type Table_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_rowContext() *Table_rowContext {
	var p = new(Table_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_row
	return p
}

func InitEmptyTable_rowContext(p *Table_rowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_row
}

func (*Table_rowContext) IsTable_rowContext() {}

func NewTable_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_rowContext {
	var p = new(Table_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_table_row

	return p
}

func (s *Table_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_rowContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Table_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Table_rowContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Table_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Table_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTable_row(s)
	}
}

func (s *Table_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTable_row(s)
	}
}

func (p *HplsqlParser) Table_row() (localctx ITable_rowContext) {
	localctx = NewTable_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, HplsqlParserRULE_table_row)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2414)
		p.Ident()
	}
	{
		p.SetState(2415)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2416)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2417)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_clauseContext is an interface to support dynamic dispatch.
type IInto_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INTO() antlr.TerminalNode
	AllTable_row() []ITable_rowContext
	Table_row(i int) ITable_rowContext
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Bulk_collect_clause() IBulk_collect_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInto_clauseContext differentiates from other interfaces.
	IsInto_clauseContext()
}

type Into_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_clauseContext() *Into_clauseContext {
	var p = new(Into_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_into_clause
	return p
}

func InitEmptyInto_clauseContext(p *Into_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_into_clause
}

func (*Into_clauseContext) IsInto_clauseContext() {}

func NewInto_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_clauseContext {
	var p = new(Into_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_into_clause

	return p
}

func (s *Into_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_clauseContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Into_clauseContext) AllTable_row() []ITable_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_rowContext); ok {
			len++
		}
	}

	tst := make([]ITable_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_rowContext); ok {
			tst[i] = t.(ITable_rowContext)
			i++
		}
	}

	return tst
}

func (s *Into_clauseContext) Table_row(i int) ITable_rowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_rowContext)
}

func (s *Into_clauseContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Into_clauseContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Into_clauseContext) Bulk_collect_clause() IBulk_collect_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulk_collect_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulk_collect_clauseContext)
}

func (s *Into_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Into_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Into_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInto_clause(s)
	}
}

func (s *Into_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInto_clause(s)
	}
}

func (p *HplsqlParser) Into_clause() (localctx IInto_clauseContext) {
	localctx = NewInto_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, HplsqlParserRULE_into_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BULK {
		{
			p.SetState(2419)
			p.Bulk_collect_clause()
		}

	}
	{
		p.SetState(2422)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2423)
			p.Table_row()
		}

	case 2:
		{
			p.SetState(2424)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2427)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2430)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2428)
					p.Table_row()
				}

			case 2:
				{
					p.SetState(2429)
					p.Ident()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBulk_collect_clauseContext is an interface to support dynamic dispatch.
type IBulk_collect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BULK() antlr.TerminalNode
	T_COLLECT() antlr.TerminalNode

	// IsBulk_collect_clauseContext differentiates from other interfaces.
	IsBulk_collect_clauseContext()
}

type Bulk_collect_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulk_collect_clauseContext() *Bulk_collect_clauseContext {
	var p = new(Bulk_collect_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause
	return p
}

func InitEmptyBulk_collect_clauseContext(p *Bulk_collect_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause
}

func (*Bulk_collect_clauseContext) IsBulk_collect_clauseContext() {}

func NewBulk_collect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bulk_collect_clauseContext {
	var p = new(Bulk_collect_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause

	return p
}

func (s *Bulk_collect_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Bulk_collect_clauseContext) T_BULK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BULK, 0)
}

func (s *Bulk_collect_clauseContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Bulk_collect_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bulk_collect_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bulk_collect_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBulk_collect_clause(s)
	}
}

func (s *Bulk_collect_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBulk_collect_clause(s)
	}
}

func (p *HplsqlParser) Bulk_collect_clause() (localctx IBulk_collect_clauseContext) {
	localctx = NewBulk_collect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, HplsqlParserRULE_bulk_collect_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		p.Match(HplsqlParserT_BULK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2438)
		p.Match(HplsqlParserT_COLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_clauseContext is an interface to support dynamic dispatch.
type IFrom_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FROM() antlr.TerminalNode
	From_table_clause() IFrom_table_clauseContext
	AllFrom_join_clause() []IFrom_join_clauseContext
	From_join_clause(i int) IFrom_join_clauseContext

	// IsFrom_clauseContext differentiates from other interfaces.
	IsFrom_clauseContext()
}

type From_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_clauseContext() *From_clauseContext {
	var p = new(From_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_clause
	return p
}

func InitEmptyFrom_clauseContext(p *From_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_clause
}

func (*From_clauseContext) IsFrom_clauseContext() {}

func NewFrom_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_clauseContext {
	var p = new(From_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_clause

	return p
}

func (s *From_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_clauseContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *From_clauseContext) From_table_clause() IFrom_table_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_clauseContext)
}

func (s *From_clauseContext) AllFrom_join_clause() []IFrom_join_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_join_clauseContext); ok {
			len++
		}
	}

	tst := make([]IFrom_join_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_join_clauseContext); ok {
			tst[i] = t.(IFrom_join_clauseContext)
			i++
		}
	}

	return tst
}

func (s *From_clauseContext) From_join_clause(i int) IFrom_join_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_join_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_join_clauseContext)
}

func (s *From_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_clause(s)
	}
}

func (s *From_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_clause(s)
	}
}

func (p *HplsqlParser) From_clause() (localctx IFrom_clauseContext) {
	localctx = NewFrom_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, HplsqlParserRULE_from_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2440)
		p.Match(HplsqlParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2441)
		p.From_table_clause()
	}
	p.SetState(2445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2442)
				p.From_join_clause()
			}

		}
		p.SetState(2447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	From_table_name_clause() IFrom_table_name_clauseContext
	From_subselect_clause() IFrom_subselect_clauseContext
	From_table_values_clause() IFrom_table_values_clauseContext

	// IsFrom_table_clauseContext differentiates from other interfaces.
	IsFrom_table_clauseContext()
}

type From_table_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_clauseContext() *From_table_clauseContext {
	var p = new(From_table_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_clause
	return p
}

func InitEmptyFrom_table_clauseContext(p *From_table_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_clause
}

func (*From_table_clauseContext) IsFrom_table_clauseContext() {}

func NewFrom_table_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_clauseContext {
	var p = new(From_table_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_clause

	return p
}

func (s *From_table_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_clauseContext) From_table_name_clause() IFrom_table_name_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_name_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_name_clauseContext)
}

func (s *From_table_clauseContext) From_subselect_clause() IFrom_subselect_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_subselect_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_subselect_clauseContext)
}

func (s *From_table_clauseContext) From_table_values_clause() IFrom_table_values_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_values_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_values_clauseContext)
}

func (s *From_table_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_clause(s)
	}
}

func (s *From_table_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_clause(s)
	}
}

func (p *HplsqlParser) From_table_clause() (localctx IFrom_table_clauseContext) {
	localctx = NewFrom_table_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, HplsqlParserRULE_from_table_clause)
	p.SetState(2451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2448)
			p.From_table_name_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2449)
			p.From_subselect_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2450)
			p.From_table_values_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_name_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_name_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_table_name_clauseContext differentiates from other interfaces.
	IsFrom_table_name_clauseContext()
}

type From_table_name_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_name_clauseContext() *From_table_name_clauseContext {
	var p = new(From_table_name_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause
	return p
}

func InitEmptyFrom_table_name_clauseContext(p *From_table_name_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause
}

func (*From_table_name_clauseContext) IsFrom_table_name_clauseContext() {}

func NewFrom_table_name_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_name_clauseContext {
	var p = new(From_table_name_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause

	return p
}

func (s *From_table_name_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_name_clauseContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *From_table_name_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_table_name_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_name_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_name_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_name_clause(s)
	}
}

func (s *From_table_name_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_name_clause(s)
	}
}

func (p *HplsqlParser) From_table_name_clause() (localctx IFrom_table_name_clauseContext) {
	localctx = NewFrom_table_name_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, HplsqlParserRULE_from_table_name_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2453)
		p.Table_name()
	}
	p.SetState(2455)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2454)
			p.From_alias_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_subselect_clauseContext is an interface to support dynamic dispatch.
type IFrom_subselect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_subselect_clauseContext differentiates from other interfaces.
	IsFrom_subselect_clauseContext()
}

type From_subselect_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_subselect_clauseContext() *From_subselect_clauseContext {
	var p = new(From_subselect_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause
	return p
}

func InitEmptyFrom_subselect_clauseContext(p *From_subselect_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause
}

func (*From_subselect_clauseContext) IsFrom_subselect_clauseContext() {}

func NewFrom_subselect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_subselect_clauseContext {
	var p = new(From_subselect_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause

	return p
}

func (s *From_subselect_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_subselect_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_subselect_clauseContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *From_subselect_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_subselect_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_subselect_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_subselect_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_subselect_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_subselect_clause(s)
	}
}

func (s *From_subselect_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_subselect_clause(s)
	}
}

func (p *HplsqlParser) From_subselect_clause() (localctx IFrom_subselect_clauseContext) {
	localctx = NewFrom_subselect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, HplsqlParserRULE_from_subselect_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2457)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2458)
		p.Select_stmt()
	}
	{
		p.SetState(2459)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2461)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2460)
			p.From_alias_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_join_clauseContext is an interface to support dynamic dispatch.
type IFrom_join_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMA() antlr.TerminalNode
	From_table_clause() IFrom_table_clauseContext
	From_join_type_clause() IFrom_join_type_clauseContext
	T_ON() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsFrom_join_clauseContext differentiates from other interfaces.
	IsFrom_join_clauseContext()
}

type From_join_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_join_clauseContext() *From_join_clauseContext {
	var p = new(From_join_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_clause
	return p
}

func InitEmptyFrom_join_clauseContext(p *From_join_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_clause
}

func (*From_join_clauseContext) IsFrom_join_clauseContext() {}

func NewFrom_join_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_join_clauseContext {
	var p = new(From_join_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_join_clause

	return p
}

func (s *From_join_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_join_clauseContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *From_join_clauseContext) From_table_clause() IFrom_table_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_clauseContext)
}

func (s *From_join_clauseContext) From_join_type_clause() IFrom_join_type_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_join_type_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_join_type_clauseContext)
}

func (s *From_join_clauseContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *From_join_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *From_join_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_join_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_join_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_join_clause(s)
	}
}

func (s *From_join_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_join_clause(s)
	}
}

func (p *HplsqlParser) From_join_clause() (localctx IFrom_join_clauseContext) {
	localctx = NewFrom_join_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, HplsqlParserRULE_from_join_clause)
	p.SetState(2470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2463)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2464)
			p.From_table_clause()
		}

	case HplsqlParserT_FULL, HplsqlParserT_INNER, HplsqlParserT_JOIN, HplsqlParserT_LEFT, HplsqlParserT_RIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2465)
			p.From_join_type_clause()
		}
		{
			p.SetState(2466)
			p.From_table_clause()
		}
		{
			p.SetState(2467)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2468)
			p.bool_expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_join_type_clauseContext is an interface to support dynamic dispatch.
type IFrom_join_type_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_JOIN() antlr.TerminalNode
	T_INNER() antlr.TerminalNode
	T_LEFT() antlr.TerminalNode
	T_RIGHT() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_OUTER() antlr.TerminalNode

	// IsFrom_join_type_clauseContext differentiates from other interfaces.
	IsFrom_join_type_clauseContext()
}

type From_join_type_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_join_type_clauseContext() *From_join_type_clauseContext {
	var p = new(From_join_type_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause
	return p
}

func InitEmptyFrom_join_type_clauseContext(p *From_join_type_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause
}

func (*From_join_type_clauseContext) IsFrom_join_type_clauseContext() {}

func NewFrom_join_type_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_join_type_clauseContext {
	var p = new(From_join_type_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause

	return p
}

func (s *From_join_type_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_join_type_clauseContext) T_JOIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_JOIN, 0)
}

func (s *From_join_type_clauseContext) T_INNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INNER, 0)
}

func (s *From_join_type_clauseContext) T_LEFT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEFT, 0)
}

func (s *From_join_type_clauseContext) T_RIGHT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RIGHT, 0)
}

func (s *From_join_type_clauseContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FULL, 0)
}

func (s *From_join_type_clauseContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUTER, 0)
}

func (s *From_join_type_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_join_type_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_join_type_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_join_type_clause(s)
	}
}

func (s *From_join_type_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_join_type_clause(s)
	}
}

func (p *HplsqlParser) From_join_type_clause() (localctx IFrom_join_type_clauseContext) {
	localctx = NewFrom_join_type_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, HplsqlParserRULE_from_join_type_clause)
	var _la int

	p.SetState(2481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_INNER, HplsqlParserT_JOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_INNER {
			{
				p.SetState(2472)
				p.Match(HplsqlParserT_INNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2475)
			p.Match(HplsqlParserT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_FULL, HplsqlParserT_LEFT, HplsqlParserT_RIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2476)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_FULL || _la == HplsqlParserT_LEFT || _la == HplsqlParserT_RIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OUTER {
			{
				p.SetState(2477)
				p.Match(HplsqlParserT_OUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2480)
			p.Match(HplsqlParserT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_values_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_values_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TABLE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	AllFrom_table_values_row() []IFrom_table_values_rowContext
	From_table_values_row(i int) IFrom_table_values_rowContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_table_values_clauseContext differentiates from other interfaces.
	IsFrom_table_values_clauseContext()
}

type From_table_values_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_values_clauseContext() *From_table_values_clauseContext {
	var p = new(From_table_values_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause
	return p
}

func InitEmptyFrom_table_values_clauseContext(p *From_table_values_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause
}

func (*From_table_values_clauseContext) IsFrom_table_values_clauseContext() {}

func NewFrom_table_values_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_values_clauseContext {
	var p = new(From_table_values_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause

	return p
}

func (s *From_table_values_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_values_clauseContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *From_table_values_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_table_values_clauseContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *From_table_values_clauseContext) AllFrom_table_values_row() []IFrom_table_values_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_table_values_rowContext); ok {
			len++
		}
	}

	tst := make([]IFrom_table_values_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_table_values_rowContext); ok {
			tst[i] = t.(IFrom_table_values_rowContext)
			i++
		}
	}

	return tst
}

func (s *From_table_values_clauseContext) From_table_values_row(i int) IFrom_table_values_rowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_values_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_values_rowContext)
}

func (s *From_table_values_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_table_values_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_table_values_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_table_values_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_table_values_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_values_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_values_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_values_clause(s)
	}
}

func (s *From_table_values_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_values_clause(s)
	}
}

func (p *HplsqlParser) From_table_values_clause() (localctx IFrom_table_values_clauseContext) {
	localctx = NewFrom_table_values_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, HplsqlParserRULE_from_table_values_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2483)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2484)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2485)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2486)
		p.From_table_values_row()
	}
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2487)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2488)
			p.From_table_values_row()
		}

		p.SetState(2493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2494)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2496)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2495)
			p.From_alias_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_values_rowContext is an interface to support dynamic dispatch.
type IFrom_table_values_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsFrom_table_values_rowContext differentiates from other interfaces.
	IsFrom_table_values_rowContext()
}

type From_table_values_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_values_rowContext() *From_table_values_rowContext {
	var p = new(From_table_values_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_row
	return p
}

func InitEmptyFrom_table_values_rowContext(p *From_table_values_rowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_row
}

func (*From_table_values_rowContext) IsFrom_table_values_rowContext() {}

func NewFrom_table_values_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_values_rowContext {
	var p = new(From_table_values_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_values_row

	return p
}

func (s *From_table_values_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_values_rowContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *From_table_values_rowContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *From_table_values_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_table_values_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_table_values_rowContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_table_values_rowContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_table_values_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_values_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_values_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_values_row(s)
	}
}

func (s *From_table_values_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_values_row(s)
	}
}

func (p *HplsqlParser) From_table_values_row() (localctx IFrom_table_values_rowContext) {
	localctx = NewFrom_table_values_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, HplsqlParserRULE_from_table_values_row)
	var _la int

	p.SetState(2510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 304, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2498)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2499)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2500)
			p.expr(0)
		}
		p.SetState(2505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2501)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2502)
				p.expr(0)
			}

			p.SetState(2507)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2508)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_alias_clauseContext is an interface to support dynamic dispatch.
type IFrom_alias_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllL_ID() []antlr.TerminalNode
	L_ID(i int) antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsFrom_alias_clauseContext differentiates from other interfaces.
	IsFrom_alias_clauseContext()
}

type From_alias_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_alias_clauseContext() *From_alias_clauseContext {
	var p = new(From_alias_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_alias_clause
	return p
}

func InitEmptyFrom_alias_clauseContext(p *From_alias_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_alias_clause
}

func (*From_alias_clauseContext) IsFrom_alias_clauseContext() {}

func NewFrom_alias_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_alias_clauseContext {
	var p = new(From_alias_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_alias_clause

	return p
}

func (s *From_alias_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_alias_clauseContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *From_alias_clauseContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *From_alias_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_alias_clauseContext) AllL_ID() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_ID)
}

func (s *From_alias_clauseContext) L_ID(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, i)
}

func (s *From_alias_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_alias_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_alias_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_alias_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_alias_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_alias_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_alias_clause(s)
	}
}

func (s *From_alias_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_alias_clause(s)
	}
}

func (p *HplsqlParser) From_alias_clause() (localctx IFrom_alias_clauseContext) {
	localctx = NewFrom_alias_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, HplsqlParserRULE_from_alias_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2512)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXEC") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXECUTE") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INNER") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LEFT") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GROUP") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ORDER") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LIMIT") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "WITH")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"EXEC\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"EXECUTE\") && \n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INNER\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"LEFT\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"GROUP\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"ORDER\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"LIMIT\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"WITH\")", ""))
		goto errorExit
	}
	p.SetState(2514)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2513)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2516)
		p.Qident()
	}
	p.SetState(2527)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2517)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2518)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2519)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2520)
				p.Match(HplsqlParserL_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2525)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2526)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_nameContext is an interface to support dynamic dispatch.
type ITable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext

	// IsTable_nameContext differentiates from other interfaces.
	IsTable_nameContext()
}

type Table_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_nameContext() *Table_nameContext {
	var p = new(Table_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_name
	return p
}

func InitEmptyTable_nameContext(p *Table_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_name
}

func (*Table_nameContext) IsTable_nameContext() {}

func NewTable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_nameContext {
	var p = new(Table_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_table_name

	return p
}

func (s *Table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_nameContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTable_name(s)
	}
}

func (s *Table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTable_name(s)
	}
}

func (p *HplsqlParser) Table_name() (localctx ITable_nameContext) {
	localctx = NewTable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, HplsqlParserRULE_table_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2529)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhere_clauseContext is an interface to support dynamic dispatch.
type IWhere_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WHERE() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsWhere_clauseContext differentiates from other interfaces.
	IsWhere_clauseContext()
}

type Where_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_clauseContext() *Where_clauseContext {
	var p = new(Where_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_where_clause
	return p
}

func InitEmptyWhere_clauseContext(p *Where_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_where_clause
}

func (*Where_clauseContext) IsWhere_clauseContext() {}

func NewWhere_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_clauseContext {
	var p = new(Where_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_where_clause

	return p
}

func (s *Where_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_clauseContext) T_WHERE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHERE, 0)
}

func (s *Where_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Where_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Where_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterWhere_clause(s)
	}
}

func (s *Where_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitWhere_clause(s)
	}
}

func (p *HplsqlParser) Where_clause() (localctx IWhere_clauseContext) {
	localctx = NewWhere_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, HplsqlParserRULE_where_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2531)
		p.Match(HplsqlParserT_WHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2532)
		p.bool_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroup_by_clauseContext is an interface to support dynamic dispatch.
type IGroup_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GROUP() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsGroup_by_clauseContext differentiates from other interfaces.
	IsGroup_by_clauseContext()
}

type Group_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clauseContext() *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_group_by_clause
	return p
}

func InitEmptyGroup_by_clauseContext(p *Group_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_group_by_clause
}

func (*Group_by_clauseContext) IsGroup_by_clauseContext() {}

func NewGroup_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_group_by_clause

	return p
}

func (s *Group_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clauseContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GROUP, 0)
}

func (s *Group_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Group_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Group_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Group_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Group_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Group_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGroup_by_clause(s)
	}
}

func (p *HplsqlParser) Group_by_clause() (localctx IGroup_by_clauseContext) {
	localctx = NewGroup_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, HplsqlParserRULE_group_by_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2534)
		p.Match(HplsqlParserT_GROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2535)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2536)
		p.expr(0)
	}
	p.SetState(2541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2537)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2538)
				p.expr(0)
			}

		}
		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHaving_clauseContext is an interface to support dynamic dispatch.
type IHaving_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HAVING() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsHaving_clauseContext differentiates from other interfaces.
	IsHaving_clauseContext()
}

type Having_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_clauseContext() *Having_clauseContext {
	var p = new(Having_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_having_clause
	return p
}

func InitEmptyHaving_clauseContext(p *Having_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_having_clause
}

func (*Having_clauseContext) IsHaving_clauseContext() {}

func NewHaving_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_clauseContext {
	var p = new(Having_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_having_clause

	return p
}

func (s *Having_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_clauseContext) T_HAVING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HAVING, 0)
}

func (s *Having_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Having_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Having_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHaving_clause(s)
	}
}

func (s *Having_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHaving_clause(s)
	}
}

func (p *HplsqlParser) Having_clause() (localctx IHaving_clauseContext) {
	localctx = NewHaving_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, HplsqlParserRULE_having_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2544)
		p.Match(HplsqlParserT_HAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2545)
		p.bool_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualify_clauseContext is an interface to support dynamic dispatch.
type IQualify_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUALIFY() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsQualify_clauseContext differentiates from other interfaces.
	IsQualify_clauseContext()
}

type Qualify_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualify_clauseContext() *Qualify_clauseContext {
	var p = new(Qualify_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qualify_clause
	return p
}

func InitEmptyQualify_clauseContext(p *Qualify_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qualify_clause
}

func (*Qualify_clauseContext) IsQualify_clauseContext() {}

func NewQualify_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualify_clauseContext {
	var p = new(Qualify_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_qualify_clause

	return p
}

func (s *Qualify_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualify_clauseContext) T_QUALIFY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUALIFY, 0)
}

func (s *Qualify_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Qualify_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualify_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualify_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQualify_clause(s)
	}
}

func (s *Qualify_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQualify_clause(s)
	}
}

func (p *HplsqlParser) Qualify_clause() (localctx IQualify_clauseContext) {
	localctx = NewQualify_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, HplsqlParserRULE_qualify_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2547)
		p.Match(HplsqlParserT_QUALIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2548)
		p.bool_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrder_by_clauseContext is an interface to support dynamic dispatch.
type IOrder_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ORDER() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode

	// IsOrder_by_clauseContext differentiates from other interfaces.
	IsOrder_by_clauseContext()
}

type Order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clauseContext() *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_order_by_clause
	return p
}

func InitEmptyOrder_by_clauseContext(p *Order_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_order_by_clause
}

func (*Order_by_clauseContext) IsOrder_by_clauseContext() {}

func NewOrder_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_order_by_clause

	return p
}

func (s *Order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clauseContext) T_ORDER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ORDER, 0)
}

func (s *Order_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Order_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Order_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Order_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Order_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Order_by_clauseContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Order_by_clauseContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Order_by_clauseContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Order_by_clauseContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitOrder_by_clause(s)
	}
}

func (p *HplsqlParser) Order_by_clause() (localctx IOrder_by_clauseContext) {
	localctx = NewOrder_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, HplsqlParserRULE_order_by_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2550)
		p.Match(HplsqlParserT_ORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2551)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2552)
		p.expr(0)
	}
	p.SetState(2554)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2553)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2556)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2557)
				p.expr(0)
			}
			p.SetState(2559)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2558)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(2565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_optionsContext is an interface to support dynamic dispatch.
type ISelect_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_options_item() []ISelect_options_itemContext
	Select_options_item(i int) ISelect_options_itemContext

	// IsSelect_optionsContext differentiates from other interfaces.
	IsSelect_optionsContext()
}

type Select_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_optionsContext() *Select_optionsContext {
	var p = new(Select_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options
	return p
}

func InitEmptySelect_optionsContext(p *Select_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options
}

func (*Select_optionsContext) IsSelect_optionsContext() {}

func NewSelect_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_optionsContext {
	var p = new(Select_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_options

	return p
}

func (s *Select_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_optionsContext) AllSelect_options_item() []ISelect_options_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_options_itemContext); ok {
			len++
		}
	}

	tst := make([]ISelect_options_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_options_itemContext); ok {
			tst[i] = t.(ISelect_options_itemContext)
			i++
		}
	}

	return tst
}

func (s *Select_optionsContext) Select_options_item(i int) ISelect_options_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_options_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_options_itemContext)
}

func (s *Select_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_options(s)
	}
}

func (s *Select_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_options(s)
	}
}

func (p *HplsqlParser) Select_options() (localctx ISelect_optionsContext) {
	localctx = NewSelect_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, HplsqlParserRULE_select_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2566)
				p.Select_options_item()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2569)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_options_itemContext is an interface to support dynamic dispatch.
type ISelect_options_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LIMIT() antlr.TerminalNode
	Expr() IExprContext
	T_WITH() antlr.TerminalNode
	T_RR() antlr.TerminalNode
	T_RS() antlr.TerminalNode
	T_CS() antlr.TerminalNode
	T_UR() antlr.TerminalNode
	T_USE() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_KEEP() antlr.TerminalNode
	T_LOCKS() antlr.TerminalNode
	T_EXCLUSIVE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_SHARE() antlr.TerminalNode

	// IsSelect_options_itemContext differentiates from other interfaces.
	IsSelect_options_itemContext()
}

type Select_options_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_options_itemContext() *Select_options_itemContext {
	var p = new(Select_options_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options_item
	return p
}

func InitEmptySelect_options_itemContext(p *Select_options_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options_item
}

func (*Select_options_itemContext) IsSelect_options_itemContext() {}

func NewSelect_options_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_options_itemContext {
	var p = new(Select_options_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_options_item

	return p
}

func (s *Select_options_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_options_itemContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Select_options_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_options_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Select_options_itemContext) T_RR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RR, 0)
}

func (s *Select_options_itemContext) T_RS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RS, 0)
}

func (s *Select_options_itemContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Select_options_itemContext) T_UR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UR, 0)
}

func (s *Select_options_itemContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Select_options_itemContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Select_options_itemContext) T_KEEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEEP, 0)
}

func (s *Select_options_itemContext) T_LOCKS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCKS, 0)
}

func (s *Select_options_itemContext) T_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCLUSIVE, 0)
}

func (s *Select_options_itemContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Select_options_itemContext) T_SHARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SHARE, 0)
}

func (s *Select_options_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_options_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_options_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_options_item(s)
	}
}

func (s *Select_options_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_options_item(s)
	}
}

func (p *HplsqlParser) Select_options_item() (localctx ISelect_options_itemContext) {
	localctx = NewSelect_options_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, HplsqlParserRULE_select_options_item)
	var _la int

	p.SetState(2582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LIMIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2571)
			p.Match(HplsqlParserT_LIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2572)
			p.expr(0)
		}

	case HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2573)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2574)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CS || ((int64((_la-247)) & ^0x3f) == 0 && ((int64(1)<<(_la-247))&144115188075855875) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2580)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2575)
				p.Match(HplsqlParserT_USE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2576)
				p.Match(HplsqlParserT_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2577)
				p.Match(HplsqlParserT_KEEP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2578)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_EXCLUSIVE || _la == HplsqlParserT_SHARE || _la == HplsqlParserT_UPDATE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2579)
				p.Match(HplsqlParserT_LOCKS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_stmtContext is an interface to support dynamic dispatch.
type IUpdate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_UPDATE() antlr.TerminalNode
	Update_table() IUpdate_tableContext
	T_SET() antlr.TerminalNode
	Update_assignment() IUpdate_assignmentContext
	Where_clause() IWhere_clauseContext
	Update_upsert() IUpdate_upsertContext

	// IsUpdate_stmtContext differentiates from other interfaces.
	IsUpdate_stmtContext()
}

type Update_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_stmtContext() *Update_stmtContext {
	var p = new(Update_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_stmt
	return p
}

func InitEmptyUpdate_stmtContext(p *Update_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_stmt
}

func (*Update_stmtContext) IsUpdate_stmtContext() {}

func NewUpdate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_stmtContext {
	var p = new(Update_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_stmt

	return p
}

func (s *Update_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_stmtContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Update_stmtContext) Update_table() IUpdate_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_tableContext)
}

func (s *Update_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Update_stmtContext) Update_assignment() IUpdate_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_assignmentContext)
}

func (s *Update_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Update_stmtContext) Update_upsert() IUpdate_upsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_upsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_upsertContext)
}

func (s *Update_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_stmt(s)
	}
}

func (s *Update_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_stmt(s)
	}
}

func (p *HplsqlParser) Update_stmt() (localctx IUpdate_stmtContext) {
	localctx = NewUpdate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, HplsqlParserRULE_update_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2584)
		p.Match(HplsqlParserT_UPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2585)
		p.Update_table()
	}
	{
		p.SetState(2586)
		p.Match(HplsqlParserT_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2587)
		p.Update_assignment()
	}
	p.SetState(2589)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2588)
			p.Where_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2592)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2591)
			p.Update_upsert()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_assignmentContext is an interface to support dynamic dispatch.
type IUpdate_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsUpdate_assignmentContext differentiates from other interfaces.
	IsUpdate_assignmentContext()
}

type Update_assignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_assignmentContext() *Update_assignmentContext {
	var p = new(Update_assignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_assignment
	return p
}

func InitEmptyUpdate_assignmentContext(p *Update_assignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_assignment
}

func (*Update_assignmentContext) IsUpdate_assignmentContext() {}

func NewUpdate_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_assignmentContext {
	var p = new(Update_assignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_assignment

	return p
}

func (s *Update_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_assignmentContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Update_assignmentContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Update_assignmentContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Update_assignmentContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Update_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_assignment(s)
	}
}

func (s *Update_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_assignment(s)
	}
}

func (p *HplsqlParser) Update_assignment() (localctx IUpdate_assignmentContext) {
	localctx = NewUpdate_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, HplsqlParserRULE_update_assignment)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2594)
		p.Assignment_stmt_item()
	}
	p.SetState(2599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2595)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2596)
				p.Assignment_stmt_item()
			}

		}
		p.SetState(2601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_tableContext is an interface to support dynamic dispatch.
type IUpdate_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Qident() IQidentContext
	From_clause() IFrom_clauseContext
	T_AS() antlr.TerminalNode

	// IsUpdate_tableContext differentiates from other interfaces.
	IsUpdate_tableContext()
}

type Update_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_tableContext() *Update_tableContext {
	var p = new(Update_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_table
	return p
}

func InitEmptyUpdate_tableContext(p *Update_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_table
}

func (*Update_tableContext) IsUpdate_tableContext() {}

func NewUpdate_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_tableContext {
	var p = new(Update_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_table

	return p
}

func (s *Update_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_tableContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Update_tableContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Update_tableContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Update_tableContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Update_tableContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Update_tableContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Update_tableContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Update_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_table(s)
	}
}

func (s *Update_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_table(s)
	}
}

func (p *HplsqlParser) Update_table() (localctx IUpdate_tableContext) {
	localctx = NewUpdate_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, HplsqlParserRULE_update_table)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2602)
			p.Table_name()
		}
		p.SetState(2604)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2603)
				p.From_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2606)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2607)
			p.Select_stmt()
		}
		{
			p.SetState(2608)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2616)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext()) == 1 {
		p.SetState(2613)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2612)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2615)
			p.Qident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_upsertContext is an interface to support dynamic dispatch.
type IUpdate_upsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ELSE() antlr.TerminalNode
	Insert_stmt() IInsert_stmtContext

	// IsUpdate_upsertContext differentiates from other interfaces.
	IsUpdate_upsertContext()
}

type Update_upsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_upsertContext() *Update_upsertContext {
	var p = new(Update_upsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_upsert
	return p
}

func InitEmptyUpdate_upsertContext(p *Update_upsertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_upsert
}

func (*Update_upsertContext) IsUpdate_upsertContext() {}

func NewUpdate_upsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_upsertContext {
	var p = new(Update_upsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_upsert

	return p
}

func (s *Update_upsertContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_upsertContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Update_upsertContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *Update_upsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_upsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_upsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_upsert(s)
	}
}

func (s *Update_upsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_upsert(s)
	}
}

func (p *HplsqlParser) Update_upsert() (localctx IUpdate_upsertContext) {
	localctx = NewUpdate_upsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, HplsqlParserRULE_update_upsert)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2618)
		p.Match(HplsqlParserT_ELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2619)
		p.Insert_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_stmtContext is an interface to support dynamic dispatch.
type IMerge_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MERGE() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	AllMerge_table() []IMerge_tableContext
	Merge_table(i int) IMerge_tableContext
	T_USING() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	AllMerge_condition() []IMerge_conditionContext
	Merge_condition(i int) IMerge_conditionContext

	// IsMerge_stmtContext differentiates from other interfaces.
	IsMerge_stmtContext()
}

type Merge_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_stmtContext() *Merge_stmtContext {
	var p = new(Merge_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_stmt
	return p
}

func InitEmptyMerge_stmtContext(p *Merge_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_stmt
}

func (*Merge_stmtContext) IsMerge_stmtContext() {}

func NewMerge_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_stmtContext {
	var p = new(Merge_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_stmt

	return p
}

func (s *Merge_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_stmtContext) T_MERGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MERGE, 0)
}

func (s *Merge_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Merge_stmtContext) AllMerge_table() []IMerge_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMerge_tableContext); ok {
			len++
		}
	}

	tst := make([]IMerge_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMerge_tableContext); ok {
			tst[i] = t.(IMerge_tableContext)
			i++
		}
	}

	return tst
}

func (s *Merge_stmtContext) Merge_table(i int) IMerge_tableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_tableContext)
}

func (s *Merge_stmtContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Merge_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Merge_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Merge_stmtContext) AllMerge_condition() []IMerge_conditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMerge_conditionContext); ok {
			len++
		}
	}

	tst := make([]IMerge_conditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMerge_conditionContext); ok {
			tst[i] = t.(IMerge_conditionContext)
			i++
		}
	}

	return tst
}

func (s *Merge_stmtContext) Merge_condition(i int) IMerge_conditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_conditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_conditionContext)
}

func (s *Merge_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_stmt(s)
	}
}

func (s *Merge_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_stmt(s)
	}
}

func (p *HplsqlParser) Merge_stmt() (localctx IMerge_stmtContext) {
	localctx = NewMerge_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, HplsqlParserRULE_merge_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2621)
		p.Match(HplsqlParserT_MERGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2622)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2623)
		p.Merge_table()
	}
	{
		p.SetState(2624)
		p.Match(HplsqlParserT_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2625)
		p.Merge_table()
	}
	{
		p.SetState(2626)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2627)
		p.bool_expr(0)
	}
	p.SetState(2629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2628)
				p.Merge_condition()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2631)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_tableContext is an interface to support dynamic dispatch.
type IMerge_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	Qident() IQidentContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_AS() antlr.TerminalNode

	// IsMerge_tableContext differentiates from other interfaces.
	IsMerge_tableContext()
}

type Merge_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_tableContext() *Merge_tableContext {
	var p = new(Merge_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_table
	return p
}

func InitEmptyMerge_tableContext(p *Merge_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_table
}

func (*Merge_tableContext) IsMerge_tableContext() {}

func NewMerge_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_tableContext {
	var p = new(Merge_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_table

	return p
}

func (s *Merge_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_tableContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Merge_tableContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Merge_tableContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Merge_tableContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Merge_tableContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Merge_tableContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Merge_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_table(s)
	}
}

func (s *Merge_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_table(s)
	}
}

func (p *HplsqlParser) Merge_table() (localctx IMerge_tableContext) {
	localctx = NewMerge_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, HplsqlParserRULE_merge_table)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2633)
			p.Table_name()
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2634)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2635)
			p.Select_stmt()
		}
		{
			p.SetState(2636)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2644)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
		p.SetState(2641)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2640)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2643)
			p.Qident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_conditionContext is an interface to support dynamic dispatch.
type IMerge_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WHEN() antlr.TerminalNode
	T_MATCHED() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	Merge_action() IMerge_actionContext
	T_NOT() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_ELSE() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode

	// IsMerge_conditionContext differentiates from other interfaces.
	IsMerge_conditionContext()
}

type Merge_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_conditionContext() *Merge_conditionContext {
	var p = new(Merge_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_condition
	return p
}

func InitEmptyMerge_conditionContext(p *Merge_conditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_condition
}

func (*Merge_conditionContext) IsMerge_conditionContext() {}

func NewMerge_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_conditionContext {
	var p = new(Merge_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_condition

	return p
}

func (s *Merge_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_conditionContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, 0)
}

func (s *Merge_conditionContext) T_MATCHED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MATCHED, 0)
}

func (s *Merge_conditionContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Merge_conditionContext) Merge_action() IMerge_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_actionContext)
}

func (s *Merge_conditionContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Merge_conditionContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Merge_conditionContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Merge_conditionContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Merge_conditionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Merge_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_condition(s)
	}
}

func (s *Merge_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_condition(s)
	}
}

func (p *HplsqlParser) Merge_condition() (localctx IMerge_conditionContext) {
	localctx = NewMerge_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, HplsqlParserRULE_merge_condition)
	var _la int

	p.SetState(2659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_WHEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2646)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2647)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2650)
			p.Match(HplsqlParserT_MATCHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AND {
			{
				p.SetState(2651)
				p.Match(HplsqlParserT_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2652)
				p.bool_expr(0)
			}

		}
		{
			p.SetState(2655)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2656)
			p.Merge_action()
		}

	case HplsqlParserT_ELSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2657)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2658)
			p.Match(HplsqlParserT_IGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_actionContext is an interface to support dynamic dispatch.
type IMerge_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	Insert_stmt_row() IInsert_stmt_rowContext
	Insert_stmt_cols() IInsert_stmt_colsContext
	T_UPDATE() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	Where_clause() IWhere_clauseContext
	T_DELETE() antlr.TerminalNode

	// IsMerge_actionContext differentiates from other interfaces.
	IsMerge_actionContext()
}

type Merge_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_actionContext() *Merge_actionContext {
	var p = new(Merge_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_action
	return p
}

func InitEmptyMerge_actionContext(p *Merge_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_action
}

func (*Merge_actionContext) IsMerge_actionContext() {}

func NewMerge_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_actionContext {
	var p = new(Merge_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_action

	return p
}

func (s *Merge_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_actionContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Merge_actionContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Merge_actionContext) Insert_stmt_row() IInsert_stmt_rowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowContext)
}

func (s *Merge_actionContext) Insert_stmt_cols() IInsert_stmt_colsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_colsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_colsContext)
}

func (s *Merge_actionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Merge_actionContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Merge_actionContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Merge_actionContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Merge_actionContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Merge_actionContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Merge_actionContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Merge_actionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Merge_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_action(s)
	}
}

func (s *Merge_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_action(s)
	}
}

func (p *HplsqlParser) Merge_action() (localctx IMerge_actionContext) {
	localctx = NewMerge_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, HplsqlParserRULE_merge_action)
	var _la int

	var _alt int

	p.SetState(2681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_INSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2661)
			p.Match(HplsqlParserT_INSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(2662)
				p.Insert_stmt_cols()
			}

		}
		{
			p.SetState(2665)
			p.Match(HplsqlParserT_VALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2666)
			p.Insert_stmt_row()
		}

	case HplsqlParserT_UPDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2667)
			p.Match(HplsqlParserT_UPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2668)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2669)
			p.Assignment_stmt_item()
		}
		p.SetState(2674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2670)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2671)
					p.Assignment_stmt_item()
				}

			}
			p.SetState(2676)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2678)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2677)
				p.Where_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_DELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2680)
			p.Match(HplsqlParserT_DELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_stmtContext is an interface to support dynamic dispatch.
type IDelete_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DELETE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_FROM() antlr.TerminalNode
	Delete_alias() IDelete_aliasContext
	Where_clause() IWhere_clauseContext
	T_ALL() antlr.TerminalNode

	// IsDelete_stmtContext differentiates from other interfaces.
	IsDelete_stmtContext()
}

type Delete_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_stmtContext() *Delete_stmtContext {
	var p = new(Delete_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_stmt
	return p
}

func InitEmptyDelete_stmtContext(p *Delete_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_stmt
}

func (*Delete_stmtContext) IsDelete_stmtContext() {}

func NewDelete_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_stmtContext {
	var p = new(Delete_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_delete_stmt

	return p
}

func (s *Delete_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_stmtContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Delete_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Delete_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Delete_stmtContext) Delete_alias() IDelete_aliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_aliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_aliasContext)
}

func (s *Delete_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Delete_stmtContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Delete_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDelete_stmt(s)
	}
}

func (s *Delete_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDelete_stmt(s)
	}
}

func (p *HplsqlParser) Delete_stmt() (localctx IDelete_stmtContext) {
	localctx = NewDelete_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, HplsqlParserRULE_delete_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2683)
		p.Match(HplsqlParserT_DELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2685)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2684)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2687)
		p.Table_name()
	}
	p.SetState(2689)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2688)
			p.Delete_alias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2691)
			p.Where_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2692)
			p.Match(HplsqlParserT_ALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_aliasContext is an interface to support dynamic dispatch.
type IDelete_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode

	// IsDelete_aliasContext differentiates from other interfaces.
	IsDelete_aliasContext()
}

type Delete_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_aliasContext() *Delete_aliasContext {
	var p = new(Delete_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_alias
	return p
}

func InitEmptyDelete_aliasContext(p *Delete_aliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_alias
}

func (*Delete_aliasContext) IsDelete_aliasContext() {}

func NewDelete_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_aliasContext {
	var p = new(Delete_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_delete_alias

	return p
}

func (s *Delete_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_aliasContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Delete_aliasContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Delete_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDelete_alias(s)
	}
}

func (s *Delete_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDelete_alias(s)
	}
}

func (p *HplsqlParser) Delete_alias() (localctx IDelete_aliasContext) {
	localctx = NewDelete_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, HplsqlParserRULE_delete_alias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2695)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ALL")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"ALL\")", ""))
		goto errorExit
	}
	p.SetState(2697)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2696)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2699)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribe_stmtContext is an interface to support dynamic dispatch.
type IDescribe_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_DESCRIBE() antlr.TerminalNode
	T_DESC() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode

	// IsDescribe_stmtContext differentiates from other interfaces.
	IsDescribe_stmtContext()
}

type Describe_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribe_stmtContext() *Describe_stmtContext {
	var p = new(Describe_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_describe_stmt
	return p
}

func InitEmptyDescribe_stmtContext(p *Describe_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_describe_stmt
}

func (*Describe_stmtContext) IsDescribe_stmtContext() {}

func NewDescribe_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Describe_stmtContext {
	var p = new(Describe_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_describe_stmt

	return p
}

func (s *Describe_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Describe_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Describe_stmtContext) T_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESCRIBE, 0)
}

func (s *Describe_stmtContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Describe_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Describe_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Describe_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Describe_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDescribe_stmt(s)
	}
}

func (s *Describe_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDescribe_stmt(s)
	}
}

func (p *HplsqlParser) Describe_stmt() (localctx IDescribe_stmtContext) {
	localctx = NewDescribe_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, HplsqlParserRULE_describe_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2701)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DESC || _la == HplsqlParserT_DESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2703)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2702)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2705)
		p.Table_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_exprContext is an interface to support dynamic dispatch.
type IBool_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllBool_expr() []IBool_exprContext
	Bool_expr(i int) IBool_exprContext
	T_CLOSE_P() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	Bool_expr_atom() IBool_expr_atomContext
	Bool_expr_logical_operator() IBool_expr_logical_operatorContext

	// IsBool_exprContext differentiates from other interfaces.
	IsBool_exprContext()
}

type Bool_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_exprContext() *Bool_exprContext {
	var p = new(Bool_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr
	return p
}

func InitEmptyBool_exprContext(p *Bool_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr
}

func (*Bool_exprContext) IsBool_exprContext() {}

func NewBool_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_exprContext {
	var p = new(Bool_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr

	return p
}

func (s *Bool_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_exprContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_exprContext) AllBool_expr() []IBool_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBool_exprContext); ok {
			len++
		}
	}

	tst := make([]IBool_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBool_exprContext); ok {
			tst[i] = t.(IBool_exprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_exprContext) Bool_expr(i int) IBool_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Bool_exprContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_exprContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_exprContext) Bool_expr_atom() IBool_expr_atomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_atomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_atomContext)
}

func (s *Bool_exprContext) Bool_expr_logical_operator() IBool_expr_logical_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_logical_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_logical_operatorContext)
}

func (s *Bool_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr(s)
	}
}

func (s *Bool_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr(s)
	}
}

func (p *HplsqlParser) Bool_expr() (localctx IBool_exprContext) {
	return p.bool_expr(0)
}

func (p *HplsqlParser) bool_expr(_p int) (localctx IBool_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBool_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBool_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 382
	p.EnterRecursionRule(localctx, 382, HplsqlParserRULE_bool_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2708)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2711)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2712)
			p.bool_expr(0)
		}
		{
			p.SetState(2713)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2715)
			p.Bool_expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBool_exprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_bool_expr)
			p.SetState(2718)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(2719)
				p.Bool_expr_logical_operator()
			}
			{
				p.SetState(2720)
				p.bool_expr(3)
			}

		}
		p.SetState(2726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_atomContext is an interface to support dynamic dispatch.
type IBool_expr_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bool_expr_unary() IBool_expr_unaryContext
	Bool_expr_binary() IBool_expr_binaryContext
	Expr() IExprContext

	// IsBool_expr_atomContext differentiates from other interfaces.
	IsBool_expr_atomContext()
}

type Bool_expr_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_atomContext() *Bool_expr_atomContext {
	var p = new(Bool_expr_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom
	return p
}

func InitEmptyBool_expr_atomContext(p *Bool_expr_atomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom
}

func (*Bool_expr_atomContext) IsBool_expr_atomContext() {}

func NewBool_expr_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_atomContext {
	var p = new(Bool_expr_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom

	return p
}

func (s *Bool_expr_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_atomContext) Bool_expr_unary() IBool_expr_unaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_unaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_unaryContext)
}

func (s *Bool_expr_atomContext) Bool_expr_binary() IBool_expr_binaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_binaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_binaryContext)
}

func (s *Bool_expr_atomContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_atom(s)
	}
}

func (s *Bool_expr_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_atom(s)
	}
}

func (p *HplsqlParser) Bool_expr_atom() (localctx IBool_expr_atomContext) {
	localctx = NewBool_expr_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, HplsqlParserRULE_bool_expr_atom)
	p.SetState(2730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2727)
			p.Bool_expr_unary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2728)
			p.Bool_expr_binary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2729)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_unaryContext is an interface to support dynamic dispatch.
type IBool_expr_unaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_IS() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_BETWEEN() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Bool_expr_single_in() IBool_expr_single_inContext
	Bool_expr_multi_in() IBool_expr_multi_inContext

	// IsBool_expr_unaryContext differentiates from other interfaces.
	IsBool_expr_unaryContext()
}

type Bool_expr_unaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_unaryContext() *Bool_expr_unaryContext {
	var p = new(Bool_expr_unaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary
	return p
}

func InitEmptyBool_expr_unaryContext(p *Bool_expr_unaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary
}

func (*Bool_expr_unaryContext) IsBool_expr_unaryContext() {}

func NewBool_expr_unaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_unaryContext {
	var p = new(Bool_expr_unaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary

	return p
}

func (s *Bool_expr_unaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_unaryContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_unaryContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_unaryContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Bool_expr_unaryContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Bool_expr_unaryContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_unaryContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BETWEEN, 0)
}

func (s *Bool_expr_unaryContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Bool_expr_unaryContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Bool_expr_unaryContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_expr_unaryContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_unaryContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_expr_unaryContext) Bool_expr_single_in() IBool_expr_single_inContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_single_inContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_single_inContext)
}

func (s *Bool_expr_unaryContext) Bool_expr_multi_in() IBool_expr_multi_inContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_multi_inContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_multi_inContext)
}

func (s *Bool_expr_unaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_unaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_unaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_unary(s)
	}
}

func (s *Bool_expr_unaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_unary(s)
	}
}

func (p *HplsqlParser) Bool_expr_unary() (localctx IBool_expr_unaryContext) {
	localctx = NewBool_expr_unaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, HplsqlParserRULE_bool_expr_unary)
	var _la int

	p.SetState(2755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2732)
			p.expr(0)
		}
		{
			p.SetState(2733)
			p.Match(HplsqlParserT_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2734)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2737)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2739)
			p.expr(0)
		}
		{
			p.SetState(2740)
			p.Match(HplsqlParserT_BETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2741)
			p.expr(0)
		}
		{
			p.SetState(2742)
			p.Match(HplsqlParserT_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2743)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2745)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2748)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2749)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)
			p.Select_stmt()
		}
		{
			p.SetState(2751)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2753)
			p.Bool_expr_single_in()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2754)
			p.Bool_expr_multi_in()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_single_inContext is an interface to support dynamic dispatch.
type IBool_expr_single_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_IN() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_NOT() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsBool_expr_single_inContext differentiates from other interfaces.
	IsBool_expr_single_inContext()
}

type Bool_expr_single_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_single_inContext() *Bool_expr_single_inContext {
	var p = new(Bool_expr_single_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in
	return p
}

func InitEmptyBool_expr_single_inContext(p *Bool_expr_single_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in
}

func (*Bool_expr_single_inContext) IsBool_expr_single_inContext() {}

func NewBool_expr_single_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_single_inContext {
	var p = new(Bool_expr_single_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in

	return p
}

func (s *Bool_expr_single_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_single_inContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_single_inContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_single_inContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Bool_expr_single_inContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_expr_single_inContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_expr_single_inContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_single_inContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_single_inContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Bool_expr_single_inContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Bool_expr_single_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_single_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_single_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_single_in(s)
	}
}

func (s *Bool_expr_single_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_single_in(s)
	}
}

func (p *HplsqlParser) Bool_expr_single_in() (localctx IBool_expr_single_inContext) {
	localctx = NewBool_expr_single_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, HplsqlParserRULE_bool_expr_single_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2757)
		p.expr(0)
	}
	p.SetState(2759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_NOT {
		{
			p.SetState(2758)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2761)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2762)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2763)
			p.expr(0)
		}
		p.SetState(2768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2764)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2765)
				p.expr(0)
			}

			p.SetState(2770)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(2771)
			p.Select_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(2774)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_multi_inContext is an interface to support dynamic dispatch.
type IBool_expr_multi_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_IN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsBool_expr_multi_inContext differentiates from other interfaces.
	IsBool_expr_multi_inContext()
}

type Bool_expr_multi_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_multi_inContext() *Bool_expr_multi_inContext {
	var p = new(Bool_expr_multi_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in
	return p
}

func InitEmptyBool_expr_multi_inContext(p *Bool_expr_multi_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in
}

func (*Bool_expr_multi_inContext) IsBool_expr_multi_inContext() {}

func NewBool_expr_multi_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_multi_inContext {
	var p = new(Bool_expr_multi_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in

	return p
}

func (s *Bool_expr_multi_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_multi_inContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Bool_expr_multi_inContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Bool_expr_multi_inContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_multi_inContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_multi_inContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Bool_expr_multi_inContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Bool_expr_multi_inContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Bool_expr_multi_inContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_multi_inContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Bool_expr_multi_inContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Bool_expr_multi_inContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_multi_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_multi_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_multi_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_multi_in(s)
	}
}

func (s *Bool_expr_multi_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_multi_in(s)
	}
}

func (p *HplsqlParser) Bool_expr_multi_in() (localctx IBool_expr_multi_inContext) {
	localctx = NewBool_expr_multi_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, HplsqlParserRULE_bool_expr_multi_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2776)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2777)
		p.expr(0)
	}
	p.SetState(2782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2778)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2779)
			p.expr(0)
		}

		p.SetState(2784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2785)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_NOT {
		{
			p.SetState(2786)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2789)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2790)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2791)
		p.Select_stmt()
	}
	{
		p.SetState(2792)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_binaryContext is an interface to support dynamic dispatch.
type IBool_expr_binaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Bool_expr_binary_operator() IBool_expr_binary_operatorContext

	// IsBool_expr_binaryContext differentiates from other interfaces.
	IsBool_expr_binaryContext()
}

type Bool_expr_binaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_binaryContext() *Bool_expr_binaryContext {
	var p = new(Bool_expr_binaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary
	return p
}

func InitEmptyBool_expr_binaryContext(p *Bool_expr_binaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary
}

func (*Bool_expr_binaryContext) IsBool_expr_binaryContext() {}

func NewBool_expr_binaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_binaryContext {
	var p = new(Bool_expr_binaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary

	return p
}

func (s *Bool_expr_binaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_binaryContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_binaryContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_binaryContext) Bool_expr_binary_operator() IBool_expr_binary_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_binary_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_binary_operatorContext)
}

func (s *Bool_expr_binaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_binaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_binaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_binary(s)
	}
}

func (s *Bool_expr_binaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_binary(s)
	}
}

func (p *HplsqlParser) Bool_expr_binary() (localctx IBool_expr_binaryContext) {
	localctx = NewBool_expr_binaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, HplsqlParserRULE_bool_expr_binary)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2794)
		p.expr(0)
	}
	{
		p.SetState(2795)
		p.Bool_expr_binary_operator()
	}
	{
		p.SetState(2796)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_logical_operatorContext is an interface to support dynamic dispatch.
type IBool_expr_logical_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AND() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsBool_expr_logical_operatorContext differentiates from other interfaces.
	IsBool_expr_logical_operatorContext()
}

type Bool_expr_logical_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_logical_operatorContext() *Bool_expr_logical_operatorContext {
	var p = new(Bool_expr_logical_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator
	return p
}

func InitEmptyBool_expr_logical_operatorContext(p *Bool_expr_logical_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator
}

func (*Bool_expr_logical_operatorContext) IsBool_expr_logical_operatorContext() {}

func NewBool_expr_logical_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_logical_operatorContext {
	var p = new(Bool_expr_logical_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator

	return p
}

func (s *Bool_expr_logical_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_logical_operatorContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Bool_expr_logical_operatorContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Bool_expr_logical_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_logical_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_logical_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_logical_operator(s)
	}
}

func (s *Bool_expr_logical_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_logical_operator(s)
	}
}

func (p *HplsqlParser) Bool_expr_logical_operator() (localctx IBool_expr_logical_operatorContext) {
	localctx = NewBool_expr_logical_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, HplsqlParserRULE_bool_expr_logical_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2798)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AND || _la == HplsqlParserT_OR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_binary_operatorContext is an interface to support dynamic dispatch.
type IBool_expr_binary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	T_EQUAL2() antlr.TerminalNode
	T_NOTEQUAL() antlr.TerminalNode
	T_NOTEQUAL2() antlr.TerminalNode
	T_LESS() antlr.TerminalNode
	T_LESSEQUAL() antlr.TerminalNode
	T_GREATER() antlr.TerminalNode
	T_GREATEREQUAL() antlr.TerminalNode
	T_LIKE() antlr.TerminalNode
	T_RLIKE() antlr.TerminalNode
	T_REGEXP() antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsBool_expr_binary_operatorContext differentiates from other interfaces.
	IsBool_expr_binary_operatorContext()
}

type Bool_expr_binary_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_binary_operatorContext() *Bool_expr_binary_operatorContext {
	var p = new(Bool_expr_binary_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator
	return p
}

func InitEmptyBool_expr_binary_operatorContext(p *Bool_expr_binary_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator
}

func (*Bool_expr_binary_operatorContext) IsBool_expr_binary_operatorContext() {}

func NewBool_expr_binary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_binary_operatorContext {
	var p = new(Bool_expr_binary_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator

	return p
}

func (s *Bool_expr_binary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_binary_operatorContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_EQUAL2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL2, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTEQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOTEQUAL2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTEQUAL2, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESS, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LESSEQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESSEQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_GREATER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, 0)
}

func (s *Bool_expr_binary_operatorContext) T_GREATEREQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATEREQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Bool_expr_binary_operatorContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RLIKE, 0)
}

func (s *Bool_expr_binary_operatorContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REGEXP, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_binary_operator(s)
	}
}

func (s *Bool_expr_binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_binary_operator(s)
	}
}

func (p *HplsqlParser) Bool_expr_binary_operator() (localctx IBool_expr_binary_operatorContext) {
	localctx = NewBool_expr_binary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, HplsqlParserRULE_bool_expr_binary_operator)
	var _la int

	p.SetState(2812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2800)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_EQUAL2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2801)
			p.Match(HplsqlParserT_EQUAL2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NOTEQUAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2802)
			p.Match(HplsqlParserT_NOTEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NOTEQUAL2:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2803)
			p.Match(HplsqlParserT_NOTEQUAL2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LESS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2804)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LESSEQUAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2805)
			p.Match(HplsqlParserT_LESSEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_GREATER:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2806)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_GREATEREQUAL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2807)
			p.Match(HplsqlParserT_GREATEREQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LIKE, HplsqlParserT_NOT, HplsqlParserT_REGEXP, HplsqlParserT_RLIKE:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2808)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2811)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LIKE || _la == HplsqlParserT_REGEXP || _la == HplsqlParserT_RLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Expr_interval() IExpr_intervalContext
	Expr_concat() IExpr_concatContext
	Expr_dot() IExpr_dotContext
	Expr_case() IExpr_caseContext
	Expr_cursor_attribute() IExpr_cursor_attributeContext
	Expr_agg_window_func() IExpr_agg_window_funcContext
	Expr_spec_func() IExpr_spec_funcContext
	Expr_func() IExpr_funcContext
	Expr_atom() IExpr_atomContext
	T_MUL() antlr.TerminalNode
	T_DIV() antlr.TerminalNode
	T_ADD() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	Interval_item() IInterval_itemContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *ExprContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *ExprContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) Expr_interval() IExpr_intervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_intervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_intervalContext)
}

func (s *ExprContext) Expr_concat() IExpr_concatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_concatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_concatContext)
}

func (s *ExprContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *ExprContext) Expr_case() IExpr_caseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_caseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_caseContext)
}

func (s *ExprContext) Expr_cursor_attribute() IExpr_cursor_attributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_cursor_attributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_cursor_attributeContext)
}

func (s *ExprContext) Expr_agg_window_func() IExpr_agg_window_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_agg_window_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_window_funcContext)
}

func (s *ExprContext) Expr_spec_func() IExpr_spec_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_spec_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_spec_funcContext)
}

func (s *ExprContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *ExprContext) Expr_atom() IExpr_atomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_atomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_atomContext)
}

func (s *ExprContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *ExprContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, 0)
}

func (s *ExprContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *ExprContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *ExprContext) Interval_item() IInterval_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterval_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterval_itemContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *HplsqlParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *HplsqlParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 398
	p.EnterRecursionRule(localctx, 398, HplsqlParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2815)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2816)
			p.Select_stmt()
		}
		{
			p.SetState(2817)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2819)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2820)
			p.expr(0)
		}
		{
			p.SetState(2821)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(2823)
			p.Expr_interval()
		}

	case 4:
		{
			p.SetState(2824)
			p.Expr_concat()
		}

	case 5:
		{
			p.SetState(2825)
			p.Expr_dot()
		}

	case 6:
		{
			p.SetState(2826)
			p.Expr_case()
		}

	case 7:
		{
			p.SetState(2827)
			p.Expr_cursor_attribute()
		}

	case 8:
		{
			p.SetState(2828)
			p.Expr_agg_window_func()
		}

	case 9:
		{
			p.SetState(2829)
			p.Expr_spec_func()
		}

	case 10:
		{
			p.SetState(2830)
			p.Expr_func()
		}

	case 11:
		{
			p.SetState(2831)
			p.Expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2842)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2834)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(2835)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_DIV || _la == HplsqlParserT_MUL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2836)
					p.expr(14)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2837)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(2838)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2839)
					p.expr(13)
				}

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2840)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(2841)
					p.Interval_item()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_atomContext is an interface to support dynamic dispatch.
type IExpr_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Date_literal() IDate_literalContext
	Timestamp_literal() ITimestamp_literalContext
	Bool_literal() IBool_literalContext
	Qident() IQidentContext
	String_() IStringContext
	Dec_number() IDec_numberContext
	Int_number() IInt_numberContext
	Null_const() INull_constContext

	// IsExpr_atomContext differentiates from other interfaces.
	IsExpr_atomContext()
}

type Expr_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atomContext() *Expr_atomContext {
	var p = new(Expr_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_atom
	return p
}

func InitEmptyExpr_atomContext(p *Expr_atomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_atom
}

func (*Expr_atomContext) IsExpr_atomContext() {}

func NewExpr_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atomContext {
	var p = new(Expr_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_atom

	return p
}

func (s *Expr_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atomContext) Date_literal() IDate_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_literalContext)
}

func (s *Expr_atomContext) Timestamp_literal() ITimestamp_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestamp_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestamp_literalContext)
}

func (s *Expr_atomContext) Bool_literal() IBool_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_literalContext)
}

func (s *Expr_atomContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Expr_atomContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Expr_atomContext) Dec_number() IDec_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDec_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDec_numberContext)
}

func (s *Expr_atomContext) Int_number() IInt_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_numberContext)
}

func (s *Expr_atomContext) Null_const() INull_constContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_constContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_constContext)
}

func (s *Expr_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_atom(s)
	}
}

func (s *Expr_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_atom(s)
	}
}

func (p *HplsqlParser) Expr_atom() (localctx IExpr_atomContext) {
	localctx = NewExpr_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, HplsqlParserRULE_expr_atom)
	p.SetState(2855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2847)
			p.Date_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2848)
			p.Timestamp_literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2849)
			p.Bool_literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2850)
			p.Qident()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2851)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2852)
			p.Dec_number()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2853)
			p.Int_number()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2854)
			p.Null_const()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_intervalContext is an interface to support dynamic dispatch.
type IExpr_intervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INTERVAL() antlr.TerminalNode
	Expr() IExprContext
	Interval_item() IInterval_itemContext

	// IsExpr_intervalContext differentiates from other interfaces.
	IsExpr_intervalContext()
}

type Expr_intervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_intervalContext() *Expr_intervalContext {
	var p = new(Expr_intervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_interval
	return p
}

func InitEmptyExpr_intervalContext(p *Expr_intervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_interval
}

func (*Expr_intervalContext) IsExpr_intervalContext() {}

func NewExpr_intervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_intervalContext {
	var p = new(Expr_intervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_interval

	return p
}

func (s *Expr_intervalContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_intervalContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERVAL, 0)
}

func (s *Expr_intervalContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_intervalContext) Interval_item() IInterval_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterval_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterval_itemContext)
}

func (s *Expr_intervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_intervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_intervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_interval(s)
	}
}

func (s *Expr_intervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_interval(s)
	}
}

func (p *HplsqlParser) Expr_interval() (localctx IExpr_intervalContext) {
	localctx = NewExpr_intervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, HplsqlParserRULE_expr_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2857)
		p.Match(HplsqlParserT_INTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2858)
		p.expr(0)
	}
	{
		p.SetState(2859)
		p.Interval_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterval_itemContext is an interface to support dynamic dispatch.
type IInterval_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode

	// IsInterval_itemContext differentiates from other interfaces.
	IsInterval_itemContext()
}

type Interval_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterval_itemContext() *Interval_itemContext {
	var p = new(Interval_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_interval_item
	return p
}

func InitEmptyInterval_itemContext(p *Interval_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_interval_item
}

func (*Interval_itemContext) IsInterval_itemContext() {}

func NewInterval_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interval_itemContext {
	var p = new(Interval_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_interval_item

	return p
}

func (s *Interval_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Interval_itemContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAY, 0)
}

func (s *Interval_itemContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAYS, 0)
}

func (s *Interval_itemContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECOND, 0)
}

func (s *Interval_itemContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECONDS, 0)
}

func (s *Interval_itemContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECOND, 0)
}

func (s *Interval_itemContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECONDS, 0)
}

func (s *Interval_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interval_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interval_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInterval_item(s)
	}
}

func (s *Interval_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInterval_item(s)
	}
}

func (p *HplsqlParser) Interval_item() (localctx IInterval_itemContext) {
	localctx = NewInterval_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, HplsqlParserRULE_interval_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2861)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DAY || _la == HplsqlParserT_DAYS || _la == HplsqlParserT_MICROSECOND || _la == HplsqlParserT_MICROSECONDS || _la == HplsqlParserT_SECOND || _la == HplsqlParserT_SECONDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_concatContext is an interface to support dynamic dispatch.
type IExpr_concatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr_concat_item() []IExpr_concat_itemContext
	Expr_concat_item(i int) IExpr_concat_itemContext
	AllT_PIPE() []antlr.TerminalNode
	T_PIPE(i int) antlr.TerminalNode
	AllT_CONCAT() []antlr.TerminalNode
	T_CONCAT(i int) antlr.TerminalNode

	// IsExpr_concatContext differentiates from other interfaces.
	IsExpr_concatContext()
}

type Expr_concatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_concatContext() *Expr_concatContext {
	var p = new(Expr_concatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat
	return p
}

func InitEmptyExpr_concatContext(p *Expr_concatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat
}

func (*Expr_concatContext) IsExpr_concatContext() {}

func NewExpr_concatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_concatContext {
	var p = new(Expr_concatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_concat

	return p
}

func (s *Expr_concatContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_concatContext) AllExpr_concat_item() []IExpr_concat_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_concat_itemContext); ok {
			len++
		}
	}

	tst := make([]IExpr_concat_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_concat_itemContext); ok {
			tst[i] = t.(IExpr_concat_itemContext)
			i++
		}
	}

	return tst
}

func (s *Expr_concatContext) Expr_concat_item(i int) IExpr_concat_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_concat_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_concat_itemContext)
}

func (s *Expr_concatContext) AllT_PIPE() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_PIPE)
}

func (s *Expr_concatContext) T_PIPE(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PIPE, i)
}

func (s *Expr_concatContext) AllT_CONCAT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CONCAT)
}

func (s *Expr_concatContext) T_CONCAT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONCAT, i)
}

func (s *Expr_concatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_concatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_concatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_concat(s)
	}
}

func (s *Expr_concatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_concat(s)
	}
}

func (p *HplsqlParser) Expr_concat() (localctx IExpr_concatContext) {
	localctx = NewExpr_concatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, HplsqlParserRULE_expr_concat)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2863)
		p.Expr_concat_item()
	}
	{
		p.SetState(2864)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_CONCAT || _la == HplsqlParserT_PIPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2865)
		p.Expr_concat_item()
	}
	p.SetState(2870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2866)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_CONCAT || _la == HplsqlParserT_PIPE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2867)
				p.Expr_concat_item()
			}

		}
		p.SetState(2872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_concat_itemContext is an interface to support dynamic dispatch.
type IExpr_concat_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Expr() IExprContext
	T_CLOSE_P() antlr.TerminalNode
	Expr_case() IExpr_caseContext
	Expr_agg_window_func() IExpr_agg_window_funcContext
	Expr_spec_func() IExpr_spec_funcContext
	Expr_dot() IExpr_dotContext
	Expr_func() IExpr_funcContext
	Expr_atom() IExpr_atomContext

	// IsExpr_concat_itemContext differentiates from other interfaces.
	IsExpr_concat_itemContext()
}

type Expr_concat_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_concat_itemContext() *Expr_concat_itemContext {
	var p = new(Expr_concat_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat_item
	return p
}

func InitEmptyExpr_concat_itemContext(p *Expr_concat_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat_item
}

func (*Expr_concat_itemContext) IsExpr_concat_itemContext() {}

func NewExpr_concat_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_concat_itemContext {
	var p = new(Expr_concat_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_concat_item

	return p
}

func (s *Expr_concat_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_concat_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_concat_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_concat_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_concat_itemContext) Expr_case() IExpr_caseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_caseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_caseContext)
}

func (s *Expr_concat_itemContext) Expr_agg_window_func() IExpr_agg_window_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_agg_window_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_window_funcContext)
}

func (s *Expr_concat_itemContext) Expr_spec_func() IExpr_spec_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_spec_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_spec_funcContext)
}

func (s *Expr_concat_itemContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *Expr_concat_itemContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_concat_itemContext) Expr_atom() IExpr_atomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_atomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_atomContext)
}

func (s *Expr_concat_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_concat_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_concat_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_concat_item(s)
	}
}

func (s *Expr_concat_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_concat_item(s)
	}
}

func (p *HplsqlParser) Expr_concat_item() (localctx IExpr_concat_itemContext) {
	localctx = NewExpr_concat_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, HplsqlParserRULE_expr_concat_item)
	p.SetState(2883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2873)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2874)
			p.expr(0)
		}
		{
			p.SetState(2875)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2877)
			p.Expr_case()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2878)
			p.Expr_agg_window_func()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2879)
			p.Expr_spec_func()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2880)
			p.Expr_dot()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2881)
			p.Expr_func()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2882)
			p.Expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_caseContext is an interface to support dynamic dispatch.
type IExpr_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_case_simple() IExpr_case_simpleContext
	Expr_case_searched() IExpr_case_searchedContext

	// IsExpr_caseContext differentiates from other interfaces.
	IsExpr_caseContext()
}

type Expr_caseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_caseContext() *Expr_caseContext {
	var p = new(Expr_caseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case
	return p
}

func InitEmptyExpr_caseContext(p *Expr_caseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case
}

func (*Expr_caseContext) IsExpr_caseContext() {}

func NewExpr_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_caseContext {
	var p = new(Expr_caseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case

	return p
}

func (s *Expr_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_caseContext) Expr_case_simple() IExpr_case_simpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_case_simpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_case_simpleContext)
}

func (s *Expr_caseContext) Expr_case_searched() IExpr_case_searchedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_case_searchedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_case_searchedContext)
}

func (s *Expr_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case(s)
	}
}

func (s *Expr_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case(s)
	}
}

func (p *HplsqlParser) Expr_case() (localctx IExpr_caseContext) {
	localctx = NewExpr_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, HplsqlParserRULE_expr_case)
	p.SetState(2887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2885)
			p.Expr_case_simple()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2886)
			p.Expr_case_searched()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_case_simpleContext is an interface to support dynamic dispatch.
type IExpr_case_simpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CASE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_END() antlr.TerminalNode
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	AllT_THEN() []antlr.TerminalNode
	T_THEN(i int) antlr.TerminalNode
	T_ELSE() antlr.TerminalNode

	// IsExpr_case_simpleContext differentiates from other interfaces.
	IsExpr_case_simpleContext()
}

type Expr_case_simpleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_case_simpleContext() *Expr_case_simpleContext {
	var p = new(Expr_case_simpleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_simple
	return p
}

func InitEmptyExpr_case_simpleContext(p *Expr_case_simpleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_simple
}

func (*Expr_case_simpleContext) IsExpr_case_simpleContext() {}

func NewExpr_case_simpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_case_simpleContext {
	var p = new(Expr_case_simpleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case_simple

	return p
}

func (s *Expr_case_simpleContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_case_simpleContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Expr_case_simpleContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_simpleContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_case_simpleContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Expr_case_simpleContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Expr_case_simpleContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Expr_case_simpleContext) AllT_THEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_THEN)
}

func (s *Expr_case_simpleContext) T_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, i)
}

func (s *Expr_case_simpleContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Expr_case_simpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_case_simpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_case_simpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case_simple(s)
	}
}

func (s *Expr_case_simpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case_simple(s)
	}
}

func (p *HplsqlParser) Expr_case_simple() (localctx IExpr_case_simpleContext) {
	localctx = NewExpr_case_simpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, HplsqlParserRULE_expr_case_simple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2889)
		p.Match(HplsqlParserT_CASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2890)
		p.expr(0)
	}
	p.SetState(2896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == HplsqlParserT_WHEN {
		{
			p.SetState(2891)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2892)
			p.expr(0)
		}
		{
			p.SetState(2893)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2894)
			p.expr(0)
		}

		p.SetState(2898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(2900)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2901)
			p.expr(0)
		}

	}
	{
		p.SetState(2904)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_case_searchedContext is an interface to support dynamic dispatch.
type IExpr_case_searchedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CASE() antlr.TerminalNode
	T_END() antlr.TerminalNode
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	AllBool_expr() []IBool_exprContext
	Bool_expr(i int) IBool_exprContext
	AllT_THEN() []antlr.TerminalNode
	T_THEN(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_ELSE() antlr.TerminalNode

	// IsExpr_case_searchedContext differentiates from other interfaces.
	IsExpr_case_searchedContext()
}

type Expr_case_searchedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_case_searchedContext() *Expr_case_searchedContext {
	var p = new(Expr_case_searchedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_searched
	return p
}

func InitEmptyExpr_case_searchedContext(p *Expr_case_searchedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_searched
}

func (*Expr_case_searchedContext) IsExpr_case_searchedContext() {}

func NewExpr_case_searchedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_case_searchedContext {
	var p = new(Expr_case_searchedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case_searched

	return p
}

func (s *Expr_case_searchedContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_case_searchedContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Expr_case_searchedContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Expr_case_searchedContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Expr_case_searchedContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Expr_case_searchedContext) AllBool_expr() []IBool_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBool_exprContext); ok {
			len++
		}
	}

	tst := make([]IBool_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBool_exprContext); ok {
			tst[i] = t.(IBool_exprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_searchedContext) Bool_expr(i int) IBool_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Expr_case_searchedContext) AllT_THEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_THEN)
}

func (s *Expr_case_searchedContext) T_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, i)
}

func (s *Expr_case_searchedContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_searchedContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_case_searchedContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Expr_case_searchedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_case_searchedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_case_searchedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case_searched(s)
	}
}

func (s *Expr_case_searchedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case_searched(s)
	}
}

func (p *HplsqlParser) Expr_case_searched() (localctx IExpr_case_searchedContext) {
	localctx = NewExpr_case_searchedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, HplsqlParserRULE_expr_case_searched)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2906)
		p.Match(HplsqlParserT_CASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == HplsqlParserT_WHEN {
		{
			p.SetState(2907)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2908)
			p.bool_expr(0)
		}
		{
			p.SetState(2909)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2910)
			p.expr(0)
		}

		p.SetState(2914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(2916)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2917)
			p.expr(0)
		}

	}
	{
		p.SetState(2920)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_cursor_attributeContext is an interface to support dynamic dispatch.
type IExpr_cursor_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_ISOPEN() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	T_NOTFOUND() antlr.TerminalNode

	// IsExpr_cursor_attributeContext differentiates from other interfaces.
	IsExpr_cursor_attributeContext()
}

type Expr_cursor_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_cursor_attributeContext() *Expr_cursor_attributeContext {
	var p = new(Expr_cursor_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute
	return p
}

func InitEmptyExpr_cursor_attributeContext(p *Expr_cursor_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute
}

func (*Expr_cursor_attributeContext) IsExpr_cursor_attributeContext() {}

func NewExpr_cursor_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_cursor_attributeContext {
	var p = new(Expr_cursor_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute

	return p
}

func (s *Expr_cursor_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_cursor_attributeContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_cursor_attributeContext) T_ISOPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ISOPEN, 0)
}

func (s *Expr_cursor_attributeContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Expr_cursor_attributeContext) T_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTFOUND, 0)
}

func (s *Expr_cursor_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_cursor_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_cursor_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_cursor_attribute(s)
	}
}

func (s *Expr_cursor_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_cursor_attribute(s)
	}
}

func (p *HplsqlParser) Expr_cursor_attribute() (localctx IExpr_cursor_attributeContext) {
	localctx = NewExpr_cursor_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, HplsqlParserRULE_expr_cursor_attribute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2922)
		p.Ident()
	}
	{
		p.SetState(2923)
		p.Match(HplsqlParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2924)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FOUND || _la == HplsqlParserT_ISOPEN || _la == HplsqlParserT_NOTFOUND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_agg_window_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_window_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AVG() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_all_distinct() IExpr_func_all_distinctContext
	Expr_func_over_clause() IExpr_func_over_clauseContext
	T_COUNT() antlr.TerminalNode
	T_MUL() antlr.TerminalNode
	T_COUNT_BIG() antlr.TerminalNode
	T_CUME_DIST() antlr.TerminalNode
	T_DENSE_RANK() antlr.TerminalNode
	T_FIRST_VALUE() antlr.TerminalNode
	T_LAG() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_LAST_VALUE() antlr.TerminalNode
	T_LEAD() antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_MIN() antlr.TerminalNode
	T_RANK() antlr.TerminalNode
	T_ROW_NUMBER() antlr.TerminalNode
	T_STDEV() antlr.TerminalNode
	T_SUM() antlr.TerminalNode
	T_VAR() antlr.TerminalNode
	T_VARIANCE() antlr.TerminalNode

	// IsExpr_agg_window_funcContext differentiates from other interfaces.
	IsExpr_agg_window_funcContext()
}

type Expr_agg_window_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_window_funcContext() *Expr_agg_window_funcContext {
	var p = new(Expr_agg_window_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func
	return p
}

func InitEmptyExpr_agg_window_funcContext(p *Expr_agg_window_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func
}

func (*Expr_agg_window_funcContext) IsExpr_agg_window_funcContext() {}

func NewExpr_agg_window_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_window_funcContext {
	var p = new(Expr_agg_window_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func

	return p
}

func (s *Expr_agg_window_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_window_funcContext) T_AVG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AVG, 0)
}

func (s *Expr_agg_window_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_agg_window_funcContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_agg_window_funcContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_agg_window_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_agg_window_funcContext) Expr_func_all_distinct() IExpr_func_all_distinctContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_all_distinctContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_all_distinctContext)
}

func (s *Expr_agg_window_funcContext) Expr_func_over_clause() IExpr_func_over_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_over_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_over_clauseContext)
}

func (s *Expr_agg_window_funcContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Expr_agg_window_funcContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Expr_agg_window_funcContext) T_COUNT_BIG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT_BIG, 0)
}

func (s *Expr_agg_window_funcContext) T_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CUME_DIST, 0)
}

func (s *Expr_agg_window_funcContext) T_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DENSE_RANK, 0)
}

func (s *Expr_agg_window_funcContext) T_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIRST_VALUE, 0)
}

func (s *Expr_agg_window_funcContext) T_LAG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAG, 0)
}

func (s *Expr_agg_window_funcContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_agg_window_funcContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_agg_window_funcContext) T_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAST_VALUE, 0)
}

func (s *Expr_agg_window_funcContext) T_LEAD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAD, 0)
}

func (s *Expr_agg_window_funcContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Expr_agg_window_funcContext) T_MIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN, 0)
}

func (s *Expr_agg_window_funcContext) T_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RANK, 0)
}

func (s *Expr_agg_window_funcContext) T_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_NUMBER, 0)
}

func (s *Expr_agg_window_funcContext) T_STDEV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STDEV, 0)
}

func (s *Expr_agg_window_funcContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Expr_agg_window_funcContext) T_VAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VAR, 0)
}

func (s *Expr_agg_window_funcContext) T_VARIANCE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARIANCE, 0)
}

func (s *Expr_agg_window_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_window_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_agg_window_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_agg_window_func(s)
	}
}

func (s *Expr_agg_window_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_agg_window_func(s)
	}
}

func (p *HplsqlParser) Expr_agg_window_func() (localctx IExpr_agg_window_funcContext) {
	localctx = NewExpr_agg_window_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, HplsqlParserRULE_expr_agg_window_func)
	var _la int

	p.SetState(3078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AVG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2926)
			p.Match(HplsqlParserT_AVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2927)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2929)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2928)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2931)
			p.expr(0)
		}
		{
			p.SetState(2932)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2934)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 364, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2933)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_COUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2936)
			p.Match(HplsqlParserT_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2937)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			p.SetState(2939)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2938)
					p.Expr_func_all_distinct()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2941)
				p.expr(0)
			}

		case HplsqlParserT_MUL:
			{
				p.SetState(2942)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2945)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2947)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2946)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_COUNT_BIG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2949)
			p.Match(HplsqlParserT_COUNT_BIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2950)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			p.SetState(2952)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2951)
					p.Expr_func_all_distinct()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2954)
				p.expr(0)
			}

		case HplsqlParserT_MUL:
			{
				p.SetState(2955)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2958)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2959)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_CUME_DIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2962)
			p.Match(HplsqlParserT_CUME_DIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2963)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2964)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2965)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_DENSE_RANK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2966)
			p.Match(HplsqlParserT_DENSE_RANK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2967)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2968)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2969)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_FIRST_VALUE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2970)
			p.Match(HplsqlParserT_FIRST_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2971)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2972)
			p.expr(0)
		}
		{
			p.SetState(2973)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2974)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_LAG:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2976)
			p.Match(HplsqlParserT_LAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2977)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2978)
			p.expr(0)
		}
		p.SetState(2985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(2979)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2980)
				p.expr(0)
			}
			p.SetState(2983)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_COMMA {
				{
					p.SetState(2981)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2982)
					p.expr(0)
				}

			}

		}
		{
			p.SetState(2987)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2988)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_LAST_VALUE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2990)
			p.Match(HplsqlParserT_LAST_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2991)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2992)
			p.expr(0)
		}
		{
			p.SetState(2993)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2994)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_LEAD:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2996)
			p.Match(HplsqlParserT_LEAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2997)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2998)
			p.expr(0)
		}
		p.SetState(3005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(2999)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3000)
				p.expr(0)
			}
			p.SetState(3003)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_COMMA {
				{
					p.SetState(3001)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3002)
					p.expr(0)
				}

			}

		}
		{
			p.SetState(3007)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3008)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_MAX:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3010)
			p.Match(HplsqlParserT_MAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3011)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3013)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3012)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3015)
			p.expr(0)
		}
		{
			p.SetState(3016)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3018)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3017)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_MIN:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3020)
			p.Match(HplsqlParserT_MIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3021)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3023)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 377, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3022)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3025)
			p.expr(0)
		}
		{
			p.SetState(3026)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3028)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 378, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3027)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_RANK:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3030)
			p.Match(HplsqlParserT_RANK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3031)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3032)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3033)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_ROW_NUMBER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3034)
			p.Match(HplsqlParserT_ROW_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3035)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3036)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3037)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_STDEV:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3038)
			p.Match(HplsqlParserT_STDEV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3039)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3041)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 379, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3040)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3043)
			p.expr(0)
		}
		{
			p.SetState(3044)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3046)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3045)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_SUM:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3048)
			p.Match(HplsqlParserT_SUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3049)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3051)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 381, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3050)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3053)
			p.expr(0)
		}
		{
			p.SetState(3054)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3056)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3055)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_VAR:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3058)
			p.Match(HplsqlParserT_VAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3059)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3061)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3060)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3063)
			p.expr(0)
		}
		{
			p.SetState(3064)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3066)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3065)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_VARIANCE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3068)
			p.Match(HplsqlParserT_VARIANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3069)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3071)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3070)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3073)
			p.expr(0)
		}
		{
			p.SetState(3074)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3076)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3075)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_all_distinctContext is an interface to support dynamic dispatch.
type IExpr_func_all_distinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALL() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode

	// IsExpr_func_all_distinctContext differentiates from other interfaces.
	IsExpr_func_all_distinctContext()
}

type Expr_func_all_distinctContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_all_distinctContext() *Expr_func_all_distinctContext {
	var p = new(Expr_func_all_distinctContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct
	return p
}

func InitEmptyExpr_func_all_distinctContext(p *Expr_func_all_distinctContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct
}

func (*Expr_func_all_distinctContext) IsExpr_func_all_distinctContext() {}

func NewExpr_func_all_distinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_all_distinctContext {
	var p = new(Expr_func_all_distinctContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct

	return p
}

func (s *Expr_func_all_distinctContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_all_distinctContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Expr_func_all_distinctContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Expr_func_all_distinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_all_distinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_all_distinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_all_distinct(s)
	}
}

func (s *Expr_func_all_distinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_all_distinct(s)
	}
}

func (p *HplsqlParser) Expr_func_all_distinct() (localctx IExpr_func_all_distinctContext) {
	localctx = NewExpr_func_all_distinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, HplsqlParserRULE_expr_func_all_distinct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3080)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ALL || _la == HplsqlParserT_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_over_clauseContext is an interface to support dynamic dispatch.
type IExpr_func_over_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OVER() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_partition_by_clause() IExpr_func_partition_by_clauseContext
	Order_by_clause() IOrder_by_clauseContext

	// IsExpr_func_over_clauseContext differentiates from other interfaces.
	IsExpr_func_over_clauseContext()
}

type Expr_func_over_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_over_clauseContext() *Expr_func_over_clauseContext {
	var p = new(Expr_func_over_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause
	return p
}

func InitEmptyExpr_func_over_clauseContext(p *Expr_func_over_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause
}

func (*Expr_func_over_clauseContext) IsExpr_func_over_clauseContext() {}

func NewExpr_func_over_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_over_clauseContext {
	var p = new(Expr_func_over_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause

	return p
}

func (s *Expr_func_over_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_over_clauseContext) T_OVER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVER, 0)
}

func (s *Expr_func_over_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_func_over_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_func_over_clauseContext) Expr_func_partition_by_clause() IExpr_func_partition_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_partition_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_partition_by_clauseContext)
}

func (s *Expr_func_over_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Expr_func_over_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_over_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_over_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_over_clause(s)
	}
}

func (s *Expr_func_over_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_over_clause(s)
	}
}

func (p *HplsqlParser) Expr_func_over_clause() (localctx IExpr_func_over_clauseContext) {
	localctx = NewExpr_func_over_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, HplsqlParserRULE_expr_func_over_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3082)
		p.Match(HplsqlParserT_OVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3083)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_PARTITION {
		{
			p.SetState(3084)
			p.Expr_func_partition_by_clause()
		}

	}
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ORDER {
		{
			p.SetState(3087)
			p.Order_by_clause()
		}

	}
	{
		p.SetState(3090)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_partition_by_clauseContext is an interface to support dynamic dispatch.
type IExpr_func_partition_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PARTITION() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExpr_func_partition_by_clauseContext differentiates from other interfaces.
	IsExpr_func_partition_by_clauseContext()
}

type Expr_func_partition_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_partition_by_clauseContext() *Expr_func_partition_by_clauseContext {
	var p = new(Expr_func_partition_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause
	return p
}

func InitEmptyExpr_func_partition_by_clauseContext(p *Expr_func_partition_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause
}

func (*Expr_func_partition_by_clauseContext) IsExpr_func_partition_by_clauseContext() {}

func NewExpr_func_partition_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_partition_by_clauseContext {
	var p = new(Expr_func_partition_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause

	return p
}

func (s *Expr_func_partition_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_partition_by_clauseContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PARTITION, 0)
}

func (s *Expr_func_partition_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Expr_func_partition_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_func_partition_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_func_partition_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_func_partition_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_func_partition_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_partition_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_partition_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_partition_by_clause(s)
	}
}

func (s *Expr_func_partition_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_partition_by_clause(s)
	}
}

func (p *HplsqlParser) Expr_func_partition_by_clause() (localctx IExpr_func_partition_by_clauseContext) {
	localctx = NewExpr_func_partition_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, HplsqlParserRULE_expr_func_partition_by_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3092)
		p.Match(HplsqlParserT_PARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3093)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3094)
		p.expr(0)
	}
	p.SetState(3099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(3095)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3096)
			p.expr(0)
		}

		p.SetState(3101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_spec_funcContext is an interface to support dynamic dispatch.
type IExpr_spec_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ACTIVITY_COUNT() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_AS() antlr.TerminalNode
	Dtype() IDtypeContext
	T_CLOSE_P() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	T_COUNT() antlr.TerminalNode
	T_MUL() antlr.TerminalNode
	T_CURRENT_DATE() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_CURRENT_TIMESTAMP() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_CURRENT_USER() antlr.TerminalNode
	T_USER() antlr.TerminalNode
	T_MAX_PART_STRING() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_EQUAL() []antlr.TerminalNode
	T_EQUAL(i int) antlr.TerminalNode
	T_MIN_PART_STRING() antlr.TerminalNode
	T_MAX_PART_INT() antlr.TerminalNode
	T_MIN_PART_INT() antlr.TerminalNode
	T_MAX_PART_DATE() antlr.TerminalNode
	T_MIN_PART_DATE() antlr.TerminalNode
	T_PART_COUNT() antlr.TerminalNode
	T_PART_LOC() antlr.TerminalNode
	T_TRIM() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_SYSDATE() antlr.TerminalNode

	// IsExpr_spec_funcContext differentiates from other interfaces.
	IsExpr_spec_funcContext()
}

type Expr_spec_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_spec_funcContext() *Expr_spec_funcContext {
	var p = new(Expr_spec_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_spec_func
	return p
}

func InitEmptyExpr_spec_funcContext(p *Expr_spec_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_spec_func
}

func (*Expr_spec_funcContext) IsExpr_spec_funcContext() {}

func NewExpr_spec_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_spec_funcContext {
	var p = new(Expr_spec_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_spec_func

	return p
}

func (s *Expr_spec_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_spec_funcContext) T_ACTIVITY_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTIVITY_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CAST, 0)
}

func (s *Expr_spec_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_spec_funcContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_spec_funcContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_spec_funcContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Expr_spec_funcContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Expr_spec_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_spec_funcContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Expr_spec_funcContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_DATE, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Expr_spec_funcContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIMESTAMP, 0)
}

func (s *Expr_spec_funcContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_USER, 0)
}

func (s *Expr_spec_funcContext) T_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USER, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_STRING, 0)
}

func (s *Expr_spec_funcContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_spec_funcContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_spec_funcContext) AllT_EQUAL() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_EQUAL)
}

func (s *Expr_spec_funcContext) T_EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, i)
}

func (s *Expr_spec_funcContext) T_MIN_PART_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_STRING, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_INT, 0)
}

func (s *Expr_spec_funcContext) T_MIN_PART_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_INT, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_DATE, 0)
}

func (s *Expr_spec_funcContext) T_MIN_PART_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_DATE, 0)
}

func (s *Expr_spec_funcContext) T_PART_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_PART_LOC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_LOC, 0)
}

func (s *Expr_spec_funcContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRIM, 0)
}

func (s *Expr_spec_funcContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBSTRING, 0)
}

func (s *Expr_spec_funcContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Expr_spec_funcContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Expr_spec_funcContext) T_SYSDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYSDATE, 0)
}

func (s *Expr_spec_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_spec_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_spec_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_spec_func(s)
	}
}

func (s *Expr_spec_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_spec_func(s)
	}
}

func (p *HplsqlParser) Expr_spec_func() (localctx IExpr_spec_funcContext) {
	localctx = NewExpr_spec_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, HplsqlParserRULE_expr_spec_func)
	var _la int

	var _alt int

	p.SetState(3302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3102)
			p.Match(HplsqlParserT_ACTIVITY_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3103)
			p.Match(HplsqlParserT_CAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3104)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3105)
			p.expr(0)
		}
		{
			p.SetState(3106)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3107)
			p.Dtype()
		}
		p.SetState(3109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(3108)
				p.Dtype_len()
			}

		}
		{
			p.SetState(3111)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3113)
			p.Match(HplsqlParserT_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3114)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			{
				p.SetState(3115)
				p.expr(0)
			}

		case HplsqlParserT_MUL:
			{
				p.SetState(3116)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3119)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3120)
			p.Match(HplsqlParserT_CURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3121)
			p.Match(HplsqlParserT_CURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3122)
			p.Match(HplsqlParserT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(3126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_CURRENT_TIMESTAMP:
			{
				p.SetState(3123)
				p.Match(HplsqlParserT_CURRENT_TIMESTAMP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_CURRENT:
			{
				p.SetState(3124)
				p.Match(HplsqlParserT_CURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3125)
				p.Match(HplsqlParserT_TIMESTAMP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3132)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 394, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3128)
				p.Match(HplsqlParserT_OPEN_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3129)
				p.expr(0)
			}
			{
				p.SetState(3130)
				p.Match(HplsqlParserT_CLOSE_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3134)
			p.Match(HplsqlParserT_CURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3135)
			p.Match(HplsqlParserT_CURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3136)
			p.Match(HplsqlParserT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3137)
			p.Match(HplsqlParserT_MAX_PART_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3138)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3139)
			p.expr(0)
		}
		p.SetState(3152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3140)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3141)
				p.expr(0)
			}
			p.SetState(3149)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3142)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3143)
					p.expr(0)
				}
				{
					p.SetState(3144)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3145)
					p.expr(0)
				}

				p.SetState(3151)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3154)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3156)
			p.Match(HplsqlParserT_MIN_PART_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3157)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3158)
			p.expr(0)
		}
		p.SetState(3171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3159)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3160)
				p.expr(0)
			}
			p.SetState(3168)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3161)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3162)
					p.expr(0)
				}
				{
					p.SetState(3163)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3164)
					p.expr(0)
				}

				p.SetState(3170)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3173)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3175)
			p.Match(HplsqlParserT_MAX_PART_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3176)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3177)
			p.expr(0)
		}
		p.SetState(3190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3178)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3179)
				p.expr(0)
			}
			p.SetState(3187)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3180)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3181)
					p.expr(0)
				}
				{
					p.SetState(3182)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3183)
					p.expr(0)
				}

				p.SetState(3189)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3192)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3194)
			p.Match(HplsqlParserT_MIN_PART_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3195)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3196)
			p.expr(0)
		}
		p.SetState(3209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3197)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3198)
				p.expr(0)
			}
			p.SetState(3206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3199)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3200)
					p.expr(0)
				}
				{
					p.SetState(3201)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3202)
					p.expr(0)
				}

				p.SetState(3208)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3211)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3213)
			p.Match(HplsqlParserT_MAX_PART_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3214)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3215)
			p.expr(0)
		}
		p.SetState(3228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3216)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3217)
				p.expr(0)
			}
			p.SetState(3225)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3218)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3219)
					p.expr(0)
				}
				{
					p.SetState(3220)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3221)
					p.expr(0)
				}

				p.SetState(3227)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3230)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3232)
			p.Match(HplsqlParserT_MIN_PART_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3233)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3234)
			p.expr(0)
		}
		p.SetState(3247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3235)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3236)
				p.expr(0)
			}
			p.SetState(3244)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3237)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3238)
					p.expr(0)
				}
				{
					p.SetState(3239)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3240)
					p.expr(0)
				}

				p.SetState(3246)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3249)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3251)
			p.Match(HplsqlParserT_PART_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3252)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3253)
			p.expr(0)
		}
		p.SetState(3261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(3254)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3255)
				p.expr(0)
			}
			{
				p.SetState(3256)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3257)
				p.expr(0)
			}

			p.SetState(3263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3264)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3266)
			p.Match(HplsqlParserT_PART_LOC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3267)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3268)
			p.expr(0)
		}
		p.SetState(3274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3269)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3270)
					p.expr(0)
				}
				{
					p.SetState(3271)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3272)
					p.expr(0)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3276)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 408, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3278)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3279)
				p.expr(0)
			}

		}
		{
			p.SetState(3282)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3284)
			p.Match(HplsqlParserT_TRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3285)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3286)
			p.expr(0)
		}
		{
			p.SetState(3287)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3289)
			p.Match(HplsqlParserT_SUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3290)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3291)
			p.expr(0)
		}
		{
			p.SetState(3292)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3293)
			p.expr(0)
		}
		p.SetState(3296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_FOR {
			{
				p.SetState(3294)
				p.Match(HplsqlParserT_FOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3295)
				p.expr(0)
			}

		}
		{
			p.SetState(3298)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3300)
			p.Match(HplsqlParserT_SYSDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3301)
			p.Match(HplsqlParserT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_params() IExpr_func_paramsContext

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func
	return p
}

func InitEmptyExpr_funcContext(p *Expr_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_funcContext) Expr_func_params() IExpr_func_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_paramsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func(s)
	}
}

func (p *HplsqlParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, HplsqlParserRULE_expr_func)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3304)
		p.Ident()
	}
	{
		p.SetState(3305)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3307)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 412, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3306)
			p.Expr_func_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3309)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_dotContext is an interface to support dynamic dispatch.
type IExpr_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_dot_method_call() IExpr_dot_method_callContext
	Expr_dot_property_access() IExpr_dot_property_accessContext

	// IsExpr_dotContext differentiates from other interfaces.
	IsExpr_dotContext()
}

type Expr_dotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dotContext() *Expr_dotContext {
	var p = new(Expr_dotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot
	return p
}

func InitEmptyExpr_dotContext(p *Expr_dotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot
}

func (*Expr_dotContext) IsExpr_dotContext() {}

func NewExpr_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dotContext {
	var p = new(Expr_dotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot

	return p
}

func (s *Expr_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dotContext) Expr_dot_method_call() IExpr_dot_method_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dot_method_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_method_callContext)
}

func (s *Expr_dotContext) Expr_dot_property_access() IExpr_dot_property_accessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dot_property_accessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_property_accessContext)
}

func (s *Expr_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot(s)
	}
}

func (s *Expr_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot(s)
	}
}

func (p *HplsqlParser) Expr_dot() (localctx IExpr_dotContext) {
	localctx = NewExpr_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, HplsqlParserRULE_expr_dot)
	p.SetState(3313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3311)
			p.Expr_dot_method_call()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3312)
			p.Expr_dot_property_access()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_dot_method_callContext is an interface to support dynamic dispatch.
type IExpr_dot_method_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	AllExpr_func() []IExpr_funcContext
	Expr_func(i int) IExpr_funcContext
	Ident() IIdentContext

	// IsExpr_dot_method_callContext differentiates from other interfaces.
	IsExpr_dot_method_callContext()
}

type Expr_dot_method_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_method_callContext() *Expr_dot_method_callContext {
	var p = new(Expr_dot_method_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call
	return p
}

func InitEmptyExpr_dot_method_callContext(p *Expr_dot_method_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call
}

func (*Expr_dot_method_callContext) IsExpr_dot_method_callContext() {}

func NewExpr_dot_method_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_method_callContext {
	var p = new(Expr_dot_method_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call

	return p
}

func (s *Expr_dot_method_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_method_callContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Expr_dot_method_callContext) AllExpr_func() []IExpr_funcContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_funcContext); ok {
			len++
		}
	}

	tst := make([]IExpr_funcContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_funcContext); ok {
			tst[i] = t.(IExpr_funcContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dot_method_callContext) Expr_func(i int) IExpr_funcContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_dot_method_callContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_dot_method_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_method_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_method_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot_method_call(s)
	}
}

func (s *Expr_dot_method_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot_method_call(s)
	}
}

func (p *HplsqlParser) Expr_dot_method_call() (localctx IExpr_dot_method_callContext) {
	localctx = NewExpr_dot_method_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, HplsqlParserRULE_expr_dot_method_call)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3315)
			p.Ident()
		}

	case 2:
		{
			p.SetState(3316)
			p.Expr_func()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3319)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3320)
		p.Expr_func()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_dot_property_accessContext is an interface to support dynamic dispatch.
type IExpr_dot_property_accessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Expr_func() IExpr_funcContext

	// IsExpr_dot_property_accessContext differentiates from other interfaces.
	IsExpr_dot_property_accessContext()
}

type Expr_dot_property_accessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_property_accessContext() *Expr_dot_property_accessContext {
	var p = new(Expr_dot_property_accessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access
	return p
}

func InitEmptyExpr_dot_property_accessContext(p *Expr_dot_property_accessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access
}

func (*Expr_dot_property_accessContext) IsExpr_dot_property_accessContext() {}

func NewExpr_dot_property_accessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_property_accessContext {
	var p = new(Expr_dot_property_accessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access

	return p
}

func (s *Expr_dot_property_accessContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_property_accessContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Expr_dot_property_accessContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dot_property_accessContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_dot_property_accessContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_dot_property_accessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_property_accessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_property_accessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot_property_access(s)
	}
}

func (s *Expr_dot_property_accessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot_property_access(s)
	}
}

func (p *HplsqlParser) Expr_dot_property_access() (localctx IExpr_dot_property_accessContext) {
	localctx = NewExpr_dot_property_accessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, HplsqlParserRULE_expr_dot_property_access)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3322)
			p.Ident()
		}

	case 2:
		{
			p.SetState(3323)
			p.Expr_func()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3326)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3327)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_paramsContext is an interface to support dynamic dispatch.
type IExpr_func_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunc_param() []IFunc_paramContext
	Func_param(i int) IFunc_paramContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExpr_func_paramsContext differentiates from other interfaces.
	IsExpr_func_paramsContext()
}

type Expr_func_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_paramsContext() *Expr_func_paramsContext {
	var p = new(Expr_func_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_params
	return p
}

func InitEmptyExpr_func_paramsContext(p *Expr_func_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_params
}

func (*Expr_func_paramsContext) IsExpr_func_paramsContext() {}

func NewExpr_func_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_paramsContext {
	var p = new(Expr_func_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_params

	return p
}

func (s *Expr_func_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_paramsContext) AllFunc_param() []IFunc_paramContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunc_paramContext); ok {
			len++
		}
	}

	tst := make([]IFunc_paramContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunc_paramContext); ok {
			tst[i] = t.(IFunc_paramContext)
			i++
		}
	}

	return tst
}

func (s *Expr_func_paramsContext) Func_param(i int) IFunc_paramContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *Expr_func_paramsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_func_paramsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_func_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_params(s)
	}
}

func (s *Expr_func_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_params(s)
	}
}

func (p *HplsqlParser) Expr_func_params() (localctx IExpr_func_paramsContext) {
	localctx = NewExpr_func_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, HplsqlParserRULE_expr_func_params)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3329)
		p.Func_param()
	}
	p.SetState(3334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3330)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3331)
				p.Func_param()
			}

		}
		p.SetState(3336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_paramContext is an interface to support dynamic dispatch.
type IFunc_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Ident() IIdentContext
	T_EQUAL() antlr.TerminalNode
	T_GREATER() antlr.TerminalNode

	// IsFunc_paramContext differentiates from other interfaces.
	IsFunc_paramContext()
}

type Func_paramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_paramContext() *Func_paramContext {
	var p = new(Func_paramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_func_param
	return p
}

func InitEmptyFunc_paramContext(p *Func_paramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_func_param
}

func (*Func_paramContext) IsFunc_paramContext() {}

func NewFunc_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_paramContext {
	var p = new(Func_paramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_func_param

	return p
}

func (s *Func_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_paramContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_paramContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Func_paramContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Func_paramContext) T_GREATER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, 0)
}

func (s *Func_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFunc_param(s)
	}
}

func (s *Func_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFunc_param(s)
	}
}

func (p *HplsqlParser) Func_param() (localctx IFunc_paramContext) {
	localctx = NewFunc_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, HplsqlParserRULE_func_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3337)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INTO\")", ""))
		goto errorExit
	}
	p.SetState(3343)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 418, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3338)
			p.Ident()
		}
		{
			p.SetState(3339)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_GREATER {
			{
				p.SetState(3340)
				p.Match(HplsqlParserT_GREATER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3345)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_selectContext is an interface to support dynamic dispatch.
type IExpr_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext

	// IsExpr_selectContext differentiates from other interfaces.
	IsExpr_selectContext()
}

type Expr_selectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_selectContext() *Expr_selectContext {
	var p = new(Expr_selectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_select
	return p
}

func InitEmptyExpr_selectContext(p *Expr_selectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_select
}

func (*Expr_selectContext) IsExpr_selectContext() {}

func NewExpr_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_selectContext {
	var p = new(Expr_selectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_select

	return p
}

func (s *Expr_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_selectContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Expr_selectContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_select(s)
	}
}

func (s *Expr_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_select(s)
	}
}

func (p *HplsqlParser) Expr_select() (localctx IExpr_selectContext) {
	localctx = NewExpr_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, HplsqlParserRULE_expr_select)
	p.SetState(3349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3347)
			p.Select_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3348)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_fileContext is an interface to support dynamic dispatch.
type IExpr_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsExpr_fileContext differentiates from other interfaces.
	IsExpr_fileContext()
}

type Expr_fileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_fileContext() *Expr_fileContext {
	var p = new(Expr_fileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_file
	return p
}

func InitEmptyExpr_fileContext(p *Expr_fileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_file
}

func (*Expr_fileContext) IsExpr_fileContext() {}

func NewExpr_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_fileContext {
	var p = new(Expr_fileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_file

	return p
}

func (s *Expr_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_fileContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Expr_fileContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_file(s)
	}
}

func (s *Expr_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_file(s)
	}
}

func (p *HplsqlParser) Expr_file() (localctx IExpr_fileContext) {
	localctx = NewExpr_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, HplsqlParserRULE_expr_file)
	p.SetState(3353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3351)
			p.File_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3352)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHiveContext is an interface to support dynamic dispatch.
type IHiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HIVE() antlr.TerminalNode
	AllHive_item() []IHive_itemContext
	Hive_item(i int) IHive_itemContext

	// IsHiveContext differentiates from other interfaces.
	IsHiveContext()
}

type HiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHiveContext() *HiveContext {
	var p = new(HiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive
	return p
}

func InitEmptyHiveContext(p *HiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive
}

func (*HiveContext) IsHiveContext() {}

func NewHiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HiveContext {
	var p = new(HiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_hive

	return p
}

func (s *HiveContext) GetParser() antlr.Parser { return s.parser }

func (s *HiveContext) T_HIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HIVE, 0)
}

func (s *HiveContext) AllHive_item() []IHive_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHive_itemContext); ok {
			len++
		}
	}

	tst := make([]IHive_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHive_itemContext); ok {
			tst[i] = t.(IHive_itemContext)
			i++
		}
	}

	return tst
}

func (s *HiveContext) Hive_item(i int) IHive_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHive_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHive_itemContext)
}

func (s *HiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHive(s)
	}
}

func (s *HiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHive(s)
	}
}

func (p *HplsqlParser) Hive() (localctx IHiveContext) {
	localctx = NewHiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, HplsqlParserRULE_hive)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3355)
		p.Match(HplsqlParserT_HIVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3356)
				p.Hive_item()
			}

		}
		p.SetState(3361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHive_itemContext is an interface to support dynamic dispatch.
type IHive_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SUB() antlr.TerminalNode
	Qident() IQidentContext
	Expr() IExprContext
	L_ID() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode

	// IsHive_itemContext differentiates from other interfaces.
	IsHive_itemContext()
}

type Hive_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHive_itemContext() *Hive_itemContext {
	var p = new(Hive_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive_item
	return p
}

func InitEmptyHive_itemContext(p *Hive_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive_item
}

func (*Hive_itemContext) IsHive_itemContext() {}

func NewHive_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hive_itemContext {
	var p = new(Hive_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_hive_item

	return p
}

func (s *Hive_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Hive_itemContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Hive_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Hive_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Hive_itemContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Hive_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Hive_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hive_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hive_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHive_item(s)
	}
}

func (s *Hive_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHive_item(s)
	}
}

func (p *HplsqlParser) Hive_item() (localctx IHive_itemContext) {
	localctx = NewHive_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, HplsqlParserRULE_hive_item)
	p.SetState(3374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3362)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3363)
			p.Qident()
		}
		{
			p.SetState(3364)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3366)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3367)
			p.Qident()
		}
		{
			p.SetState(3368)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3369)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3370)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3372)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3373)
			p.Qident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHostContext is an interface to support dynamic dispatch.
type IHostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Host_cmd() IHost_cmdContext
	T_SEMICOLON() antlr.TerminalNode
	Host_stmt() IHost_stmtContext

	// IsHostContext differentiates from other interfaces.
	IsHostContext()
}

type HostContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostContext() *HostContext {
	var p = new(HostContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host
	return p
}

func InitEmptyHostContext(p *HostContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host
}

func (*HostContext) IsHostContext() {}

func NewHostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostContext {
	var p = new(HostContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host

	return p
}

func (s *HostContext) GetParser() antlr.Parser { return s.parser }

func (s *HostContext) Host_cmd() IHost_cmdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHost_cmdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHost_cmdContext)
}

func (s *HostContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *HostContext) Host_stmt() IHost_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHost_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHost_stmtContext)
}

func (s *HostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost(s)
	}
}

func (s *HostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost(s)
	}
}

func (p *HplsqlParser) Host() (localctx IHostContext) {
	localctx = NewHostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, HplsqlParserRULE_host)
	p.SetState(3381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3376)
			p.Match(HplsqlParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3377)
			p.Host_cmd()
		}
		{
			p.SetState(3378)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_HOST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3380)
			p.Host_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHost_cmdContext is an interface to support dynamic dispatch.
type IHost_cmdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsHost_cmdContext differentiates from other interfaces.
	IsHost_cmdContext()
}

type Host_cmdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHost_cmdContext() *Host_cmdContext {
	var p = new(Host_cmdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_cmd
	return p
}

func InitEmptyHost_cmdContext(p *Host_cmdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_cmd
}

func (*Host_cmdContext) IsHost_cmdContext() {}

func NewHost_cmdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Host_cmdContext {
	var p = new(Host_cmdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host_cmd

	return p
}

func (s *Host_cmdContext) GetParser() antlr.Parser { return s.parser }
func (s *Host_cmdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Host_cmdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Host_cmdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost_cmd(s)
	}
}

func (s *Host_cmdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost_cmd(s)
	}
}

func (p *HplsqlParser) Host_cmd() (localctx IHost_cmdContext) {
	localctx = NewHost_cmdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, HplsqlParserRULE_host_cmd)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(3383)
			p.MatchWildcard()

		}
		p.SetState(3388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHost_stmtContext is an interface to support dynamic dispatch.
type IHost_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HOST() antlr.TerminalNode
	Expr() IExprContext

	// IsHost_stmtContext differentiates from other interfaces.
	IsHost_stmtContext()
}

type Host_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHost_stmtContext() *Host_stmtContext {
	var p = new(Host_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_stmt
	return p
}

func InitEmptyHost_stmtContext(p *Host_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_stmt
}

func (*Host_stmtContext) IsHost_stmtContext() {}

func NewHost_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Host_stmtContext {
	var p = new(Host_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host_stmt

	return p
}

func (s *Host_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Host_stmtContext) T_HOST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HOST, 0)
}

func (s *Host_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Host_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Host_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Host_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost_stmt(s)
	}
}

func (s *Host_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost_stmt(s)
	}
}

func (p *HplsqlParser) Host_stmt() (localctx IHost_stmtContext) {
	localctx = NewHost_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, HplsqlParserRULE_host_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3389)
		p.Match(HplsqlParserT_HOST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3390)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFile_nameContext is an interface to support dynamic dispatch.
type IFile_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_FILE() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_DIV() []antlr.TerminalNode
	T_DIV(i int) antlr.TerminalNode
	T_DOT() antlr.TerminalNode

	// IsFile_nameContext differentiates from other interfaces.
	IsFile_nameContext()
}

type File_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_nameContext() *File_nameContext {
	var p = new(File_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_file_name
	return p
}

func InitEmptyFile_nameContext(p *File_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_file_name
}

func (*File_nameContext) IsFile_nameContext() {}

func NewFile_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_nameContext {
	var p = new(File_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_file_name

	return p
}

func (s *File_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_nameContext) L_FILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_FILE, 0)
}

func (s *File_nameContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *File_nameContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *File_nameContext) AllT_DIV() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DIV)
}

func (s *File_nameContext) T_DIV(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, i)
}

func (s *File_nameContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *File_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFile_name(s)
	}
}

func (s *File_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFile_name(s)
	}
}

func (p *HplsqlParser) File_name() (localctx IFile_nameContext) {
	localctx = NewFile_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, HplsqlParserRULE_file_name)
	var _alt int

	p.SetState(3406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_FILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3392)
			p.Match(HplsqlParserL_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_DIV, HplsqlParserT_DOT, HplsqlParserT_SUB, HplsqlParserL_ID:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_DIV:
			{
				p.SetState(3393)
				p.Match(HplsqlParserT_DIV)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_DOT:
			{
				p.SetState(3394)
				p.Match(HplsqlParserT_DOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3395)
				p.Match(HplsqlParserT_DIV)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:

		default:
		}
		{
			p.SetState(3398)
			p.Qident()
		}
		p.SetState(3403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3399)
					p.Match(HplsqlParserT_DIV)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3400)
					p.Qident()
				}

			}
			p.SetState(3405)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDate_literalContext is an interface to support dynamic dispatch.
type IDate_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DATE() antlr.TerminalNode
	String_() IStringContext

	// IsDate_literalContext differentiates from other interfaces.
	IsDate_literalContext()
}

type Date_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_literalContext() *Date_literalContext {
	var p = new(Date_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_date_literal
	return p
}

func InitEmptyDate_literalContext(p *Date_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_date_literal
}

func (*Date_literalContext) IsDate_literalContext() {}

func NewDate_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_literalContext {
	var p = new(Date_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_date_literal

	return p
}

func (s *Date_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_literalContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Date_literalContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Date_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Date_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDate_literal(s)
	}
}

func (s *Date_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDate_literal(s)
	}
}

func (p *HplsqlParser) Date_literal() (localctx IDate_literalContext) {
	localctx = NewDate_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, HplsqlParserRULE_date_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3408)
		p.Match(HplsqlParserT_DATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3409)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimestamp_literalContext is an interface to support dynamic dispatch.
type ITimestamp_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TIMESTAMP() antlr.TerminalNode
	String_() IStringContext

	// IsTimestamp_literalContext differentiates from other interfaces.
	IsTimestamp_literalContext()
}

type Timestamp_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestamp_literalContext() *Timestamp_literalContext {
	var p = new(Timestamp_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_timestamp_literal
	return p
}

func InitEmptyTimestamp_literalContext(p *Timestamp_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_timestamp_literal
}

func (*Timestamp_literalContext) IsTimestamp_literalContext() {}

func NewTimestamp_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timestamp_literalContext {
	var p = new(Timestamp_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_timestamp_literal

	return p
}

func (s *Timestamp_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Timestamp_literalContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Timestamp_literalContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Timestamp_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timestamp_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timestamp_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTimestamp_literal(s)
	}
}

func (s *Timestamp_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTimestamp_literal(s)
	}
}

func (p *HplsqlParser) Timestamp_literal() (localctx ITimestamp_literalContext) {
	localctx = NewTimestamp_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, HplsqlParserRULE_timestamp_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3411)
		p.Match(HplsqlParserT_TIMESTAMP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3412)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentContext is an interface to support dynamic dispatch.
type IIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_ID() antlr.TerminalNode
	Non_reserved_words() INon_reserved_wordsContext
	T_SUB() antlr.TerminalNode

	// IsIdentContext differentiates from other interfaces.
	IsIdentContext()
}

type IdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentContext() *IdentContext {
	var p = new(IdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_ident
	return p
}

func InitEmptyIdentContext(p *IdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_ident
}

func (*IdentContext) IsIdentContext() {}

func NewIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentContext {
	var p = new(IdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_ident

	return p
}

func (s *IdentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *IdentContext) Non_reserved_words() INon_reserved_wordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INon_reserved_wordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INon_reserved_wordsContext)
}

func (s *IdentContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *IdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIdent(s)
	}
}

func (s *IdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIdent(s)
	}
}

func (p *HplsqlParser) Ident() (localctx IIdentContext) {
	localctx = NewIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, HplsqlParserRULE_ident)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_SUB {
		{
			p.SetState(3414)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_ID:
		{
			p.SetState(3417)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIME, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER:
		{
			p.SetState(3418)
			p.Non_reserved_words()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQidentContext is an interface to support dynamic dispatch.
type IQidentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_DOT() []antlr.TerminalNode
	T_DOT(i int) antlr.TerminalNode

	// IsQidentContext differentiates from other interfaces.
	IsQidentContext()
}

type QidentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQidentContext() *QidentContext {
	var p = new(QidentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qident
	return p
}

func InitEmptyQidentContext(p *QidentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qident
}

func (*QidentContext) IsQidentContext() {}

func NewQidentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QidentContext {
	var p = new(QidentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_qident

	return p
}

func (s *QidentContext) GetParser() antlr.Parser { return s.parser }

func (s *QidentContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *QidentContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *QidentContext) AllT_DOT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DOT)
}

func (s *QidentContext) T_DOT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, i)
}

func (s *QidentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QidentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QidentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQident(s)
	}
}

func (s *QidentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQident(s)
	}
}

func (p *HplsqlParser) Qident() (localctx IQidentContext) {
	localctx = NewQidentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, HplsqlParserRULE_qident)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3421)
		p.Ident()
	}
	p.SetState(3426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3422)
				p.Match(HplsqlParserT_DOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3423)
				p.Ident()
			}

		}
		p.SetState(3428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) CopyAll(ctx *StringContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Double_quotedStringContext struct {
	StringContext
}

func NewDouble_quotedStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Double_quotedStringContext {
	var p = new(Double_quotedStringContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *Double_quotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Double_quotedStringContext) L_D_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_D_STRING, 0)
}

func (s *Double_quotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDouble_quotedString(s)
	}
}

func (s *Double_quotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDouble_quotedString(s)
	}
}

type Single_quotedStringContext struct {
	StringContext
}

func NewSingle_quotedStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Single_quotedStringContext {
	var p = new(Single_quotedStringContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *Single_quotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_quotedStringContext) L_S_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_S_STRING, 0)
}

func (s *Single_quotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSingle_quotedString(s)
	}
}

func (s *Single_quotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSingle_quotedString(s)
	}
}

func (p *HplsqlParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, HplsqlParserRULE_string)
	p.SetState(3431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_S_STRING:
		localctx = NewSingle_quotedStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3429)
			p.Match(HplsqlParserL_S_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserL_D_STRING:
		localctx = NewDouble_quotedStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3430)
			p.Match(HplsqlParserL_D_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInt_numberContext is an interface to support dynamic dispatch.
type IInt_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_INT() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	T_ADD() antlr.TerminalNode

	// IsInt_numberContext differentiates from other interfaces.
	IsInt_numberContext()
}

type Int_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_numberContext() *Int_numberContext {
	var p = new(Int_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_int_number
	return p
}

func InitEmptyInt_numberContext(p *Int_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_int_number
}

func (*Int_numberContext) IsInt_numberContext() {}

func NewInt_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_numberContext {
	var p = new(Int_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_int_number

	return p
}

func (s *Int_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_numberContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Int_numberContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Int_numberContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *Int_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInt_number(s)
	}
}

func (s *Int_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInt_number(s)
	}
}

func (p *HplsqlParser) Int_number() (localctx IInt_numberContext) {
	localctx = NewInt_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, HplsqlParserRULE_int_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB {
		{
			p.SetState(3433)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3436)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDec_numberContext is an interface to support dynamic dispatch.
type IDec_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_DEC() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	T_ADD() antlr.TerminalNode

	// IsDec_numberContext differentiates from other interfaces.
	IsDec_numberContext()
}

type Dec_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDec_numberContext() *Dec_numberContext {
	var p = new(Dec_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dec_number
	return p
}

func InitEmptyDec_numberContext(p *Dec_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dec_number
}

func (*Dec_numberContext) IsDec_numberContext() {}

func NewDec_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dec_numberContext {
	var p = new(Dec_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dec_number

	return p
}

func (s *Dec_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Dec_numberContext) L_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_DEC, 0)
}

func (s *Dec_numberContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Dec_numberContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *Dec_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dec_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dec_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDec_number(s)
	}
}

func (s *Dec_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDec_number(s)
	}
}

func (p *HplsqlParser) Dec_number() (localctx IDec_numberContext) {
	localctx = NewDec_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, HplsqlParserRULE_dec_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB {
		{
			p.SetState(3438)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3441)
		p.Match(HplsqlParserL_DEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_literalContext is an interface to support dynamic dispatch.
type IBool_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRUE() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode

	// IsBool_literalContext differentiates from other interfaces.
	IsBool_literalContext()
}

type Bool_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_literalContext() *Bool_literalContext {
	var p = new(Bool_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_literal
	return p
}

func InitEmptyBool_literalContext(p *Bool_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_literal
}

func (*Bool_literalContext) IsBool_literalContext() {}

func NewBool_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_literalContext {
	var p = new(Bool_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_literal

	return p
}

func (s *Bool_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_literalContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUE, 0)
}

func (s *Bool_literalContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALSE, 0)
}

func (s *Bool_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_literal(s)
	}
}

func (s *Bool_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_literal(s)
	}
}

func (p *HplsqlParser) Bool_literal() (localctx IBool_literalContext) {
	localctx = NewBool_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, HplsqlParserRULE_bool_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3443)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FALSE || _la == HplsqlParserT_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INull_constContext is an interface to support dynamic dispatch.
type INull_constContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode

	// IsNull_constContext differentiates from other interfaces.
	IsNull_constContext()
}

type Null_constContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_constContext() *Null_constContext {
	var p = new(Null_constContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_const
	return p
}

func InitEmptyNull_constContext(p *Null_constContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_const
}

func (*Null_constContext) IsNull_constContext() {}

func NewNull_constContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_constContext {
	var p = new(Null_constContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_null_const

	return p
}

func (s *Null_constContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_constContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Null_constContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_constContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_constContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNull_const(s)
	}
}

func (s *Null_constContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNull_const(s)
	}
}

func (p *HplsqlParser) Null_const() (localctx INull_constContext) {
	localctx = NewNull_constContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, HplsqlParserRULE_null_const)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3445)
		p.Match(HplsqlParserT_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INon_reserved_wordsContext is an interface to support dynamic dispatch.
type INon_reserved_wordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ACTION() antlr.TerminalNode
	T_ACTIVITY_COUNT() antlr.TerminalNode
	T_ADD2() antlr.TerminalNode
	T_ALL() antlr.TerminalNode
	T_ALLOCATE() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_ANSI_NULLS() antlr.TerminalNode
	T_ANSI_PADDING() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_ASC() antlr.TerminalNode
	T_ASSOCIATE() antlr.TerminalNode
	T_AT() antlr.TerminalNode
	T_AUTO_INCREMENT() antlr.TerminalNode
	T_AVG() antlr.TerminalNode
	T_BATCHSIZE() antlr.TerminalNode
	T_BEGIN() antlr.TerminalNode
	T_BETWEEN() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_BODY() antlr.TerminalNode
	T_BREAK() antlr.TerminalNode
	T_BULK() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode
	T_CALL() antlr.TerminalNode
	T_CALLER() antlr.TerminalNode
	T_CASCADE() antlr.TerminalNode
	T_CASE() antlr.TerminalNode
	T_CASESPECIFIC() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_CHARSET() antlr.TerminalNode
	T_CLIENT() antlr.TerminalNode
	T_CLOSE() antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	T_CMP() antlr.TerminalNode
	T_COLLECT() antlr.TerminalNode
	T_COLLECTION() antlr.TerminalNode
	T_COLUMN() antlr.TerminalNode
	T_COMMENT() antlr.TerminalNode
	T_COMPRESS() antlr.TerminalNode
	T_CONSTANT() antlr.TerminalNode
	T_COPY() antlr.TerminalNode
	T_COMMIT() antlr.TerminalNode
	T_CONCAT() antlr.TerminalNode
	T_CONDITION() antlr.TerminalNode
	T_CONSTRAINT() antlr.TerminalNode
	T_CONTINUE() antlr.TerminalNode
	T_COUNT() antlr.TerminalNode
	T_COUNT_BIG() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_CREATION() antlr.TerminalNode
	T_CREATOR() antlr.TerminalNode
	T_CS() antlr.TerminalNode
	T_CUME_DIST() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode
	T_CURRENT_DATE() antlr.TerminalNode
	T_CURRENT_SCHEMA() antlr.TerminalNode
	T_CURRENT_TIME_MILLIS() antlr.TerminalNode
	T_CURRENT_TIMESTAMP() antlr.TerminalNode
	T_CURRENT_USER() antlr.TerminalNode
	T_CURSOR() antlr.TerminalNode
	T_DATA() antlr.TerminalNode
	T_DATABASE() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DECLARE() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	T_DEFINED() antlr.TerminalNode
	T_DEFINER() antlr.TerminalNode
	T_DEFINITION() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_DELIMITED() antlr.TerminalNode
	T_DELIMITER() antlr.TerminalNode
	T_DENSE_RANK() antlr.TerminalNode
	T_DESC() antlr.TerminalNode
	T_DESCRIBE() antlr.TerminalNode
	T_DIAGNOSTICS() antlr.TerminalNode
	T_DIR() antlr.TerminalNode
	T_DIRECTORY() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode
	T_DISTRIBUTE() antlr.TerminalNode
	T_DO() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_DROP() antlr.TerminalNode
	T_DYNAMIC() antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	T_ENGINE() antlr.TerminalNode
	T_ESCAPED() antlr.TerminalNode
	T_EXCEPT() antlr.TerminalNode
	T_EXEC() antlr.TerminalNode
	T_EXECUTE() antlr.TerminalNode
	T_EXCEPTION() antlr.TerminalNode
	T_EXCLUSIVE() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_EXIT() antlr.TerminalNode
	T_FALLBACK() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode
	T_FETCH() antlr.TerminalNode
	T_FIELDS() antlr.TerminalNode
	T_FILE() antlr.TerminalNode
	T_FILES() antlr.TerminalNode
	T_FIRST_VALUE() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_FORMAT() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_FUNCTION() antlr.TerminalNode
	T_GET() antlr.TerminalNode
	T_GLOBAL() antlr.TerminalNode
	T_GO() antlr.TerminalNode
	T_GRANT() antlr.TerminalNode
	T_GROUP() antlr.TerminalNode
	T_HANDLER() antlr.TerminalNode
	T_HASH() antlr.TerminalNode
	T_HAVING() antlr.TerminalNode
	T_HDFS() antlr.TerminalNode
	T_HIVE() antlr.TerminalNode
	T_HOST() antlr.TerminalNode
	T_IDENTITY() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	T_INCLUDE() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	T_INITRANS() antlr.TerminalNode
	T_INNER() antlr.TerminalNode
	T_INOUT() antlr.TerminalNode
	T_INSERT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_INTERSECT() antlr.TerminalNode
	T_INTERVAL() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	T_INVOKER() antlr.TerminalNode
	T_ITEMS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ISOPEN() antlr.TerminalNode
	T_JOIN() antlr.TerminalNode
	T_KEEP() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	T_KEYS() antlr.TerminalNode
	T_LAG() antlr.TerminalNode
	T_LANGUAGE() antlr.TerminalNode
	T_LAST_VALUE() antlr.TerminalNode
	T_LEAD() antlr.TerminalNode
	T_LEAVE() antlr.TerminalNode
	T_LEFT() antlr.TerminalNode
	T_LIKE() antlr.TerminalNode
	T_LIMIT() antlr.TerminalNode
	T_LINES() antlr.TerminalNode
	T_LOCAL() antlr.TerminalNode
	T_LOCATION() antlr.TerminalNode
	T_LOCATOR() antlr.TerminalNode
	T_LOCATORS() antlr.TerminalNode
	T_LOCKS() antlr.TerminalNode
	T_LOG() antlr.TerminalNode
	T_LOGGED() antlr.TerminalNode
	T_LOGGING() antlr.TerminalNode
	T_LOOP() antlr.TerminalNode
	T_MAP() antlr.TerminalNode
	T_MATCHED() antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_MAXTRANS() antlr.TerminalNode
	T_MERGE() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_MIN() antlr.TerminalNode
	T_MULTISET() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NEW() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_NOCOMPRESS() antlr.TerminalNode
	T_NOCOUNT() antlr.TerminalNode
	T_NOLOGGING() antlr.TerminalNode
	T_NONE() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_NOTFOUND() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_OBJECT() antlr.TerminalNode
	T_OFF() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_OPEN() antlr.TerminalNode
	T_OR() antlr.TerminalNode
	T_ORDER() antlr.TerminalNode
	T_OUT() antlr.TerminalNode
	T_OUTER() antlr.TerminalNode
	T_OVER() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode
	T_OWNER() antlr.TerminalNode
	T_PACKAGE() antlr.TerminalNode
	T_PART_COUNT() antlr.TerminalNode
	T_PART_LOC() antlr.TerminalNode
	T_PARTITION() antlr.TerminalNode
	T_PCTFREE() antlr.TerminalNode
	T_PCTUSED() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_PRESERVE() antlr.TerminalNode
	T_PRIMARY() antlr.TerminalNode
	T_PRINT() antlr.TerminalNode
	T_PROC() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_PWD() antlr.TerminalNode
	T_QUALIFY() antlr.TerminalNode
	T_QUERY_BAND() antlr.TerminalNode
	T_QUIT() antlr.TerminalNode
	T_QUOTED_IDENTIFIER() antlr.TerminalNode
	T_RAISE() antlr.TerminalNode
	T_RANK() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	T_REGEXP() antlr.TerminalNode
	T_RR() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_RESIGNAL() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode
	T_RETURNS() antlr.TerminalNode
	T_REVERSE() antlr.TerminalNode
	T_RIGHT() antlr.TerminalNode
	T_RLIKE() antlr.TerminalNode
	T_RS() antlr.TerminalNode
	T_ROLE() antlr.TerminalNode
	T_ROLLBACK() antlr.TerminalNode
	T_ROW() antlr.TerminalNode
	T_ROWS() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode
	T_ROW_NUMBER() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode
	T_SECURITY() antlr.TerminalNode
	T_SEGMENT() antlr.TerminalNode
	T_SEL() antlr.TerminalNode
	T_SELECT() antlr.TerminalNode
	T_SESSION() antlr.TerminalNode
	T_SESSIONS() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_SETS() antlr.TerminalNode
	T_SHARE() antlr.TerminalNode
	T_SIGNAL() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SQL() antlr.TerminalNode
	T_SQLEXCEPTION() antlr.TerminalNode
	T_SQLINSERT() antlr.TerminalNode
	T_SQLSTATE() antlr.TerminalNode
	T_SQLWARNING() antlr.TerminalNode
	T_STATS() antlr.TerminalNode
	T_STATISTICS() antlr.TerminalNode
	T_STEP() antlr.TerminalNode
	T_STDEV() antlr.TerminalNode
	T_STORAGE() antlr.TerminalNode
	T_STORED() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SUBDIR() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_SUM() antlr.TerminalNode
	T_SUMMARY() antlr.TerminalNode
	T_SYSDATE() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_TABLESPACE() antlr.TerminalNode
	T_TEMPORARY() antlr.TerminalNode
	T_TERMINATED() antlr.TerminalNode
	T_TEXTIMAGE_ON() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	T_TIME() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TITLE() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_TOP() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode
	T_TRIM() antlr.TerminalNode
	T_TRUE() antlr.TerminalNode
	T_TRUNCATE() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_UR() antlr.TerminalNode
	T_USE() antlr.TerminalNode
	T_USER() antlr.TerminalNode
	T_USING() antlr.TerminalNode
	T_VALUE() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	T_VAR() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_VARIANCE() antlr.TerminalNode
	T_VOLATILE() antlr.TerminalNode
	T_WHILE() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_WITHOUT() antlr.TerminalNode
	T_WORK() antlr.TerminalNode
	T_XACT_ABORT() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	T_YES() antlr.TerminalNode

	// IsNon_reserved_wordsContext differentiates from other interfaces.
	IsNon_reserved_wordsContext()
}

type Non_reserved_wordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_reserved_wordsContext() *Non_reserved_wordsContext {
	var p = new(Non_reserved_wordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_non_reserved_words
	return p
}

func InitEmptyNon_reserved_wordsContext(p *Non_reserved_wordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_non_reserved_words
}

func (*Non_reserved_wordsContext) IsNon_reserved_wordsContext() {}

func NewNon_reserved_wordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_reserved_wordsContext {
	var p = new(Non_reserved_wordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_non_reserved_words

	return p
}

func (s *Non_reserved_wordsContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_reserved_wordsContext) T_ACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTION, 0)
}

func (s *Non_reserved_wordsContext) T_ACTIVITY_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTIVITY_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_ADD2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD2, 0)
}

func (s *Non_reserved_wordsContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Non_reserved_wordsContext) T_ALLOCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALLOCATE, 0)
}

func (s *Non_reserved_wordsContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Non_reserved_wordsContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Non_reserved_wordsContext) T_ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_NULLS, 0)
}

func (s *Non_reserved_wordsContext) T_ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_PADDING, 0)
}

func (s *Non_reserved_wordsContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Non_reserved_wordsContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, 0)
}

func (s *Non_reserved_wordsContext) T_ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASSOCIATE, 0)
}

func (s *Non_reserved_wordsContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Non_reserved_wordsContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Non_reserved_wordsContext) T_AVG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AVG, 0)
}

func (s *Non_reserved_wordsContext) T_BATCHSIZE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BATCHSIZE, 0)
}

func (s *Non_reserved_wordsContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Non_reserved_wordsContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BETWEEN, 0)
}

func (s *Non_reserved_wordsContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIGINT, 0)
}

func (s *Non_reserved_wordsContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIT, 0)
}

func (s *Non_reserved_wordsContext) T_BODY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BODY, 0)
}

func (s *Non_reserved_wordsContext) T_BREAK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BREAK, 0)
}

func (s *Non_reserved_wordsContext) T_BULK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BULK, 0)
}

func (s *Non_reserved_wordsContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Non_reserved_wordsContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BYTE, 0)
}

func (s *Non_reserved_wordsContext) T_CALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALL, 0)
}

func (s *Non_reserved_wordsContext) T_CALLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALLER, 0)
}

func (s *Non_reserved_wordsContext) T_CASCADE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASCADE, 0)
}

func (s *Non_reserved_wordsContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Non_reserved_wordsContext) T_CASESPECIFIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASESPECIFIC, 0)
}

func (s *Non_reserved_wordsContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CAST, 0)
}

func (s *Non_reserved_wordsContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Non_reserved_wordsContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Non_reserved_wordsContext) T_CHARSET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARSET, 0)
}

func (s *Non_reserved_wordsContext) T_CLIENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLIENT, 0)
}

func (s *Non_reserved_wordsContext) T_CLOSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE, 0)
}

func (s *Non_reserved_wordsContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Non_reserved_wordsContext) T_CMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CMP, 0)
}

func (s *Non_reserved_wordsContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Non_reserved_wordsContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECTION, 0)
}

func (s *Non_reserved_wordsContext) T_COLUMN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLUMN, 0)
}

func (s *Non_reserved_wordsContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Non_reserved_wordsContext) T_COMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMPRESS, 0)
}

func (s *Non_reserved_wordsContext) T_CONSTANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTANT, 0)
}

func (s *Non_reserved_wordsContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Non_reserved_wordsContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Non_reserved_wordsContext) T_CONCAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONCAT, 0)
}

func (s *Non_reserved_wordsContext) T_CONDITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONDITION, 0)
}

func (s *Non_reserved_wordsContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Non_reserved_wordsContext) T_CONTINUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONTINUE, 0)
}

func (s *Non_reserved_wordsContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_COUNT_BIG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT_BIG, 0)
}

func (s *Non_reserved_wordsContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Non_reserved_wordsContext) T_CREATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATION, 0)
}

func (s *Non_reserved_wordsContext) T_CREATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATOR, 0)
}

func (s *Non_reserved_wordsContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Non_reserved_wordsContext) T_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CUME_DIST, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_DATE, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_SCHEMA, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_TIME_MILLIS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIME_MILLIS, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIMESTAMP, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_USER, 0)
}

func (s *Non_reserved_wordsContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Non_reserved_wordsContext) T_DATA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATA, 0)
}

func (s *Non_reserved_wordsContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Non_reserved_wordsContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Non_reserved_wordsContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATETIME, 0)
}

func (s *Non_reserved_wordsContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAY, 0)
}

func (s *Non_reserved_wordsContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAYS, 0)
}

func (s *Non_reserved_wordsContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEC, 0)
}

func (s *Non_reserved_wordsContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECIMAL, 0)
}

func (s *Non_reserved_wordsContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Non_reserved_wordsContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Non_reserved_wordsContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFERRED, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINED, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINER, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINITION, 0)
}

func (s *Non_reserved_wordsContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Non_reserved_wordsContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITED, 0)
}

func (s *Non_reserved_wordsContext) T_DELIMITER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITER, 0)
}

func (s *Non_reserved_wordsContext) T_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DENSE_RANK, 0)
}

func (s *Non_reserved_wordsContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Non_reserved_wordsContext) T_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESCRIBE, 0)
}

func (s *Non_reserved_wordsContext) T_DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIAGNOSTICS, 0)
}

func (s *Non_reserved_wordsContext) T_DIR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIR, 0)
}

func (s *Non_reserved_wordsContext) T_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIRECTORY, 0)
}

func (s *Non_reserved_wordsContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Non_reserved_wordsContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTRIBUTE, 0)
}

func (s *Non_reserved_wordsContext) T_DO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DO, 0)
}

func (s *Non_reserved_wordsContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Non_reserved_wordsContext) T_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DYNAMIC, 0)
}

func (s *Non_reserved_wordsContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Non_reserved_wordsContext) T_ENGINE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENGINE, 0)
}

func (s *Non_reserved_wordsContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ESCAPED, 0)
}

func (s *Non_reserved_wordsContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPT, 0)
}

func (s *Non_reserved_wordsContext) T_EXEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXEC, 0)
}

func (s *Non_reserved_wordsContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Non_reserved_wordsContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Non_reserved_wordsContext) T_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCLUSIVE, 0)
}

func (s *Non_reserved_wordsContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Non_reserved_wordsContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Non_reserved_wordsContext) T_FALLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALLBACK, 0)
}

func (s *Non_reserved_wordsContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALSE, 0)
}

func (s *Non_reserved_wordsContext) T_FETCH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FETCH, 0)
}

func (s *Non_reserved_wordsContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIELDS, 0)
}

func (s *Non_reserved_wordsContext) T_FILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FILE, 0)
}

func (s *Non_reserved_wordsContext) T_FILES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FILES, 0)
}

func (s *Non_reserved_wordsContext) T_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIRST_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Non_reserved_wordsContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Non_reserved_wordsContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FORMAT, 0)
}

func (s *Non_reserved_wordsContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Non_reserved_wordsContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Non_reserved_wordsContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FULL, 0)
}

func (s *Non_reserved_wordsContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Non_reserved_wordsContext) T_GET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GET, 0)
}

func (s *Non_reserved_wordsContext) T_GLOBAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GLOBAL, 0)
}

func (s *Non_reserved_wordsContext) T_GO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, 0)
}

func (s *Non_reserved_wordsContext) T_GRANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GRANT, 0)
}

func (s *Non_reserved_wordsContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GROUP, 0)
}

func (s *Non_reserved_wordsContext) T_HANDLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HANDLER, 0)
}

func (s *Non_reserved_wordsContext) T_HASH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HASH, 0)
}

func (s *Non_reserved_wordsContext) T_HAVING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HAVING, 0)
}

func (s *Non_reserved_wordsContext) T_HDFS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HDFS, 0)
}

func (s *Non_reserved_wordsContext) T_HIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HIVE, 0)
}

func (s *Non_reserved_wordsContext) T_HOST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HOST, 0)
}

func (s *Non_reserved_wordsContext) T_IDENTITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IDENTITY, 0)
}

func (s *Non_reserved_wordsContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Non_reserved_wordsContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Non_reserved_wordsContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Non_reserved_wordsContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Non_reserved_wordsContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INCLUDE, 0)
}

func (s *Non_reserved_wordsContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Non_reserved_wordsContext) T_INITRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INITRANS, 0)
}

func (s *Non_reserved_wordsContext) T_INNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INNER, 0)
}

func (s *Non_reserved_wordsContext) T_INOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INOUT, 0)
}

func (s *Non_reserved_wordsContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Non_reserved_wordsContext) T_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT, 0)
}

func (s *Non_reserved_wordsContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT2, 0)
}

func (s *Non_reserved_wordsContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT4, 0)
}

func (s *Non_reserved_wordsContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT8, 0)
}

func (s *Non_reserved_wordsContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTEGER, 0)
}

func (s *Non_reserved_wordsContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERSECT, 0)
}

func (s *Non_reserved_wordsContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERVAL, 0)
}

func (s *Non_reserved_wordsContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Non_reserved_wordsContext) T_INVOKER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INVOKER, 0)
}

func (s *Non_reserved_wordsContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ITEMS, 0)
}

func (s *Non_reserved_wordsContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Non_reserved_wordsContext) T_ISOPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ISOPEN, 0)
}

func (s *Non_reserved_wordsContext) T_JOIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_JOIN, 0)
}

func (s *Non_reserved_wordsContext) T_KEEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEEP, 0)
}

func (s *Non_reserved_wordsContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Non_reserved_wordsContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEYS, 0)
}

func (s *Non_reserved_wordsContext) T_LAG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAG, 0)
}

func (s *Non_reserved_wordsContext) T_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LANGUAGE, 0)
}

func (s *Non_reserved_wordsContext) T_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAST_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_LEAD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAD, 0)
}

func (s *Non_reserved_wordsContext) T_LEAVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAVE, 0)
}

func (s *Non_reserved_wordsContext) T_LEFT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEFT, 0)
}

func (s *Non_reserved_wordsContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Non_reserved_wordsContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Non_reserved_wordsContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LINES, 0)
}

func (s *Non_reserved_wordsContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATION, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATOR, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATORS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATORS, 0)
}

func (s *Non_reserved_wordsContext) T_LOCKS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCKS, 0)
}

func (s *Non_reserved_wordsContext) T_LOG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOG, 0)
}

func (s *Non_reserved_wordsContext) T_LOGGED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGED, 0)
}

func (s *Non_reserved_wordsContext) T_LOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGING, 0)
}

func (s *Non_reserved_wordsContext) T_LOOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, 0)
}

func (s *Non_reserved_wordsContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Non_reserved_wordsContext) T_MATCHED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MATCHED, 0)
}

func (s *Non_reserved_wordsContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Non_reserved_wordsContext) T_MAXTRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAXTRANS, 0)
}

func (s *Non_reserved_wordsContext) T_MERGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MERGE, 0)
}

func (s *Non_reserved_wordsContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Non_reserved_wordsContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECOND, 0)
}

func (s *Non_reserved_wordsContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECONDS, 0)
}

func (s *Non_reserved_wordsContext) T_MIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN, 0)
}

func (s *Non_reserved_wordsContext) T_MULTISET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MULTISET, 0)
}

func (s *Non_reserved_wordsContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_NEW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NEW, 0)
}

func (s *Non_reserved_wordsContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NVARCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Non_reserved_wordsContext) T_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOMPRESS, 0)
}

func (s *Non_reserved_wordsContext) T_NOCOUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOUNT, 0)
}

func (s *Non_reserved_wordsContext) T_NOLOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOLOGGING, 0)
}

func (s *Non_reserved_wordsContext) T_NONE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NONE, 0)
}

func (s *Non_reserved_wordsContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Non_reserved_wordsContext) T_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTFOUND, 0)
}

func (s *Non_reserved_wordsContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMERIC, 0)
}

func (s *Non_reserved_wordsContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMBER, 0)
}

func (s *Non_reserved_wordsContext) T_OBJECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OBJECT, 0)
}

func (s *Non_reserved_wordsContext) T_OFF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OFF, 0)
}

func (s *Non_reserved_wordsContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Non_reserved_wordsContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Non_reserved_wordsContext) T_OPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN, 0)
}

func (s *Non_reserved_wordsContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Non_reserved_wordsContext) T_ORDER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ORDER, 0)
}

func (s *Non_reserved_wordsContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUT, 0)
}

func (s *Non_reserved_wordsContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUTER, 0)
}

func (s *Non_reserved_wordsContext) T_OVER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVER, 0)
}

func (s *Non_reserved_wordsContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Non_reserved_wordsContext) T_OWNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OWNER, 0)
}

func (s *Non_reserved_wordsContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Non_reserved_wordsContext) T_PART_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_PART_LOC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_LOC, 0)
}

func (s *Non_reserved_wordsContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PARTITION, 0)
}

func (s *Non_reserved_wordsContext) T_PCTFREE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTFREE, 0)
}

func (s *Non_reserved_wordsContext) T_PCTUSED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTUSED, 0)
}

func (s *Non_reserved_wordsContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRECISION, 0)
}

func (s *Non_reserved_wordsContext) T_PRESERVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRESERVE, 0)
}

func (s *Non_reserved_wordsContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Non_reserved_wordsContext) T_PRINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRINT, 0)
}

func (s *Non_reserved_wordsContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Non_reserved_wordsContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Non_reserved_wordsContext) T_PWD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PWD, 0)
}

func (s *Non_reserved_wordsContext) T_QUALIFY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUALIFY, 0)
}

func (s *Non_reserved_wordsContext) T_QUERY_BAND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUERY_BAND, 0)
}

func (s *Non_reserved_wordsContext) T_QUIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUIT, 0)
}

func (s *Non_reserved_wordsContext) T_QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUOTED_IDENTIFIER, 0)
}

func (s *Non_reserved_wordsContext) T_RAISE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RAISE, 0)
}

func (s *Non_reserved_wordsContext) T_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RANK, 0)
}

func (s *Non_reserved_wordsContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REAL, 0)
}

func (s *Non_reserved_wordsContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Non_reserved_wordsContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REGEXP, 0)
}

func (s *Non_reserved_wordsContext) T_RR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RR, 0)
}

func (s *Non_reserved_wordsContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Non_reserved_wordsContext) T_RESIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESIGNAL, 0)
}

func (s *Non_reserved_wordsContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Non_reserved_wordsContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Non_reserved_wordsContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT_SET_LOCATOR, 0)
}

func (s *Non_reserved_wordsContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Non_reserved_wordsContext) T_RETURNS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURNS, 0)
}

func (s *Non_reserved_wordsContext) T_REVERSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REVERSE, 0)
}

func (s *Non_reserved_wordsContext) T_RIGHT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RIGHT, 0)
}

func (s *Non_reserved_wordsContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RLIKE, 0)
}

func (s *Non_reserved_wordsContext) T_RS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RS, 0)
}

func (s *Non_reserved_wordsContext) T_ROLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLE, 0)
}

func (s *Non_reserved_wordsContext) T_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLLBACK, 0)
}

func (s *Non_reserved_wordsContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW, 0)
}

func (s *Non_reserved_wordsContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWS, 0)
}

func (s *Non_reserved_wordsContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_NUMBER, 0)
}

func (s *Non_reserved_wordsContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Non_reserved_wordsContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECOND, 0)
}

func (s *Non_reserved_wordsContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECONDS, 0)
}

func (s *Non_reserved_wordsContext) T_SECURITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECURITY, 0)
}

func (s *Non_reserved_wordsContext) T_SEGMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEGMENT, 0)
}

func (s *Non_reserved_wordsContext) T_SEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEL, 0)
}

func (s *Non_reserved_wordsContext) T_SELECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SELECT, 0)
}

func (s *Non_reserved_wordsContext) T_SESSION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSION, 0)
}

func (s *Non_reserved_wordsContext) T_SESSIONS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSIONS, 0)
}

func (s *Non_reserved_wordsContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Non_reserved_wordsContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SETS, 0)
}

func (s *Non_reserved_wordsContext) T_SHARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SHARE, 0)
}

func (s *Non_reserved_wordsContext) T_SIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIGNAL, 0)
}

func (s *Non_reserved_wordsContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLDATETIME, 0)
}

func (s *Non_reserved_wordsContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLINT, 0)
}

func (s *Non_reserved_wordsContext) T_SQL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQL, 0)
}

func (s *Non_reserved_wordsContext) T_SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLEXCEPTION, 0)
}

func (s *Non_reserved_wordsContext) T_SQLINSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLINSERT, 0)
}

func (s *Non_reserved_wordsContext) T_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLSTATE, 0)
}

func (s *Non_reserved_wordsContext) T_SQLWARNING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLWARNING, 0)
}

func (s *Non_reserved_wordsContext) T_STATS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATS, 0)
}

func (s *Non_reserved_wordsContext) T_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATISTICS, 0)
}

func (s *Non_reserved_wordsContext) T_STEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STEP, 0)
}

func (s *Non_reserved_wordsContext) T_STDEV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STDEV, 0)
}

func (s *Non_reserved_wordsContext) T_STORAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORAGE, 0)
}

func (s *Non_reserved_wordsContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORED, 0)
}

func (s *Non_reserved_wordsContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STRING, 0)
}

func (s *Non_reserved_wordsContext) T_SUBDIR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBDIR, 0)
}

func (s *Non_reserved_wordsContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBSTRING, 0)
}

func (s *Non_reserved_wordsContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Non_reserved_wordsContext) T_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUMMARY, 0)
}

func (s *Non_reserved_wordsContext) T_SYSDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYSDATE, 0)
}

func (s *Non_reserved_wordsContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYS_REFCURSOR, 0)
}

func (s *Non_reserved_wordsContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Non_reserved_wordsContext) T_TABLESPACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLESPACE, 0)
}

func (s *Non_reserved_wordsContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Non_reserved_wordsContext) T_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TERMINATED, 0)
}

func (s *Non_reserved_wordsContext) T_TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEXTIMAGE_ON, 0)
}

func (s *Non_reserved_wordsContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Non_reserved_wordsContext) T_TIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIME, 0)
}

func (s *Non_reserved_wordsContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Non_reserved_wordsContext) T_TITLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TITLE, 0)
}

func (s *Non_reserved_wordsContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Non_reserved_wordsContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Non_reserved_wordsContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Non_reserved_wordsContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRIM, 0)
}

func (s *Non_reserved_wordsContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUE, 0)
}

func (s *Non_reserved_wordsContext) T_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUNCATE, 0)
}

func (s *Non_reserved_wordsContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Non_reserved_wordsContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Non_reserved_wordsContext) T_UR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UR, 0)
}

func (s *Non_reserved_wordsContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Non_reserved_wordsContext) T_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USER, 0)
}

func (s *Non_reserved_wordsContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Non_reserved_wordsContext) T_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Non_reserved_wordsContext) T_VAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VAR, 0)
}

func (s *Non_reserved_wordsContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR2, 0)
}

func (s *Non_reserved_wordsContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARYING, 0)
}

func (s *Non_reserved_wordsContext) T_VARIANCE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARIANCE, 0)
}

func (s *Non_reserved_wordsContext) T_VOLATILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VOLATILE, 0)
}

func (s *Non_reserved_wordsContext) T_WHILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHILE, 0)
}

func (s *Non_reserved_wordsContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Non_reserved_wordsContext) T_WITHOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITHOUT, 0)
}

func (s *Non_reserved_wordsContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Non_reserved_wordsContext) T_XACT_ABORT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XACT_ABORT, 0)
}

func (s *Non_reserved_wordsContext) T_XML() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XML, 0)
}

func (s *Non_reserved_wordsContext) T_YES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_YES, 0)
}

func (s *Non_reserved_wordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_reserved_wordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_reserved_wordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNon_reserved_words(s)
	}
}

func (s *Non_reserved_wordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNon_reserved_words(s)
	}
}

func (p *HplsqlParser) Non_reserved_words() (localctx INon_reserved_wordsContext) {
	localctx = NewNon_reserved_wordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, HplsqlParserRULE_non_reserved_words)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3447)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-33554464) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-24696061953) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-36028797018963969) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-9007199271518737) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-864744042452222977) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&267403263) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *HplsqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 4:
		var t *Block_endContext = nil
		if localctx != nil {
			t = localctx.(*Block_endContext)
		}
		return p.Block_end_Sempred(t, predIndex)

	case 11:
		var t *Expr_stmtContext = nil
		if localctx != nil {
			t = localctx.(*Expr_stmtContext)
		}
		return p.Expr_stmt_Sempred(t, predIndex)

	case 78:
		var t *Create_routine_paramsContext = nil
		if localctx != nil {
			t = localctx.(*Create_routine_paramsContext)
		}
		return p.Create_routine_params_Sempred(t, predIndex)

	case 158:
		var t *Select_list_aliasContext = nil
		if localctx != nil {
			t = localctx.(*Select_list_aliasContext)
		}
		return p.Select_list_alias_Sempred(t, predIndex)

	case 171:
		var t *From_alias_clauseContext = nil
		if localctx != nil {
			t = localctx.(*From_alias_clauseContext)
		}
		return p.From_alias_clause_Sempred(t, predIndex)

	case 189:
		var t *Delete_aliasContext = nil
		if localctx != nil {
			t = localctx.(*Delete_aliasContext)
		}
		return p.Delete_alias_Sempred(t, predIndex)

	case 191:
		var t *Bool_exprContext = nil
		if localctx != nil {
			t = localctx.(*Bool_exprContext)
		}
		return p.Bool_expr_Sempred(t, predIndex)

	case 199:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 219:
		var t *Func_paramContext = nil
		if localctx != nil {
			t = localctx.(*Func_paramContext)
		}
		return p.Func_param_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *HplsqlParser) Block_end_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return !strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "TRANSACTION")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Expr_stmt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GO")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Create_routine_params_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "IS") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "AS") &&
			!(strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "DYNAMIC") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "RESULT"))

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Select_list_alias_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "FROM")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) From_alias_clause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXEC") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXECUTE") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INNER") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LEFT") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GROUP") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ORDER") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LIMIT") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "WITH")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Delete_alias_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ALL")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Bool_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 14)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Func_param_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
