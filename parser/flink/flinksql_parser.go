// Code generated from FlinkSqlParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // FlinkSqlParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type FlinkSqlParser struct {
	*antlr.BaseParser
}

var FlinkSqlParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func flinksqlparserParserInit() {
	staticData := &FlinkSqlParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "'ABS'", "'ALL'", "'ALLOCATE'", "'ALLOW'", "'ALTER'",
		"'ANALYZE'", "'AND'", "'ANY'", "'ARE'", "'ARRAY'", "'ARRAY_AGG'", "'ARRAY_CONCAT_AGG'",
		"'ARRAY_MAX_CARDINALITY'", "'AS'", "'ASENSITIVE'", "'ASYMMETRIC'", "'AT'",
		"'ATOMIC'", "'AUTHORIZATION'", "'AVG'", "'BEGIN'", "'BEGIN_FRAME'",
		"'BEGIN_PARTITION'", "'BETWEEN'", "'BIGINT'", "'BINARY'", "'BIT'", "'BLOB'",
		"'BOOLEAN'", "'BOTH'", "'BY'", "'BYTES'", "'CALL'", "'CALLED'", "'CARDINALITY'",
		"'CASCADED'", "'CASE'", "'CAST'", "'CATALOGS'", "'CEIL'", "'CEILING'",
		"'CHANGELOG_MODE'", "'CHAR'", "'CHARACTER'", "'CHARACTER_LENGTH'", "'CHAR_LENGTH'",
		"'CHECK'", "'CLASSIFIER'", "'CLOB'", "'CLOSE'", "'COALESCE'", "'COLLATE'",
		"'COLLECT'", "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMPUTE'",
		"'CONDITION'", "'CONNECT'", "'CONSTRAINT'", "'CONTAINS'", "'CONVERT'",
		"'CORR'", "'CORRESPONDING'", "'COUNT'", "'COVAR_POP'", "'COVAR_SAMP'",
		"'CREATE'", "'CROSS'", "'CUBE'", "'CUME_DIST'", "'CURRENT'", "'CURRENT_CATALOG'",
		"'CURRENT_DATE'", "'CURRENT_DEFAULT_TRANSFORM_GROUP'", "'CURRENT_PATH'",
		"'CURRENT_ROLE'", "'CURRENT_ROW'", "'CURRENT_SCHEMA'", "'CURRENT_TIME'",
		"'CURRENT_TIMESTAMP'", "'CURRENT_TRANSFORM_GROUP_FOR_TYPE'", "'CURRENT_USER'",
		"'CURSOR'", "'CYCLE'", "'DATABASES'", "'DATE'", "'DATETIME'", "'DATETIME_DIFF'",
		"'DATETIME_TRUNC'", "'DATE_DIFF'", "'DATE_TRUNC'", "'DAY'", "'DAYOFWEEK'",
		"'DAYOFYEAR'", "'DEALLOCATE'", "'DEC'", "'DECIMAL'", "'DECLARE'", "'DEFAULT'",
		"'DEFINE'", "'DELETE'", "'DENSE_RANK'", "'DEREF'", "'DESCRIBE'", "'DETERMINISTIC'",
		"'DISALLOW'", "'DISCONNECT'", "'DISTINCT'", "'DOT'", "'DOUBLE'", "'DROP'",
		"'DYNAMIC'", "'EACH'", "'ELEMENT'", "'ELSE'", "'EMPTY'", "'END'", "'END_FRAME'",
		"'END_PARTITION'", "'ENFORCED'", "'EQUALS'", "'ESCAPE'", "'ESTIMATED_COST'",
		"'EVERY'", "'EXCEPT'", "'EXEC'", "'EXECUTE'", "'EXISTS'", "'EXP'", "'EXPLAIN'",
		"'EXTEND'", "'EXTENDED'", "'EXTERNAL'", "'EXTRACT'", "'FALSE'", "'FETCH'",
		"'FILTER'", "'FIRST_VALUE'", "'FLOAT'", "'FLOOR'", "'FOR'", "'FOREIGN'",
		"'FRAME_ROW'", "'FREE'", "'FRIDAY'", "'FROM'", "'FULL'", "'FUNCTION'",
		"'FUNCTIONS'", "'FUSION'", "'GET'", "'GLOBAL'", "'GRANT'", "'GROUP'",
		"'GROUPING'", "'GROUPS'", "'GROUP_CONCAT'", "'HAVING'", "'HOLD'", "'HOUR'",
		"'IDENTITY'", "'IF'", "'ILIKE'", "'IMPORT'", "'IN'", "'INCLUDE'", "'INDICATOR'",
		"'INITIAL'", "'INNER'", "'INOUT'", "'INSENSITIVE'", "'INSERT'", "'INT'",
		"'INTEGER'", "'INTERSECT'", "'INTERSECTION'", "'INTERVAL'", "'INTO'",
		"'IS'", "'JOIN'", "'JSON'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_EXECUTION_PLAN'",
		"'JSON_EXISTS'", "'JSON_OBJECT'", "'JSON_OBJECTAGG'", "'JSON_QUERY'",
		"'JSON_VALUE'", "'LAG'", "'LANGUAGE'", "'LARGE'", "'LAST_VALUE'", "'LATERAL'",
		"'LEAD'", "'LEADING'", "'LEFT'", "'LIKE'", "'LIKE_REGEX'", "'LIMIT'",
		"'LN'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'", "'LOWER'", "'MATCH'",
		"'MATCHES'", "'MATCH_NUMBER'", "'MATCH_RECOGNIZE'", "'MAX'", "'MEASURES'",
		"'MEMBER'", "'MERGE'", "'METADATA'", "'METHOD'", "'MIN'", "'MINUS'",
		"'MINUTE'", "'MOD'", "'MODIFIES'", "'MODIFY'", "'MODULE'", "'MODULES'",
		"'MONDAY'", "'MONTH'", "'MORE'", "'MULTISET'", "'NATIONAL'", "'NATURAL'",
		"'NCHAR'", "'NCLOB'", "'NEW'", "'NEXT'", "'NO'", "'NONE'", "'NORMALIZE'",
		"'NOT'", "'NTH_VALUE'", "'NTILE'", "'NULL'", "'NULLIF'", "'NUMERIC'",
		"'OCCURRENCES_REGEX'", "'OCTET_LENGTH'", "'OF'", "'OFFSET'", "'OLD'",
		"'OMIT'", "'ON'", "'ONE'", "'ONLY'", "'OPEN'", "'OR'", "'ORDER'", "'ORDINAL'",
		"'OUT'", "'OUTER'", "'OVER'", "'OVERLAPS'", "'OVERLAY'", "'OVERWRITE'",
		"'OVERWRITING'", "'PARAMETER'", "'PARTITION'", "'PARTITIONED'", "'PARTITIONS'",
		"'PATTERN'", "'PER'", "'PERCENT'", "'PERCENTILE_CONT'", "'PERCENTILE_DISC'",
		"'PERCENT_RANK'", "'PERIOD'", "'PERMUTE'", "'PLAN_ADVICE'", "'PIVOT'",
		"'PORTION'", "'POSITION'", "'POSITION_REGEX'", "'POWER'", "'PRECEDES'",
		"'PRECISION'", "'PREPARE'", "'PREV'", "'PRIMARY'", "'PROCEDURE'", "'QUALIFY'",
		"'QUARTERS'", "'RANGE'", "'RANK'", "'RAW'", "'READS'", "'REAL'", "'RECURSIVE'",
		"'REF'", "'REFERENCES'", "'REFERENCING'", "'REGR_AVGX'", "'REGR_AVGY'",
		"'REGR_COUNT'", "'REGR_INTERCEPT'", "'REGR_R2'", "'REGR_SLOPE'", "'REGR_SXX'",
		"'REGR_SXY'", "'REGR_SYY'", "'RELEASE'", "'RENAME'", "'RESET'", "'RESULT'",
		"'RETURN'", "'RETURNS'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'ROLLBACK'",
		"'ROLLUP'", "'ROW'", "'ROWS'", "'ROW_NUMBER'", "'RUNNING'", "'SAFE_CAST'",
		"'SAFE_OFFSET'", "'SAFE_ORDINAL'", "'SATURDAY'", "'SAVEPOINT'", "'SCALA'",
		"'SCOPE'", "'SCROLL'", "'SEARCH'", "'SECOND'", "'SEEK'", "'SELECT'",
		"'SENSITIVE'", "'SEPARATOR'", "'SESSION_USER'", "'SET'", "'SHOW'", "'SIMILAR'",
		"'SKIP'", "'SMALLINT'", "'SOME'", "'SPECIFIC'", "'SPECIFICTYPE'", "'SQL'",
		"'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQRT'", "'START'",
		"'STATEMENT'", "'STATIC'", "'STATISTICS'", "'STDDEV_POP'", "'STDDEV_SAMP'",
		"'STREAM'", "'STRING'", "'STRING_AGG'", "'SUBMULTISET'", "'SUBSET'",
		"'SUBSTRING'", "'SUBSTRING_REGEX'", "'SUCCEEDS'", "'SUM'", "'SUNDAY'",
		"'SYMMETRIC'", "'SYSTEM'", "'SYSTEM_TIME'", "'SYSTEM_USER'", "'TABLE'",
		"'TABLES'", "'TABLESAMPLE'", "'THEN'", "'THURSDAY'", "'TIME'", "'TIMESTAMP'",
		"'TIMESTAMP_DIFF'", "'TIMESTAMP_LTZ'", "'TIMESTAMP_TRUNC'", "'TIMEZONE_HOUR'",
		"'TIMEZONE_MINUTE'", "'TIME_DIFF'", "'TIME_TRUNC'", "'TINYINT'", "'TO'",
		"'TRAILING'", "'TRANSLATE'", "'TRANSLATE_REGEX'", "'TRANSLATION'", "'TREAT'",
		"'TRIGGER'", "'TRIM'", "'TRIM_ARRAY'", "'TRUE'", "'TRUNCATE'", "'TRY_CAST'",
		"'TUESDAY'", "'UESCAPE'", "'UNION'", "'UNIQUE'", "'UNKNOWN'", "'UNNEST'",
		"'UNPIVOT'", "'UPDATE'", "'UPPER'", "'UPSERT'", "'USE'", "'USER'", "'USING'",
		"'VALUE'", "'VALUES'", "'VALUE_OF'", "'VARBINARY'", "'VARCHAR'", "'VARYING'",
		"'VAR_POP'", "'VAR_SAMP'", "'VERSIONING'", "'VIEWS'", "'VIRTUAL'", "'WATERMARK'",
		"'WATERMARKS'", "'WEDNESDAY'", "'WEEKS'", "'WHEN'", "'WHENEVER'", "'WHERE'",
		"'WIDTH_BUCKET'", "'WINDOW'", "'WITH'", "'WITHIN'", "'WITHOUT'", "'YEAR'",
		"'ADD'", "'AFTER'", "'ASC'", "'CASCADE'", "'CATALOG'", "'CENTURY'",
		"'CONFIG'", "'CONSTRAINTS'", "'CUMULATE'", "'DATA'", "'DATABASE'", "'DAYS'",
		"'DECADE'", "'DESC'", "'DESCRIPTOR'", "'DIV'", "'ENGINE'", "'EPOCH'",
		"'EXCLUDING'", "'FILE'", "'FIRST'", "'GENERATED'", "'HOP'", "'HOURS'",
		"'IGNORE'", "'INCLUDING'", "'JAR'", "'JARS'", "'JAVA'", "'KEY'", "'LAST'",
		"'LOAD'", "'MAP'", "'MICROSECOND'", "'MILLENNIUM'", "'MILLISECOND'",
		"'MINUTES'", "'MONTHS'", "'NANOSECOND'", "'NULLS'", "'OPTIONS'", "'PAST'",
		"'PLAN'", "'PRECEDING'", "'PYTHON'", "'PYTHON_ARCHIVES'", "'PYTHON_DEPENDENCIES'",
		"'PYTHON_FILES'", "'PYTHON_JAR'", "'PYTHON_PARAMETER'", "'PYTHON_REQUIREMENTS'",
		"'QUARTER'", "'REMOVE'", "'RESTRICT'", "'SECONDS'", "'SESSION'", "'SETS'",
		"'SIZE'", "'SLIDE'", "'STEP'", "'TEMPORARY'", "'TIMECOL'", "'TUMBLE'",
		"'UNLOAD'", "'VIEW'", "'WEEK'", "'YEARS'", "'ZONE'", "'='", "'>'", "'<'",
		"'!'", "'~'", "'|'", "'&'", "'^'", "'.'", "'['", "']'", "'('", "')'",
		"'{'", "'}'", "','", "';'", "'@'", "'''", "'\"'", "'`'", "':'", "'*'",
		"'_'", "'-'", "'+'", "'%'", "'||'", "'--'", "'/'", "'?'", "'=>'",
	}
	staticData.SymbolicNames = []string{
		"", "WHITE_SPACE", "BRACKETED_COMMENT", "LINE_COMMENT", "KW_ABS", "KW_ALL",
		"KW_ALLOCATE", "KW_ALLOW", "KW_ALTER", "KW_ANALYZE", "KW_AND", "KW_ANY",
		"KW_ARE", "KW_ARRAY", "KW_ARRAY_AGG", "KW_ARRAY_CONCAT_AGG", "KW_ARRAY_MAX_CARDINALITY",
		"KW_AS", "KW_ASENSITIVE", "KW_ASYMMETRIC", "KW_AT", "KW_ATOMIC", "KW_AUTHORIZATION",
		"KW_AVG", "KW_BEGIN", "KW_BEGIN_FRAME", "KW_BEGIN_PARTITION", "KW_BETWEEN",
		"KW_BIGINT", "KW_BINARY", "KW_BIT", "KW_BLOB", "KW_BOOLEAN", "KW_BOTH",
		"KW_BY", "KW_BYTES", "KW_CALL", "KW_CALLED", "KW_CARDINALITY", "KW_CASCADED",
		"KW_CASE", "KW_CAST", "KW_CATALOGS", "KW_CEIL", "KW_CEILING", "KW_CHANGELOG_MODE",
		"KW_CHAR", "KW_CHARACTER", "KW_CHARACTER_LENGTH", "KW_CHAR_LENGTH",
		"KW_CHECK", "KW_CLASSIFIER", "KW_CLOB", "KW_CLOSE", "KW_COALESCE", "KW_COLLATE",
		"KW_COLLECT", "KW_COLUMN", "KW_COLUMNS", "KW_COMMENT", "KW_COMMIT",
		"KW_COMPUTE", "KW_CONDITION", "KW_CONNECT", "KW_CONSTRAINT", "KW_CONTAINS",
		"KW_CONVERT", "KW_CORR", "KW_CORRESPONDING", "KW_COUNT", "KW_COVAR_POP",
		"KW_COVAR_SAMP", "KW_CREATE", "KW_CROSS", "KW_CUBE", "KW_CUME_DIST",
		"KW_CURRENT", "KW_CURRENT_CATALOG", "KW_CURRENT_DATE", "KW_CURRENT_DEFAULT_TRANSFORM_GROUP",
		"KW_CURRENT_PATH", "KW_CURRENT_ROLE", "KW_CURRENT_ROW", "KW_CURRENT_SCHEMA",
		"KW_CURRENT_TIME", "KW_CURRENT_TIMESTAMP", "KW_CURRENT_TRANSFORM_GROUP_FOR_TYPE",
		"KW_CURRENT_USER", "KW_CURSOR", "KW_CYCLE", "KW_DATABASES", "KW_DATE",
		"KW_DATETIME", "KW_DATETIME_DIFF", "KW_DATETIME_TRUNC", "KW_DATE_DIFF",
		"KW_DATE_TRUNC", "KW_DAY", "KW_DAYOFWEEK", "KW_DAYOFYEAR", "KW_DEALLOCATE",
		"KW_DEC", "KW_DECIMAL", "KW_DECLARE", "KW_DEFAULT", "KW_DEFINE", "KW_DELETE",
		"KW_DENSE_RANK", "KW_DEREF", "KW_DESCRIBE", "KW_DETERMINISTIC", "KW_DISALLOW",
		"KW_DISCONNECT", "KW_DISTINCT", "KW_DOT", "KW_DOUBLE", "KW_DROP", "KW_DYNAMIC",
		"KW_EACH", "KW_ELEMENT", "KW_ELSE", "KW_EMPTY", "KW_END", "KW_END_FRAME",
		"KW_END_PARTITION", "KW_ENFORCED", "KW_EQUALS", "KW_ESCAPE", "KW_ESTIMATED_COST",
		"KW_EVERY", "KW_EXCEPT", "KW_EXEC", "KW_EXECUTE", "KW_EXISTS", "KW_EXP",
		"KW_EXPLAIN", "KW_EXTEND", "KW_EXTENDED", "KW_EXTERNAL", "KW_EXTRACT",
		"KW_FALSE", "KW_FETCH", "KW_FILTER", "KW_FIRST_VALUE", "KW_FLOAT", "KW_FLOOR",
		"KW_FOR", "KW_FOREIGN", "KW_FRAME_ROW", "KW_FREE", "KW_FRIDAY", "KW_FROM",
		"KW_FULL", "KW_FUNCTION", "KW_FUNCTIONS", "KW_FUSION", "KW_GET", "KW_GLOBAL",
		"KW_GRANT", "KW_GROUP", "KW_GROUPING", "KW_GROUPS", "KW_GROUP_CONCAT",
		"KW_HAVING", "KW_HOLD", "KW_HOUR", "KW_IDENTITY", "KW_IF", "KW_ILIKE",
		"KW_IMPORT", "KW_IN", "KW_INCLUDE", "KW_INDICATOR", "KW_INITIAL", "KW_INNER",
		"KW_INOUT", "KW_INSENSITIVE", "KW_INSERT", "KW_INT", "KW_INTEGER", "KW_INTERSECT",
		"KW_INTERSECTION", "KW_INTERVAL", "KW_INTO", "KW_IS", "KW_JOIN", "KW_JSON",
		"KW_JSON_ARRAY", "KW_JSON_ARRAYAGG", "KW_JSON_EXECUTION_PLAN", "KW_JSON_EXISTS",
		"KW_JSON_OBJECT", "KW_JSON_OBJECTAGG", "KW_JSON_QUERY", "KW_JSON_VALUE",
		"KW_LAG", "KW_LANGUAGE", "KW_LARGE", "KW_LAST_VALUE", "KW_LATERAL",
		"KW_LEAD", "KW_LEADING", "KW_LEFT", "KW_LIKE", "KW_LIKE_REGEX", "KW_LIMIT",
		"KW_LN", "KW_LOCAL", "KW_LOCALTIME", "KW_LOCALTIMESTAMP", "KW_LOWER",
		"KW_MATCH", "KW_MATCHES", "KW_MATCH_NUMBER", "KW_MATCH_RECOGNIZE", "KW_MAX",
		"KW_MEASURES", "KW_MEMBER", "KW_MERGE", "KW_METADATA", "KW_METHOD",
		"KW_MIN", "KW_MINUS", "KW_MINUTE", "KW_MOD", "KW_MODIFIES", "KW_MODIFY",
		"KW_MODULE", "KW_MODULES", "KW_MONDAY", "KW_MONTH", "KW_MORE", "KW_MULTISET",
		"KW_NATIONAL", "KW_NATURAL", "KW_NCHAR", "KW_NCLOB", "KW_NEW", "KW_NEXT",
		"KW_NO", "KW_NONE", "KW_NORMALIZE", "KW_NOT", "KW_NTH_VALUE", "KW_NTILE",
		"KW_NULL", "KW_NULLIF", "KW_NUMERIC", "KW_OCCURRENCES_REGEX", "KW_OCTET_LENGTH",
		"KW_OF", "KW_OFFSET", "KW_OLD", "KW_OMIT", "KW_ON", "KW_ONE", "KW_ONLY",
		"KW_OPEN", "KW_OR", "KW_ORDER", "KW_ORDINAL", "KW_OUT", "KW_OUTER",
		"KW_OVER", "KW_OVERLAPS", "KW_OVERLAY", "KW_OVERWRITE", "KW_OVERWRITING",
		"KW_PARAMETER", "KW_PARTITION", "KW_PARTITIONED", "KW_PARTITIONS", "KW_PATTERN",
		"KW_PER", "KW_PERCENT", "KW_PERCENTILE_CONT", "KW_PERCENTILE_DISC",
		"KW_PERCENT_RANK", "KW_PERIOD", "KW_PERMUTE", "KW_PLAN_ADVICE", "KW_PIVOT",
		"KW_PORTION", "KW_POSITION", "KW_POSITION_REGEX", "KW_POWER", "KW_PRECEDES",
		"KW_PRECISION", "KW_PREPARE", "KW_PREV", "KW_PRIMARY", "KW_PROCEDURE",
		"KW_QUALIFY", "KW_QUARTERS", "KW_RANGE", "KW_RANK", "KW_RAW", "KW_READS",
		"KW_REAL", "KW_RECURSIVE", "KW_REF", "KW_REFERENCES", "KW_REFERENCING",
		"KW_REGR_AVGX", "KW_REGR_AVGY", "KW_REGR_COUNT", "KW_REGR_INTERCEPT",
		"KW_REGR_R2", "KW_REGR_SLOPE", "KW_REGR_SXX", "KW_REGR_SXY", "KW_REGR_SYY",
		"KW_RELEASE", "KW_RENAME", "KW_RESET", "KW_RESULT", "KW_RETURN", "KW_RETURNS",
		"KW_REVOKE", "KW_RIGHT", "KW_RLIKE", "KW_ROLLBACK", "KW_ROLLUP", "KW_ROW",
		"KW_ROWS", "KW_ROW_NUMBER", "KW_RUNNING", "KW_SAFE_CAST", "KW_SAFE_OFFSET",
		"KW_SAFE_ORDINAL", "KW_SATURDAY", "KW_SAVEPOINT", "KW_SCALA", "KW_SCOPE",
		"KW_SCROLL", "KW_SEARCH", "KW_SECOND", "KW_SEEK", "KW_SELECT", "KW_SENSITIVE",
		"KW_SEPARATOR", "KW_SESSION_USER", "KW_SET", "KW_SHOW", "KW_SIMILAR",
		"KW_SKIP", "KW_SMALLINT", "KW_SOME", "KW_SPECIFIC", "KW_SPECIFICTYPE",
		"KW_SQL", "KW_SQLEXCEPTION", "KW_SQLSTATE", "KW_SQLWARNING", "KW_SQRT",
		"KW_START", "KW_STATEMENT", "KW_STATIC", "KW_STATISTICS", "KW_STDDEV_POP",
		"KW_STDDEV_SAMP", "KW_STREAM", "KW_STRING", "KW_STRING_AGG", "KW_SUBMULTISET",
		"KW_SUBSET", "KW_SUBSTRING", "KW_SUBSTRING_REGEX", "KW_SUCCEEDS", "KW_SUM",
		"KW_SUNDAY", "KW_SYMMETRIC", "KW_SYSTEM", "KW_SYSTEM_TIME", "KW_SYSTEM_USER",
		"KW_TABLE", "KW_TABLES", "KW_TABLESAMPLE", "KW_THEN", "KW_THURSDAY",
		"KW_TIME", "KW_TIMESTAMP", "KW_TIMESTAMP_DIFF", "KW_TIMESTAMP_LTZ",
		"KW_TIMESTAMP_TRUNC", "KW_TIMEZONE_HOUR", "KW_TIMEZONE_MINUTE", "KW_TIME_DIFF",
		"KW_TIME_TRUNC", "KW_TINYINT", "KW_TO", "KW_TRAILING", "KW_TRANSLATE",
		"KW_TRANSLATE_REGEX", "KW_TRANSLATION", "KW_TREAT", "KW_TRIGGER", "KW_TRIM",
		"KW_TRIM_ARRAY", "KW_TRUE", "KW_TRUNCATE", "KW_TRY_CAST", "KW_TUESDAY",
		"KW_UESCAPE", "KW_UNION", "KW_UNIQUE", "KW_UNKNOWN", "KW_UNNEST", "KW_UNPIVOT",
		"KW_UPDATE", "KW_UPPER", "KW_UPSERT", "KW_USE", "KW_USER", "KW_USING",
		"KW_VALUE", "KW_VALUES", "KW_VALUE_OF", "KW_VARBINARY", "KW_VARCHAR",
		"KW_VARYING", "KW_VAR_POP", "KW_VAR_SAMP", "KW_VERSIONING", "KW_VIEWS",
		"KW_VIRTUAL", "KW_WATERMARK", "KW_WATERMARKS", "KW_WEDNESDAY", "KW_WEEKS",
		"KW_WHEN", "KW_WHENEVER", "KW_WHERE", "KW_WIDTH_BUCKET", "KW_WINDOW",
		"KW_WITH", "KW_WITHIN", "KW_WITHOUT", "KW_YEAR", "KW_ADD", "KW_AFTER",
		"KW_ASC", "KW_CASCADE", "KW_CATALOG", "KW_CENTURY", "KW_CONFIG", "KW_CONSTRAINTS",
		"KW_CUMULATE", "KW_DATA", "KW_DATABASE", "KW_DAYS", "KW_DECADE", "KW_DESC",
		"KW_DESCRIPTOR", "KW_DIV", "KW_ENGINE", "KW_EPOCH", "KW_EXCLUDING",
		"KW_FILE", "KW_FIRST", "KW_GENERATED", "KW_HOP", "KW_HOURS", "KW_IGNORE",
		"KW_INCLUDING", "KW_JAR", "KW_JARS", "KW_JAVA", "KW_KEY", "KW_LAST",
		"KW_LOAD", "KW_MAP", "KW_MICROSECOND", "KW_MILLENNIUM", "KW_MILLISECOND",
		"KW_MINUTES", "KW_MONTHS", "KW_NANOSECOND", "KW_NULLS", "KW_OPTIONS",
		"KW_PAST", "KW_PLAN", "KW_PRECEDING", "KW_PYTHON", "KW_PYTHON_ARCHIVES",
		"KW_PYTHON_DEPENDENCIES", "KW_PYTHON_FILES", "KW_PYTHON_JAR", "KW_PYTHON_PARAMETER",
		"KW_PYTHON_REQUIREMENTS", "KW_QUARTER", "KW_REMOVE", "KW_RESTRICT",
		"KW_SECONDS", "KW_SESSION", "KW_SETS", "KW_SIZE", "KW_SLIDE", "KW_STEP",
		"KW_TEMPORARY", "KW_TIMECOL", "KW_TUMBLE", "KW_UNLOAD", "KW_VIEW", "KW_WEEK",
		"KW_YEARS", "KW_ZONE", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL",
		"EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP",
		"DOT", "LS_BRACKET", "RS_BRACKET", "LR_BRACKET", "RR_BRACKET", "LB_BRACKET",
		"RB_BRACKET", "COMMA", "SEMICOLON", "AT_SIGN", "SINGLE_QUOTE_SYMB",
		"DOUBLE_QUOTE_SYMB", "REVERSE_QUOTE_SYMB", "COLON_SYMB", "ASTERISK_SIGN",
		"UNDERLINE_SIGN", "HYPHEN_SIGN", "ADD_SIGN", "PERCENT_SIGN", "DOUBLE_VERTICAL_SIGN",
		"DOUBLE_HYPHEN_SIGN", "SLASH_SIGN", "QUESTION_MARK_SIGN", "DOUBLE_RIGHT_ARROW",
		"STRING_LITERAL", "DIG_LITERAL", "REAL_LITERAL", "BIT_STRING", "ID_LITERAL",
	}
	staticData.RuleNames = []string{
		"sqlStatements", "singleStatement", "sqlStatement", "emptyStatement",
		"ddlStatement", "dmlStatement", "describeStatement", "explainStatement",
		"explainDetails", "explainDetail", "useStatement", "useModuleStatement",
		"showStatement", "loadStatement", "unloadStatement", "setStatement",
		"resetStatement", "jarStatement", "dtAddStatement", "dtFilePath", "createTable",
		"simpleCreateTable", "createTableAsSelect", "columnOptionDefinition",
		"physicalColumnDefinition", "columnNameCreate", "columnName", "columnNamePath",
		"columnNameList", "columnType", "lengthOneDimension", "lengthTwoOptionalDimension",
		"lengthTwoStringDimension", "lengthOneTypeDimension", "mapTypeDimension",
		"rowTypeDimension", "columnConstraint", "metadataColumnDefinition",
		"metadataKey", "computedColumnDefinition", "computedColumnExpression",
		"watermarkDefinition", "tableConstraint", "constraintName", "selfDefinitionClause",
		"partitionDefinition", "transformList", "transform", "transformArgument",
		"likeDefinition", "likeOption", "createCatalog", "createDatabase", "createView",
		"createFunction", "usingClause", "jarFileName", "alterTable", "renameDefinition",
		"setKeyValueDefinition", "addConstraint", "dropConstraint", "addUnique",
		"notForced", "alterView", "alterDatabase", "alterFunction", "dropCatalog",
		"dropTable", "dropDatabase", "dropView", "dropFunction", "insertStatement",
		"insertSimpleStatement", "insertPartitionDefinition", "valuesDefinition",
		"valuesRowDefinition", "insertMulStatementCompatibility", "insertMulStatement",
		"queryStatement", "valuesClause", "withClause", "withItem", "withItemName",
		"selectStatement", "selectClause", "projectItemDefinition", "overWindowItem",
		"fromClause", "tableExpression", "tableReference", "tablePrimary", "systemTimePeriod",
		"dateTimeExpression", "inlineDataValueClause", "windowTVFClause", "windowTVFExpression",
		"windowTVFName", "windowTVFParam", "timeIntervalParamName", "columnDescriptor",
		"joinCondition", "whereClause", "groupByClause", "groupItemDefinition",
		"groupingSets", "groupingSetsNotationName", "groupWindowFunction", "groupWindowFunctionName",
		"timeAttrColumn", "havingClause", "windowClause", "namedWindow", "windowSpec",
		"matchRecognizeClause", "orderByClause", "orderItemDefinition", "limitClause",
		"partitionByClause", "quantifiers", "measuresClause", "patternDefinition",
		"patternVariable", "outputMode", "afterMatchStrategy", "patternVariablesDefinition",
		"windowFrame", "frameBound", "withinClause", "expression", "booleanExpression",
		"predicate", "likePredicate", "valueExpression", "functionCallExpression",
		"primaryExpression", "functionNameCreate", "functionName", "functionNameAndParams",
		"functionNameWithParams", "functionParam", "dereferenceDefinition",
		"correlationName", "qualifiedName", "timeIntervalExpression", "errorCapturingMultiUnitsInterval",
		"multiUnitsInterval", "errorCapturingUnitToUnitInterval", "unitToUnitInterval",
		"intervalValue", "tableAlias", "errorCapturingIdentifier", "errorCapturingIdentifierExtra",
		"identifierList", "identifierSeq", "identifier", "unquotedIdentifier",
		"quotedIdentifier", "whenClause", "catalogPath", "catalogPathCreate",
		"databasePath", "databasePathCreate", "tablePathCreate", "tablePath",
		"viewPath", "viewPathCreate", "uid", "withOption", "ifNotExists", "ifExists",
		"tablePropertyList", "tableProperty", "tablePropertyKey", "tablePropertyValue",
		"logicalOperator", "comparisonOperator", "bitOperator", "mathOperator",
		"unaryOperator", "constant", "timePointLiteral", "stringLiteral", "decimalLiteral",
		"booleanLiteral", "setQuantifier", "timePointUnit", "timeIntervalUnit",
		"reservedKeywordsUsedAsFuncParam", "reservedKeywordsNoParamsUsedAsFuncName",
		"reservedKeywordsFollowParamsUsedAsFuncName", "reservedKeywordsUsedAsFuncName",
		"nonReservedKeywords",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 543, 2311, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 1, 0, 5, 0, 388, 8,
		0, 10, 0, 12, 0, 391, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 397, 8, 1, 1,
		1, 3, 1, 400, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 3, 2, 414, 8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 432,
		8, 4, 1, 5, 1, 5, 3, 5, 436, 8, 5, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7,
		1, 7, 3, 7, 445, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 450, 8, 7, 1, 8, 1, 8, 1,
		8, 5, 8, 455, 8, 8, 10, 8, 12, 8, 458, 9, 8, 1, 9, 1, 9, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 468, 8, 10, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 5, 11, 475, 8, 11, 10, 11, 12, 11, 478, 9, 11, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 489, 8, 12, 1,
		12, 3, 12, 492, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 499, 8,
		12, 1, 12, 3, 12, 502, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		3, 12, 510, 8, 12, 1, 12, 1, 12, 3, 12, 514, 8, 12, 1, 12, 1, 12, 1, 12,
		3, 12, 519, 8, 12, 1, 12, 3, 12, 522, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 3, 13, 529, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 3,
		15, 537, 8, 15, 1, 16, 1, 16, 3, 16, 541, 8, 16, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 553, 8, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 561, 8, 18, 1, 18, 1, 18, 3,
		18, 565, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 3, 18, 597, 8, 18, 1, 19, 3, 19, 600, 8, 19, 1, 19, 4, 19, 603,
		8, 19, 11, 19, 12, 19, 604, 1, 20, 1, 20, 3, 20, 609, 8, 20, 1, 21, 1,
		21, 3, 21, 613, 8, 21, 1, 21, 1, 21, 3, 21, 617, 8, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 5, 21, 624, 8, 21, 10, 21, 12, 21, 627, 9, 21, 1, 21,
		1, 21, 3, 21, 631, 8, 21, 1, 21, 1, 21, 3, 21, 635, 8, 21, 1, 21, 1, 21,
		3, 21, 639, 8, 21, 1, 21, 1, 21, 1, 21, 3, 21, 644, 8, 21, 1, 21, 3, 21,
		647, 8, 21, 1, 21, 1, 21, 3, 21, 651, 8, 21, 1, 22, 1, 22, 1, 22, 3, 22,
		656, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 662, 8, 22, 1, 23, 1, 23,
		1, 23, 3, 23, 667, 8, 23, 1, 24, 1, 24, 1, 24, 3, 24, 672, 8, 24, 1, 24,
		1, 24, 3, 24, 676, 8, 24, 1, 25, 1, 25, 3, 25, 680, 8, 25, 1, 26, 1, 26,
		1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 5, 28, 690, 8, 28, 10, 28, 12,
		28, 693, 9, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 3, 29, 700, 8, 29, 1,
		29, 1, 29, 3, 29, 704, 8, 29, 1, 29, 1, 29, 3, 29, 708, 8, 29, 1, 29, 1,
		29, 3, 29, 712, 8, 29, 1, 29, 1, 29, 3, 29, 716, 8, 29, 1, 29, 1, 29, 3,
		29, 720, 8, 29, 1, 29, 1, 29, 3, 29, 724, 8, 29, 1, 29, 1, 29, 3, 29, 728,
		8, 29, 1, 29, 1, 29, 3, 29, 732, 8, 29, 3, 29, 734, 8, 29, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 744, 8, 31, 1, 31, 1,
		31, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 752, 8, 32, 1, 32, 1, 32, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 774, 8, 35, 10, 35,
		12, 35, 777, 9, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 5, 35, 788, 8, 35, 10, 35, 12, 35, 791, 9, 35, 1, 35, 1, 35,
		3, 35, 795, 8, 35, 1, 36, 1, 36, 3, 36, 799, 8, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 3, 36, 805, 8, 36, 1, 36, 3, 36, 808, 8, 36, 1, 36, 3, 36, 811,
		8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 818, 8, 37, 1, 37, 3,
		37, 821, 8, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39,
		830, 8, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		42, 1, 42, 3, 42, 842, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		46, 1, 46, 1, 46, 1, 46, 5, 46, 864, 8, 46, 10, 46, 12, 46, 867, 9, 46,
		1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 876, 8, 47, 10,
		47, 12, 47, 879, 9, 47, 1, 47, 1, 47, 3, 47, 883, 8, 47, 1, 48, 1, 48,
		3, 48, 887, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 893, 8, 49, 10, 49,
		12, 49, 896, 9, 49, 1, 49, 3, 49, 899, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50,
		3, 50, 905, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1,
		52, 3, 52, 915, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 920, 8, 52, 1, 52, 1,
		52, 1, 53, 1, 53, 3, 53, 926, 8, 53, 1, 53, 1, 53, 3, 53, 930, 8, 53, 1,
		53, 1, 53, 3, 53, 934, 8, 53, 1, 53, 1, 53, 3, 53, 938, 8, 53, 1, 53, 1,
		53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 947, 8, 54, 1, 54, 1, 54,
		3, 54, 951, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 958, 8, 54,
		1, 54, 3, 54, 961, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 5,
		55, 969, 8, 55, 10, 55, 12, 55, 972, 9, 55, 1, 56, 1, 56, 1, 57, 1, 57,
		1, 57, 3, 57, 979, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3,
		57, 987, 8, 57, 1, 58, 1, 58, 3, 58, 991, 8, 58, 1, 58, 1, 58, 1, 58, 1,
		59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60,
		1006, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1025,
		8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 3,
		66, 1036, 8, 66, 1, 66, 1, 66, 3, 66, 1040, 8, 66, 1, 66, 1, 66, 1, 66,
		1, 66, 1, 66, 3, 66, 1047, 8, 66, 1, 67, 1, 67, 1, 67, 3, 67, 1052, 8,
		67, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68, 1058, 8, 68, 1, 68, 1, 68, 3, 68,
		1062, 8, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 3, 69, 1069, 8, 69, 1,
		69, 1, 69, 3, 69, 1073, 8, 69, 1, 70, 1, 70, 3, 70, 1077, 8, 70, 1, 70,
		1, 70, 3, 70, 1081, 8, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 3,
		71, 1089, 8, 71, 1, 71, 1, 71, 3, 71, 1093, 8, 71, 1, 71, 1, 71, 1, 72,
		3, 72, 1098, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1104, 8, 72, 1,
		73, 1, 73, 1, 73, 1, 73, 3, 73, 1110, 8, 73, 1, 73, 3, 73, 1113, 8, 73,
		1, 73, 1, 73, 3, 73, 1117, 8, 73, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1,
		75, 1, 75, 5, 75, 1126, 8, 75, 10, 75, 12, 75, 1129, 9, 75, 1, 76, 1, 76,
		1, 76, 1, 76, 5, 76, 1135, 8, 76, 10, 76, 12, 76, 1138, 9, 76, 1, 76, 1,
		76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 4, 77, 1149, 8, 77,
		11, 77, 12, 77, 1150, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 4, 78, 1161, 8, 78, 11, 78, 12, 78, 1162, 1, 78, 1, 78, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79,
		1178, 8, 79, 1, 79, 3, 79, 1181, 8, 79, 1, 79, 1, 79, 3, 79, 1185, 8, 79,
		1, 79, 3, 79, 1188, 8, 79, 3, 79, 1190, 8, 79, 1, 79, 1, 79, 1, 79, 3,
		79, 1195, 8, 79, 1, 79, 1, 79, 3, 79, 1199, 8, 79, 1, 79, 3, 79, 1202,
		8, 79, 5, 79, 1204, 8, 79, 10, 79, 12, 79, 1207, 9, 79, 1, 80, 1, 80, 1,
		80, 1, 80, 5, 80, 1213, 8, 80, 10, 80, 12, 80, 1216, 9, 80, 1, 81, 1, 81,
		1, 81, 1, 81, 5, 81, 1222, 8, 81, 10, 81, 12, 81, 1225, 9, 81, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 5, 82, 1232, 8, 82, 10, 82, 12, 82, 1235, 9, 82,
		1, 82, 1, 82, 3, 82, 1239, 8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1,
		83, 1, 83, 1, 84, 1, 84, 3, 84, 1250, 8, 84, 1, 84, 3, 84, 1253, 8, 84,
		1, 84, 3, 84, 1256, 8, 84, 1, 84, 3, 84, 1259, 8, 84, 1, 84, 3, 84, 1262,
		8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1268, 8, 84, 1, 85, 1, 85, 3,
		85, 1272, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 5, 85, 1278, 8, 85, 10, 85,
		12, 85, 1281, 9, 85, 3, 85, 1283, 8, 85, 1, 86, 1, 86, 1, 86, 3, 86, 1288,
		8, 86, 1, 86, 3, 86, 1291, 8, 86, 1, 86, 1, 86, 3, 86, 1295, 8, 86, 1,
		86, 3, 86, 1298, 8, 86, 3, 86, 1300, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1314, 8,
		87, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 1323, 8, 89,
		10, 89, 12, 89, 1326, 9, 89, 1, 89, 1, 89, 3, 89, 1330, 8, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1338, 8, 89, 1, 89, 3, 89, 1341,
		8, 89, 1, 89, 3, 89, 1344, 8, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1349, 8,
		89, 5, 89, 1351, 8, 89, 10, 89, 12, 89, 1354, 9, 89, 1, 90, 1, 90, 3, 90,
		1358, 8, 90, 1, 91, 3, 91, 1361, 8, 91, 1, 91, 1, 91, 3, 91, 1365, 8, 91,
		1, 91, 1, 91, 3, 91, 1369, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1,
		91, 1, 91, 3, 91, 1378, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91,
		1, 91, 1, 91, 1, 91, 3, 91, 1389, 8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 1, 92, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95,
		1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 1414, 8,
		96, 10, 96, 12, 96, 1417, 9, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 98, 1,
		98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98,
		1, 98, 1, 98, 1, 98, 3, 98, 1438, 8, 98, 1, 99, 1, 99, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1451, 8,
		101, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 5,
		103, 1461, 8, 103, 10, 103, 12, 103, 1464, 9, 103, 1, 104, 1, 104, 1, 104,
		1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 5, 104, 1474, 8, 104, 10, 104,
		12, 104, 1477, 9, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104,
		1, 104, 5, 104, 1486, 8, 104, 10, 104, 12, 104, 1489, 9, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 5, 104, 1498, 8, 104, 10,
		104, 12, 104, 1501, 9, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1506, 8, 104,
		1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107,
		1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 109, 1, 109, 1, 110, 1, 110,
		1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 5, 111, 1531, 8, 111, 10, 111,
		12, 111, 1534, 9, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 3, 113,
		1541, 8, 113, 1, 113, 1, 113, 3, 113, 1545, 8, 113, 1, 113, 3, 113, 1548,
		8, 113, 1, 113, 3, 113, 1551, 8, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1,
		114, 3, 114, 1558, 8, 114, 1, 114, 3, 114, 1561, 8, 114, 1, 114, 3, 114,
		1564, 8, 114, 1, 114, 3, 114, 1567, 8, 114, 1, 114, 3, 114, 1570, 8, 114,
		1, 114, 3, 114, 1573, 8, 114, 1, 114, 1, 114, 1, 114, 3, 114, 1578, 8,
		114, 1, 114, 3, 114, 1581, 8, 114, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115,
		5, 115, 1588, 8, 115, 10, 115, 12, 115, 1591, 9, 115, 1, 116, 1, 116, 3,
		116, 1595, 8, 116, 1, 116, 1, 116, 3, 116, 1599, 8, 116, 1, 117, 1, 117,
		1, 117, 3, 117, 1604, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1610,
		8, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1615, 8, 118, 5, 118, 1617, 8,
		118, 10, 118, 12, 118, 1620, 9, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 3, 119, 1638, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120,
		5, 120, 1644, 8, 120, 10, 120, 12, 120, 1647, 9, 120, 1, 121, 1, 121, 1,
		121, 4, 121, 1652, 8, 121, 11, 121, 12, 121, 1653, 1, 121, 1, 121, 3, 121,
		1658, 8, 121, 1, 122, 1, 122, 3, 122, 1662, 8, 122, 1, 123, 1, 123, 1,
		123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1672, 8, 123, 1, 124,
		1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124,
		1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124,
		1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1698, 8, 124, 1, 125, 1,
		125, 1, 125, 1, 125, 5, 125, 1704, 8, 125, 10, 125, 12, 125, 1707, 9, 125,
		1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126,
		3, 126, 1718, 8, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 128, 1,
		128, 1, 128, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1,
		130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1740, 8, 130, 3, 130, 1742,
		8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 3, 130, 1753, 8, 130, 1, 130, 5, 130, 1756, 8, 130, 10, 130, 12,
		130, 1759, 9, 130, 1, 131, 3, 131, 1762, 8, 131, 1, 131, 1, 131, 3, 131,
		1766, 8, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1773, 8,
		131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 5, 131, 1780, 8, 131, 10,
		131, 12, 131, 1783, 9, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1788, 8, 131,
		1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 3, 131, 1801, 8, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1,
		131, 3, 131, 1808, 8, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1813, 8, 131,
		1, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1819, 8, 131, 1, 131, 1, 131, 1,
		131, 1, 131, 1, 131, 3, 131, 1826, 8, 131, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 3, 131, 1833, 8, 131, 3, 131, 1835, 8, 131, 1, 132, 3, 132, 1838,
		8, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132,
		5, 132, 1848, 8, 132, 10, 132, 12, 132, 1851, 9, 132, 1, 132, 1, 132, 3,
		132, 1855, 8, 132, 1, 132, 3, 132, 1858, 8, 132, 1, 132, 1, 132, 1, 132,
		1, 132, 3, 132, 1864, 8, 132, 3, 132, 1866, 8, 132, 1, 133, 1, 133, 1,
		133, 1, 133, 3, 133, 1872, 8, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 1893, 8, 133, 10, 133,
		12, 133, 1896, 9, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134,
		1903, 8, 134, 1, 134, 1, 134, 1, 134, 5, 134, 1908, 8, 134, 10, 134, 12,
		134, 1911, 9, 134, 3, 134, 1913, 8, 134, 1, 134, 1, 134, 3, 134, 1917,
		8, 134, 1, 135, 1, 135, 1, 135, 4, 135, 1922, 8, 135, 11, 135, 12, 135,
		1923, 1, 135, 1, 135, 3, 135, 1928, 8, 135, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 135, 4, 135, 1935, 8, 135, 11, 135, 12, 135, 1936, 1, 135, 1, 135,
		3, 135, 1941, 8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1957,
		8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135,
		1966, 8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1,
		135, 3, 135, 1994, 8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 5, 135,
		2001, 8, 135, 10, 135, 12, 135, 2004, 9, 135, 1, 136, 1, 136, 1, 137, 1,
		137, 1, 137, 1, 137, 3, 137, 2012, 8, 137, 1, 138, 1, 138, 1, 138, 1, 138,
		3, 138, 2018, 8, 138, 1, 139, 1, 139, 3, 139, 2022, 8, 139, 1, 140, 1,
		140, 1, 140, 1, 140, 3, 140, 2028, 8, 140, 1, 141, 1, 141, 1, 142, 1, 142,
		1, 143, 1, 143, 3, 143, 2036, 8, 143, 1, 144, 1, 144, 1, 144, 3, 144, 2041,
		8, 144, 1, 145, 1, 145, 3, 145, 2045, 8, 145, 1, 146, 1, 146, 1, 146, 4,
		146, 2050, 8, 146, 11, 146, 12, 146, 2051, 1, 147, 1, 147, 1, 147, 3, 147,
		2057, 8, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 149, 3, 149, 2065,
		8, 149, 1, 149, 1, 149, 3, 149, 2069, 8, 149, 1, 150, 3, 150, 2072, 8,
		150, 1, 150, 1, 150, 3, 150, 2076, 8, 150, 1, 151, 1, 151, 1, 151, 1, 152,
		1, 152, 4, 152, 2083, 8, 152, 11, 152, 12, 152, 2084, 1, 152, 3, 152, 2088,
		8, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 5, 154,
		2097, 8, 154, 10, 154, 12, 154, 2100, 9, 154, 1, 155, 1, 155, 1, 155, 3,
		155, 2105, 8, 155, 1, 156, 1, 156, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158,
		1, 158, 1, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1, 161, 1, 161, 1, 161,
		3, 161, 2123, 8, 161, 1, 162, 1, 162, 1, 162, 3, 162, 2128, 8, 162, 1,
		163, 1, 163, 1, 163, 3, 163, 2133, 8, 163, 1, 163, 1, 163, 1, 163, 1, 163,
		1, 163, 3, 163, 2140, 8, 163, 3, 163, 2142, 8, 163, 1, 164, 1, 164, 1,
		164, 3, 164, 2147, 8, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 3, 164,
		2154, 8, 164, 3, 164, 2156, 8, 164, 1, 165, 1, 165, 1, 165, 3, 165, 2161,
		8, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 3, 165, 2168, 8, 165, 3,
		165, 2170, 8, 165, 1, 166, 1, 166, 1, 166, 3, 166, 2175, 8, 166, 1, 166,
		1, 166, 1, 166, 1, 166, 1, 166, 3, 166, 2182, 8, 166, 3, 166, 2184, 8,
		166, 1, 167, 1, 167, 1, 167, 5, 167, 2189, 8, 167, 10, 167, 12, 167, 2192,
		9, 167, 1, 168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 170,
		1, 170, 1, 170, 1, 171, 1, 171, 1, 171, 1, 171, 5, 171, 2208, 8, 171, 10,
		171, 12, 171, 2211, 9, 171, 1, 171, 1, 171, 1, 172, 1, 172, 3, 172, 2217,
		8, 172, 1, 172, 3, 172, 2220, 8, 172, 1, 173, 1, 173, 1, 173, 3, 173, 2225,
		8, 173, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 2231, 8, 174, 1, 175, 1,
		175, 1, 175, 1, 175, 1, 175, 1, 175, 3, 175, 2239, 8, 175, 1, 176, 1, 176,
		1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176,
		1, 176, 1, 176, 1, 176, 3, 176, 2255, 8, 176, 1, 177, 1, 177, 1, 177, 1,
		177, 1, 177, 1, 177, 1, 177, 3, 177, 2264, 8, 177, 1, 178, 1, 178, 1, 179,
		1, 179, 1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 2274, 8, 180, 1, 180, 1,
		180, 1, 180, 1, 180, 1, 180, 3, 180, 2281, 8, 180, 1, 180, 3, 180, 2284,
		8, 180, 1, 181, 1, 181, 1, 181, 1, 182, 1, 182, 1, 183, 1, 183, 1, 184,
		1, 184, 1, 185, 1, 185, 1, 186, 1, 186, 1, 187, 1, 187, 1, 188, 1, 188,
		1, 189, 1, 189, 1, 190, 1, 190, 1, 191, 1, 191, 1, 192, 1, 192, 1, 192,
		1, 2190, 5, 158, 178, 260, 266, 270, 193, 0, 2, 4, 6, 8, 10, 12, 14, 16,
		18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
		54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
		90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
		212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
		242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
		272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300,
		302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330,
		332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360,
		362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 0, 47, 2, 0,
		109, 109, 452, 452, 4, 0, 45, 45, 128, 128, 189, 189, 280, 280, 4, 0, 42,
		42, 90, 90, 424, 424, 466, 466, 2, 0, 443, 443, 449, 449, 2, 0, 151, 151,
		170, 170, 2, 0, 439, 439, 491, 491, 2, 0, 484, 487, 489, 489, 3, 0, 32,
		32, 91, 91, 245, 245, 11, 0, 28, 29, 35, 35, 46, 46, 92, 92, 178, 179,
		346, 346, 362, 362, 380, 380, 383, 383, 389, 389, 418, 419, 2, 0, 435,
		435, 437, 437, 4, 0, 101, 102, 115, 115, 144, 144, 247, 247, 2, 0, 13,
		13, 232, 232, 2, 0, 457, 457, 464, 464, 3, 0, 5, 5, 271, 271, 446, 446,
		3, 0, 267, 267, 457, 457, 464, 464, 3, 0, 427, 427, 460, 460, 479, 479,
		3, 0, 332, 332, 467, 467, 483, 483, 2, 0, 442, 442, 492, 492, 2, 0, 183,
		183, 266, 266, 3, 0, 130, 130, 180, 180, 404, 404, 4, 0, 152, 152, 174,
		174, 202, 202, 319, 319, 3, 0, 447, 447, 461, 461, 501, 501, 4, 0, 251,
		251, 448, 448, 496, 498, 500, 500, 2, 0, 74, 74, 322, 322, 3, 0, 461, 461,
		494, 494, 501, 501, 2, 0, 441, 441, 452, 452, 2, 0, 459, 459, 469, 469,
		4, 0, 140, 140, 245, 245, 399, 399, 406, 406, 2, 0, 19, 19, 371, 371, 2,
		0, 5, 5, 11, 11, 2, 0, 511, 511, 531, 532, 4, 0, 454, 454, 529, 529, 533,
		533, 536, 536, 2, 0, 531, 532, 534, 534, 1, 0, 531, 532, 1, 0, 540, 541,
		2, 0, 540, 540, 543, 543, 4, 0, 454, 454, 529, 529, 531, 533, 535, 536,
		3, 0, 242, 242, 510, 511, 531, 532, 2, 0, 140, 140, 399, 399, 2, 0, 5,
		5, 113, 113, 10, 0, 97, 97, 165, 165, 223, 223, 230, 230, 336, 336, 438,
		438, 472, 472, 474, 474, 490, 490, 504, 504, 15, 0, 97, 97, 165, 165, 223,
		223, 230, 230, 336, 336, 429, 429, 438, 438, 444, 444, 450, 451, 456, 456,
		462, 462, 472, 477, 490, 490, 493, 493, 504, 505, 11, 0, 5, 5, 13, 13,
		33, 33, 78, 78, 84, 85, 113, 113, 201, 201, 208, 209, 391, 391, 415, 415,
		529, 529, 3, 0, 78, 78, 84, 85, 208, 209, 2, 0, 91, 91, 380, 381, 53, 0,
		4, 4, 13, 13, 23, 23, 38, 38, 41, 41, 43, 44, 54, 54, 56, 56, 69, 69, 75,
		75, 98, 99, 107, 107, 119, 119, 134, 134, 139, 139, 143, 143, 145, 145,
		160, 160, 165, 165, 167, 167, 187, 188, 190, 195, 198, 198, 200, 200, 202,
		202, 206, 206, 210, 210, 215, 215, 221, 221, 223, 224, 230, 230, 244, 244,
		246, 246, 265, 265, 277, 277, 283, 283, 285, 285, 295, 295, 319, 319, 323,
		325, 336, 336, 359, 360, 366, 366, 369, 369, 382, 382, 397, 397, 400, 401,
		410, 410, 421, 422, 438, 438, 471, 471, 490, 490, 504, 504, 1, 0, 439,
		506, 2516, 0, 389, 1, 0, 0, 0, 2, 399, 1, 0, 0, 0, 4, 413, 1, 0, 0, 0,
		6, 415, 1, 0, 0, 0, 8, 431, 1, 0, 0, 0, 10, 435, 1, 0, 0, 0, 12, 437, 1,
		0, 0, 0, 14, 440, 1, 0, 0, 0, 16, 451, 1, 0, 0, 0, 18, 459, 1, 0, 0, 0,
		20, 467, 1, 0, 0, 0, 22, 469, 1, 0, 0, 0, 24, 521, 1, 0, 0, 0, 26, 523,
		1, 0, 0, 0, 28, 530, 1, 0, 0, 0, 30, 534, 1, 0, 0, 0, 32, 538, 1, 0, 0,
		0, 34, 542, 1, 0, 0, 0, 36, 596, 1, 0, 0, 0, 38, 602, 1, 0, 0, 0, 40, 608,
		1, 0, 0, 0, 42, 610, 1, 0, 0, 0, 44, 652, 1, 0, 0, 0, 46, 666, 1, 0, 0,
		0, 48, 668, 1, 0, 0, 0, 50, 679, 1, 0, 0, 0, 52, 681, 1, 0, 0, 0, 54, 683,
		1, 0, 0, 0, 56, 685, 1, 0, 0, 0, 58, 733, 1, 0, 0, 0, 60, 735, 1, 0, 0,
		0, 62, 739, 1, 0, 0, 0, 64, 747, 1, 0, 0, 0, 66, 755, 1, 0, 0, 0, 68, 759,
		1, 0, 0, 0, 70, 794, 1, 0, 0, 0, 72, 810, 1, 0, 0, 0, 74, 812, 1, 0, 0,
		0, 76, 822, 1, 0, 0, 0, 78, 824, 1, 0, 0, 0, 80, 831, 1, 0, 0, 0, 82, 833,
		1, 0, 0, 0, 84, 841, 1, 0, 0, 0, 86, 849, 1, 0, 0, 0, 88, 851, 1, 0, 0,
		0, 90, 855, 1, 0, 0, 0, 92, 859, 1, 0, 0, 0, 94, 882, 1, 0, 0, 0, 96, 886,
		1, 0, 0, 0, 98, 888, 1, 0, 0, 0, 100, 904, 1, 0, 0, 0, 102, 906, 1, 0,
		0, 0, 104, 911, 1, 0, 0, 0, 106, 923, 1, 0, 0, 0, 108, 942, 1, 0, 0, 0,
		110, 962, 1, 0, 0, 0, 112, 973, 1, 0, 0, 0, 114, 975, 1, 0, 0, 0, 116,
		988, 1, 0, 0, 0, 118, 995, 1, 0, 0, 0, 120, 998, 1, 0, 0, 0, 122, 1007,
		1, 0, 0, 0, 124, 1011, 1, 0, 0, 0, 126, 1015, 1, 0, 0, 0, 128, 1018, 1,
		0, 0, 0, 130, 1026, 1, 0, 0, 0, 132, 1031, 1, 0, 0, 0, 134, 1048, 1, 0,
		0, 0, 136, 1055, 1, 0, 0, 0, 138, 1065, 1, 0, 0, 0, 140, 1074, 1, 0, 0,
		0, 142, 1084, 1, 0, 0, 0, 144, 1103, 1, 0, 0, 0, 146, 1105, 1, 0, 0, 0,
		148, 1118, 1, 0, 0, 0, 150, 1121, 1, 0, 0, 0, 152, 1130, 1, 0, 0, 0, 154,
		1141, 1, 0, 0, 0, 156, 1154, 1, 0, 0, 0, 158, 1189, 1, 0, 0, 0, 160, 1208,
		1, 0, 0, 0, 162, 1217, 1, 0, 0, 0, 164, 1226, 1, 0, 0, 0, 166, 1245, 1,
		0, 0, 0, 168, 1267, 1, 0, 0, 0, 170, 1269, 1, 0, 0, 0, 172, 1299, 1, 0,
		0, 0, 174, 1313, 1, 0, 0, 0, 176, 1315, 1, 0, 0, 0, 178, 1329, 1, 0, 0,
		0, 180, 1355, 1, 0, 0, 0, 182, 1388, 1, 0, 0, 0, 184, 1390, 1, 0, 0, 0,
		186, 1396, 1, 0, 0, 0, 188, 1398, 1, 0, 0, 0, 190, 1403, 1, 0, 0, 0, 192,
		1408, 1, 0, 0, 0, 194, 1420, 1, 0, 0, 0, 196, 1437, 1, 0, 0, 0, 198, 1439,
		1, 0, 0, 0, 200, 1441, 1, 0, 0, 0, 202, 1450, 1, 0, 0, 0, 204, 1452, 1,
		0, 0, 0, 206, 1455, 1, 0, 0, 0, 208, 1505, 1, 0, 0, 0, 210, 1507, 1, 0,
		0, 0, 212, 1510, 1, 0, 0, 0, 214, 1512, 1, 0, 0, 0, 216, 1519, 1, 0, 0,
		0, 218, 1521, 1, 0, 0, 0, 220, 1523, 1, 0, 0, 0, 222, 1526, 1, 0, 0, 0,
		224, 1535, 1, 0, 0, 0, 226, 1540, 1, 0, 0, 0, 228, 1554, 1, 0, 0, 0, 230,
		1582, 1, 0, 0, 0, 232, 1592, 1, 0, 0, 0, 234, 1600, 1, 0, 0, 0, 236, 1605,
		1, 0, 0, 0, 238, 1637, 1, 0, 0, 0, 240, 1639, 1, 0, 0, 0, 242, 1648, 1,
		0, 0, 0, 244, 1659, 1, 0, 0, 0, 246, 1671, 1, 0, 0, 0, 248, 1697, 1, 0,
		0, 0, 250, 1699, 1, 0, 0, 0, 252, 1717, 1, 0, 0, 0, 254, 1719, 1, 0, 0,
		0, 256, 1724, 1, 0, 0, 0, 258, 1727, 1, 0, 0, 0, 260, 1741, 1, 0, 0, 0,
		262, 1834, 1, 0, 0, 0, 264, 1865, 1, 0, 0, 0, 266, 1871, 1, 0, 0, 0, 268,
		1916, 1, 0, 0, 0, 270, 1993, 1, 0, 0, 0, 272, 2005, 1, 0, 0, 0, 274, 2011,
		1, 0, 0, 0, 276, 2017, 1, 0, 0, 0, 278, 2021, 1, 0, 0, 0, 280, 2027, 1,
		0, 0, 0, 282, 2029, 1, 0, 0, 0, 284, 2031, 1, 0, 0, 0, 286, 2035, 1, 0,
		0, 0, 288, 2037, 1, 0, 0, 0, 290, 2042, 1, 0, 0, 0, 292, 2049, 1, 0, 0,
		0, 294, 2053, 1, 0, 0, 0, 296, 2058, 1, 0, 0, 0, 298, 2068, 1, 0, 0, 0,
		300, 2071, 1, 0, 0, 0, 302, 2077, 1, 0, 0, 0, 304, 2087, 1, 0, 0, 0, 306,
		2089, 1, 0, 0, 0, 308, 2093, 1, 0, 0, 0, 310, 2104, 1, 0, 0, 0, 312, 2106,
		1, 0, 0, 0, 314, 2108, 1, 0, 0, 0, 316, 2110, 1, 0, 0, 0, 318, 2115, 1,
		0, 0, 0, 320, 2117, 1, 0, 0, 0, 322, 2119, 1, 0, 0, 0, 324, 2124, 1, 0,
		0, 0, 326, 2141, 1, 0, 0, 0, 328, 2155, 1, 0, 0, 0, 330, 2169, 1, 0, 0,
		0, 332, 2183, 1, 0, 0, 0, 334, 2185, 1, 0, 0, 0, 336, 2193, 1, 0, 0, 0,
		338, 2196, 1, 0, 0, 0, 340, 2200, 1, 0, 0, 0, 342, 2203, 1, 0, 0, 0, 344,
		2214, 1, 0, 0, 0, 346, 2224, 1, 0, 0, 0, 348, 2230, 1, 0, 0, 0, 350, 2238,
		1, 0, 0, 0, 352, 2254, 1, 0, 0, 0, 354, 2263, 1, 0, 0, 0, 356, 2265, 1,
		0, 0, 0, 358, 2267, 1, 0, 0, 0, 360, 2283, 1, 0, 0, 0, 362, 2285, 1, 0,
		0, 0, 364, 2288, 1, 0, 0, 0, 366, 2290, 1, 0, 0, 0, 368, 2292, 1, 0, 0,
		0, 370, 2294, 1, 0, 0, 0, 372, 2296, 1, 0, 0, 0, 374, 2298, 1, 0, 0, 0,
		376, 2300, 1, 0, 0, 0, 378, 2302, 1, 0, 0, 0, 380, 2304, 1, 0, 0, 0, 382,
		2306, 1, 0, 0, 0, 384, 2308, 1, 0, 0, 0, 386, 388, 3, 2, 1, 0, 387, 386,
		1, 0, 0, 0, 388, 391, 1, 0, 0, 0, 389, 387, 1, 0, 0, 0, 389, 390, 1, 0,
		0, 0, 390, 392, 1, 0, 0, 0, 391, 389, 1, 0, 0, 0, 392, 393, 5, 0, 0, 1,
		393, 1, 1, 0, 0, 0, 394, 396, 3, 4, 2, 0, 395, 397, 5, 523, 0, 0, 396,
		395, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 400, 1, 0, 0, 0, 398, 400,
		3, 6, 3, 0, 399, 394, 1, 0, 0, 0, 399, 398, 1, 0, 0, 0, 400, 3, 1, 0, 0,
		0, 401, 414, 3, 8, 4, 0, 402, 414, 3, 10, 5, 0, 403, 414, 3, 12, 6, 0,
		404, 414, 3, 14, 7, 0, 405, 414, 3, 20, 10, 0, 406, 414, 3, 24, 12, 0,
		407, 414, 3, 26, 13, 0, 408, 414, 3, 28, 14, 0, 409, 414, 3, 30, 15, 0,
		410, 414, 3, 32, 16, 0, 411, 414, 3, 34, 17, 0, 412, 414, 3, 36, 18, 0,
		413, 401, 1, 0, 0, 0, 413, 402, 1, 0, 0, 0, 413, 403, 1, 0, 0, 0, 413,
		404, 1, 0, 0, 0, 413, 405, 1, 0, 0, 0, 413, 406, 1, 0, 0, 0, 413, 407,
		1, 0, 0, 0, 413, 408, 1, 0, 0, 0, 413, 409, 1, 0, 0, 0, 413, 410, 1, 0,
		0, 0, 413, 411, 1, 0, 0, 0, 413, 412, 1, 0, 0, 0, 414, 5, 1, 0, 0, 0, 415,
		416, 5, 523, 0, 0, 416, 7, 1, 0, 0, 0, 417, 432, 3, 40, 20, 0, 418, 432,
		3, 104, 52, 0, 419, 432, 3, 106, 53, 0, 420, 432, 3, 108, 54, 0, 421, 432,
		3, 102, 51, 0, 422, 432, 3, 114, 57, 0, 423, 432, 3, 128, 64, 0, 424, 432,
		3, 130, 65, 0, 425, 432, 3, 132, 66, 0, 426, 432, 3, 134, 67, 0, 427, 432,
		3, 136, 68, 0, 428, 432, 3, 138, 69, 0, 429, 432, 3, 140, 70, 0, 430, 432,
		3, 142, 71, 0, 431, 417, 1, 0, 0, 0, 431, 418, 1, 0, 0, 0, 431, 419, 1,
		0, 0, 0, 431, 420, 1, 0, 0, 0, 431, 421, 1, 0, 0, 0, 431, 422, 1, 0, 0,
		0, 431, 423, 1, 0, 0, 0, 431, 424, 1, 0, 0, 0, 431, 425, 1, 0, 0, 0, 431,
		426, 1, 0, 0, 0, 431, 427, 1, 0, 0, 0, 431, 428, 1, 0, 0, 0, 431, 429,
		1, 0, 0, 0, 431, 430, 1, 0, 0, 0, 432, 9, 1, 0, 0, 0, 433, 436, 3, 158,
		79, 0, 434, 436, 3, 144, 72, 0, 435, 433, 1, 0, 0, 0, 435, 434, 1, 0, 0,
		0, 436, 11, 1, 0, 0, 0, 437, 438, 7, 0, 0, 0, 438, 439, 3, 328, 164, 0,
		439, 13, 1, 0, 0, 0, 440, 444, 5, 135, 0, 0, 441, 445, 3, 16, 8, 0, 442,
		443, 5, 481, 0, 0, 443, 445, 5, 146, 0, 0, 444, 441, 1, 0, 0, 0, 444, 442,
		1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 449, 1, 0, 0, 0, 446, 450, 3, 10,
		5, 0, 447, 450, 3, 146, 73, 0, 448, 450, 3, 156, 78, 0, 449, 446, 1, 0,
		0, 0, 449, 447, 1, 0, 0, 0, 449, 448, 1, 0, 0, 0, 450, 15, 1, 0, 0, 0,
		451, 456, 3, 18, 9, 0, 452, 453, 5, 522, 0, 0, 453, 455, 3, 18, 9, 0, 454,
		452, 1, 0, 0, 0, 455, 458, 1, 0, 0, 0, 456, 454, 1, 0, 0, 0, 456, 457,
		1, 0, 0, 0, 457, 17, 1, 0, 0, 0, 458, 456, 1, 0, 0, 0, 459, 460, 7, 1,
		0, 0, 460, 19, 1, 0, 0, 0, 461, 462, 5, 412, 0, 0, 462, 463, 5, 443, 0,
		0, 463, 468, 3, 318, 159, 0, 464, 465, 5, 412, 0, 0, 465, 468, 3, 322,
		161, 0, 466, 468, 3, 22, 11, 0, 467, 461, 1, 0, 0, 0, 467, 464, 1, 0, 0,
		0, 467, 466, 1, 0, 0, 0, 468, 21, 1, 0, 0, 0, 469, 470, 5, 412, 0, 0, 470,
		471, 5, 228, 0, 0, 471, 476, 3, 334, 167, 0, 472, 473, 5, 522, 0, 0, 473,
		475, 3, 334, 167, 0, 474, 472, 1, 0, 0, 0, 475, 478, 1, 0, 0, 0, 476, 474,
		1, 0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 23, 1, 0, 0, 0, 478, 476, 1, 0,
		0, 0, 479, 480, 5, 343, 0, 0, 480, 522, 7, 2, 0, 0, 481, 482, 5, 343, 0,
		0, 482, 483, 5, 76, 0, 0, 483, 522, 7, 3, 0, 0, 484, 485, 5, 343, 0, 0,
		485, 488, 5, 376, 0, 0, 486, 487, 7, 4, 0, 0, 487, 489, 3, 322, 161, 0,
		488, 486, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489, 491, 1, 0, 0, 0, 490,
		492, 3, 264, 132, 0, 491, 490, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 522,
		1, 0, 0, 0, 493, 494, 5, 343, 0, 0, 494, 495, 5, 58, 0, 0, 495, 498, 7,
		4, 0, 0, 496, 499, 3, 330, 165, 0, 497, 499, 3, 328, 164, 0, 498, 496,
		1, 0, 0, 0, 498, 497, 1, 0, 0, 0, 499, 501, 1, 0, 0, 0, 500, 502, 3, 264,
		132, 0, 501, 500, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 522, 1, 0, 0,
		0, 503, 504, 5, 343, 0, 0, 504, 509, 5, 72, 0, 0, 505, 506, 5, 375, 0,
		0, 506, 510, 3, 328, 164, 0, 507, 508, 5, 503, 0, 0, 508, 510, 3, 330,
		165, 0, 509, 505, 1, 0, 0, 0, 509, 507, 1, 0, 0, 0, 510, 522, 1, 0, 0,
		0, 511, 513, 5, 343, 0, 0, 512, 514, 5, 413, 0, 0, 513, 512, 1, 0, 0, 0,
		513, 514, 1, 0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 522, 5, 154, 0, 0, 516,
		518, 5, 343, 0, 0, 517, 519, 5, 152, 0, 0, 518, 517, 1, 0, 0, 0, 518, 519,
		1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 522, 5, 228, 0, 0, 521, 479, 1,
		0, 0, 0, 521, 481, 1, 0, 0, 0, 521, 484, 1, 0, 0, 0, 521, 493, 1, 0, 0,
		0, 521, 503, 1, 0, 0, 0, 521, 511, 1, 0, 0, 0, 521, 516, 1, 0, 0, 0, 522,
		25, 1, 0, 0, 0, 523, 524, 5, 470, 0, 0, 524, 525, 5, 227, 0, 0, 525, 528,
		3, 334, 167, 0, 526, 527, 5, 435, 0, 0, 527, 529, 3, 342, 171, 0, 528,
		526, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 27, 1, 0, 0, 0, 530, 531, 5,
		502, 0, 0, 531, 532, 5, 227, 0, 0, 532, 533, 3, 334, 167, 0, 533, 29, 1,
		0, 0, 0, 534, 536, 5, 342, 0, 0, 535, 537, 3, 344, 172, 0, 536, 535, 1,
		0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 31, 1, 0, 0, 0, 538, 540, 5, 314, 0,
		0, 539, 541, 3, 346, 173, 0, 540, 539, 1, 0, 0, 0, 540, 541, 1, 0, 0, 0,
		541, 33, 1, 0, 0, 0, 542, 543, 7, 5, 0, 0, 543, 544, 5, 465, 0, 0, 544,
		545, 3, 112, 56, 0, 545, 35, 1, 0, 0, 0, 546, 547, 5, 439, 0, 0, 547, 548,
		5, 465, 0, 0, 548, 549, 5, 435, 0, 0, 549, 552, 3, 38, 19, 0, 550, 551,
		5, 17, 0, 0, 551, 553, 3, 334, 167, 0, 552, 550, 1, 0, 0, 0, 552, 553,
		1, 0, 0, 0, 553, 597, 1, 0, 0, 0, 554, 555, 5, 439, 0, 0, 555, 556, 5,
		458, 0, 0, 556, 557, 5, 435, 0, 0, 557, 560, 3, 38, 19, 0, 558, 559, 5,
		17, 0, 0, 559, 561, 3, 334, 167, 0, 560, 558, 1, 0, 0, 0, 560, 561, 1,
		0, 0, 0, 561, 564, 1, 0, 0, 0, 562, 563, 5, 313, 0, 0, 563, 565, 3, 334,
		167, 0, 564, 562, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 597, 1, 0, 0,
		0, 566, 567, 5, 439, 0, 0, 567, 568, 7, 6, 0, 0, 568, 569, 5, 435, 0, 0,
		569, 570, 3, 38, 19, 0, 570, 571, 5, 313, 0, 0, 571, 572, 3, 334, 167,
		0, 572, 597, 1, 0, 0, 0, 573, 574, 5, 439, 0, 0, 574, 575, 5, 488, 0, 0,
		575, 597, 3, 38, 19, 0, 576, 577, 5, 439, 0, 0, 577, 578, 5, 455, 0, 0,
		578, 579, 5, 458, 0, 0, 579, 580, 5, 435, 0, 0, 580, 581, 3, 38, 19, 0,
		581, 582, 5, 313, 0, 0, 582, 583, 3, 334, 167, 0, 583, 584, 5, 468, 0,
		0, 584, 585, 3, 334, 167, 0, 585, 597, 1, 0, 0, 0, 586, 587, 5, 439, 0,
		0, 587, 588, 5, 445, 0, 0, 588, 589, 5, 458, 0, 0, 589, 590, 5, 435, 0,
		0, 590, 591, 3, 38, 19, 0, 591, 592, 5, 146, 0, 0, 592, 593, 3, 334, 167,
		0, 593, 594, 5, 17, 0, 0, 594, 595, 3, 334, 167, 0, 595, 597, 1, 0, 0,
		0, 596, 546, 1, 0, 0, 0, 596, 554, 1, 0, 0, 0, 596, 566, 1, 0, 0, 0, 596,
		573, 1, 0, 0, 0, 596, 576, 1, 0, 0, 0, 596, 586, 1, 0, 0, 0, 597, 37, 1,
		0, 0, 0, 598, 600, 5, 536, 0, 0, 599, 598, 1, 0, 0, 0, 599, 600, 1, 0,
		0, 0, 600, 601, 1, 0, 0, 0, 601, 603, 3, 334, 167, 0, 602, 599, 1, 0, 0,
		0, 603, 604, 1, 0, 0, 0, 604, 602, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605,
		39, 1, 0, 0, 0, 606, 609, 3, 42, 21, 0, 607, 609, 3, 44, 22, 0, 608, 606,
		1, 0, 0, 0, 608, 607, 1, 0, 0, 0, 609, 41, 1, 0, 0, 0, 610, 612, 5, 72,
		0, 0, 611, 613, 5, 499, 0, 0, 612, 611, 1, 0, 0, 0, 612, 613, 1, 0, 0,
		0, 613, 614, 1, 0, 0, 0, 614, 616, 5, 375, 0, 0, 615, 617, 3, 338, 169,
		0, 616, 615, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618,
		619, 3, 326, 163, 0, 619, 620, 5, 518, 0, 0, 620, 625, 3, 46, 23, 0, 621,
		622, 5, 522, 0, 0, 622, 624, 3, 46, 23, 0, 623, 621, 1, 0, 0, 0, 624, 627,
		1, 0, 0, 0, 625, 623, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0, 626, 630, 1, 0,
		0, 0, 627, 625, 1, 0, 0, 0, 628, 629, 5, 522, 0, 0, 629, 631, 3, 82, 41,
		0, 630, 628, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632,
		633, 5, 522, 0, 0, 633, 635, 3, 84, 42, 0, 634, 632, 1, 0, 0, 0, 634, 635,
		1, 0, 0, 0, 635, 638, 1, 0, 0, 0, 636, 637, 5, 522, 0, 0, 637, 639, 3,
		88, 44, 0, 638, 636, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 1, 0,
		0, 0, 640, 643, 5, 519, 0, 0, 641, 642, 5, 59, 0, 0, 642, 644, 5, 539,
		0, 0, 643, 641, 1, 0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 646, 1, 0, 0, 0,
		645, 647, 3, 90, 45, 0, 646, 645, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647,
		648, 1, 0, 0, 0, 648, 650, 3, 336, 168, 0, 649, 651, 3, 98, 49, 0, 650,
		649, 1, 0, 0, 0, 650, 651, 1, 0, 0, 0, 651, 43, 1, 0, 0, 0, 652, 653, 5,
		72, 0, 0, 653, 655, 5, 375, 0, 0, 654, 656, 3, 338, 169, 0, 655, 654, 1,
		0, 0, 0, 655, 656, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657, 658, 3, 326,
		163, 0, 658, 661, 3, 336, 168, 0, 659, 660, 5, 17, 0, 0, 660, 662, 3, 158,
		79, 0, 661, 659, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 45, 1, 0, 0, 0,
		663, 667, 3, 48, 24, 0, 664, 667, 3, 74, 37, 0, 665, 667, 3, 78, 39, 0,
		666, 663, 1, 0, 0, 0, 666, 664, 1, 0, 0, 0, 666, 665, 1, 0, 0, 0, 667,
		47, 1, 0, 0, 0, 668, 669, 3, 50, 25, 0, 669, 671, 3, 58, 29, 0, 670, 672,
		3, 72, 36, 0, 671, 670, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 675, 1,
		0, 0, 0, 673, 674, 5, 59, 0, 0, 674, 676, 5, 539, 0, 0, 675, 673, 1, 0,
		0, 0, 675, 676, 1, 0, 0, 0, 676, 49, 1, 0, 0, 0, 677, 680, 3, 334, 167,
		0, 678, 680, 3, 258, 129, 0, 679, 677, 1, 0, 0, 0, 679, 678, 1, 0, 0, 0,
		680, 51, 1, 0, 0, 0, 681, 682, 3, 334, 167, 0, 682, 53, 1, 0, 0, 0, 683,
		684, 3, 334, 167, 0, 684, 55, 1, 0, 0, 0, 685, 686, 5, 518, 0, 0, 686,
		691, 3, 52, 26, 0, 687, 688, 5, 522, 0, 0, 688, 690, 3, 52, 26, 0, 689,
		687, 1, 0, 0, 0, 690, 693, 1, 0, 0, 0, 691, 689, 1, 0, 0, 0, 691, 692,
		1, 0, 0, 0, 692, 694, 1, 0, 0, 0, 693, 691, 1, 0, 0, 0, 694, 695, 5, 519,
		0, 0, 695, 57, 1, 0, 0, 0, 696, 734, 7, 7, 0, 0, 697, 699, 7, 8, 0, 0,
		698, 700, 3, 60, 30, 0, 699, 698, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700,
		734, 1, 0, 0, 0, 701, 703, 5, 381, 0, 0, 702, 704, 3, 60, 30, 0, 703, 702,
		1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 711, 1, 0, 0, 0, 705, 707, 7, 9,
		0, 0, 706, 708, 5, 207, 0, 0, 707, 706, 1, 0, 0, 0, 707, 708, 1, 0, 0,
		0, 708, 709, 1, 0, 0, 0, 709, 710, 5, 380, 0, 0, 710, 712, 5, 506, 0, 0,
		711, 705, 1, 0, 0, 0, 711, 712, 1, 0, 0, 0, 712, 734, 1, 0, 0, 0, 713,
		715, 7, 10, 0, 0, 714, 716, 3, 62, 31, 0, 715, 714, 1, 0, 0, 0, 715, 716,
		1, 0, 0, 0, 716, 734, 1, 0, 0, 0, 717, 719, 7, 11, 0, 0, 718, 720, 3, 66,
		33, 0, 719, 718, 1, 0, 0, 0, 719, 720, 1, 0, 0, 0, 720, 734, 1, 0, 0, 0,
		721, 723, 5, 471, 0, 0, 722, 724, 3, 68, 34, 0, 723, 722, 1, 0, 0, 0, 723,
		724, 1, 0, 0, 0, 724, 734, 1, 0, 0, 0, 725, 727, 5, 323, 0, 0, 726, 728,
		3, 70, 35, 0, 727, 726, 1, 0, 0, 0, 727, 728, 1, 0, 0, 0, 728, 734, 1,
		0, 0, 0, 729, 731, 5, 296, 0, 0, 730, 732, 3, 64, 32, 0, 731, 730, 1, 0,
		0, 0, 731, 732, 1, 0, 0, 0, 732, 734, 1, 0, 0, 0, 733, 696, 1, 0, 0, 0,
		733, 697, 1, 0, 0, 0, 733, 701, 1, 0, 0, 0, 733, 713, 1, 0, 0, 0, 733,
		717, 1, 0, 0, 0, 733, 721, 1, 0, 0, 0, 733, 725, 1, 0, 0, 0, 733, 729,
		1, 0, 0, 0, 734, 59, 1, 0, 0, 0, 735, 736, 5, 518, 0, 0, 736, 737, 3, 366,
		183, 0, 737, 738, 5, 519, 0, 0, 738, 61, 1, 0, 0, 0, 739, 740, 5, 518,
		0, 0, 740, 743, 3, 366, 183, 0, 741, 742, 5, 522, 0, 0, 742, 744, 3, 366,
		183, 0, 743, 741, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 745, 1, 0, 0,
		0, 745, 746, 5, 519, 0, 0, 746, 63, 1, 0, 0, 0, 747, 748, 5, 518, 0, 0,
		748, 751, 3, 364, 182, 0, 749, 750, 5, 522, 0, 0, 750, 752, 3, 364, 182,
		0, 751, 749, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753,
		754, 5, 519, 0, 0, 754, 65, 1, 0, 0, 0, 755, 756, 5, 509, 0, 0, 756, 757,
		3, 58, 29, 0, 757, 758, 5, 508, 0, 0, 758, 67, 1, 0, 0, 0, 759, 760, 5,
		509, 0, 0, 760, 761, 3, 58, 29, 0, 761, 762, 5, 522, 0, 0, 762, 763, 3,
		58, 29, 0, 763, 764, 1, 0, 0, 0, 764, 765, 5, 508, 0, 0, 765, 69, 1, 0,
		0, 0, 766, 767, 5, 509, 0, 0, 767, 768, 3, 52, 26, 0, 768, 775, 3, 58,
		29, 0, 769, 770, 5, 522, 0, 0, 770, 771, 3, 52, 26, 0, 771, 772, 3, 58,
		29, 0, 772, 774, 1, 0, 0, 0, 773, 769, 1, 0, 0, 0, 774, 777, 1, 0, 0, 0,
		775, 773, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 778, 1, 0, 0, 0, 777,
		775, 1, 0, 0, 0, 778, 779, 5, 508, 0, 0, 779, 795, 1, 0, 0, 0, 780, 781,
		5, 518, 0, 0, 781, 782, 3, 52, 26, 0, 782, 789, 3, 58, 29, 0, 783, 784,
		5, 522, 0, 0, 784, 785, 3, 52, 26, 0, 785, 786, 3, 58, 29, 0, 786, 788,
		1, 0, 0, 0, 787, 783, 1, 0, 0, 0, 788, 791, 1, 0, 0, 0, 789, 787, 1, 0,
		0, 0, 789, 790, 1, 0, 0, 0, 790, 792, 1, 0, 0, 0, 791, 789, 1, 0, 0, 0,
		792, 793, 5, 519, 0, 0, 793, 795, 1, 0, 0, 0, 794, 766, 1, 0, 0, 0, 794,
		780, 1, 0, 0, 0, 795, 71, 1, 0, 0, 0, 796, 797, 5, 64, 0, 0, 797, 799,
		3, 86, 43, 0, 798, 796, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 800, 1,
		0, 0, 0, 800, 801, 5, 290, 0, 0, 801, 804, 5, 468, 0, 0, 802, 803, 5, 242,
		0, 0, 803, 805, 5, 125, 0, 0, 804, 802, 1, 0, 0, 0, 804, 805, 1, 0, 0,
		0, 805, 811, 1, 0, 0, 0, 806, 808, 5, 242, 0, 0, 807, 806, 1, 0, 0, 0,
		807, 808, 1, 0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 811, 5, 245, 0, 0, 810,
		798, 1, 0, 0, 0, 810, 807, 1, 0, 0, 0, 811, 73, 1, 0, 0, 0, 812, 813, 3,
		50, 25, 0, 813, 814, 3, 58, 29, 0, 814, 817, 5, 219, 0, 0, 815, 816, 5,
		151, 0, 0, 816, 818, 3, 76, 38, 0, 817, 815, 1, 0, 0, 0, 817, 818, 1, 0,
		0, 0, 818, 820, 1, 0, 0, 0, 819, 821, 5, 425, 0, 0, 820, 819, 1, 0, 0,
		0, 820, 821, 1, 0, 0, 0, 821, 75, 1, 0, 0, 0, 822, 823, 5, 539, 0, 0, 823,
		77, 1, 0, 0, 0, 824, 825, 3, 50, 25, 0, 825, 826, 5, 17, 0, 0, 826, 829,
		3, 80, 40, 0, 827, 828, 5, 59, 0, 0, 828, 830, 5, 539, 0, 0, 829, 827,
		1, 0, 0, 0, 829, 830, 1, 0, 0, 0, 830, 79, 1, 0, 0, 0, 831, 832, 3, 258,
		129, 0, 832, 81, 1, 0, 0, 0, 833, 834, 5, 426, 0, 0, 834, 835, 5, 146,
		0, 0, 835, 836, 3, 52, 26, 0, 836, 837, 5, 17, 0, 0, 837, 838, 3, 258,
		129, 0, 838, 83, 1, 0, 0, 0, 839, 840, 5, 64, 0, 0, 840, 842, 3, 86, 43,
		0, 841, 839, 1, 0, 0, 0, 841, 842, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843,
		844, 5, 290, 0, 0, 844, 845, 5, 468, 0, 0, 845, 846, 3, 56, 28, 0, 846,
		847, 5, 242, 0, 0, 847, 848, 5, 125, 0, 0, 848, 85, 1, 0, 0, 0, 849, 850,
		3, 310, 155, 0, 850, 87, 1, 0, 0, 0, 851, 852, 5, 278, 0, 0, 852, 853,
		5, 146, 0, 0, 853, 854, 5, 373, 0, 0, 854, 89, 1, 0, 0, 0, 855, 856, 5,
		270, 0, 0, 856, 857, 5, 34, 0, 0, 857, 858, 3, 92, 46, 0, 858, 91, 1, 0,
		0, 0, 859, 860, 5, 518, 0, 0, 860, 865, 3, 94, 47, 0, 861, 862, 5, 522,
		0, 0, 862, 864, 3, 94, 47, 0, 863, 861, 1, 0, 0, 0, 864, 867, 1, 0, 0,
		0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866, 868, 1, 0, 0, 0, 867,
		865, 1, 0, 0, 0, 868, 869, 5, 519, 0, 0, 869, 93, 1, 0, 0, 0, 870, 883,
		3, 52, 26, 0, 871, 872, 5, 518, 0, 0, 872, 877, 3, 96, 48, 0, 873, 874,
		5, 522, 0, 0, 874, 876, 3, 96, 48, 0, 875, 873, 1, 0, 0, 0, 876, 879, 1,
		0, 0, 0, 877, 875, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 880, 1, 0, 0,
		0, 879, 877, 1, 0, 0, 0, 880, 881, 5, 519, 0, 0, 881, 883, 1, 0, 0, 0,
		882, 870, 1, 0, 0, 0, 882, 871, 1, 0, 0, 0, 883, 95, 1, 0, 0, 0, 884, 887,
		3, 286, 143, 0, 885, 887, 3, 360, 180, 0, 886, 884, 1, 0, 0, 0, 886, 885,
		1, 0, 0, 0, 887, 97, 1, 0, 0, 0, 888, 889, 5, 203, 0, 0, 889, 898, 3, 328,
		164, 0, 890, 894, 5, 518, 0, 0, 891, 893, 3, 100, 50, 0, 892, 891, 1, 0,
		0, 0, 893, 896, 1, 0, 0, 0, 894, 892, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0,
		895, 897, 1, 0, 0, 0, 896, 894, 1, 0, 0, 0, 897, 899, 5, 519, 0, 0, 898,
		890, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 99, 1, 0, 0, 0, 900, 901, 7,
		12, 0, 0, 901, 905, 7, 13, 0, 0, 902, 903, 7, 14, 0, 0, 903, 905, 7, 15,
		0, 0, 904, 900, 1, 0, 0, 0, 904, 902, 1, 0, 0, 0, 905, 101, 1, 0, 0, 0,
		906, 907, 5, 72, 0, 0, 907, 908, 5, 443, 0, 0, 908, 909, 3, 320, 160, 0,
		909, 910, 3, 336, 168, 0, 910, 103, 1, 0, 0, 0, 911, 912, 5, 72, 0, 0,
		912, 914, 5, 449, 0, 0, 913, 915, 3, 338, 169, 0, 914, 913, 1, 0, 0, 0,
		914, 915, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 919, 3, 324, 162, 0, 917,
		918, 5, 59, 0, 0, 918, 920, 5, 539, 0, 0, 919, 917, 1, 0, 0, 0, 919, 920,
		1, 0, 0, 0, 920, 921, 1, 0, 0, 0, 921, 922, 3, 336, 168, 0, 922, 105, 1,
		0, 0, 0, 923, 925, 5, 72, 0, 0, 924, 926, 5, 499, 0, 0, 925, 924, 1, 0,
		0, 0, 925, 926, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 929, 5, 503, 0,
		0, 928, 930, 3, 338, 169, 0, 929, 928, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0,
		930, 931, 1, 0, 0, 0, 931, 933, 3, 332, 166, 0, 932, 934, 3, 56, 28, 0,
		933, 932, 1, 0, 0, 0, 933, 934, 1, 0, 0, 0, 934, 937, 1, 0, 0, 0, 935,
		936, 5, 59, 0, 0, 936, 938, 5, 539, 0, 0, 937, 935, 1, 0, 0, 0, 937, 938,
		1, 0, 0, 0, 938, 939, 1, 0, 0, 0, 939, 940, 5, 17, 0, 0, 940, 941, 3, 158,
		79, 0, 941, 107, 1, 0, 0, 0, 942, 946, 5, 72, 0, 0, 943, 947, 5, 499, 0,
		0, 944, 945, 5, 499, 0, 0, 945, 947, 5, 372, 0, 0, 946, 943, 1, 0, 0, 0,
		946, 944, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948,
		950, 5, 153, 0, 0, 949, 951, 3, 338, 169, 0, 950, 949, 1, 0, 0, 0, 950,
		951, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 952, 953, 3, 272, 136, 0, 953, 954,
		5, 17, 0, 0, 954, 957, 3, 310, 155, 0, 955, 956, 5, 196, 0, 0, 956, 958,
		7, 16, 0, 0, 957, 955, 1, 0, 0, 0, 957, 958, 1, 0, 0, 0, 958, 960, 1, 0,
		0, 0, 959, 961, 3, 110, 55, 0, 960, 959, 1, 0, 0, 0, 960, 961, 1, 0, 0,
		0, 961, 109, 1, 0, 0, 0, 962, 963, 5, 414, 0, 0, 963, 964, 5, 465, 0, 0,
		964, 970, 3, 112, 56, 0, 965, 966, 5, 522, 0, 0, 966, 967, 5, 465, 0, 0,
		967, 969, 3, 112, 56, 0, 968, 965, 1, 0, 0, 0, 969, 972, 1, 0, 0, 0, 970,
		968, 1, 0, 0, 0, 970, 971, 1, 0, 0, 0, 971, 111, 1, 0, 0, 0, 972, 970,
		1, 0, 0, 0, 973, 974, 5, 539, 0, 0, 974, 113, 1, 0, 0, 0, 975, 976, 5,
		8, 0, 0, 976, 978, 5, 375, 0, 0, 977, 979, 3, 340, 170, 0, 978, 977, 1,
		0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 986, 3, 328,
		164, 0, 981, 987, 3, 116, 58, 0, 982, 987, 3, 118, 59, 0, 983, 987, 3,
		120, 60, 0, 984, 987, 3, 122, 61, 0, 985, 987, 3, 124, 62, 0, 986, 981,
		1, 0, 0, 0, 986, 982, 1, 0, 0, 0, 986, 983, 1, 0, 0, 0, 986, 984, 1, 0,
		0, 0, 986, 985, 1, 0, 0, 0, 987, 115, 1, 0, 0, 0, 988, 990, 5, 313, 0,
		0, 989, 991, 3, 334, 167, 0, 990, 989, 1, 0, 0, 0, 990, 991, 1, 0, 0, 0,
		991, 992, 1, 0, 0, 0, 992, 993, 5, 390, 0, 0, 993, 994, 3, 334, 167, 0,
		994, 117, 1, 0, 0, 0, 995, 996, 5, 342, 0, 0, 996, 997, 3, 342, 171, 0,
		997, 119, 1, 0, 0, 0, 998, 999, 5, 439, 0, 0, 999, 1000, 5, 64, 0, 0, 1000,
		1001, 3, 86, 43, 0, 1001, 1002, 5, 290, 0, 0, 1002, 1003, 5, 468, 0, 0,
		1003, 1005, 3, 56, 28, 0, 1004, 1006, 3, 126, 63, 0, 1005, 1004, 1, 0,
		0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 121, 1, 0, 0, 0, 1007, 1008, 5, 116,
		0, 0, 1008, 1009, 5, 64, 0, 0, 1009, 1010, 3, 86, 43, 0, 1010, 123, 1,
		0, 0, 0, 1011, 1012, 5, 439, 0, 0, 1012, 1013, 5, 405, 0, 0, 1013, 1014,
		3, 56, 28, 0, 1014, 125, 1, 0, 0, 0, 1015, 1016, 5, 242, 0, 0, 1016, 1017,
		5, 125, 0, 0, 1017, 127, 1, 0, 0, 0, 1018, 1019, 5, 8, 0, 0, 1019, 1020,
		5, 503, 0, 0, 1020, 1024, 3, 330, 165, 0, 1021, 1025, 3, 116, 58, 0, 1022,
		1023, 5, 17, 0, 0, 1023, 1025, 3, 158, 79, 0, 1024, 1021, 1, 0, 0, 0, 1024,
		1022, 1, 0, 0, 0, 1025, 129, 1, 0, 0, 0, 1026, 1027, 5, 8, 0, 0, 1027,
		1028, 5, 449, 0, 0, 1028, 1029, 3, 322, 161, 0, 1029, 1030, 3, 118, 59,
		0, 1030, 131, 1, 0, 0, 0, 1031, 1035, 5, 8, 0, 0, 1032, 1036, 5, 499, 0,
		0, 1033, 1034, 5, 499, 0, 0, 1034, 1036, 5, 372, 0, 0, 1035, 1032, 1, 0,
		0, 0, 1035, 1033, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1037, 1, 0,
		0, 0, 1037, 1039, 5, 153, 0, 0, 1038, 1040, 3, 340, 170, 0, 1039, 1038,
		1, 0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1042,
		3, 274, 137, 0, 1042, 1043, 5, 17, 0, 0, 1043, 1046, 3, 310, 155, 0, 1044,
		1045, 5, 196, 0, 0, 1045, 1047, 7, 16, 0, 0, 1046, 1044, 1, 0, 0, 0, 1046,
		1047, 1, 0, 0, 0, 1047, 133, 1, 0, 0, 0, 1048, 1049, 5, 116, 0, 0, 1049,
		1051, 5, 443, 0, 0, 1050, 1052, 3, 340, 170, 0, 1051, 1050, 1, 0, 0, 0,
		1051, 1052, 1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 1054, 3, 318, 159,
		0, 1054, 135, 1, 0, 0, 0, 1055, 1057, 5, 116, 0, 0, 1056, 1058, 5, 499,
		0, 0, 1057, 1056, 1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 1059, 1, 0,
		0, 0, 1059, 1061, 5, 375, 0, 0, 1060, 1062, 3, 340, 170, 0, 1061, 1060,
		1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1063, 1, 0, 0, 0, 1063, 1064,
		3, 328, 164, 0, 1064, 137, 1, 0, 0, 0, 1065, 1066, 5, 116, 0, 0, 1066,
		1068, 5, 449, 0, 0, 1067, 1069, 3, 340, 170, 0, 1068, 1067, 1, 0, 0, 0,
		1068, 1069, 1, 0, 0, 0, 1069, 1070, 1, 0, 0, 0, 1070, 1072, 3, 322, 161,
		0, 1071, 1073, 7, 17, 0, 0, 1072, 1071, 1, 0, 0, 0, 1072, 1073, 1, 0, 0,
		0, 1073, 139, 1, 0, 0, 0, 1074, 1076, 5, 116, 0, 0, 1075, 1077, 5, 499,
		0, 0, 1076, 1075, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1078, 1, 0,
		0, 0, 1078, 1080, 5, 503, 0, 0, 1079, 1081, 3, 340, 170, 0, 1080, 1079,
		1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082, 1083,
		3, 330, 165, 0, 1083, 141, 1, 0, 0, 0, 1084, 1088, 5, 116, 0, 0, 1085,
		1089, 5, 499, 0, 0, 1086, 1087, 5, 499, 0, 0, 1087, 1089, 5, 372, 0, 0,
		1088, 1085, 1, 0, 0, 0, 1088, 1086, 1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0,
		1089, 1090, 1, 0, 0, 0, 1090, 1092, 5, 153, 0, 0, 1091, 1093, 3, 340, 170,
		0, 1092, 1091, 1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093, 1094, 1, 0, 0,
		0, 1094, 1095, 3, 274, 137, 0, 1095, 143, 1, 0, 0, 0, 1096, 1098, 5, 132,
		0, 0, 1097, 1096, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 1099, 1, 0,
		0, 0, 1099, 1104, 3, 146, 73, 0, 1100, 1104, 3, 154, 77, 0, 1101, 1102,
		5, 132, 0, 0, 1102, 1104, 3, 156, 78, 0, 1103, 1097, 1, 0, 0, 0, 1103,
		1100, 1, 0, 0, 0, 1103, 1101, 1, 0, 0, 0, 1104, 145, 1, 0, 0, 0, 1105,
		1106, 5, 177, 0, 0, 1106, 1107, 7, 18, 0, 0, 1107, 1116, 3, 328, 164, 0,
		1108, 1110, 3, 148, 74, 0, 1109, 1108, 1, 0, 0, 0, 1109, 1110, 1, 0, 0,
		0, 1110, 1112, 1, 0, 0, 0, 1111, 1113, 3, 56, 28, 0, 1112, 1111, 1, 0,
		0, 0, 1112, 1113, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114, 1117, 3, 158,
		79, 0, 1115, 1117, 3, 150, 75, 0, 1116, 1109, 1, 0, 0, 0, 1116, 1115, 1,
		0, 0, 0, 1117, 147, 1, 0, 0, 0, 1118, 1119, 5, 269, 0, 0, 1119, 1120, 3,
		342, 171, 0, 1120, 149, 1, 0, 0, 0, 1121, 1122, 5, 416, 0, 0, 1122, 1127,
		3, 152, 76, 0, 1123, 1124, 5, 522, 0, 0, 1124, 1126, 3, 152, 76, 0, 1125,
		1123, 1, 0, 0, 0, 1126, 1129, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1127,
		1128, 1, 0, 0, 0, 1128, 151, 1, 0, 0, 0, 1129, 1127, 1, 0, 0, 0, 1130,
		1131, 5, 518, 0, 0, 1131, 1136, 3, 360, 180, 0, 1132, 1133, 5, 522, 0,
		0, 1133, 1135, 3, 360, 180, 0, 1134, 1132, 1, 0, 0, 0, 1135, 1138, 1, 0,
		0, 0, 1136, 1134, 1, 0, 0, 0, 1136, 1137, 1, 0, 0, 0, 1137, 1139, 1, 0,
		0, 0, 1138, 1136, 1, 0, 0, 0, 1139, 1140, 5, 519, 0, 0, 1140, 153, 1, 0,
		0, 0, 1141, 1142, 5, 24, 0, 0, 1142, 1143, 5, 356, 0, 0, 1143, 1144, 5,
		342, 0, 0, 1144, 1148, 5, 523, 0, 0, 1145, 1146, 3, 146, 73, 0, 1146, 1147,
		5, 523, 0, 0, 1147, 1149, 1, 0, 0, 0, 1148, 1145, 1, 0, 0, 0, 1149, 1150,
		1, 0, 0, 0, 1150, 1148, 1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151, 1152,
		1, 0, 0, 0, 1152, 1153, 5, 122, 0, 0, 1153, 155, 1, 0, 0, 0, 1154, 1155,
		5, 356, 0, 0, 1155, 1156, 5, 342, 0, 0, 1156, 1160, 5, 24, 0, 0, 1157,
		1158, 3, 146, 73, 0, 1158, 1159, 5, 523, 0, 0, 1159, 1161, 1, 0, 0, 0,
		1160, 1157, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1160, 1, 0, 0, 0,
		1162, 1163, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164, 1165, 5, 122, 0,
		0, 1165, 157, 1, 0, 0, 0, 1166, 1167, 6, 79, -1, 0, 1167, 1190, 3, 160,
		80, 0, 1168, 1169, 3, 162, 81, 0, 1169, 1170, 3, 158, 79, 5, 1170, 1190,
		1, 0, 0, 0, 1171, 1172, 5, 518, 0, 0, 1172, 1173, 3, 158, 79, 0, 1173,
		1174, 5, 519, 0, 0, 1174, 1190, 1, 0, 0, 0, 1175, 1177, 3, 170, 85, 0,
		1176, 1178, 3, 230, 115, 0, 1177, 1176, 1, 0, 0, 0, 1177, 1178, 1, 0, 0,
		0, 1178, 1180, 1, 0, 0, 0, 1179, 1181, 3, 234, 117, 0, 1180, 1179, 1, 0,
		0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1190, 1, 0, 0, 0, 1182, 1184, 3, 168,
		84, 0, 1183, 1185, 3, 230, 115, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185,
		1, 0, 0, 0, 1185, 1187, 1, 0, 0, 0, 1186, 1188, 3, 234, 117, 0, 1187, 1186,
		1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 1190, 1, 0, 0, 0, 1189, 1166,
		1, 0, 0, 0, 1189, 1168, 1, 0, 0, 0, 1189, 1171, 1, 0, 0, 0, 1189, 1175,
		1, 0, 0, 0, 1189, 1182, 1, 0, 0, 0, 1190, 1205, 1, 0, 0, 0, 1191, 1192,
		10, 3, 0, 0, 1192, 1194, 7, 19, 0, 0, 1193, 1195, 5, 5, 0, 0, 1194, 1193,
		1, 0, 0, 0, 1194, 1195, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1198,
		3, 158, 79, 0, 1197, 1199, 3, 230, 115, 0, 1198, 1197, 1, 0, 0, 0, 1198,
		1199, 1, 0, 0, 0, 1199, 1201, 1, 0, 0, 0, 1200, 1202, 3, 234, 117, 0, 1201,
		1200, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1204, 1, 0, 0, 0, 1203,
		1191, 1, 0, 0, 0, 1204, 1207, 1, 0, 0, 0, 1205, 1203, 1, 0, 0, 0, 1205,
		1206, 1, 0, 0, 0, 1206, 159, 1, 0, 0, 0, 1207, 1205, 1, 0, 0, 0, 1208,
		1209, 5, 416, 0, 0, 1209, 1214, 3, 258, 129, 0, 1210, 1211, 5, 522, 0,
		0, 1211, 1213, 3, 258, 129, 0, 1212, 1210, 1, 0, 0, 0, 1213, 1216, 1, 0,
		0, 0, 1214, 1212, 1, 0, 0, 0, 1214, 1215, 1, 0, 0, 0, 1215, 161, 1, 0,
		0, 0, 1216, 1214, 1, 0, 0, 0, 1217, 1218, 5, 435, 0, 0, 1218, 1223, 3,
		164, 82, 0, 1219, 1220, 5, 522, 0, 0, 1220, 1222, 3, 164, 82, 0, 1221,
		1219, 1, 0, 0, 0, 1222, 1225, 1, 0, 0, 0, 1223, 1221, 1, 0, 0, 0, 1223,
		1224, 1, 0, 0, 0, 1224, 163, 1, 0, 0, 0, 1225, 1223, 1, 0, 0, 0, 1226,
		1238, 3, 166, 83, 0, 1227, 1228, 5, 518, 0, 0, 1228, 1233, 3, 52, 26, 0,
		1229, 1230, 5, 522, 0, 0, 1230, 1232, 3, 52, 26, 0, 1231, 1229, 1, 0, 0,
		0, 1232, 1235, 1, 0, 0, 0, 1233, 1231, 1, 0, 0, 0, 1233, 1234, 1, 0, 0,
		0, 1234, 1236, 1, 0, 0, 0, 1235, 1233, 1, 0, 0, 0, 1236, 1237, 5, 519,
		0, 0, 1237, 1239, 1, 0, 0, 0, 1238, 1227, 1, 0, 0, 0, 1238, 1239, 1, 0,
		0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 1241, 5, 17, 0, 0, 1241, 1242, 5, 518,
		0, 0, 1242, 1243, 3, 158, 79, 0, 1243, 1244, 5, 519, 0, 0, 1244, 165, 1,
		0, 0, 0, 1245, 1246, 3, 310, 155, 0, 1246, 167, 1, 0, 0, 0, 1247, 1249,
		3, 170, 85, 0, 1248, 1250, 3, 176, 88, 0, 1249, 1248, 1, 0, 0, 0, 1249,
		1250, 1, 0, 0, 0, 1250, 1252, 1, 0, 0, 0, 1251, 1253, 3, 204, 102, 0, 1252,
		1251, 1, 0, 0, 0, 1252, 1253, 1, 0, 0, 0, 1253, 1255, 1, 0, 0, 0, 1254,
		1256, 3, 206, 103, 0, 1255, 1254, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256,
		1258, 1, 0, 0, 0, 1257, 1259, 3, 220, 110, 0, 1258, 1257, 1, 0, 0, 0, 1258,
		1259, 1, 0, 0, 0, 1259, 1261, 1, 0, 0, 0, 1260, 1262, 3, 222, 111, 0, 1261,
		1260, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1268, 1, 0, 0, 0, 1263,
		1264, 3, 170, 85, 0, 1264, 1265, 3, 176, 88, 0, 1265, 1266, 3, 228, 114,
		0, 1266, 1268, 1, 0, 0, 0, 1267, 1247, 1, 0, 0, 0, 1267, 1263, 1, 0, 0,
		0, 1268, 169, 1, 0, 0, 0, 1269, 1271, 5, 338, 0, 0, 1270, 1272, 3, 370,
		185, 0, 1271, 1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 1282, 1,
		0, 0, 0, 1273, 1283, 5, 529, 0, 0, 1274, 1279, 3, 172, 86, 0, 1275, 1276,
		5, 522, 0, 0, 1276, 1278, 3, 172, 86, 0, 1277, 1275, 1, 0, 0, 0, 1278,
		1281, 1, 0, 0, 0, 1279, 1277, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280,
		1283, 1, 0, 0, 0, 1281, 1279, 1, 0, 0, 0, 1282, 1273, 1, 0, 0, 0, 1282,
		1274, 1, 0, 0, 0, 1283, 171, 1, 0, 0, 0, 1284, 1300, 3, 174, 87, 0, 1285,
		1290, 3, 258, 129, 0, 1286, 1288, 5, 17, 0, 0, 1287, 1286, 1, 0, 0, 0,
		1287, 1288, 1, 0, 0, 0, 1288, 1289, 1, 0, 0, 0, 1289, 1291, 3, 52, 26,
		0, 1290, 1287, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 1300, 1, 0, 0,
		0, 1292, 1297, 3, 52, 26, 0, 1293, 1295, 5, 17, 0, 0, 1294, 1293, 1, 0,
		0, 0, 1294, 1295, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 1298, 3, 258,
		129, 0, 1297, 1294, 1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298, 1300, 1,
		0, 0, 0, 1299, 1284, 1, 0, 0, 0, 1299, 1285, 1, 0, 0, 0, 1299, 1292, 1,
		0, 0, 0, 1300, 173, 1, 0, 0, 0, 1301, 1302, 3, 270, 135, 0, 1302, 1303,
		5, 263, 0, 0, 1303, 1304, 3, 226, 113, 0, 1304, 1305, 5, 17, 0, 0, 1305,
		1306, 3, 310, 155, 0, 1306, 1314, 1, 0, 0, 0, 1307, 1308, 3, 270, 135,
		0, 1308, 1309, 5, 263, 0, 0, 1309, 1310, 3, 302, 151, 0, 1310, 1311, 5,
		17, 0, 0, 1311, 1312, 3, 310, 155, 0, 1312, 1314, 1, 0, 0, 0, 1313, 1301,
		1, 0, 0, 0, 1313, 1307, 1, 0, 0, 0, 1314, 175, 1, 0, 0, 0, 1315, 1316,
		5, 151, 0, 0, 1316, 1317, 3, 178, 89, 0, 1317, 177, 1, 0, 0, 0, 1318, 1319,
		6, 89, -1, 0, 1319, 1324, 3, 180, 90, 0, 1320, 1321, 5, 522, 0, 0, 1321,
		1323, 3, 180, 90, 0, 1322, 1320, 1, 0, 0, 0, 1323, 1326, 1, 0, 0, 0, 1324,
		1322, 1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 1330, 1, 0, 0, 0, 1326,
		1324, 1, 0, 0, 0, 1327, 1330, 3, 188, 94, 0, 1328, 1330, 3, 190, 95, 0,
		1329, 1318, 1, 0, 0, 0, 1329, 1327, 1, 0, 0, 0, 1329, 1328, 1, 0, 0, 0,
		1330, 1352, 1, 0, 0, 0, 1331, 1332, 10, 3, 0, 0, 1332, 1333, 5, 73, 0,
		0, 1333, 1334, 5, 185, 0, 0, 1334, 1351, 3, 178, 89, 4, 1335, 1337, 10,
		4, 0, 0, 1336, 1338, 5, 234, 0, 0, 1337, 1336, 1, 0, 0, 0, 1337, 1338,
		1, 0, 0, 0, 1338, 1340, 1, 0, 0, 0, 1339, 1341, 7, 20, 0, 0, 1340, 1339,
		1, 0, 0, 0, 1340, 1341, 1, 0, 0, 0, 1341, 1343, 1, 0, 0, 0, 1342, 1344,
		5, 262, 0, 0, 1343, 1342, 1, 0, 0, 0, 1343, 1344, 1, 0, 0, 0, 1344, 1345,
		1, 0, 0, 0, 1345, 1346, 5, 185, 0, 0, 1346, 1348, 3, 178, 89, 0, 1347,
		1349, 3, 202, 101, 0, 1348, 1347, 1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0, 1349,
		1351, 1, 0, 0, 0, 1350, 1331, 1, 0, 0, 0, 1350, 1335, 1, 0, 0, 0, 1351,
		1354, 1, 0, 0, 0, 1352, 1350, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353,
		179, 1, 0, 0, 0, 1354, 1352, 1, 0, 0, 0, 1355, 1357, 3, 182, 91, 0, 1356,
		1358, 3, 300, 150, 0, 1357, 1356, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0, 1358,
		181, 1, 0, 0, 0, 1359, 1361, 5, 375, 0, 0, 1360, 1359, 1, 0, 0, 0, 1360,
		1361, 1, 0, 0, 0, 1361, 1362, 1, 0, 0, 0, 1362, 1364, 3, 328, 164, 0, 1363,
		1365, 3, 184, 92, 0, 1364, 1363, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365,
		1389, 1, 0, 0, 0, 1366, 1368, 3, 330, 165, 0, 1367, 1369, 3, 184, 92, 0,
		1368, 1367, 1, 0, 0, 0, 1368, 1369, 1, 0, 0, 0, 1369, 1389, 1, 0, 0, 0,
		1370, 1371, 5, 199, 0, 0, 1371, 1372, 5, 375, 0, 0, 1372, 1373, 5, 518,
		0, 0, 1373, 1374, 3, 268, 134, 0, 1374, 1375, 5, 519, 0, 0, 1375, 1389,
		1, 0, 0, 0, 1376, 1378, 5, 199, 0, 0, 1377, 1376, 1, 0, 0, 0, 1377, 1378,
		1, 0, 0, 0, 1378, 1379, 1, 0, 0, 0, 1379, 1380, 5, 518, 0, 0, 1380, 1381,
		3, 158, 79, 0, 1381, 1382, 5, 519, 0, 0, 1382, 1389, 1, 0, 0, 0, 1383,
		1384, 5, 407, 0, 0, 1384, 1385, 5, 518, 0, 0, 1385, 1386, 3, 258, 129,
		0, 1386, 1387, 5, 519, 0, 0, 1387, 1389, 1, 0, 0, 0, 1388, 1360, 1, 0,
		0, 0, 1388, 1366, 1, 0, 0, 0, 1388, 1370, 1, 0, 0, 0, 1388, 1377, 1, 0,
		0, 0, 1388, 1383, 1, 0, 0, 0, 1389, 183, 1, 0, 0, 0, 1390, 1391, 5, 146,
		0, 0, 1391, 1392, 5, 373, 0, 0, 1392, 1393, 5, 17, 0, 0, 1393, 1394, 5,
		250, 0, 0, 1394, 1395, 3, 186, 93, 0, 1395, 185, 1, 0, 0, 0, 1396, 1397,
		3, 258, 129, 0, 1397, 187, 1, 0, 0, 0, 1398, 1399, 5, 518, 0, 0, 1399,
		1400, 3, 150, 75, 0, 1400, 1401, 5, 519, 0, 0, 1401, 1402, 3, 300, 150,
		0, 1402, 189, 1, 0, 0, 0, 1403, 1404, 5, 375, 0, 0, 1404, 1405, 5, 518,
		0, 0, 1405, 1406, 3, 192, 96, 0, 1406, 1407, 5, 519, 0, 0, 1407, 191, 1,
		0, 0, 0, 1408, 1409, 3, 194, 97, 0, 1409, 1410, 5, 518, 0, 0, 1410, 1415,
		3, 196, 98, 0, 1411, 1412, 5, 522, 0, 0, 1412, 1414, 3, 196, 98, 0, 1413,
		1411, 1, 0, 0, 0, 1414, 1417, 1, 0, 0, 0, 1415, 1413, 1, 0, 0, 0, 1415,
		1416, 1, 0, 0, 0, 1416, 1418, 1, 0, 0, 0, 1417, 1415, 1, 0, 0, 0, 1418,
		1419, 5, 519, 0, 0, 1419, 193, 1, 0, 0, 0, 1420, 1421, 7, 21, 0, 0, 1421,
		195, 1, 0, 0, 0, 1422, 1423, 5, 375, 0, 0, 1423, 1438, 3, 218, 109, 0,
		1424, 1438, 3, 200, 100, 0, 1425, 1438, 3, 288, 144, 0, 1426, 1427, 5,
		448, 0, 0, 1427, 1428, 5, 538, 0, 0, 1428, 1429, 5, 375, 0, 0, 1429, 1438,
		3, 218, 109, 0, 1430, 1431, 5, 500, 0, 0, 1431, 1432, 5, 538, 0, 0, 1432,
		1438, 3, 200, 100, 0, 1433, 1434, 3, 198, 99, 0, 1434, 1435, 5, 538, 0,
		0, 1435, 1436, 3, 288, 144, 0, 1436, 1438, 1, 0, 0, 0, 1437, 1422, 1, 0,
		0, 0, 1437, 1424, 1, 0, 0, 0, 1437, 1425, 1, 0, 0, 0, 1437, 1426, 1, 0,
		0, 0, 1437, 1430, 1, 0, 0, 0, 1437, 1433, 1, 0, 0, 0, 1438, 197, 1, 0,
		0, 0, 1439, 1440, 7, 22, 0, 0, 1440, 199, 1, 0, 0, 0, 1441, 1442, 5, 453,
		0, 0, 1442, 1443, 5, 518, 0, 0, 1443, 1444, 3, 52, 26, 0, 1444, 1445, 5,
		519, 0, 0, 1445, 201, 1, 0, 0, 0, 1446, 1447, 5, 254, 0, 0, 1447, 1451,
		3, 260, 130, 0, 1448, 1449, 5, 414, 0, 0, 1449, 1451, 3, 56, 28, 0, 1450,
		1446, 1, 0, 0, 0, 1450, 1448, 1, 0, 0, 0, 1451, 203, 1, 0, 0, 0, 1452,
		1453, 5, 432, 0, 0, 1453, 1454, 3, 260, 130, 0, 1454, 205, 1, 0, 0, 0,
		1455, 1456, 5, 159, 0, 0, 1456, 1457, 5, 34, 0, 0, 1457, 1462, 3, 208,
		104, 0, 1458, 1459, 5, 522, 0, 0, 1459, 1461, 3, 208, 104, 0, 1460, 1458,
		1, 0, 0, 0, 1461, 1464, 1, 0, 0, 0, 1462, 1460, 1, 0, 0, 0, 1462, 1463,
		1, 0, 0, 0, 1463, 207, 1, 0, 0, 0, 1464, 1462, 1, 0, 0, 0, 1465, 1506,
		3, 52, 26, 0, 1466, 1506, 3, 214, 107, 0, 1467, 1468, 5, 518, 0, 0, 1468,
		1506, 5, 519, 0, 0, 1469, 1470, 5, 518, 0, 0, 1470, 1475, 3, 258, 129,
		0, 1471, 1472, 5, 522, 0, 0, 1472, 1474, 3, 258, 129, 0, 1473, 1471, 1,
		0, 0, 0, 1474, 1477, 1, 0, 0, 0, 1475, 1473, 1, 0, 0, 0, 1475, 1476, 1,
		0, 0, 0, 1476, 1478, 1, 0, 0, 0, 1477, 1475, 1, 0, 0, 0, 1478, 1479, 5,
		519, 0, 0, 1479, 1506, 1, 0, 0, 0, 1480, 1481, 3, 212, 106, 0, 1481, 1482,
		5, 518, 0, 0, 1482, 1487, 3, 258, 129, 0, 1483, 1484, 5, 522, 0, 0, 1484,
		1486, 3, 258, 129, 0, 1485, 1483, 1, 0, 0, 0, 1486, 1489, 1, 0, 0, 0, 1487,
		1485, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 1490, 1, 0, 0, 0, 1489,
		1487, 1, 0, 0, 0, 1490, 1491, 5, 519, 0, 0, 1491, 1506, 1, 0, 0, 0, 1492,
		1493, 3, 210, 105, 0, 1493, 1494, 5, 518, 0, 0, 1494, 1499, 3, 208, 104,
		0, 1495, 1496, 5, 522, 0, 0, 1496, 1498, 3, 208, 104, 0, 1497, 1495, 1,
		0, 0, 0, 1498, 1501, 1, 0, 0, 0, 1499, 1497, 1, 0, 0, 0, 1499, 1500, 1,
		0, 0, 0, 1500, 1502, 1, 0, 0, 0, 1501, 1499, 1, 0, 0, 0, 1502, 1503, 5,
		519, 0, 0, 1503, 1506, 1, 0, 0, 0, 1504, 1506, 3, 258, 129, 0, 1505, 1465,
		1, 0, 0, 0, 1505, 1466, 1, 0, 0, 0, 1505, 1467, 1, 0, 0, 0, 1505, 1469,
		1, 0, 0, 0, 1505, 1480, 1, 0, 0, 0, 1505, 1492, 1, 0, 0, 0, 1505, 1504,
		1, 0, 0, 0, 1506, 209, 1, 0, 0, 0, 1507, 1508, 5, 160, 0, 0, 1508, 1509,
		5, 495, 0, 0, 1509, 211, 1, 0, 0, 0, 1510, 1511, 7, 23, 0, 0, 1511, 213,
		1, 0, 0, 0, 1512, 1513, 3, 216, 108, 0, 1513, 1514, 5, 518, 0, 0, 1514,
		1515, 3, 218, 109, 0, 1515, 1516, 5, 522, 0, 0, 1516, 1517, 3, 288, 144,
		0, 1517, 1518, 5, 519, 0, 0, 1518, 215, 1, 0, 0, 0, 1519, 1520, 7, 24,
		0, 0, 1520, 217, 1, 0, 0, 0, 1521, 1522, 3, 334, 167, 0, 1522, 219, 1,
		0, 0, 0, 1523, 1524, 5, 163, 0, 0, 1524, 1525, 3, 260, 130, 0, 1525, 221,
		1, 0, 0, 0, 1526, 1527, 5, 434, 0, 0, 1527, 1532, 3, 224, 112, 0, 1528,
		1529, 5, 522, 0, 0, 1529, 1531, 3, 224, 112, 0, 1530, 1528, 1, 0, 0, 0,
		1531, 1534, 1, 0, 0, 0, 1532, 1530, 1, 0, 0, 0, 1532, 1533, 1, 0, 0, 0,
		1533, 223, 1, 0, 0, 0, 1534, 1532, 1, 0, 0, 0, 1535, 1536, 3, 302, 151,
		0, 1536, 1537, 5, 17, 0, 0, 1537, 1538, 3, 226, 113, 0, 1538, 225, 1, 0,
		0, 0, 1539, 1541, 3, 302, 151, 0, 1540, 1539, 1, 0, 0, 0, 1540, 1541, 1,
		0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1544, 5, 518, 0, 0, 1543, 1545,
		3, 236, 118, 0, 1544, 1543, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1547,
		1, 0, 0, 0, 1546, 1548, 3, 230, 115, 0, 1547, 1546, 1, 0, 0, 0, 1547, 1548,
		1, 0, 0, 0, 1548, 1550, 1, 0, 0, 0, 1549, 1551, 3, 252, 126, 0, 1550, 1549,
		1, 0, 0, 0, 1550, 1551, 1, 0, 0, 0, 1551, 1552, 1, 0, 0, 0, 1552, 1553,
		5, 519, 0, 0, 1553, 227, 1, 0, 0, 0, 1554, 1555, 5, 214, 0, 0, 1555, 1557,
		5, 518, 0, 0, 1556, 1558, 3, 236, 118, 0, 1557, 1556, 1, 0, 0, 0, 1557,
		1558, 1, 0, 0, 0, 1558, 1560, 1, 0, 0, 0, 1559, 1561, 3, 230, 115, 0, 1560,
		1559, 1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1563, 1, 0, 0, 0, 1562,
		1564, 3, 240, 120, 0, 1563, 1562, 1, 0, 0, 0, 1563, 1564, 1, 0, 0, 0, 1564,
		1566, 1, 0, 0, 0, 1565, 1567, 3, 246, 123, 0, 1566, 1565, 1, 0, 0, 0, 1566,
		1567, 1, 0, 0, 0, 1567, 1569, 1, 0, 0, 0, 1568, 1570, 3, 248, 124, 0, 1569,
		1568, 1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570, 1572, 1, 0, 0, 0, 1571,
		1573, 3, 242, 121, 0, 1572, 1571, 1, 0, 0, 0, 1572, 1573, 1, 0, 0, 0, 1573,
		1574, 1, 0, 0, 0, 1574, 1575, 3, 250, 125, 0, 1575, 1580, 5, 519, 0, 0,
		1576, 1578, 5, 17, 0, 0, 1577, 1576, 1, 0, 0, 0, 1577, 1578, 1, 0, 0, 0,
		1578, 1579, 1, 0, 0, 0, 1579, 1581, 3, 310, 155, 0, 1580, 1577, 1, 0, 0,
		0, 1580, 1581, 1, 0, 0, 0, 1581, 229, 1, 0, 0, 0, 1582, 1583, 5, 259, 0,
		0, 1583, 1584, 5, 34, 0, 0, 1584, 1589, 3, 232, 116, 0, 1585, 1586, 5,
		522, 0, 0, 1586, 1588, 3, 232, 116, 0, 1587, 1585, 1, 0, 0, 0, 1588, 1591,
		1, 0, 0, 0, 1589, 1587, 1, 0, 0, 0, 1589, 1590, 1, 0, 0, 0, 1590, 231,
		1, 0, 0, 0, 1591, 1589, 1, 0, 0, 0, 1592, 1594, 3, 52, 26, 0, 1593, 1595,
		7, 25, 0, 0, 1594, 1593, 1, 0, 0, 0, 1594, 1595, 1, 0, 0, 0, 1595, 1598,
		1, 0, 0, 0, 1596, 1597, 5, 478, 0, 0, 1597, 1599, 7, 26, 0, 0, 1598, 1596,
		1, 0, 0, 0, 1598, 1599, 1, 0, 0, 0, 1599, 233, 1, 0, 0, 0, 1600, 1603,
		5, 205, 0, 0, 1601, 1604, 5, 5, 0, 0, 1602, 1604, 3, 258, 129, 0, 1603,
		1601, 1, 0, 0, 0, 1603, 1602, 1, 0, 0, 0, 1604, 235, 1, 0, 0, 0, 1605,
		1606, 5, 269, 0, 0, 1606, 1609, 5, 34, 0, 0, 1607, 1610, 3, 52, 26, 0,
		1608, 1610, 3, 270, 135, 0, 1609, 1607, 1, 0, 0, 0, 1609, 1608, 1, 0, 0,
		0, 1610, 1618, 1, 0, 0, 0, 1611, 1614, 5, 522, 0, 0, 1612, 1615, 3, 52,
		26, 0, 1613, 1615, 3, 270, 135, 0, 1614, 1612, 1, 0, 0, 0, 1614, 1613,
		1, 0, 0, 0, 1615, 1617, 1, 0, 0, 0, 1616, 1611, 1, 0, 0, 0, 1617, 1620,
		1, 0, 0, 0, 1618, 1616, 1, 0, 0, 0, 1618, 1619, 1, 0, 0, 0, 1619, 237,
		1, 0, 0, 0, 1620, 1618, 1, 0, 0, 0, 1621, 1638, 5, 529, 0, 0, 1622, 1638,
		5, 532, 0, 0, 1623, 1638, 5, 537, 0, 0, 1624, 1625, 5, 520, 0, 0, 1625,
		1626, 5, 540, 0, 0, 1626, 1627, 5, 522, 0, 0, 1627, 1628, 5, 540, 0, 0,
		1628, 1638, 5, 521, 0, 0, 1629, 1630, 5, 520, 0, 0, 1630, 1631, 5, 540,
		0, 0, 1631, 1632, 5, 522, 0, 0, 1632, 1638, 5, 521, 0, 0, 1633, 1634, 5,
		520, 0, 0, 1634, 1635, 5, 522, 0, 0, 1635, 1636, 5, 540, 0, 0, 1636, 1638,
		5, 521, 0, 0, 1637, 1621, 1, 0, 0, 0, 1637, 1622, 1, 0, 0, 0, 1637, 1623,
		1, 0, 0, 0, 1637, 1624, 1, 0, 0, 0, 1637, 1629, 1, 0, 0, 0, 1637, 1633,
		1, 0, 0, 0, 1638, 239, 1, 0, 0, 0, 1639, 1640, 5, 216, 0, 0, 1640, 1645,
		3, 172, 86, 0, 1641, 1642, 5, 522, 0, 0, 1642, 1644, 3, 172, 86, 0, 1643,
		1641, 1, 0, 0, 0, 1644, 1647, 1, 0, 0, 0, 1645, 1643, 1, 0, 0, 0, 1645,
		1646, 1, 0, 0, 0, 1646, 241, 1, 0, 0, 0, 1647, 1645, 1, 0, 0, 0, 1648,
		1649, 5, 272, 0, 0, 1649, 1651, 5, 518, 0, 0, 1650, 1652, 3, 244, 122,
		0, 1651, 1650, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1651, 1, 0, 0,
		0, 1653, 1654, 1, 0, 0, 0, 1654, 1655, 1, 0, 0, 0, 1655, 1657, 5, 519,
		0, 0, 1656, 1658, 3, 256, 128, 0, 1657, 1656, 1, 0, 0, 0, 1657, 1658, 1,
		0, 0, 0, 1658, 243, 1, 0, 0, 0, 1659, 1661, 3, 312, 156, 0, 1660, 1662,
		3, 238, 119, 0, 1661, 1660, 1, 0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662, 245,
		1, 0, 0, 0, 1663, 1664, 5, 5, 0, 0, 1664, 1665, 5, 324, 0, 0, 1665, 1666,
		5, 273, 0, 0, 1666, 1672, 5, 211, 0, 0, 1667, 1668, 5, 255, 0, 0, 1668,
		1669, 5, 323, 0, 0, 1669, 1670, 5, 273, 0, 0, 1670, 1672, 5, 211, 0, 0,
		1671, 1663, 1, 0, 0, 0, 1671, 1667, 1, 0, 0, 0, 1672, 247, 1, 0, 0, 0,
		1673, 1674, 5, 440, 0, 0, 1674, 1675, 5, 211, 0, 0, 1675, 1676, 5, 345,
		0, 0, 1676, 1677, 5, 480, 0, 0, 1677, 1678, 5, 469, 0, 0, 1678, 1698, 5,
		323, 0, 0, 1679, 1680, 5, 440, 0, 0, 1680, 1681, 5, 211, 0, 0, 1681, 1682,
		5, 345, 0, 0, 1682, 1683, 5, 390, 0, 0, 1683, 1684, 5, 238, 0, 0, 1684,
		1698, 5, 323, 0, 0, 1685, 1686, 5, 440, 0, 0, 1686, 1687, 5, 211, 0, 0,
		1687, 1688, 5, 345, 0, 0, 1688, 1689, 5, 390, 0, 0, 1689, 1690, 5, 469,
		0, 0, 1690, 1698, 3, 312, 156, 0, 1691, 1692, 5, 440, 0, 0, 1692, 1693,
		5, 211, 0, 0, 1693, 1694, 5, 345, 0, 0, 1694, 1695, 5, 390, 0, 0, 1695,
		1696, 5, 459, 0, 0, 1696, 1698, 3, 312, 156, 0, 1697, 1673, 1, 0, 0, 0,
		1697, 1679, 1, 0, 0, 0, 1697, 1685, 1, 0, 0, 0, 1697, 1691, 1, 0, 0, 0,
		1698, 249, 1, 0, 0, 0, 1699, 1700, 5, 105, 0, 0, 1700, 1705, 3, 172, 86,
		0, 1701, 1702, 5, 522, 0, 0, 1702, 1704, 3, 172, 86, 0, 1703, 1701, 1,
		0, 0, 0, 1704, 1707, 1, 0, 0, 0, 1705, 1703, 1, 0, 0, 0, 1705, 1706, 1,
		0, 0, 0, 1706, 251, 1, 0, 0, 0, 1707, 1705, 1, 0, 0, 0, 1708, 1709, 5,
		294, 0, 0, 1709, 1710, 5, 27, 0, 0, 1710, 1711, 3, 288, 144, 0, 1711, 1712,
		3, 254, 127, 0, 1712, 1718, 1, 0, 0, 0, 1713, 1714, 5, 324, 0, 0, 1714,
		1715, 5, 27, 0, 0, 1715, 1716, 5, 540, 0, 0, 1716, 1718, 3, 254, 127, 0,
		1717, 1708, 1, 0, 0, 0, 1717, 1713, 1, 0, 0, 0, 1718, 253, 1, 0, 0, 0,
		1719, 1720, 5, 482, 0, 0, 1720, 1721, 5, 10, 0, 0, 1721, 1722, 5, 76, 0,
		0, 1722, 1723, 5, 323, 0, 0, 1723, 255, 1, 0, 0, 0, 1724, 1725, 5, 436,
		0, 0, 1725, 1726, 3, 288, 144, 0, 1726, 257, 1, 0, 0, 0, 1727, 1728, 3,
		260, 130, 0, 1728, 259, 1, 0, 0, 0, 1729, 1730, 6, 130, -1, 0, 1730, 1731,
		5, 242, 0, 0, 1731, 1742, 3, 260, 130, 6, 1732, 1733, 5, 133, 0, 0, 1733,
		1734, 5, 518, 0, 0, 1734, 1735, 3, 158, 79, 0, 1735, 1736, 5, 519, 0, 0,
		1736, 1742, 1, 0, 0, 0, 1737, 1739, 3, 266, 133, 0, 1738, 1740, 3, 262,
		131, 0, 1739, 1738, 1, 0, 0, 0, 1739, 1740, 1, 0, 0, 0, 1740, 1742, 1,
		0, 0, 0, 1741, 1729, 1, 0, 0, 0, 1741, 1732, 1, 0, 0, 0, 1741, 1737, 1,
		0, 0, 0, 1742, 1757, 1, 0, 0, 0, 1743, 1744, 10, 3, 0, 0, 1744, 1745, 5,
		10, 0, 0, 1745, 1756, 3, 260, 130, 4, 1746, 1747, 10, 2, 0, 0, 1747, 1748,
		5, 258, 0, 0, 1748, 1756, 3, 260, 130, 3, 1749, 1750, 10, 1, 0, 0, 1750,
		1752, 5, 184, 0, 0, 1751, 1753, 5, 242, 0, 0, 1752, 1751, 1, 0, 0, 0, 1752,
		1753, 1, 0, 0, 0, 1753, 1754, 1, 0, 0, 0, 1754, 1756, 7, 27, 0, 0, 1755,
		1743, 1, 0, 0, 0, 1755, 1746, 1, 0, 0, 0, 1755, 1749, 1, 0, 0, 0, 1756,
		1759, 1, 0, 0, 0, 1757, 1755, 1, 0, 0, 0, 1757, 1758, 1, 0, 0, 0, 1758,
		261, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1760, 1762, 5, 242, 0, 0, 1761,
		1760, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762, 1763, 1, 0, 0, 0, 1763,
		1765, 5, 27, 0, 0, 1764, 1766, 7, 28, 0, 0, 1765, 1764, 1, 0, 0, 0, 1765,
		1766, 1, 0, 0, 0, 1766, 1767, 1, 0, 0, 0, 1767, 1768, 3, 266, 133, 0, 1768,
		1769, 5, 10, 0, 0, 1769, 1770, 3, 266, 133, 0, 1770, 1835, 1, 0, 0, 0,
		1771, 1773, 5, 242, 0, 0, 1772, 1771, 1, 0, 0, 0, 1772, 1773, 1, 0, 0,
		0, 1773, 1774, 1, 0, 0, 0, 1774, 1775, 5, 170, 0, 0, 1775, 1776, 5, 518,
		0, 0, 1776, 1781, 3, 258, 129, 0, 1777, 1778, 5, 522, 0, 0, 1778, 1780,
		3, 258, 129, 0, 1779, 1777, 1, 0, 0, 0, 1780, 1783, 1, 0, 0, 0, 1781, 1779,
		1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1784, 1, 0, 0, 0, 1783, 1781,
		1, 0, 0, 0, 1784, 1785, 5, 519, 0, 0, 1785, 1835, 1, 0, 0, 0, 1786, 1788,
		5, 242, 0, 0, 1787, 1786, 1, 0, 0, 0, 1787, 1788, 1, 0, 0, 0, 1788, 1789,
		1, 0, 0, 0, 1789, 1790, 5, 170, 0, 0, 1790, 1791, 5, 518, 0, 0, 1791, 1792,
		3, 158, 79, 0, 1792, 1793, 5, 519, 0, 0, 1793, 1835, 1, 0, 0, 0, 1794,
		1795, 5, 133, 0, 0, 1795, 1796, 5, 518, 0, 0, 1796, 1797, 3, 158, 79, 0,
		1797, 1798, 5, 519, 0, 0, 1798, 1835, 1, 0, 0, 0, 1799, 1801, 5, 242, 0,
		0, 1800, 1799, 1, 0, 0, 0, 1800, 1801, 1, 0, 0, 0, 1801, 1802, 1, 0, 0,
		0, 1802, 1803, 5, 320, 0, 0, 1803, 1835, 3, 266, 133, 0, 1804, 1835, 3,
		264, 132, 0, 1805, 1807, 5, 184, 0, 0, 1806, 1808, 5, 242, 0, 0, 1807,
		1806, 1, 0, 0, 0, 1807, 1808, 1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0, 1809,
		1835, 7, 27, 0, 0, 1810, 1812, 5, 184, 0, 0, 1811, 1813, 5, 242, 0, 0,
		1812, 1811, 1, 0, 0, 0, 1812, 1813, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0,
		1814, 1815, 5, 113, 0, 0, 1815, 1816, 5, 151, 0, 0, 1816, 1835, 3, 266,
		133, 0, 1817, 1819, 5, 242, 0, 0, 1818, 1817, 1, 0, 0, 0, 1818, 1819, 1,
		0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1820, 1821, 5, 344, 0, 0, 1821, 1822,
		5, 390, 0, 0, 1822, 1825, 3, 266, 133, 0, 1823, 1824, 5, 127, 0, 0, 1824,
		1826, 3, 364, 182, 0, 1825, 1823, 1, 0, 0, 0, 1825, 1826, 1, 0, 0, 0, 1826,
		1835, 1, 0, 0, 0, 1827, 1828, 5, 184, 0, 0, 1828, 1832, 5, 186, 0, 0, 1829,
		1833, 5, 415, 0, 0, 1830, 1833, 5, 13, 0, 0, 1831, 1833, 3, 310, 155, 0,
		1832, 1829, 1, 0, 0, 0, 1832, 1830, 1, 0, 0, 0, 1832, 1831, 1, 0, 0, 0,
		1832, 1833, 1, 0, 0, 0, 1833, 1835, 1, 0, 0, 0, 1834, 1761, 1, 0, 0, 0,
		1834, 1772, 1, 0, 0, 0, 1834, 1787, 1, 0, 0, 0, 1834, 1794, 1, 0, 0, 0,
		1834, 1800, 1, 0, 0, 0, 1834, 1804, 1, 0, 0, 0, 1834, 1805, 1, 0, 0, 0,
		1834, 1810, 1, 0, 0, 0, 1834, 1818, 1, 0, 0, 0, 1834, 1827, 1, 0, 0, 0,
		1835, 263, 1, 0, 0, 0, 1836, 1838, 5, 242, 0, 0, 1837, 1836, 1, 0, 0, 0,
		1837, 1838, 1, 0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839, 1840, 5, 203, 0,
		0, 1840, 1854, 7, 29, 0, 0, 1841, 1842, 5, 518, 0, 0, 1842, 1855, 5, 519,
		0, 0, 1843, 1844, 5, 518, 0, 0, 1844, 1849, 3, 258, 129, 0, 1845, 1846,
		5, 522, 0, 0, 1846, 1848, 3, 258, 129, 0, 1847, 1845, 1, 0, 0, 0, 1848,
		1851, 1, 0, 0, 0, 1849, 1847, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850,
		1852, 1, 0, 0, 0, 1851, 1849, 1, 0, 0, 0, 1852, 1853, 5, 519, 0, 0, 1853,
		1855, 1, 0, 0, 0, 1854, 1841, 1, 0, 0, 0, 1854, 1843, 1, 0, 0, 0, 1855,
		1866, 1, 0, 0, 0, 1856, 1858, 5, 242, 0, 0, 1857, 1856, 1, 0, 0, 0, 1857,
		1858, 1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0, 1859, 1860, 5, 203, 0, 0, 1860,
		1863, 3, 266, 133, 0, 1861, 1862, 5, 127, 0, 0, 1862, 1864, 3, 364, 182,
		0, 1863, 1861, 1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 1866, 1, 0, 0,
		0, 1865, 1837, 1, 0, 0, 0, 1865, 1857, 1, 0, 0, 0, 1866, 265, 1, 0, 0,
		0, 1867, 1868, 6, 133, -1, 0, 1868, 1872, 3, 270, 135, 0, 1869, 1870, 7,
		30, 0, 0, 1870, 1872, 3, 266, 133, 7, 1871, 1867, 1, 0, 0, 0, 1871, 1869,
		1, 0, 0, 0, 1872, 1894, 1, 0, 0, 0, 1873, 1874, 10, 6, 0, 0, 1874, 1875,
		7, 31, 0, 0, 1875, 1893, 3, 266, 133, 7, 1876, 1877, 10, 5, 0, 0, 1877,
		1878, 7, 32, 0, 0, 1878, 1893, 3, 266, 133, 6, 1879, 1880, 10, 4, 0, 0,
		1880, 1881, 5, 513, 0, 0, 1881, 1893, 3, 266, 133, 5, 1882, 1883, 10, 3,
		0, 0, 1883, 1884, 5, 514, 0, 0, 1884, 1893, 3, 266, 133, 4, 1885, 1886,
		10, 2, 0, 0, 1886, 1887, 5, 512, 0, 0, 1887, 1893, 3, 266, 133, 3, 1888,
		1889, 10, 1, 0, 0, 1889, 1890, 3, 352, 176, 0, 1890, 1891, 3, 266, 133,
		2, 1891, 1893, 1, 0, 0, 0, 1892, 1873, 1, 0, 0, 0, 1892, 1876, 1, 0, 0,
		0, 1892, 1879, 1, 0, 0, 0, 1892, 1882, 1, 0, 0, 0, 1892, 1885, 1, 0, 0,
		0, 1892, 1888, 1, 0, 0, 0, 1893, 1896, 1, 0, 0, 0, 1894, 1892, 1, 0, 0,
		0, 1894, 1895, 1, 0, 0, 0, 1895, 267, 1, 0, 0, 0, 1896, 1894, 1, 0, 0,
		0, 1897, 1917, 3, 378, 189, 0, 1898, 1917, 3, 276, 138, 0, 1899, 1900,
		3, 278, 139, 0, 1900, 1912, 5, 518, 0, 0, 1901, 1903, 3, 370, 185, 0, 1902,
		1901, 1, 0, 0, 0, 1902, 1903, 1, 0, 0, 0, 1903, 1904, 1, 0, 0, 0, 1904,
		1909, 3, 280, 140, 0, 1905, 1906, 5, 522, 0, 0, 1906, 1908, 3, 280, 140,
		0, 1907, 1905, 1, 0, 0, 0, 1908, 1911, 1, 0, 0, 0, 1909, 1907, 1, 0, 0,
		0, 1909, 1910, 1, 0, 0, 0, 1910, 1913, 1, 0, 0, 0, 1911, 1909, 1, 0, 0,
		0, 1912, 1902, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1914, 1, 0, 0,
		0, 1914, 1915, 5, 519, 0, 0, 1915, 1917, 1, 0, 0, 0, 1916, 1897, 1, 0,
		0, 0, 1916, 1898, 1, 0, 0, 0, 1916, 1899, 1, 0, 0, 0, 1917, 269, 1, 0,
		0, 0, 1918, 1919, 6, 135, -1, 0, 1919, 1921, 5, 40, 0, 0, 1920, 1922, 3,
		316, 158, 0, 1921, 1920, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 1921,
		1, 0, 0, 0, 1923, 1924, 1, 0, 0, 0, 1924, 1927, 1, 0, 0, 0, 1925, 1926,
		5, 120, 0, 0, 1926, 1928, 3, 258, 129, 0, 1927, 1925, 1, 0, 0, 0, 1927,
		1928, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1930, 5, 122, 0, 0, 1930,
		1994, 1, 0, 0, 0, 1931, 1932, 5, 40, 0, 0, 1932, 1934, 3, 258, 129, 0,
		1933, 1935, 3, 316, 158, 0, 1934, 1933, 1, 0, 0, 0, 1935, 1936, 1, 0, 0,
		0, 1936, 1934, 1, 0, 0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1940, 1, 0, 0,
		0, 1938, 1939, 5, 120, 0, 0, 1939, 1941, 3, 258, 129, 0, 1940, 1938, 1,
		0, 0, 0, 1940, 1941, 1, 0, 0, 0, 1941, 1942, 1, 0, 0, 0, 1942, 1943, 5,
		122, 0, 0, 1943, 1994, 1, 0, 0, 0, 1944, 1945, 5, 41, 0, 0, 1945, 1946,
		5, 518, 0, 0, 1946, 1947, 3, 258, 129, 0, 1947, 1948, 5, 17, 0, 0, 1948,
		1949, 3, 58, 29, 0, 1949, 1950, 5, 519, 0, 0, 1950, 1994, 1, 0, 0, 0, 1951,
		1952, 5, 459, 0, 0, 1952, 1953, 5, 518, 0, 0, 1953, 1956, 3, 258, 129,
		0, 1954, 1955, 5, 463, 0, 0, 1955, 1957, 5, 478, 0, 0, 1956, 1954, 1, 0,
		0, 0, 1956, 1957, 1, 0, 0, 0, 1957, 1958, 1, 0, 0, 0, 1958, 1959, 5, 519,
		0, 0, 1959, 1994, 1, 0, 0, 0, 1960, 1961, 5, 469, 0, 0, 1961, 1962, 5,
		518, 0, 0, 1962, 1965, 3, 258, 129, 0, 1963, 1964, 5, 463, 0, 0, 1964,
		1966, 5, 478, 0, 0, 1965, 1963, 1, 0, 0, 0, 1965, 1966, 1, 0, 0, 0, 1966,
		1967, 1, 0, 0, 0, 1967, 1968, 5, 519, 0, 0, 1968, 1994, 1, 0, 0, 0, 1969,
		1970, 5, 283, 0, 0, 1970, 1971, 5, 518, 0, 0, 1971, 1972, 3, 266, 133,
		0, 1972, 1973, 5, 170, 0, 0, 1973, 1974, 3, 266, 133, 0, 1974, 1975, 5,
		519, 0, 0, 1975, 1994, 1, 0, 0, 0, 1976, 1994, 3, 360, 180, 0, 1977, 1994,
		5, 529, 0, 0, 1978, 1979, 3, 334, 167, 0, 1979, 1980, 5, 515, 0, 0, 1980,
		1981, 5, 529, 0, 0, 1981, 1994, 1, 0, 0, 0, 1982, 1983, 5, 518, 0, 0, 1983,
		1984, 3, 158, 79, 0, 1984, 1985, 5, 519, 0, 0, 1985, 1994, 1, 0, 0, 0,
		1986, 1994, 3, 268, 134, 0, 1987, 1994, 3, 54, 27, 0, 1988, 1994, 3, 282,
		141, 0, 1989, 1990, 5, 518, 0, 0, 1990, 1991, 3, 258, 129, 0, 1991, 1992,
		5, 519, 0, 0, 1992, 1994, 1, 0, 0, 0, 1993, 1918, 1, 0, 0, 0, 1993, 1931,
		1, 0, 0, 0, 1993, 1944, 1, 0, 0, 0, 1993, 1951, 1, 0, 0, 0, 1993, 1960,
		1, 0, 0, 0, 1993, 1969, 1, 0, 0, 0, 1993, 1976, 1, 0, 0, 0, 1993, 1977,
		1, 0, 0, 0, 1993, 1978, 1, 0, 0, 0, 1993, 1982, 1, 0, 0, 0, 1993, 1986,
		1, 0, 0, 0, 1993, 1987, 1, 0, 0, 0, 1993, 1988, 1, 0, 0, 0, 1993, 1989,
		1, 0, 0, 0, 1994, 2002, 1, 0, 0, 0, 1995, 1996, 10, 4, 0, 0, 1996, 1997,
		5, 516, 0, 0, 1997, 1998, 3, 266, 133, 0, 1998, 1999, 5, 517, 0, 0, 1999,
		2001, 1, 0, 0, 0, 2000, 1995, 1, 0, 0, 0, 2001, 2004, 1, 0, 0, 0, 2002,
		2000, 1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003, 271, 1, 0, 0, 0, 2004,
		2002, 1, 0, 0, 0, 2005, 2006, 3, 334, 167, 0, 2006, 273, 1, 0, 0, 0, 2007,
		2012, 3, 382, 191, 0, 2008, 2012, 3, 378, 189, 0, 2009, 2012, 3, 380, 190,
		0, 2010, 2012, 3, 334, 167, 0, 2011, 2007, 1, 0, 0, 0, 2011, 2008, 1, 0,
		0, 0, 2011, 2009, 1, 0, 0, 0, 2011, 2010, 1, 0, 0, 0, 2012, 275, 1, 0,
		0, 0, 2013, 2014, 3, 380, 190, 0, 2014, 2015, 5, 539, 0, 0, 2015, 2018,
		1, 0, 0, 0, 2016, 2018, 3, 288, 144, 0, 2017, 2013, 1, 0, 0, 0, 2017, 2016,
		1, 0, 0, 0, 2018, 277, 1, 0, 0, 0, 2019, 2022, 3, 382, 191, 0, 2020, 2022,
		3, 334, 167, 0, 2021, 2019, 1, 0, 0, 0, 2021, 2020, 1, 0, 0, 0, 2022, 279,
		1, 0, 0, 0, 2023, 2028, 3, 376, 188, 0, 2024, 2028, 3, 374, 187, 0, 2025,
		2028, 3, 372, 186, 0, 2026, 2028, 3, 258, 129, 0, 2027, 2023, 1, 0, 0,
		0, 2027, 2024, 1, 0, 0, 0, 2027, 2025, 1, 0, 0, 0, 2027, 2026, 1, 0, 0,
		0, 2028, 281, 1, 0, 0, 0, 2029, 2030, 3, 334, 167, 0, 2030, 283, 1, 0,
		0, 0, 2031, 2032, 3, 310, 155, 0, 2032, 285, 1, 0, 0, 0, 2033, 2036, 3,
		310, 155, 0, 2034, 2036, 3, 282, 141, 0, 2035, 2033, 1, 0, 0, 0, 2035,
		2034, 1, 0, 0, 0, 2036, 287, 1, 0, 0, 0, 2037, 2040, 5, 182, 0, 0, 2038,
		2041, 3, 290, 145, 0, 2039, 2041, 3, 294, 147, 0, 2040, 2038, 1, 0, 0,
		0, 2040, 2039, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041, 289, 1, 0, 0,
		0, 2042, 2044, 3, 292, 146, 0, 2043, 2045, 3, 296, 148, 0, 2044, 2043,
		1, 0, 0, 0, 2044, 2045, 1, 0, 0, 0, 2045, 291, 1, 0, 0, 0, 2046, 2047,
		3, 298, 149, 0, 2047, 2048, 3, 374, 187, 0, 2048, 2050, 1, 0, 0, 0, 2049,
		2046, 1, 0, 0, 0, 2050, 2051, 1, 0, 0, 0, 2051, 2049, 1, 0, 0, 0, 2051,
		2052, 1, 0, 0, 0, 2052, 293, 1, 0, 0, 0, 2053, 2056, 3, 296, 148, 0, 2054,
		2057, 3, 292, 146, 0, 2055, 2057, 3, 296, 148, 0, 2056, 2054, 1, 0, 0,
		0, 2056, 2055, 1, 0, 0, 0, 2056, 2057, 1, 0, 0, 0, 2057, 295, 1, 0, 0,
		0, 2058, 2059, 3, 298, 149, 0, 2059, 2060, 3, 374, 187, 0, 2060, 2061,
		5, 390, 0, 0, 2061, 2062, 3, 374, 187, 0, 2062, 297, 1, 0, 0, 0, 2063,
		2065, 7, 33, 0, 0, 2064, 2063, 1, 0, 0, 0, 2064, 2065, 1, 0, 0, 0, 2065,
		2066, 1, 0, 0, 0, 2066, 2069, 7, 34, 0, 0, 2067, 2069, 5, 539, 0, 0, 2068,
		2064, 1, 0, 0, 0, 2068, 2067, 1, 0, 0, 0, 2069, 299, 1, 0, 0, 0, 2070,
		2072, 5, 17, 0, 0, 2071, 2070, 1, 0, 0, 0, 2071, 2072, 1, 0, 0, 0, 2072,
		2073, 1, 0, 0, 0, 2073, 2075, 3, 310, 155, 0, 2074, 2076, 3, 306, 153,
		0, 2075, 2074, 1, 0, 0, 0, 2075, 2076, 1, 0, 0, 0, 2076, 301, 1, 0, 0,
		0, 2077, 2078, 3, 310, 155, 0, 2078, 2079, 3, 304, 152, 0, 2079, 303, 1,
		0, 0, 0, 2080, 2081, 5, 222, 0, 0, 2081, 2083, 3, 310, 155, 0, 2082, 2080,
		1, 0, 0, 0, 2083, 2084, 1, 0, 0, 0, 2084, 2082, 1, 0, 0, 0, 2084, 2085,
		1, 0, 0, 0, 2085, 2088, 1, 0, 0, 0, 2086, 2088, 1, 0, 0, 0, 2087, 2082,
		1, 0, 0, 0, 2087, 2086, 1, 0, 0, 0, 2088, 305, 1, 0, 0, 0, 2089, 2090,
		5, 518, 0, 0, 2090, 2091, 3, 308, 154, 0, 2091, 2092, 5, 519, 0, 0, 2092,
		307, 1, 0, 0, 0, 2093, 2098, 3, 310, 155, 0, 2094, 2095, 5, 522, 0, 0,
		2095, 2097, 3, 310, 155, 0, 2096, 2094, 1, 0, 0, 0, 2097, 2100, 1, 0, 0,
		0, 2098, 2096, 1, 0, 0, 0, 2098, 2099, 1, 0, 0, 0, 2099, 309, 1, 0, 0,
		0, 2100, 2098, 1, 0, 0, 0, 2101, 2105, 3, 312, 156, 0, 2102, 2105, 3, 314,
		157, 0, 2103, 2105, 3, 384, 192, 0, 2104, 2101, 1, 0, 0, 0, 2104, 2102,
		1, 0, 0, 0, 2104, 2103, 1, 0, 0, 0, 2105, 311, 1, 0, 0, 0, 2106, 2107,
		7, 35, 0, 0, 2107, 313, 1, 0, 0, 0, 2108, 2109, 5, 539, 0, 0, 2109, 315,
		1, 0, 0, 0, 2110, 2111, 5, 430, 0, 0, 2111, 2112, 3, 258, 129, 0, 2112,
		2113, 5, 378, 0, 0, 2113, 2114, 3, 258, 129, 0, 2114, 317, 1, 0, 0, 0,
		2115, 2116, 3, 310, 155, 0, 2116, 319, 1, 0, 0, 0, 2117, 2118, 3, 310,
		155, 0, 2118, 321, 1, 0, 0, 0, 2119, 2122, 3, 310, 155, 0, 2120, 2121,
		5, 515, 0, 0, 2121, 2123, 3, 310, 155, 0, 2122, 2120, 1, 0, 0, 0, 2122,
		2123, 1, 0, 0, 0, 2123, 323, 1, 0, 0, 0, 2124, 2127, 3, 310, 155, 0, 2125,
		2126, 5, 515, 0, 0, 2126, 2128, 3, 310, 155, 0, 2127, 2125, 1, 0, 0, 0,
		2127, 2128, 1, 0, 0, 0, 2128, 325, 1, 0, 0, 0, 2129, 2132, 3, 310, 155,
		0, 2130, 2131, 5, 515, 0, 0, 2131, 2133, 3, 310, 155, 0, 2132, 2130, 1,
		0, 0, 0, 2132, 2133, 1, 0, 0, 0, 2133, 2142, 1, 0, 0, 0, 2134, 2135, 3,
		310, 155, 0, 2135, 2136, 5, 515, 0, 0, 2136, 2139, 3, 310, 155, 0, 2137,
		2138, 5, 515, 0, 0, 2138, 2140, 3, 310, 155, 0, 2139, 2137, 1, 0, 0, 0,
		2139, 2140, 1, 0, 0, 0, 2140, 2142, 1, 0, 0, 0, 2141, 2129, 1, 0, 0, 0,
		2141, 2134, 1, 0, 0, 0, 2142, 327, 1, 0, 0, 0, 2143, 2146, 3, 310, 155,
		0, 2144, 2145, 5, 515, 0, 0, 2145, 2147, 3, 310, 155, 0, 2146, 2144, 1,
		0, 0, 0, 2146, 2147, 1, 0, 0, 0, 2147, 2156, 1, 0, 0, 0, 2148, 2149, 3,
		310, 155, 0, 2149, 2150, 5, 515, 0, 0, 2150, 2153, 3, 310, 155, 0, 2151,
		2152, 5, 515, 0, 0, 2152, 2154, 3, 310, 155, 0, 2153, 2151, 1, 0, 0, 0,
		2153, 2154, 1, 0, 0, 0, 2154, 2156, 1, 0, 0, 0, 2155, 2143, 1, 0, 0, 0,
		2155, 2148, 1, 0, 0, 0, 2156, 329, 1, 0, 0, 0, 2157, 2160, 3, 310, 155,
		0, 2158, 2159, 5, 515, 0, 0, 2159, 2161, 3, 310, 155, 0, 2160, 2158, 1,
		0, 0, 0, 2160, 2161, 1, 0, 0, 0, 2161, 2170, 1, 0, 0, 0, 2162, 2163, 3,
		310, 155, 0, 2163, 2164, 5, 515, 0, 0, 2164, 2167, 3, 310, 155, 0, 2165,
		2166, 5, 515, 0, 0, 2166, 2168, 3, 310, 155, 0, 2167, 2165, 1, 0, 0, 0,
		2167, 2168, 1, 0, 0, 0, 2168, 2170, 1, 0, 0, 0, 2169, 2157, 1, 0, 0, 0,
		2169, 2162, 1, 0, 0, 0, 2170, 331, 1, 0, 0, 0, 2171, 2174, 3, 310, 155,
		0, 2172, 2173, 5, 515, 0, 0, 2173, 2175, 3, 310, 155, 0, 2174, 2172, 1,
		0, 0, 0, 2174, 2175, 1, 0, 0, 0, 2175, 2184, 1, 0, 0, 0, 2176, 2177, 3,
		310, 155, 0, 2177, 2178, 5, 515, 0, 0, 2178, 2181, 3, 310, 155, 0, 2179,
		2180, 5, 515, 0, 0, 2180, 2182, 3, 310, 155, 0, 2181, 2179, 1, 0, 0, 0,
		2181, 2182, 1, 0, 0, 0, 2182, 2184, 1, 0, 0, 0, 2183, 2171, 1, 0, 0, 0,
		2183, 2176, 1, 0, 0, 0, 2184, 333, 1, 0, 0, 0, 2185, 2190, 3, 310, 155,
		0, 2186, 2187, 5, 515, 0, 0, 2187, 2189, 3, 310, 155, 0, 2188, 2186, 1,
		0, 0, 0, 2189, 2192, 1, 0, 0, 0, 2190, 2191, 1, 0, 0, 0, 2190, 2188, 1,
		0, 0, 0, 2191, 335, 1, 0, 0, 0, 2192, 2190, 1, 0, 0, 0, 2193, 2194, 5,
		435, 0, 0, 2194, 2195, 3, 342, 171, 0, 2195, 337, 1, 0, 0, 0, 2196, 2197,
		5, 167, 0, 0, 2197, 2198, 5, 242, 0, 0, 2198, 2199, 5, 133, 0, 0, 2199,
		339, 1, 0, 0, 0, 2200, 2201, 5, 167, 0, 0, 2201, 2202, 5, 133, 0, 0, 2202,
		341, 1, 0, 0, 0, 2203, 2204, 5, 518, 0, 0, 2204, 2209, 3, 344, 172, 0,
		2205, 2206, 5, 522, 0, 0, 2206, 2208, 3, 344, 172, 0, 2207, 2205, 1, 0,
		0, 0, 2208, 2211, 1, 0, 0, 0, 2209, 2207, 1, 0, 0, 0, 2209, 2210, 1, 0,
		0, 0, 2210, 2212, 1, 0, 0, 0, 2211, 2209, 1, 0, 0, 0, 2212, 2213, 5, 519,
		0, 0, 2213, 343, 1, 0, 0, 0, 2214, 2219, 3, 346, 173, 0, 2215, 2217, 5,
		507, 0, 0, 2216, 2215, 1, 0, 0, 0, 2216, 2217, 1, 0, 0, 0, 2217, 2218,
		1, 0, 0, 0, 2218, 2220, 3, 348, 174, 0, 2219, 2216, 1, 0, 0, 0, 2219, 2220,
		1, 0, 0, 0, 2220, 345, 1, 0, 0, 0, 2221, 2225, 3, 310, 155, 0, 2222, 2225,
		3, 282, 141, 0, 2223, 2225, 5, 539, 0, 0, 2224, 2221, 1, 0, 0, 0, 2224,
		2222, 1, 0, 0, 0, 2224, 2223, 1, 0, 0, 0, 2225, 347, 1, 0, 0, 0, 2226,
		2231, 5, 540, 0, 0, 2227, 2231, 5, 541, 0, 0, 2228, 2231, 3, 368, 184,
		0, 2229, 2231, 5, 539, 0, 0, 2230, 2226, 1, 0, 0, 0, 2230, 2227, 1, 0,
		0, 0, 2230, 2228, 1, 0, 0, 0, 2230, 2229, 1, 0, 0, 0, 2231, 349, 1, 0,
		0, 0, 2232, 2239, 5, 10, 0, 0, 2233, 2234, 5, 513, 0, 0, 2234, 2239, 5,
		513, 0, 0, 2235, 2239, 5, 258, 0, 0, 2236, 2237, 5, 512, 0, 0, 2237, 2239,
		5, 512, 0, 0, 2238, 2232, 1, 0, 0, 0, 2238, 2233, 1, 0, 0, 0, 2238, 2235,
		1, 0, 0, 0, 2238, 2236, 1, 0, 0, 0, 2239, 351, 1, 0, 0, 0, 2240, 2255,
		5, 507, 0, 0, 2241, 2255, 5, 508, 0, 0, 2242, 2255, 5, 509, 0, 0, 2243,
		2244, 5, 509, 0, 0, 2244, 2255, 5, 507, 0, 0, 2245, 2246, 5, 508, 0, 0,
		2246, 2255, 5, 507, 0, 0, 2247, 2248, 5, 509, 0, 0, 2248, 2255, 5, 508,
		0, 0, 2249, 2250, 5, 510, 0, 0, 2250, 2255, 5, 507, 0, 0, 2251, 2252, 5,
		509, 0, 0, 2252, 2253, 5, 507, 0, 0, 2253, 2255, 5, 508, 0, 0, 2254, 2240,
		1, 0, 0, 0, 2254, 2241, 1, 0, 0, 0, 2254, 2242, 1, 0, 0, 0, 2254, 2243,
		1, 0, 0, 0, 2254, 2245, 1, 0, 0, 0, 2254, 2247, 1, 0, 0, 0, 2254, 2249,
		1, 0, 0, 0, 2254, 2251, 1, 0, 0, 0, 2255, 353, 1, 0, 0, 0, 2256, 2257,
		5, 509, 0, 0, 2257, 2264, 5, 509, 0, 0, 2258, 2259, 5, 508, 0, 0, 2259,
		2264, 5, 508, 0, 0, 2260, 2264, 5, 513, 0, 0, 2261, 2264, 5, 514, 0, 0,
		2262, 2264, 5, 512, 0, 0, 2263, 2256, 1, 0, 0, 0, 2263, 2258, 1, 0, 0,
		0, 2263, 2260, 1, 0, 0, 0, 2263, 2261, 1, 0, 0, 0, 2263, 2262, 1, 0, 0,
		0, 2264, 355, 1, 0, 0, 0, 2265, 2266, 7, 36, 0, 0, 2266, 357, 1, 0, 0,
		0, 2267, 2268, 7, 37, 0, 0, 2268, 359, 1, 0, 0, 0, 2269, 2284, 3, 288,
		144, 0, 2270, 2284, 3, 362, 181, 0, 2271, 2284, 3, 364, 182, 0, 2272, 2274,
		5, 531, 0, 0, 2273, 2272, 1, 0, 0, 0, 2273, 2274, 1, 0, 0, 0, 2274, 2275,
		1, 0, 0, 0, 2275, 2284, 3, 366, 183, 0, 2276, 2284, 3, 368, 184, 0, 2277,
		2284, 5, 541, 0, 0, 2278, 2284, 5, 542, 0, 0, 2279, 2281, 5, 242, 0, 0,
		2280, 2279, 1, 0, 0, 0, 2280, 2281, 1, 0, 0, 0, 2281, 2282, 1, 0, 0, 0,
		2282, 2284, 5, 245, 0, 0, 2283, 2269, 1, 0, 0, 0, 2283, 2270, 1, 0, 0,
		0, 2283, 2271, 1, 0, 0, 0, 2283, 2273, 1, 0, 0, 0, 2283, 2276, 1, 0, 0,
		0, 2283, 2277, 1, 0, 0, 0, 2283, 2278, 1, 0, 0, 0, 2283, 2280, 1, 0, 0,
		0, 2284, 361, 1, 0, 0, 0, 2285, 2286, 3, 372, 186, 0, 2286, 2287, 3, 364,
		182, 0, 2287, 363, 1, 0, 0, 0, 2288, 2289, 5, 539, 0, 0, 2289, 365, 1,
		0, 0, 0, 2290, 2291, 5, 540, 0, 0, 2291, 367, 1, 0, 0, 0, 2292, 2293, 7,
		38, 0, 0, 2293, 369, 1, 0, 0, 0, 2294, 2295, 7, 39, 0, 0, 2295, 371, 1,
		0, 0, 0, 2296, 2297, 7, 40, 0, 0, 2297, 373, 1, 0, 0, 0, 2298, 2299, 7,
		41, 0, 0, 2299, 375, 1, 0, 0, 0, 2300, 2301, 7, 42, 0, 0, 2301, 377, 1,
		0, 0, 0, 2302, 2303, 7, 43, 0, 0, 2303, 379, 1, 0, 0, 0, 2304, 2305, 7,
		44, 0, 0, 2305, 381, 1, 0, 0, 0, 2306, 2307, 7, 45, 0, 0, 2307, 383, 1,
		0, 0, 0, 2308, 2309, 7, 46, 0, 0, 2309, 385, 1, 0, 0, 0, 272, 389, 396,
		399, 413, 431, 435, 444, 449, 456, 467, 476, 488, 491, 498, 501, 509, 513,
		518, 521, 528, 536, 540, 552, 560, 564, 596, 599, 604, 608, 612, 616, 625,
		630, 634, 638, 643, 646, 650, 655, 661, 666, 671, 675, 679, 691, 699, 703,
		707, 711, 715, 719, 723, 727, 731, 733, 743, 751, 775, 789, 794, 798, 804,
		807, 810, 817, 820, 829, 841, 865, 877, 882, 886, 894, 898, 904, 914, 919,
		925, 929, 933, 937, 946, 950, 957, 960, 970, 978, 986, 990, 1005, 1024,
		1035, 1039, 1046, 1051, 1057, 1061, 1068, 1072, 1076, 1080, 1088, 1092,
		1097, 1103, 1109, 1112, 1116, 1127, 1136, 1150, 1162, 1177, 1180, 1184,
		1187, 1189, 1194, 1198, 1201, 1205, 1214, 1223, 1233, 1238, 1249, 1252,
		1255, 1258, 1261, 1267, 1271, 1279, 1282, 1287, 1290, 1294, 1297, 1299,
		1313, 1324, 1329, 1337, 1340, 1343, 1348, 1350, 1352, 1357, 1360, 1364,
		1368, 1377, 1388, 1415, 1437, 1450, 1462, 1475, 1487, 1499, 1505, 1532,
		1540, 1544, 1547, 1550, 1557, 1560, 1563, 1566, 1569, 1572, 1577, 1580,
		1589, 1594, 1598, 1603, 1609, 1614, 1618, 1637, 1645, 1653, 1657, 1661,
		1671, 1697, 1705, 1717, 1739, 1741, 1752, 1755, 1757, 1761, 1765, 1772,
		1781, 1787, 1800, 1807, 1812, 1818, 1825, 1832, 1834, 1837, 1849, 1854,
		1857, 1863, 1865, 1871, 1892, 1894, 1902, 1909, 1912, 1916, 1923, 1927,
		1936, 1940, 1956, 1965, 1993, 2002, 2011, 2017, 2021, 2027, 2035, 2040,
		2044, 2051, 2056, 2064, 2068, 2071, 2075, 2084, 2087, 2098, 2104, 2122,
		2127, 2132, 2139, 2141, 2146, 2153, 2155, 2160, 2167, 2169, 2174, 2181,
		2183, 2190, 2209, 2216, 2219, 2224, 2230, 2238, 2254, 2263, 2273, 2280,
		2283,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// FlinkSqlParserInit initializes any static state used to implement FlinkSqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewFlinkSqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func FlinkSqlParserInit() {
	staticData := &FlinkSqlParserParserStaticData
	staticData.once.Do(flinksqlparserParserInit)
}

// NewFlinkSqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewFlinkSqlParser(input antlr.TokenStream) *FlinkSqlParser {
	FlinkSqlParserInit()
	this := new(FlinkSqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &FlinkSqlParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "FlinkSqlParser.g4"

	return this
}

// FlinkSqlParser tokens.
const (
	FlinkSqlParserEOF                                 = antlr.TokenEOF
	FlinkSqlParserWHITE_SPACE                         = 1
	FlinkSqlParserBRACKETED_COMMENT                   = 2
	FlinkSqlParserLINE_COMMENT                        = 3
	FlinkSqlParserKW_ABS                              = 4
	FlinkSqlParserKW_ALL                              = 5
	FlinkSqlParserKW_ALLOCATE                         = 6
	FlinkSqlParserKW_ALLOW                            = 7
	FlinkSqlParserKW_ALTER                            = 8
	FlinkSqlParserKW_ANALYZE                          = 9
	FlinkSqlParserKW_AND                              = 10
	FlinkSqlParserKW_ANY                              = 11
	FlinkSqlParserKW_ARE                              = 12
	FlinkSqlParserKW_ARRAY                            = 13
	FlinkSqlParserKW_ARRAY_AGG                        = 14
	FlinkSqlParserKW_ARRAY_CONCAT_AGG                 = 15
	FlinkSqlParserKW_ARRAY_MAX_CARDINALITY            = 16
	FlinkSqlParserKW_AS                               = 17
	FlinkSqlParserKW_ASENSITIVE                       = 18
	FlinkSqlParserKW_ASYMMETRIC                       = 19
	FlinkSqlParserKW_AT                               = 20
	FlinkSqlParserKW_ATOMIC                           = 21
	FlinkSqlParserKW_AUTHORIZATION                    = 22
	FlinkSqlParserKW_AVG                              = 23
	FlinkSqlParserKW_BEGIN                            = 24
	FlinkSqlParserKW_BEGIN_FRAME                      = 25
	FlinkSqlParserKW_BEGIN_PARTITION                  = 26
	FlinkSqlParserKW_BETWEEN                          = 27
	FlinkSqlParserKW_BIGINT                           = 28
	FlinkSqlParserKW_BINARY                           = 29
	FlinkSqlParserKW_BIT                              = 30
	FlinkSqlParserKW_BLOB                             = 31
	FlinkSqlParserKW_BOOLEAN                          = 32
	FlinkSqlParserKW_BOTH                             = 33
	FlinkSqlParserKW_BY                               = 34
	FlinkSqlParserKW_BYTES                            = 35
	FlinkSqlParserKW_CALL                             = 36
	FlinkSqlParserKW_CALLED                           = 37
	FlinkSqlParserKW_CARDINALITY                      = 38
	FlinkSqlParserKW_CASCADED                         = 39
	FlinkSqlParserKW_CASE                             = 40
	FlinkSqlParserKW_CAST                             = 41
	FlinkSqlParserKW_CATALOGS                         = 42
	FlinkSqlParserKW_CEIL                             = 43
	FlinkSqlParserKW_CEILING                          = 44
	FlinkSqlParserKW_CHANGELOG_MODE                   = 45
	FlinkSqlParserKW_CHAR                             = 46
	FlinkSqlParserKW_CHARACTER                        = 47
	FlinkSqlParserKW_CHARACTER_LENGTH                 = 48
	FlinkSqlParserKW_CHAR_LENGTH                      = 49
	FlinkSqlParserKW_CHECK                            = 50
	FlinkSqlParserKW_CLASSIFIER                       = 51
	FlinkSqlParserKW_CLOB                             = 52
	FlinkSqlParserKW_CLOSE                            = 53
	FlinkSqlParserKW_COALESCE                         = 54
	FlinkSqlParserKW_COLLATE                          = 55
	FlinkSqlParserKW_COLLECT                          = 56
	FlinkSqlParserKW_COLUMN                           = 57
	FlinkSqlParserKW_COLUMNS                          = 58
	FlinkSqlParserKW_COMMENT                          = 59
	FlinkSqlParserKW_COMMIT                           = 60
	FlinkSqlParserKW_COMPUTE                          = 61
	FlinkSqlParserKW_CONDITION                        = 62
	FlinkSqlParserKW_CONNECT                          = 63
	FlinkSqlParserKW_CONSTRAINT                       = 64
	FlinkSqlParserKW_CONTAINS                         = 65
	FlinkSqlParserKW_CONVERT                          = 66
	FlinkSqlParserKW_CORR                             = 67
	FlinkSqlParserKW_CORRESPONDING                    = 68
	FlinkSqlParserKW_COUNT                            = 69
	FlinkSqlParserKW_COVAR_POP                        = 70
	FlinkSqlParserKW_COVAR_SAMP                       = 71
	FlinkSqlParserKW_CREATE                           = 72
	FlinkSqlParserKW_CROSS                            = 73
	FlinkSqlParserKW_CUBE                             = 74
	FlinkSqlParserKW_CUME_DIST                        = 75
	FlinkSqlParserKW_CURRENT                          = 76
	FlinkSqlParserKW_CURRENT_CATALOG                  = 77
	FlinkSqlParserKW_CURRENT_DATE                     = 78
	FlinkSqlParserKW_CURRENT_DEFAULT_TRANSFORM_GROUP  = 79
	FlinkSqlParserKW_CURRENT_PATH                     = 80
	FlinkSqlParserKW_CURRENT_ROLE                     = 81
	FlinkSqlParserKW_CURRENT_ROW                      = 82
	FlinkSqlParserKW_CURRENT_SCHEMA                   = 83
	FlinkSqlParserKW_CURRENT_TIME                     = 84
	FlinkSqlParserKW_CURRENT_TIMESTAMP                = 85
	FlinkSqlParserKW_CURRENT_TRANSFORM_GROUP_FOR_TYPE = 86
	FlinkSqlParserKW_CURRENT_USER                     = 87
	FlinkSqlParserKW_CURSOR                           = 88
	FlinkSqlParserKW_CYCLE                            = 89
	FlinkSqlParserKW_DATABASES                        = 90
	FlinkSqlParserKW_DATE                             = 91
	FlinkSqlParserKW_DATETIME                         = 92
	FlinkSqlParserKW_DATETIME_DIFF                    = 93
	FlinkSqlParserKW_DATETIME_TRUNC                   = 94
	FlinkSqlParserKW_DATE_DIFF                        = 95
	FlinkSqlParserKW_DATE_TRUNC                       = 96
	FlinkSqlParserKW_DAY                              = 97
	FlinkSqlParserKW_DAYOFWEEK                        = 98
	FlinkSqlParserKW_DAYOFYEAR                        = 99
	FlinkSqlParserKW_DEALLOCATE                       = 100
	FlinkSqlParserKW_DEC                              = 101
	FlinkSqlParserKW_DECIMAL                          = 102
	FlinkSqlParserKW_DECLARE                          = 103
	FlinkSqlParserKW_DEFAULT                          = 104
	FlinkSqlParserKW_DEFINE                           = 105
	FlinkSqlParserKW_DELETE                           = 106
	FlinkSqlParserKW_DENSE_RANK                       = 107
	FlinkSqlParserKW_DEREF                            = 108
	FlinkSqlParserKW_DESCRIBE                         = 109
	FlinkSqlParserKW_DETERMINISTIC                    = 110
	FlinkSqlParserKW_DISALLOW                         = 111
	FlinkSqlParserKW_DISCONNECT                       = 112
	FlinkSqlParserKW_DISTINCT                         = 113
	FlinkSqlParserKW_DOT                              = 114
	FlinkSqlParserKW_DOUBLE                           = 115
	FlinkSqlParserKW_DROP                             = 116
	FlinkSqlParserKW_DYNAMIC                          = 117
	FlinkSqlParserKW_EACH                             = 118
	FlinkSqlParserKW_ELEMENT                          = 119
	FlinkSqlParserKW_ELSE                             = 120
	FlinkSqlParserKW_EMPTY                            = 121
	FlinkSqlParserKW_END                              = 122
	FlinkSqlParserKW_END_FRAME                        = 123
	FlinkSqlParserKW_END_PARTITION                    = 124
	FlinkSqlParserKW_ENFORCED                         = 125
	FlinkSqlParserKW_EQUALS                           = 126
	FlinkSqlParserKW_ESCAPE                           = 127
	FlinkSqlParserKW_ESTIMATED_COST                   = 128
	FlinkSqlParserKW_EVERY                            = 129
	FlinkSqlParserKW_EXCEPT                           = 130
	FlinkSqlParserKW_EXEC                             = 131
	FlinkSqlParserKW_EXECUTE                          = 132
	FlinkSqlParserKW_EXISTS                           = 133
	FlinkSqlParserKW_EXP                              = 134
	FlinkSqlParserKW_EXPLAIN                          = 135
	FlinkSqlParserKW_EXTEND                           = 136
	FlinkSqlParserKW_EXTENDED                         = 137
	FlinkSqlParserKW_EXTERNAL                         = 138
	FlinkSqlParserKW_EXTRACT                          = 139
	FlinkSqlParserKW_FALSE                            = 140
	FlinkSqlParserKW_FETCH                            = 141
	FlinkSqlParserKW_FILTER                           = 142
	FlinkSqlParserKW_FIRST_VALUE                      = 143
	FlinkSqlParserKW_FLOAT                            = 144
	FlinkSqlParserKW_FLOOR                            = 145
	FlinkSqlParserKW_FOR                              = 146
	FlinkSqlParserKW_FOREIGN                          = 147
	FlinkSqlParserKW_FRAME_ROW                        = 148
	FlinkSqlParserKW_FREE                             = 149
	FlinkSqlParserKW_FRIDAY                           = 150
	FlinkSqlParserKW_FROM                             = 151
	FlinkSqlParserKW_FULL                             = 152
	FlinkSqlParserKW_FUNCTION                         = 153
	FlinkSqlParserKW_FUNCTIONS                        = 154
	FlinkSqlParserKW_FUSION                           = 155
	FlinkSqlParserKW_GET                              = 156
	FlinkSqlParserKW_GLOBAL                           = 157
	FlinkSqlParserKW_GRANT                            = 158
	FlinkSqlParserKW_GROUP                            = 159
	FlinkSqlParserKW_GROUPING                         = 160
	FlinkSqlParserKW_GROUPS                           = 161
	FlinkSqlParserKW_GROUP_CONCAT                     = 162
	FlinkSqlParserKW_HAVING                           = 163
	FlinkSqlParserKW_HOLD                             = 164
	FlinkSqlParserKW_HOUR                             = 165
	FlinkSqlParserKW_IDENTITY                         = 166
	FlinkSqlParserKW_IF                               = 167
	FlinkSqlParserKW_ILIKE                            = 168
	FlinkSqlParserKW_IMPORT                           = 169
	FlinkSqlParserKW_IN                               = 170
	FlinkSqlParserKW_INCLUDE                          = 171
	FlinkSqlParserKW_INDICATOR                        = 172
	FlinkSqlParserKW_INITIAL                          = 173
	FlinkSqlParserKW_INNER                            = 174
	FlinkSqlParserKW_INOUT                            = 175
	FlinkSqlParserKW_INSENSITIVE                      = 176
	FlinkSqlParserKW_INSERT                           = 177
	FlinkSqlParserKW_INT                              = 178
	FlinkSqlParserKW_INTEGER                          = 179
	FlinkSqlParserKW_INTERSECT                        = 180
	FlinkSqlParserKW_INTERSECTION                     = 181
	FlinkSqlParserKW_INTERVAL                         = 182
	FlinkSqlParserKW_INTO                             = 183
	FlinkSqlParserKW_IS                               = 184
	FlinkSqlParserKW_JOIN                             = 185
	FlinkSqlParserKW_JSON                             = 186
	FlinkSqlParserKW_JSON_ARRAY                       = 187
	FlinkSqlParserKW_JSON_ARRAYAGG                    = 188
	FlinkSqlParserKW_JSON_EXECUTION_PLAN              = 189
	FlinkSqlParserKW_JSON_EXISTS                      = 190
	FlinkSqlParserKW_JSON_OBJECT                      = 191
	FlinkSqlParserKW_JSON_OBJECTAGG                   = 192
	FlinkSqlParserKW_JSON_QUERY                       = 193
	FlinkSqlParserKW_JSON_VALUE                       = 194
	FlinkSqlParserKW_LAG                              = 195
	FlinkSqlParserKW_LANGUAGE                         = 196
	FlinkSqlParserKW_LARGE                            = 197
	FlinkSqlParserKW_LAST_VALUE                       = 198
	FlinkSqlParserKW_LATERAL                          = 199
	FlinkSqlParserKW_LEAD                             = 200
	FlinkSqlParserKW_LEADING                          = 201
	FlinkSqlParserKW_LEFT                             = 202
	FlinkSqlParserKW_LIKE                             = 203
	FlinkSqlParserKW_LIKE_REGEX                       = 204
	FlinkSqlParserKW_LIMIT                            = 205
	FlinkSqlParserKW_LN                               = 206
	FlinkSqlParserKW_LOCAL                            = 207
	FlinkSqlParserKW_LOCALTIME                        = 208
	FlinkSqlParserKW_LOCALTIMESTAMP                   = 209
	FlinkSqlParserKW_LOWER                            = 210
	FlinkSqlParserKW_MATCH                            = 211
	FlinkSqlParserKW_MATCHES                          = 212
	FlinkSqlParserKW_MATCH_NUMBER                     = 213
	FlinkSqlParserKW_MATCH_RECOGNIZE                  = 214
	FlinkSqlParserKW_MAX                              = 215
	FlinkSqlParserKW_MEASURES                         = 216
	FlinkSqlParserKW_MEMBER                           = 217
	FlinkSqlParserKW_MERGE                            = 218
	FlinkSqlParserKW_METADATA                         = 219
	FlinkSqlParserKW_METHOD                           = 220
	FlinkSqlParserKW_MIN                              = 221
	FlinkSqlParserKW_MINUS                            = 222
	FlinkSqlParserKW_MINUTE                           = 223
	FlinkSqlParserKW_MOD                              = 224
	FlinkSqlParserKW_MODIFIES                         = 225
	FlinkSqlParserKW_MODIFY                           = 226
	FlinkSqlParserKW_MODULE                           = 227
	FlinkSqlParserKW_MODULES                          = 228
	FlinkSqlParserKW_MONDAY                           = 229
	FlinkSqlParserKW_MONTH                            = 230
	FlinkSqlParserKW_MORE                             = 231
	FlinkSqlParserKW_MULTISET                         = 232
	FlinkSqlParserKW_NATIONAL                         = 233
	FlinkSqlParserKW_NATURAL                          = 234
	FlinkSqlParserKW_NCHAR                            = 235
	FlinkSqlParserKW_NCLOB                            = 236
	FlinkSqlParserKW_NEW                              = 237
	FlinkSqlParserKW_NEXT                             = 238
	FlinkSqlParserKW_NO                               = 239
	FlinkSqlParserKW_NONE                             = 240
	FlinkSqlParserKW_NORMALIZE                        = 241
	FlinkSqlParserKW_NOT                              = 242
	FlinkSqlParserKW_NTH_VALUE                        = 243
	FlinkSqlParserKW_NTILE                            = 244
	FlinkSqlParserKW_NULL                             = 245
	FlinkSqlParserKW_NULLIF                           = 246
	FlinkSqlParserKW_NUMERIC                          = 247
	FlinkSqlParserKW_OCCURRENCES_REGEX                = 248
	FlinkSqlParserKW_OCTET_LENGTH                     = 249
	FlinkSqlParserKW_OF                               = 250
	FlinkSqlParserKW_OFFSET                           = 251
	FlinkSqlParserKW_OLD                              = 252
	FlinkSqlParserKW_OMIT                             = 253
	FlinkSqlParserKW_ON                               = 254
	FlinkSqlParserKW_ONE                              = 255
	FlinkSqlParserKW_ONLY                             = 256
	FlinkSqlParserKW_OPEN                             = 257
	FlinkSqlParserKW_OR                               = 258
	FlinkSqlParserKW_ORDER                            = 259
	FlinkSqlParserKW_ORDINAL                          = 260
	FlinkSqlParserKW_OUT                              = 261
	FlinkSqlParserKW_OUTER                            = 262
	FlinkSqlParserKW_OVER                             = 263
	FlinkSqlParserKW_OVERLAPS                         = 264
	FlinkSqlParserKW_OVERLAY                          = 265
	FlinkSqlParserKW_OVERWRITE                        = 266
	FlinkSqlParserKW_OVERWRITING                      = 267
	FlinkSqlParserKW_PARAMETER                        = 268
	FlinkSqlParserKW_PARTITION                        = 269
	FlinkSqlParserKW_PARTITIONED                      = 270
	FlinkSqlParserKW_PARTITIONS                       = 271
	FlinkSqlParserKW_PATTERN                          = 272
	FlinkSqlParserKW_PER                              = 273
	FlinkSqlParserKW_PERCENT                          = 274
	FlinkSqlParserKW_PERCENTILE_CONT                  = 275
	FlinkSqlParserKW_PERCENTILE_DISC                  = 276
	FlinkSqlParserKW_PERCENT_RANK                     = 277
	FlinkSqlParserKW_PERIOD                           = 278
	FlinkSqlParserKW_PERMUTE                          = 279
	FlinkSqlParserKW_PLAN_ADVICE                      = 280
	FlinkSqlParserKW_PIVOT                            = 281
	FlinkSqlParserKW_PORTION                          = 282
	FlinkSqlParserKW_POSITION                         = 283
	FlinkSqlParserKW_POSITION_REGEX                   = 284
	FlinkSqlParserKW_POWER                            = 285
	FlinkSqlParserKW_PRECEDES                         = 286
	FlinkSqlParserKW_PRECISION                        = 287
	FlinkSqlParserKW_PREPARE                          = 288
	FlinkSqlParserKW_PREV                             = 289
	FlinkSqlParserKW_PRIMARY                          = 290
	FlinkSqlParserKW_PROCEDURE                        = 291
	FlinkSqlParserKW_QUALIFY                          = 292
	FlinkSqlParserKW_QUARTERS                         = 293
	FlinkSqlParserKW_RANGE                            = 294
	FlinkSqlParserKW_RANK                             = 295
	FlinkSqlParserKW_RAW                              = 296
	FlinkSqlParserKW_READS                            = 297
	FlinkSqlParserKW_REAL                             = 298
	FlinkSqlParserKW_RECURSIVE                        = 299
	FlinkSqlParserKW_REF                              = 300
	FlinkSqlParserKW_REFERENCES                       = 301
	FlinkSqlParserKW_REFERENCING                      = 302
	FlinkSqlParserKW_REGR_AVGX                        = 303
	FlinkSqlParserKW_REGR_AVGY                        = 304
	FlinkSqlParserKW_REGR_COUNT                       = 305
	FlinkSqlParserKW_REGR_INTERCEPT                   = 306
	FlinkSqlParserKW_REGR_R2                          = 307
	FlinkSqlParserKW_REGR_SLOPE                       = 308
	FlinkSqlParserKW_REGR_SXX                         = 309
	FlinkSqlParserKW_REGR_SXY                         = 310
	FlinkSqlParserKW_REGR_SYY                         = 311
	FlinkSqlParserKW_RELEASE                          = 312
	FlinkSqlParserKW_RENAME                           = 313
	FlinkSqlParserKW_RESET                            = 314
	FlinkSqlParserKW_RESULT                           = 315
	FlinkSqlParserKW_RETURN                           = 316
	FlinkSqlParserKW_RETURNS                          = 317
	FlinkSqlParserKW_REVOKE                           = 318
	FlinkSqlParserKW_RIGHT                            = 319
	FlinkSqlParserKW_RLIKE                            = 320
	FlinkSqlParserKW_ROLLBACK                         = 321
	FlinkSqlParserKW_ROLLUP                           = 322
	FlinkSqlParserKW_ROW                              = 323
	FlinkSqlParserKW_ROWS                             = 324
	FlinkSqlParserKW_ROW_NUMBER                       = 325
	FlinkSqlParserKW_RUNNING                          = 326
	FlinkSqlParserKW_SAFE_CAST                        = 327
	FlinkSqlParserKW_SAFE_OFFSET                      = 328
	FlinkSqlParserKW_SAFE_ORDINAL                     = 329
	FlinkSqlParserKW_SATURDAY                         = 330
	FlinkSqlParserKW_SAVEPOINT                        = 331
	FlinkSqlParserKW_SCALA                            = 332
	FlinkSqlParserKW_SCOPE                            = 333
	FlinkSqlParserKW_SCROLL                           = 334
	FlinkSqlParserKW_SEARCH                           = 335
	FlinkSqlParserKW_SECOND                           = 336
	FlinkSqlParserKW_SEEK                             = 337
	FlinkSqlParserKW_SELECT                           = 338
	FlinkSqlParserKW_SENSITIVE                        = 339
	FlinkSqlParserKW_SEPARATOR                        = 340
	FlinkSqlParserKW_SESSION_USER                     = 341
	FlinkSqlParserKW_SET                              = 342
	FlinkSqlParserKW_SHOW                             = 343
	FlinkSqlParserKW_SIMILAR                          = 344
	FlinkSqlParserKW_SKIP                             = 345
	FlinkSqlParserKW_SMALLINT                         = 346
	FlinkSqlParserKW_SOME                             = 347
	FlinkSqlParserKW_SPECIFIC                         = 348
	FlinkSqlParserKW_SPECIFICTYPE                     = 349
	FlinkSqlParserKW_SQL                              = 350
	FlinkSqlParserKW_SQLEXCEPTION                     = 351
	FlinkSqlParserKW_SQLSTATE                         = 352
	FlinkSqlParserKW_SQLWARNING                       = 353
	FlinkSqlParserKW_SQRT                             = 354
	FlinkSqlParserKW_START                            = 355
	FlinkSqlParserKW_STATEMENT                        = 356
	FlinkSqlParserKW_STATIC                           = 357
	FlinkSqlParserKW_STATISTICS                       = 358
	FlinkSqlParserKW_STDDEV_POP                       = 359
	FlinkSqlParserKW_STDDEV_SAMP                      = 360
	FlinkSqlParserKW_STREAM                           = 361
	FlinkSqlParserKW_STRING                           = 362
	FlinkSqlParserKW_STRING_AGG                       = 363
	FlinkSqlParserKW_SUBMULTISET                      = 364
	FlinkSqlParserKW_SUBSET                           = 365
	FlinkSqlParserKW_SUBSTRING                        = 366
	FlinkSqlParserKW_SUBSTRING_REGEX                  = 367
	FlinkSqlParserKW_SUCCEEDS                         = 368
	FlinkSqlParserKW_SUM                              = 369
	FlinkSqlParserKW_SUNDAY                           = 370
	FlinkSqlParserKW_SYMMETRIC                        = 371
	FlinkSqlParserKW_SYSTEM                           = 372
	FlinkSqlParserKW_SYSTEM_TIME                      = 373
	FlinkSqlParserKW_SYSTEM_USER                      = 374
	FlinkSqlParserKW_TABLE                            = 375
	FlinkSqlParserKW_TABLES                           = 376
	FlinkSqlParserKW_TABLESAMPLE                      = 377
	FlinkSqlParserKW_THEN                             = 378
	FlinkSqlParserKW_THURSDAY                         = 379
	FlinkSqlParserKW_TIME                             = 380
	FlinkSqlParserKW_TIMESTAMP                        = 381
	FlinkSqlParserKW_TIMESTAMP_DIFF                   = 382
	FlinkSqlParserKW_TIMESTAMP_LTZ                    = 383
	FlinkSqlParserKW_TIMESTAMP_TRUNC                  = 384
	FlinkSqlParserKW_TIMEZONE_HOUR                    = 385
	FlinkSqlParserKW_TIMEZONE_MINUTE                  = 386
	FlinkSqlParserKW_TIME_DIFF                        = 387
	FlinkSqlParserKW_TIME_TRUNC                       = 388
	FlinkSqlParserKW_TINYINT                          = 389
	FlinkSqlParserKW_TO                               = 390
	FlinkSqlParserKW_TRAILING                         = 391
	FlinkSqlParserKW_TRANSLATE                        = 392
	FlinkSqlParserKW_TRANSLATE_REGEX                  = 393
	FlinkSqlParserKW_TRANSLATION                      = 394
	FlinkSqlParserKW_TREAT                            = 395
	FlinkSqlParserKW_TRIGGER                          = 396
	FlinkSqlParserKW_TRIM                             = 397
	FlinkSqlParserKW_TRIM_ARRAY                       = 398
	FlinkSqlParserKW_TRUE                             = 399
	FlinkSqlParserKW_TRUNCATE                         = 400
	FlinkSqlParserKW_TRY_CAST                         = 401
	FlinkSqlParserKW_TUESDAY                          = 402
	FlinkSqlParserKW_UESCAPE                          = 403
	FlinkSqlParserKW_UNION                            = 404
	FlinkSqlParserKW_UNIQUE                           = 405
	FlinkSqlParserKW_UNKNOWN                          = 406
	FlinkSqlParserKW_UNNEST                           = 407
	FlinkSqlParserKW_UNPIVOT                          = 408
	FlinkSqlParserKW_UPDATE                           = 409
	FlinkSqlParserKW_UPPER                            = 410
	FlinkSqlParserKW_UPSERT                           = 411
	FlinkSqlParserKW_USE                              = 412
	FlinkSqlParserKW_USER                             = 413
	FlinkSqlParserKW_USING                            = 414
	FlinkSqlParserKW_VALUE                            = 415
	FlinkSqlParserKW_VALUES                           = 416
	FlinkSqlParserKW_VALUE_OF                         = 417
	FlinkSqlParserKW_VARBINARY                        = 418
	FlinkSqlParserKW_VARCHAR                          = 419
	FlinkSqlParserKW_VARYING                          = 420
	FlinkSqlParserKW_VAR_POP                          = 421
	FlinkSqlParserKW_VAR_SAMP                         = 422
	FlinkSqlParserKW_VERSIONING                       = 423
	FlinkSqlParserKW_VIEWS                            = 424
	FlinkSqlParserKW_VIRTUAL                          = 425
	FlinkSqlParserKW_WATERMARK                        = 426
	FlinkSqlParserKW_WATERMARKS                       = 427
	FlinkSqlParserKW_WEDNESDAY                        = 428
	FlinkSqlParserKW_WEEKS                            = 429
	FlinkSqlParserKW_WHEN                             = 430
	FlinkSqlParserKW_WHENEVER                         = 431
	FlinkSqlParserKW_WHERE                            = 432
	FlinkSqlParserKW_WIDTH_BUCKET                     = 433
	FlinkSqlParserKW_WINDOW                           = 434
	FlinkSqlParserKW_WITH                             = 435
	FlinkSqlParserKW_WITHIN                           = 436
	FlinkSqlParserKW_WITHOUT                          = 437
	FlinkSqlParserKW_YEAR                             = 438
	FlinkSqlParserKW_ADD                              = 439
	FlinkSqlParserKW_AFTER                            = 440
	FlinkSqlParserKW_ASC                              = 441
	FlinkSqlParserKW_CASCADE                          = 442
	FlinkSqlParserKW_CATALOG                          = 443
	FlinkSqlParserKW_CENTURY                          = 444
	FlinkSqlParserKW_CONFIG                           = 445
	FlinkSqlParserKW_CONSTRAINTS                      = 446
	FlinkSqlParserKW_CUMULATE                         = 447
	FlinkSqlParserKW_DATA                             = 448
	FlinkSqlParserKW_DATABASE                         = 449
	FlinkSqlParserKW_DAYS                             = 450
	FlinkSqlParserKW_DECADE                           = 451
	FlinkSqlParserKW_DESC                             = 452
	FlinkSqlParserKW_DESCRIPTOR                       = 453
	FlinkSqlParserKW_DIV                              = 454
	FlinkSqlParserKW_ENGINE                           = 455
	FlinkSqlParserKW_EPOCH                            = 456
	FlinkSqlParserKW_EXCLUDING                        = 457
	FlinkSqlParserKW_FILE                             = 458
	FlinkSqlParserKW_FIRST                            = 459
	FlinkSqlParserKW_GENERATED                        = 460
	FlinkSqlParserKW_HOP                              = 461
	FlinkSqlParserKW_HOURS                            = 462
	FlinkSqlParserKW_IGNORE                           = 463
	FlinkSqlParserKW_INCLUDING                        = 464
	FlinkSqlParserKW_JAR                              = 465
	FlinkSqlParserKW_JARS                             = 466
	FlinkSqlParserKW_JAVA                             = 467
	FlinkSqlParserKW_KEY                              = 468
	FlinkSqlParserKW_LAST                             = 469
	FlinkSqlParserKW_LOAD                             = 470
	FlinkSqlParserKW_MAP                              = 471
	FlinkSqlParserKW_MICROSECOND                      = 472
	FlinkSqlParserKW_MILLENNIUM                       = 473
	FlinkSqlParserKW_MILLISECOND                      = 474
	FlinkSqlParserKW_MINUTES                          = 475
	FlinkSqlParserKW_MONTHS                           = 476
	FlinkSqlParserKW_NANOSECOND                       = 477
	FlinkSqlParserKW_NULLS                            = 478
	FlinkSqlParserKW_OPTIONS                          = 479
	FlinkSqlParserKW_PAST                             = 480
	FlinkSqlParserKW_PLAN                             = 481
	FlinkSqlParserKW_PRECEDING                        = 482
	FlinkSqlParserKW_PYTHON                           = 483
	FlinkSqlParserKW_PYTHON_ARCHIVES                  = 484
	FlinkSqlParserKW_PYTHON_DEPENDENCIES              = 485
	FlinkSqlParserKW_PYTHON_FILES                     = 486
	FlinkSqlParserKW_PYTHON_JAR                       = 487
	FlinkSqlParserKW_PYTHON_PARAMETER                 = 488
	FlinkSqlParserKW_PYTHON_REQUIREMENTS              = 489
	FlinkSqlParserKW_QUARTER                          = 490
	FlinkSqlParserKW_REMOVE                           = 491
	FlinkSqlParserKW_RESTRICT                         = 492
	FlinkSqlParserKW_SECONDS                          = 493
	FlinkSqlParserKW_SESSION                          = 494
	FlinkSqlParserKW_SETS                             = 495
	FlinkSqlParserKW_SIZE                             = 496
	FlinkSqlParserKW_SLIDE                            = 497
	FlinkSqlParserKW_STEP                             = 498
	FlinkSqlParserKW_TEMPORARY                        = 499
	FlinkSqlParserKW_TIMECOL                          = 500
	FlinkSqlParserKW_TUMBLE                           = 501
	FlinkSqlParserKW_UNLOAD                           = 502
	FlinkSqlParserKW_VIEW                             = 503
	FlinkSqlParserKW_WEEK                             = 504
	FlinkSqlParserKW_YEARS                            = 505
	FlinkSqlParserKW_ZONE                             = 506
	FlinkSqlParserEQUAL_SYMBOL                        = 507
	FlinkSqlParserGREATER_SYMBOL                      = 508
	FlinkSqlParserLESS_SYMBOL                         = 509
	FlinkSqlParserEXCLAMATION_SYMBOL                  = 510
	FlinkSqlParserBIT_NOT_OP                          = 511
	FlinkSqlParserBIT_OR_OP                           = 512
	FlinkSqlParserBIT_AND_OP                          = 513
	FlinkSqlParserBIT_XOR_OP                          = 514
	FlinkSqlParserDOT                                 = 515
	FlinkSqlParserLS_BRACKET                          = 516
	FlinkSqlParserRS_BRACKET                          = 517
	FlinkSqlParserLR_BRACKET                          = 518
	FlinkSqlParserRR_BRACKET                          = 519
	FlinkSqlParserLB_BRACKET                          = 520
	FlinkSqlParserRB_BRACKET                          = 521
	FlinkSqlParserCOMMA                               = 522
	FlinkSqlParserSEMICOLON                           = 523
	FlinkSqlParserAT_SIGN                             = 524
	FlinkSqlParserSINGLE_QUOTE_SYMB                   = 525
	FlinkSqlParserDOUBLE_QUOTE_SYMB                   = 526
	FlinkSqlParserREVERSE_QUOTE_SYMB                  = 527
	FlinkSqlParserCOLON_SYMB                          = 528
	FlinkSqlParserASTERISK_SIGN                       = 529
	FlinkSqlParserUNDERLINE_SIGN                      = 530
	FlinkSqlParserHYPHEN_SIGN                         = 531
	FlinkSqlParserADD_SIGN                            = 532
	FlinkSqlParserPERCENT_SIGN                        = 533
	FlinkSqlParserDOUBLE_VERTICAL_SIGN                = 534
	FlinkSqlParserDOUBLE_HYPHEN_SIGN                  = 535
	FlinkSqlParserSLASH_SIGN                          = 536
	FlinkSqlParserQUESTION_MARK_SIGN                  = 537
	FlinkSqlParserDOUBLE_RIGHT_ARROW                  = 538
	FlinkSqlParserSTRING_LITERAL                      = 539
	FlinkSqlParserDIG_LITERAL                         = 540
	FlinkSqlParserREAL_LITERAL                        = 541
	FlinkSqlParserBIT_STRING                          = 542
	FlinkSqlParserID_LITERAL                          = 543
)

// FlinkSqlParser rules.
const (
	FlinkSqlParserRULE_sqlStatements                              = 0
	FlinkSqlParserRULE_singleStatement                            = 1
	FlinkSqlParserRULE_sqlStatement                               = 2
	FlinkSqlParserRULE_emptyStatement                             = 3
	FlinkSqlParserRULE_ddlStatement                               = 4
	FlinkSqlParserRULE_dmlStatement                               = 5
	FlinkSqlParserRULE_describeStatement                          = 6
	FlinkSqlParserRULE_explainStatement                           = 7
	FlinkSqlParserRULE_explainDetails                             = 8
	FlinkSqlParserRULE_explainDetail                              = 9
	FlinkSqlParserRULE_useStatement                               = 10
	FlinkSqlParserRULE_useModuleStatement                         = 11
	FlinkSqlParserRULE_showStatement                              = 12
	FlinkSqlParserRULE_loadStatement                              = 13
	FlinkSqlParserRULE_unloadStatement                            = 14
	FlinkSqlParserRULE_setStatement                               = 15
	FlinkSqlParserRULE_resetStatement                             = 16
	FlinkSqlParserRULE_jarStatement                               = 17
	FlinkSqlParserRULE_dtAddStatement                             = 18
	FlinkSqlParserRULE_dtFilePath                                 = 19
	FlinkSqlParserRULE_createTable                                = 20
	FlinkSqlParserRULE_simpleCreateTable                          = 21
	FlinkSqlParserRULE_createTableAsSelect                        = 22
	FlinkSqlParserRULE_columnOptionDefinition                     = 23
	FlinkSqlParserRULE_physicalColumnDefinition                   = 24
	FlinkSqlParserRULE_columnNameCreate                           = 25
	FlinkSqlParserRULE_columnName                                 = 26
	FlinkSqlParserRULE_columnNamePath                             = 27
	FlinkSqlParserRULE_columnNameList                             = 28
	FlinkSqlParserRULE_columnType                                 = 29
	FlinkSqlParserRULE_lengthOneDimension                         = 30
	FlinkSqlParserRULE_lengthTwoOptionalDimension                 = 31
	FlinkSqlParserRULE_lengthTwoStringDimension                   = 32
	FlinkSqlParserRULE_lengthOneTypeDimension                     = 33
	FlinkSqlParserRULE_mapTypeDimension                           = 34
	FlinkSqlParserRULE_rowTypeDimension                           = 35
	FlinkSqlParserRULE_columnConstraint                           = 36
	FlinkSqlParserRULE_metadataColumnDefinition                   = 37
	FlinkSqlParserRULE_metadataKey                                = 38
	FlinkSqlParserRULE_computedColumnDefinition                   = 39
	FlinkSqlParserRULE_computedColumnExpression                   = 40
	FlinkSqlParserRULE_watermarkDefinition                        = 41
	FlinkSqlParserRULE_tableConstraint                            = 42
	FlinkSqlParserRULE_constraintName                             = 43
	FlinkSqlParserRULE_selfDefinitionClause                       = 44
	FlinkSqlParserRULE_partitionDefinition                        = 45
	FlinkSqlParserRULE_transformList                              = 46
	FlinkSqlParserRULE_transform                                  = 47
	FlinkSqlParserRULE_transformArgument                          = 48
	FlinkSqlParserRULE_likeDefinition                             = 49
	FlinkSqlParserRULE_likeOption                                 = 50
	FlinkSqlParserRULE_createCatalog                              = 51
	FlinkSqlParserRULE_createDatabase                             = 52
	FlinkSqlParserRULE_createView                                 = 53
	FlinkSqlParserRULE_createFunction                             = 54
	FlinkSqlParserRULE_usingClause                                = 55
	FlinkSqlParserRULE_jarFileName                                = 56
	FlinkSqlParserRULE_alterTable                                 = 57
	FlinkSqlParserRULE_renameDefinition                           = 58
	FlinkSqlParserRULE_setKeyValueDefinition                      = 59
	FlinkSqlParserRULE_addConstraint                              = 60
	FlinkSqlParserRULE_dropConstraint                             = 61
	FlinkSqlParserRULE_addUnique                                  = 62
	FlinkSqlParserRULE_notForced                                  = 63
	FlinkSqlParserRULE_alterView                                  = 64
	FlinkSqlParserRULE_alterDatabase                              = 65
	FlinkSqlParserRULE_alterFunction                              = 66
	FlinkSqlParserRULE_dropCatalog                                = 67
	FlinkSqlParserRULE_dropTable                                  = 68
	FlinkSqlParserRULE_dropDatabase                               = 69
	FlinkSqlParserRULE_dropView                                   = 70
	FlinkSqlParserRULE_dropFunction                               = 71
	FlinkSqlParserRULE_insertStatement                            = 72
	FlinkSqlParserRULE_insertSimpleStatement                      = 73
	FlinkSqlParserRULE_insertPartitionDefinition                  = 74
	FlinkSqlParserRULE_valuesDefinition                           = 75
	FlinkSqlParserRULE_valuesRowDefinition                        = 76
	FlinkSqlParserRULE_insertMulStatementCompatibility            = 77
	FlinkSqlParserRULE_insertMulStatement                         = 78
	FlinkSqlParserRULE_queryStatement                             = 79
	FlinkSqlParserRULE_valuesClause                               = 80
	FlinkSqlParserRULE_withClause                                 = 81
	FlinkSqlParserRULE_withItem                                   = 82
	FlinkSqlParserRULE_withItemName                               = 83
	FlinkSqlParserRULE_selectStatement                            = 84
	FlinkSqlParserRULE_selectClause                               = 85
	FlinkSqlParserRULE_projectItemDefinition                      = 86
	FlinkSqlParserRULE_overWindowItem                             = 87
	FlinkSqlParserRULE_fromClause                                 = 88
	FlinkSqlParserRULE_tableExpression                            = 89
	FlinkSqlParserRULE_tableReference                             = 90
	FlinkSqlParserRULE_tablePrimary                               = 91
	FlinkSqlParserRULE_systemTimePeriod                           = 92
	FlinkSqlParserRULE_dateTimeExpression                         = 93
	FlinkSqlParserRULE_inlineDataValueClause                      = 94
	FlinkSqlParserRULE_windowTVFClause                            = 95
	FlinkSqlParserRULE_windowTVFExpression                        = 96
	FlinkSqlParserRULE_windowTVFName                              = 97
	FlinkSqlParserRULE_windowTVFParam                             = 98
	FlinkSqlParserRULE_timeIntervalParamName                      = 99
	FlinkSqlParserRULE_columnDescriptor                           = 100
	FlinkSqlParserRULE_joinCondition                              = 101
	FlinkSqlParserRULE_whereClause                                = 102
	FlinkSqlParserRULE_groupByClause                              = 103
	FlinkSqlParserRULE_groupItemDefinition                        = 104
	FlinkSqlParserRULE_groupingSets                               = 105
	FlinkSqlParserRULE_groupingSetsNotationName                   = 106
	FlinkSqlParserRULE_groupWindowFunction                        = 107
	FlinkSqlParserRULE_groupWindowFunctionName                    = 108
	FlinkSqlParserRULE_timeAttrColumn                             = 109
	FlinkSqlParserRULE_havingClause                               = 110
	FlinkSqlParserRULE_windowClause                               = 111
	FlinkSqlParserRULE_namedWindow                                = 112
	FlinkSqlParserRULE_windowSpec                                 = 113
	FlinkSqlParserRULE_matchRecognizeClause                       = 114
	FlinkSqlParserRULE_orderByClause                              = 115
	FlinkSqlParserRULE_orderItemDefinition                        = 116
	FlinkSqlParserRULE_limitClause                                = 117
	FlinkSqlParserRULE_partitionByClause                          = 118
	FlinkSqlParserRULE_quantifiers                                = 119
	FlinkSqlParserRULE_measuresClause                             = 120
	FlinkSqlParserRULE_patternDefinition                          = 121
	FlinkSqlParserRULE_patternVariable                            = 122
	FlinkSqlParserRULE_outputMode                                 = 123
	FlinkSqlParserRULE_afterMatchStrategy                         = 124
	FlinkSqlParserRULE_patternVariablesDefinition                 = 125
	FlinkSqlParserRULE_windowFrame                                = 126
	FlinkSqlParserRULE_frameBound                                 = 127
	FlinkSqlParserRULE_withinClause                               = 128
	FlinkSqlParserRULE_expression                                 = 129
	FlinkSqlParserRULE_booleanExpression                          = 130
	FlinkSqlParserRULE_predicate                                  = 131
	FlinkSqlParserRULE_likePredicate                              = 132
	FlinkSqlParserRULE_valueExpression                            = 133
	FlinkSqlParserRULE_functionCallExpression                     = 134
	FlinkSqlParserRULE_primaryExpression                          = 135
	FlinkSqlParserRULE_functionNameCreate                         = 136
	FlinkSqlParserRULE_functionName                               = 137
	FlinkSqlParserRULE_functionNameAndParams                      = 138
	FlinkSqlParserRULE_functionNameWithParams                     = 139
	FlinkSqlParserRULE_functionParam                              = 140
	FlinkSqlParserRULE_dereferenceDefinition                      = 141
	FlinkSqlParserRULE_correlationName                            = 142
	FlinkSqlParserRULE_qualifiedName                              = 143
	FlinkSqlParserRULE_timeIntervalExpression                     = 144
	FlinkSqlParserRULE_errorCapturingMultiUnitsInterval           = 145
	FlinkSqlParserRULE_multiUnitsInterval                         = 146
	FlinkSqlParserRULE_errorCapturingUnitToUnitInterval           = 147
	FlinkSqlParserRULE_unitToUnitInterval                         = 148
	FlinkSqlParserRULE_intervalValue                              = 149
	FlinkSqlParserRULE_tableAlias                                 = 150
	FlinkSqlParserRULE_errorCapturingIdentifier                   = 151
	FlinkSqlParserRULE_errorCapturingIdentifierExtra              = 152
	FlinkSqlParserRULE_identifierList                             = 153
	FlinkSqlParserRULE_identifierSeq                              = 154
	FlinkSqlParserRULE_identifier                                 = 155
	FlinkSqlParserRULE_unquotedIdentifier                         = 156
	FlinkSqlParserRULE_quotedIdentifier                           = 157
	FlinkSqlParserRULE_whenClause                                 = 158
	FlinkSqlParserRULE_catalogPath                                = 159
	FlinkSqlParserRULE_catalogPathCreate                          = 160
	FlinkSqlParserRULE_databasePath                               = 161
	FlinkSqlParserRULE_databasePathCreate                         = 162
	FlinkSqlParserRULE_tablePathCreate                            = 163
	FlinkSqlParserRULE_tablePath                                  = 164
	FlinkSqlParserRULE_viewPath                                   = 165
	FlinkSqlParserRULE_viewPathCreate                             = 166
	FlinkSqlParserRULE_uid                                        = 167
	FlinkSqlParserRULE_withOption                                 = 168
	FlinkSqlParserRULE_ifNotExists                                = 169
	FlinkSqlParserRULE_ifExists                                   = 170
	FlinkSqlParserRULE_tablePropertyList                          = 171
	FlinkSqlParserRULE_tableProperty                              = 172
	FlinkSqlParserRULE_tablePropertyKey                           = 173
	FlinkSqlParserRULE_tablePropertyValue                         = 174
	FlinkSqlParserRULE_logicalOperator                            = 175
	FlinkSqlParserRULE_comparisonOperator                         = 176
	FlinkSqlParserRULE_bitOperator                                = 177
	FlinkSqlParserRULE_mathOperator                               = 178
	FlinkSqlParserRULE_unaryOperator                              = 179
	FlinkSqlParserRULE_constant                                   = 180
	FlinkSqlParserRULE_timePointLiteral                           = 181
	FlinkSqlParserRULE_stringLiteral                              = 182
	FlinkSqlParserRULE_decimalLiteral                             = 183
	FlinkSqlParserRULE_booleanLiteral                             = 184
	FlinkSqlParserRULE_setQuantifier                              = 185
	FlinkSqlParserRULE_timePointUnit                              = 186
	FlinkSqlParserRULE_timeIntervalUnit                           = 187
	FlinkSqlParserRULE_reservedKeywordsUsedAsFuncParam            = 188
	FlinkSqlParserRULE_reservedKeywordsNoParamsUsedAsFuncName     = 189
	FlinkSqlParserRULE_reservedKeywordsFollowParamsUsedAsFuncName = 190
	FlinkSqlParserRULE_reservedKeywordsUsedAsFuncName             = 191
	FlinkSqlParserRULE_nonReservedKeywords                        = 192
)

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSingleStatement() []ISingleStatementContext
	SingleStatement(i int) ISingleStatementContext

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserEOF, 0)
}

func (s *SqlStatementsContext) AllSingleStatement() []ISingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleStatementContext); ok {
			tst[i] = t.(ISingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (p *FlinkSqlParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, FlinkSqlParserRULE_sqlStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserKW_ALTER || _la == FlinkSqlParserKW_BEGIN || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&-8070432802622930943) != 0) || _la == FlinkSqlParserKW_INSERT || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&822083585) != 0) || ((int64((_la-412)) & ^0x3f) == 0 && ((int64(1)<<(_la-412))&288231475805945873) != 0) || ((int64((_la-491)) & ^0x3f) == 0 && ((int64(1)<<(_la-491))&4429187073) != 0) {
		{
			p.SetState(386)
			p.SingleStatement()
		}

		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(392)
		p.Match(FlinkSqlParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SqlStatement() ISqlStatementContext
	SEMICOLON() antlr.TerminalNode
	EmptyStatement() IEmptyStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SingleStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSEMICOLON, 0)
}

func (s *SingleStatementContext) EmptyStatement() IEmptyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *FlinkSqlParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, FlinkSqlParserRULE_singleStatement)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_ALTER, FlinkSqlParserKW_BEGIN, FlinkSqlParserKW_CREATE, FlinkSqlParserKW_DESCRIBE, FlinkSqlParserKW_DROP, FlinkSqlParserKW_EXECUTE, FlinkSqlParserKW_EXPLAIN, FlinkSqlParserKW_INSERT, FlinkSqlParserKW_RESET, FlinkSqlParserKW_SELECT, FlinkSqlParserKW_SET, FlinkSqlParserKW_SHOW, FlinkSqlParserKW_USE, FlinkSqlParserKW_VALUES, FlinkSqlParserKW_WITH, FlinkSqlParserKW_ADD, FlinkSqlParserKW_DESC, FlinkSqlParserKW_LOAD, FlinkSqlParserKW_REMOVE, FlinkSqlParserKW_UNLOAD, FlinkSqlParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)
			p.SqlStatement()
		}
		p.SetState(396)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(395)
				p.Match(FlinkSqlParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case FlinkSqlParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(398)
			p.EmptyStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DdlStatement() IDdlStatementContext
	DmlStatement() IDmlStatementContext
	DescribeStatement() IDescribeStatementContext
	ExplainStatement() IExplainStatementContext
	UseStatement() IUseStatementContext
	ShowStatement() IShowStatementContext
	LoadStatement() ILoadStatementContext
	UnloadStatement() IUnloadStatementContext
	SetStatement() ISetStatementContext
	ResetStatement() IResetStatementContext
	JarStatement() IJarStatementContext
	DtAddStatement() IDtAddStatementContext

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_sqlStatement
	return p
}

func InitEmptySqlStatementContext(p *SqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_sqlStatement
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DdlStatement() IDdlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDdlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDdlStatementContext)
}

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) DescribeStatement() IDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeStatementContext)
}

func (s *SqlStatementContext) ExplainStatement() IExplainStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainStatementContext)
}

func (s *SqlStatementContext) UseStatement() IUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *SqlStatementContext) ShowStatement() IShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatementContext)
}

func (s *SqlStatementContext) LoadStatement() ILoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadStatementContext)
}

func (s *SqlStatementContext) UnloadStatement() IUnloadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnloadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnloadStatementContext)
}

func (s *SqlStatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *SqlStatementContext) ResetStatement() IResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetStatementContext)
}

func (s *SqlStatementContext) JarStatement() IJarStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJarStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJarStatementContext)
}

func (s *SqlStatementContext) DtAddStatement() IDtAddStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtAddStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtAddStatementContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (p *FlinkSqlParser) SqlStatement() (localctx ISqlStatementContext) {
	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, FlinkSqlParserRULE_sqlStatement)
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(401)
			p.DdlStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(402)
			p.DmlStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(403)
			p.DescribeStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(404)
			p.ExplainStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(405)
			p.UseStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(406)
			p.ShowStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(407)
			p.LoadStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(408)
			p.UnloadStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(409)
			p.SetStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(410)
			p.ResetStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(411)
			p.JarStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(412)
			p.DtAddStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatementContext is an interface to support dynamic dispatch.
type IEmptyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode

	// IsEmptyStatementContext differentiates from other interfaces.
	IsEmptyStatementContext()
}

type EmptyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatementContext() *EmptyStatementContext {
	var p = new(EmptyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_emptyStatement
	return p
}

func InitEmptyEmptyStatementContext(p *EmptyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_emptyStatement
}

func (*EmptyStatementContext) IsEmptyStatementContext() {}

func NewEmptyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatementContext {
	var p = new(EmptyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_emptyStatement

	return p
}

func (s *EmptyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSEMICOLON, 0)
}

func (s *EmptyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitEmptyStatement(s)
	}
}

func (p *FlinkSqlParser) EmptyStatement() (localctx IEmptyStatementContext) {
	localctx = NewEmptyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, FlinkSqlParserRULE_emptyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(FlinkSqlParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDdlStatementContext is an interface to support dynamic dispatch.
type IDdlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateTable() ICreateTableContext
	CreateDatabase() ICreateDatabaseContext
	CreateView() ICreateViewContext
	CreateFunction() ICreateFunctionContext
	CreateCatalog() ICreateCatalogContext
	AlterTable() IAlterTableContext
	AlterView() IAlterViewContext
	AlterDatabase() IAlterDatabaseContext
	AlterFunction() IAlterFunctionContext
	DropCatalog() IDropCatalogContext
	DropTable() IDropTableContext
	DropDatabase() IDropDatabaseContext
	DropView() IDropViewContext
	DropFunction() IDropFunctionContext

	// IsDdlStatementContext differentiates from other interfaces.
	IsDdlStatementContext()
}

type DdlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDdlStatementContext() *DdlStatementContext {
	var p = new(DdlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_ddlStatement
	return p
}

func InitEmptyDdlStatementContext(p *DdlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_ddlStatement
}

func (*DdlStatementContext) IsDdlStatementContext() {}

func NewDdlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DdlStatementContext {
	var p = new(DdlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_ddlStatement

	return p
}

func (s *DdlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DdlStatementContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *DdlStatementContext) CreateDatabase() ICreateDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *DdlStatementContext) CreateView() ICreateViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *DdlStatementContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *DdlStatementContext) CreateCatalog() ICreateCatalogContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateCatalogContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateCatalogContext)
}

func (s *DdlStatementContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *DdlStatementContext) AlterView() IAlterViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewContext)
}

func (s *DdlStatementContext) AlterDatabase() IAlterDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseContext)
}

func (s *DdlStatementContext) AlterFunction() IAlterFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterFunctionContext)
}

func (s *DdlStatementContext) DropCatalog() IDropCatalogContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropCatalogContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropCatalogContext)
}

func (s *DdlStatementContext) DropTable() IDropTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *DdlStatementContext) DropDatabase() IDropDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *DdlStatementContext) DropView() IDropViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *DdlStatementContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *DdlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DdlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DdlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDdlStatement(s)
	}
}

func (s *DdlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDdlStatement(s)
	}
}

func (p *FlinkSqlParser) DdlStatement() (localctx IDdlStatementContext) {
	localctx = NewDdlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, FlinkSqlParserRULE_ddlStatement)
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(417)
			p.CreateTable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(418)
			p.CreateDatabase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(419)
			p.CreateView()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(420)
			p.CreateFunction()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(421)
			p.CreateCatalog()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(422)
			p.AlterTable()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(423)
			p.AlterView()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(424)
			p.AlterDatabase()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(425)
			p.AlterFunction()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(426)
			p.DropCatalog()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(427)
			p.DropTable()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(428)
			p.DropDatabase()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(429)
			p.DropView()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(430)
			p.DropFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryStatement() IQueryStatementContext
	InsertStatement() IInsertStatementContext

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dmlStatement
	return p
}

func InitEmptyDmlStatementContext(p *DmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dmlStatement
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *DmlStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDmlStatement(s)
	}
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDmlStatement(s)
	}
}

func (p *FlinkSqlParser) DmlStatement() (localctx IDmlStatementContext) {
	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, FlinkSqlParserRULE_dmlStatement)
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_SELECT, FlinkSqlParserKW_VALUES, FlinkSqlParserKW_WITH, FlinkSqlParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(433)
			p.queryStatement(0)
		}

	case FlinkSqlParserKW_BEGIN, FlinkSqlParserKW_EXECUTE, FlinkSqlParserKW_INSERT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(434)
			p.InsertStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeStatementContext is an interface to support dynamic dispatch.
type IDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TablePath() ITablePathContext
	KW_DESCRIBE() antlr.TerminalNode
	KW_DESC() antlr.TerminalNode

	// IsDescribeStatementContext differentiates from other interfaces.
	IsDescribeStatementContext()
}

type DescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeStatementContext() *DescribeStatementContext {
	var p = new(DescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_describeStatement
	return p
}

func InitEmptyDescribeStatementContext(p *DescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_describeStatement
}

func (*DescribeStatementContext) IsDescribeStatementContext() {}

func NewDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeStatementContext {
	var p = new(DescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_describeStatement

	return p
}

func (s *DescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeStatementContext) TablePath() ITablePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathContext)
}

func (s *DescribeStatementContext) KW_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DESCRIBE, 0)
}

func (s *DescribeStatementContext) KW_DESC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DESC, 0)
}

func (s *DescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDescribeStatement(s)
	}
}

func (s *DescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDescribeStatement(s)
	}
}

func (p *FlinkSqlParser) DescribeStatement() (localctx IDescribeStatementContext) {
	localctx = NewDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, FlinkSqlParserRULE_describeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_DESCRIBE || _la == FlinkSqlParserKW_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(438)
		p.TablePath()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainStatementContext is an interface to support dynamic dispatch.
type IExplainStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXPLAIN() antlr.TerminalNode
	DmlStatement() IDmlStatementContext
	InsertSimpleStatement() IInsertSimpleStatementContext
	InsertMulStatement() IInsertMulStatementContext
	ExplainDetails() IExplainDetailsContext
	KW_PLAN() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode

	// IsExplainStatementContext differentiates from other interfaces.
	IsExplainStatementContext()
}

type ExplainStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainStatementContext() *ExplainStatementContext {
	var p = new(ExplainStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_explainStatement
	return p
}

func InitEmptyExplainStatementContext(p *ExplainStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_explainStatement
}

func (*ExplainStatementContext) IsExplainStatementContext() {}

func NewExplainStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainStatementContext {
	var p = new(ExplainStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_explainStatement

	return p
}

func (s *ExplainStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainStatementContext) KW_EXPLAIN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXPLAIN, 0)
}

func (s *ExplainStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *ExplainStatementContext) InsertSimpleStatement() IInsertSimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertSimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertSimpleStatementContext)
}

func (s *ExplainStatementContext) InsertMulStatement() IInsertMulStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertMulStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertMulStatementContext)
}

func (s *ExplainStatementContext) ExplainDetails() IExplainDetailsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDetailsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDetailsContext)
}

func (s *ExplainStatementContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PLAN, 0)
}

func (s *ExplainStatementContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FOR, 0)
}

func (s *ExplainStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterExplainStatement(s)
	}
}

func (s *ExplainStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitExplainStatement(s)
	}
}

func (p *FlinkSqlParser) ExplainStatement() (localctx IExplainStatementContext) {
	localctx = NewExplainStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, FlinkSqlParserRULE_explainStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(440)
		p.Match(FlinkSqlParserKW_EXPLAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_CHANGELOG_MODE, FlinkSqlParserKW_ESTIMATED_COST, FlinkSqlParserKW_JSON_EXECUTION_PLAN, FlinkSqlParserKW_PLAN_ADVICE:
		{
			p.SetState(441)
			p.ExplainDetails()
		}

	case FlinkSqlParserKW_PLAN:
		{
			p.SetState(442)
			p.Match(FlinkSqlParserKW_PLAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(443)
			p.Match(FlinkSqlParserKW_FOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserKW_BEGIN, FlinkSqlParserKW_EXECUTE, FlinkSqlParserKW_INSERT, FlinkSqlParserKW_SELECT, FlinkSqlParserKW_STATEMENT, FlinkSqlParserKW_VALUES, FlinkSqlParserKW_WITH, FlinkSqlParserLR_BRACKET:

	default:
	}
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(446)
			p.DmlStatement()
		}

	case 2:
		{
			p.SetState(447)
			p.InsertSimpleStatement()
		}

	case 3:
		{
			p.SetState(448)
			p.InsertMulStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainDetailsContext is an interface to support dynamic dispatch.
type IExplainDetailsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExplainDetail() []IExplainDetailContext
	ExplainDetail(i int) IExplainDetailContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExplainDetailsContext differentiates from other interfaces.
	IsExplainDetailsContext()
}

type ExplainDetailsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainDetailsContext() *ExplainDetailsContext {
	var p = new(ExplainDetailsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_explainDetails
	return p
}

func InitEmptyExplainDetailsContext(p *ExplainDetailsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_explainDetails
}

func (*ExplainDetailsContext) IsExplainDetailsContext() {}

func NewExplainDetailsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainDetailsContext {
	var p = new(ExplainDetailsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_explainDetails

	return p
}

func (s *ExplainDetailsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainDetailsContext) AllExplainDetail() []IExplainDetailContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExplainDetailContext); ok {
			len++
		}
	}

	tst := make([]IExplainDetailContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExplainDetailContext); ok {
			tst[i] = t.(IExplainDetailContext)
			i++
		}
	}

	return tst
}

func (s *ExplainDetailsContext) ExplainDetail(i int) IExplainDetailContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDetailContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDetailContext)
}

func (s *ExplainDetailsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *ExplainDetailsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *ExplainDetailsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainDetailsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainDetailsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterExplainDetails(s)
	}
}

func (s *ExplainDetailsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitExplainDetails(s)
	}
}

func (p *FlinkSqlParser) ExplainDetails() (localctx IExplainDetailsContext) {
	localctx = NewExplainDetailsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, FlinkSqlParserRULE_explainDetails)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.ExplainDetail()
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(452)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(453)
			p.ExplainDetail()
		}

		p.SetState(458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainDetailContext is an interface to support dynamic dispatch.
type IExplainDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CHANGELOG_MODE() antlr.TerminalNode
	KW_PLAN_ADVICE() antlr.TerminalNode
	KW_JSON_EXECUTION_PLAN() antlr.TerminalNode
	KW_ESTIMATED_COST() antlr.TerminalNode

	// IsExplainDetailContext differentiates from other interfaces.
	IsExplainDetailContext()
}

type ExplainDetailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainDetailContext() *ExplainDetailContext {
	var p = new(ExplainDetailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_explainDetail
	return p
}

func InitEmptyExplainDetailContext(p *ExplainDetailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_explainDetail
}

func (*ExplainDetailContext) IsExplainDetailContext() {}

func NewExplainDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainDetailContext {
	var p = new(ExplainDetailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_explainDetail

	return p
}

func (s *ExplainDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainDetailContext) KW_CHANGELOG_MODE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CHANGELOG_MODE, 0)
}

func (s *ExplainDetailContext) KW_PLAN_ADVICE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PLAN_ADVICE, 0)
}

func (s *ExplainDetailContext) KW_JSON_EXECUTION_PLAN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_EXECUTION_PLAN, 0)
}

func (s *ExplainDetailContext) KW_ESTIMATED_COST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ESTIMATED_COST, 0)
}

func (s *ExplainDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterExplainDetail(s)
	}
}

func (s *ExplainDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitExplainDetail(s)
	}
}

func (p *FlinkSqlParser) ExplainDetail() (localctx IExplainDetailContext) {
	localctx = NewExplainDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, FlinkSqlParserRULE_explainDetail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(459)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_CHANGELOG_MODE || _la == FlinkSqlParserKW_ESTIMATED_COST || _la == FlinkSqlParserKW_JSON_EXECUTION_PLAN || _la == FlinkSqlParserKW_PLAN_ADVICE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_USE() antlr.TerminalNode
	KW_CATALOG() antlr.TerminalNode
	CatalogPath() ICatalogPathContext
	DatabasePath() IDatabasePathContext
	UseModuleStatement() IUseModuleStatementContext

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_useStatement
	return p
}

func InitEmptyUseStatementContext(p *UseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_useStatement
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) KW_USE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_USE, 0)
}

func (s *UseStatementContext) KW_CATALOG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CATALOG, 0)
}

func (s *UseStatementContext) CatalogPath() ICatalogPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogPathContext)
}

func (s *UseStatementContext) DatabasePath() IDatabasePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabasePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabasePathContext)
}

func (s *UseStatementContext) UseModuleStatement() IUseModuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseModuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseModuleStatementContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (p *FlinkSqlParser) UseStatement() (localctx IUseStatementContext) {
	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, FlinkSqlParserRULE_useStatement)
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(461)
			p.Match(FlinkSqlParserKW_USE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(462)
			p.Match(FlinkSqlParserKW_CATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)
			p.CatalogPath()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.Match(FlinkSqlParserKW_USE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(465)
			p.DatabasePath()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(466)
			p.UseModuleStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseModuleStatementContext is an interface to support dynamic dispatch.
type IUseModuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_USE() antlr.TerminalNode
	KW_MODULES() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUseModuleStatementContext differentiates from other interfaces.
	IsUseModuleStatementContext()
}

type UseModuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseModuleStatementContext() *UseModuleStatementContext {
	var p = new(UseModuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_useModuleStatement
	return p
}

func InitEmptyUseModuleStatementContext(p *UseModuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_useModuleStatement
}

func (*UseModuleStatementContext) IsUseModuleStatementContext() {}

func NewUseModuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseModuleStatementContext {
	var p = new(UseModuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_useModuleStatement

	return p
}

func (s *UseModuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseModuleStatementContext) KW_USE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_USE, 0)
}

func (s *UseModuleStatementContext) KW_MODULES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MODULES, 0)
}

func (s *UseModuleStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UseModuleStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UseModuleStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *UseModuleStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *UseModuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseModuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseModuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUseModuleStatement(s)
	}
}

func (s *UseModuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUseModuleStatement(s)
	}
}

func (p *FlinkSqlParser) UseModuleStatement() (localctx IUseModuleStatementContext) {
	localctx = NewUseModuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, FlinkSqlParserRULE_useModuleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(FlinkSqlParserKW_USE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(470)
		p.Match(FlinkSqlParserKW_MODULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(471)
		p.Uid()
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(472)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(473)
			p.Uid()
		}

		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SHOW() antlr.TerminalNode
	KW_CATALOGS() antlr.TerminalNode
	KW_DATABASES() antlr.TerminalNode
	KW_VIEWS() antlr.TerminalNode
	KW_JARS() antlr.TerminalNode
	KW_CURRENT() antlr.TerminalNode
	KW_CATALOG() antlr.TerminalNode
	KW_DATABASE() antlr.TerminalNode
	KW_TABLES() antlr.TerminalNode
	DatabasePath() IDatabasePathContext
	LikePredicate() ILikePredicateContext
	KW_FROM() antlr.TerminalNode
	KW_IN() antlr.TerminalNode
	KW_COLUMNS() antlr.TerminalNode
	ViewPath() IViewPathContext
	TablePath() ITablePathContext
	KW_CREATE() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	KW_FUNCTIONS() antlr.TerminalNode
	KW_USER() antlr.TerminalNode
	KW_MODULES() antlr.TerminalNode
	KW_FULL() antlr.TerminalNode

	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_showStatement
	return p
}

func InitEmptyShowStatementContext(p *ShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_showStatement
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) KW_SHOW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SHOW, 0)
}

func (s *ShowStatementContext) KW_CATALOGS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CATALOGS, 0)
}

func (s *ShowStatementContext) KW_DATABASES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATABASES, 0)
}

func (s *ShowStatementContext) KW_VIEWS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VIEWS, 0)
}

func (s *ShowStatementContext) KW_JARS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JARS, 0)
}

func (s *ShowStatementContext) KW_CURRENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT, 0)
}

func (s *ShowStatementContext) KW_CATALOG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CATALOG, 0)
}

func (s *ShowStatementContext) KW_DATABASE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATABASE, 0)
}

func (s *ShowStatementContext) KW_TABLES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLES, 0)
}

func (s *ShowStatementContext) DatabasePath() IDatabasePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabasePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabasePathContext)
}

func (s *ShowStatementContext) LikePredicate() ILikePredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikePredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikePredicateContext)
}

func (s *ShowStatementContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FROM, 0)
}

func (s *ShowStatementContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IN, 0)
}

func (s *ShowStatementContext) KW_COLUMNS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COLUMNS, 0)
}

func (s *ShowStatementContext) ViewPath() IViewPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewPathContext)
}

func (s *ShowStatementContext) TablePath() ITablePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathContext)
}

func (s *ShowStatementContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CREATE, 0)
}

func (s *ShowStatementContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *ShowStatementContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VIEW, 0)
}

func (s *ShowStatementContext) KW_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FUNCTIONS, 0)
}

func (s *ShowStatementContext) KW_USER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_USER, 0)
}

func (s *ShowStatementContext) KW_MODULES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MODULES, 0)
}

func (s *ShowStatementContext) KW_FULL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FULL, 0)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterShowStatement(s)
	}
}

func (s *ShowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitShowStatement(s)
	}
}

func (p *FlinkSqlParser) ShowStatement() (localctx IShowStatementContext) {
	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, FlinkSqlParserRULE_showStatement)
	var _la int

	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.Match(FlinkSqlParserKW_SHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(480)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_CATALOGS || _la == FlinkSqlParserKW_DATABASES || _la == FlinkSqlParserKW_VIEWS || _la == FlinkSqlParserKW_JARS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(481)
			p.Match(FlinkSqlParserKW_SHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(482)
			p.Match(FlinkSqlParserKW_CURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_CATALOG || _la == FlinkSqlParserKW_DATABASE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(484)
			p.Match(FlinkSqlParserKW_SHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(485)
			p.Match(FlinkSqlParserKW_TABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_FROM || _la == FlinkSqlParserKW_IN {
			{
				p.SetState(486)
				_la = p.GetTokenStream().LA(1)

				if !(_la == FlinkSqlParserKW_FROM || _la == FlinkSqlParserKW_IN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(487)
				p.DatabasePath()
			}

		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_LIKE || _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(490)
				p.LikePredicate()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(493)
			p.Match(FlinkSqlParserKW_SHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(494)
			p.Match(FlinkSqlParserKW_COLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(495)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_FROM || _la == FlinkSqlParserKW_IN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(496)
				p.ViewPath()
			}

		case 2:
			{
				p.SetState(497)
				p.TablePath()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_LIKE || _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(500)
				p.LikePredicate()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(503)
			p.Match(FlinkSqlParserKW_SHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(504)
			p.Match(FlinkSqlParserKW_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case FlinkSqlParserKW_TABLE:
			{
				p.SetState(505)
				p.Match(FlinkSqlParserKW_TABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(506)
				p.TablePath()
			}

		case FlinkSqlParserKW_VIEW:
			{
				p.SetState(507)
				p.Match(FlinkSqlParserKW_VIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(508)
				p.ViewPath()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(511)
			p.Match(FlinkSqlParserKW_SHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_USER {
			{
				p.SetState(512)
				p.Match(FlinkSqlParserKW_USER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(515)
			p.Match(FlinkSqlParserKW_FUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(516)
			p.Match(FlinkSqlParserKW_SHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_FULL {
			{
				p.SetState(517)
				p.Match(FlinkSqlParserKW_FULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(520)
			p.Match(FlinkSqlParserKW_MODULES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadStatementContext is an interface to support dynamic dispatch.
type ILoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LOAD() antlr.TerminalNode
	KW_MODULE() antlr.TerminalNode
	Uid() IUidContext
	KW_WITH() antlr.TerminalNode
	TablePropertyList() ITablePropertyListContext

	// IsLoadStatementContext differentiates from other interfaces.
	IsLoadStatementContext()
}

type LoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadStatementContext() *LoadStatementContext {
	var p = new(LoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_loadStatement
	return p
}

func InitEmptyLoadStatementContext(p *LoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_loadStatement
}

func (*LoadStatementContext) IsLoadStatementContext() {}

func NewLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStatementContext {
	var p = new(LoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_loadStatement

	return p
}

func (s *LoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStatementContext) KW_LOAD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOAD, 0)
}

func (s *LoadStatementContext) KW_MODULE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MODULE, 0)
}

func (s *LoadStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LoadStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WITH, 0)
}

func (s *LoadStatementContext) TablePropertyList() ITablePropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyListContext)
}

func (s *LoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLoadStatement(s)
	}
}

func (s *LoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLoadStatement(s)
	}
}

func (p *FlinkSqlParser) LoadStatement() (localctx ILoadStatementContext) {
	localctx = NewLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, FlinkSqlParserRULE_loadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Match(FlinkSqlParserKW_LOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(524)
		p.Match(FlinkSqlParserKW_MODULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.Uid()
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(526)
			p.Match(FlinkSqlParserKW_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(527)
			p.TablePropertyList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnloadStatementContext is an interface to support dynamic dispatch.
type IUnloadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_UNLOAD() antlr.TerminalNode
	KW_MODULE() antlr.TerminalNode
	Uid() IUidContext

	// IsUnloadStatementContext differentiates from other interfaces.
	IsUnloadStatementContext()
}

type UnloadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnloadStatementContext() *UnloadStatementContext {
	var p = new(UnloadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unloadStatement
	return p
}

func InitEmptyUnloadStatementContext(p *UnloadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unloadStatement
}

func (*UnloadStatementContext) IsUnloadStatementContext() {}

func NewUnloadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnloadStatementContext {
	var p = new(UnloadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_unloadStatement

	return p
}

func (s *UnloadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnloadStatementContext) KW_UNLOAD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UNLOAD, 0)
}

func (s *UnloadStatementContext) KW_MODULE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MODULE, 0)
}

func (s *UnloadStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UnloadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnloadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnloadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUnloadStatement(s)
	}
}

func (s *UnloadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUnloadStatement(s)
	}
}

func (p *FlinkSqlParser) UnloadStatement() (localctx IUnloadStatementContext) {
	localctx = NewUnloadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, FlinkSqlParserRULE_unloadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(FlinkSqlParserKW_UNLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(531)
		p.Match(FlinkSqlParserKW_MODULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(532)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	TableProperty() ITablePropertyContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SET, 0)
}

func (s *SetStatementContext) TableProperty() ITablePropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (p *FlinkSqlParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, FlinkSqlParserRULE_setStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Match(FlinkSqlParserKW_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(536)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(535)
			p.TableProperty()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetStatementContext is an interface to support dynamic dispatch.
type IResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RESET() antlr.TerminalNode
	TablePropertyKey() ITablePropertyKeyContext

	// IsResetStatementContext differentiates from other interfaces.
	IsResetStatementContext()
}

type ResetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStatementContext() *ResetStatementContext {
	var p = new(ResetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_resetStatement
	return p
}

func InitEmptyResetStatementContext(p *ResetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_resetStatement
}

func (*ResetStatementContext) IsResetStatementContext() {}

func NewResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStatementContext {
	var p = new(ResetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_resetStatement

	return p
}

func (s *ResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStatementContext) KW_RESET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RESET, 0)
}

func (s *ResetStatementContext) TablePropertyKey() ITablePropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyKeyContext)
}

func (s *ResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterResetStatement(s)
	}
}

func (s *ResetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitResetStatement(s)
	}
}

func (p *FlinkSqlParser) ResetStatement() (localctx IResetStatementContext) {
	localctx = NewResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, FlinkSqlParserRULE_resetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(538)
		p.Match(FlinkSqlParserKW_RESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(539)
			p.TablePropertyKey()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJarStatementContext is an interface to support dynamic dispatch.
type IJarStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_JAR() antlr.TerminalNode
	JarFileName() IJarFileNameContext
	KW_ADD() antlr.TerminalNode
	KW_REMOVE() antlr.TerminalNode

	// IsJarStatementContext differentiates from other interfaces.
	IsJarStatementContext()
}

type JarStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJarStatementContext() *JarStatementContext {
	var p = new(JarStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_jarStatement
	return p
}

func InitEmptyJarStatementContext(p *JarStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_jarStatement
}

func (*JarStatementContext) IsJarStatementContext() {}

func NewJarStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JarStatementContext {
	var p = new(JarStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_jarStatement

	return p
}

func (s *JarStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JarStatementContext) KW_JAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JAR, 0)
}

func (s *JarStatementContext) JarFileName() IJarFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJarFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJarFileNameContext)
}

func (s *JarStatementContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ADD, 0)
}

func (s *JarStatementContext) KW_REMOVE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_REMOVE, 0)
}

func (s *JarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JarStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterJarStatement(s)
	}
}

func (s *JarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitJarStatement(s)
	}
}

func (p *FlinkSqlParser) JarStatement() (localctx IJarStatementContext) {
	localctx = NewJarStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, FlinkSqlParserRULE_jarStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_ADD || _la == FlinkSqlParserKW_REMOVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(543)
		p.Match(FlinkSqlParserKW_JAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(544)
		p.JarFileName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtAddStatementContext is an interface to support dynamic dispatch.
type IDtAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ADD() antlr.TerminalNode
	KW_JAR() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	DtFilePath() IDtFilePathContext
	KW_AS() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	KW_FILE() antlr.TerminalNode
	KW_RENAME() antlr.TerminalNode
	KW_PYTHON_FILES() antlr.TerminalNode
	KW_PYTHON_REQUIREMENTS() antlr.TerminalNode
	KW_PYTHON_DEPENDENCIES() antlr.TerminalNode
	KW_PYTHON_JAR() antlr.TerminalNode
	KW_PYTHON_ARCHIVES() antlr.TerminalNode
	KW_PYTHON_PARAMETER() antlr.TerminalNode
	KW_ENGINE() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	KW_CONFIG() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode

	// IsDtAddStatementContext differentiates from other interfaces.
	IsDtAddStatementContext()
}

type DtAddStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtAddStatementContext() *DtAddStatementContext {
	var p = new(DtAddStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dtAddStatement
	return p
}

func InitEmptyDtAddStatementContext(p *DtAddStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dtAddStatement
}

func (*DtAddStatementContext) IsDtAddStatementContext() {}

func NewDtAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtAddStatementContext {
	var p = new(DtAddStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dtAddStatement

	return p
}

func (s *DtAddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DtAddStatementContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ADD, 0)
}

func (s *DtAddStatementContext) KW_JAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JAR, 0)
}

func (s *DtAddStatementContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WITH, 0)
}

func (s *DtAddStatementContext) DtFilePath() IDtFilePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtFilePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtFilePathContext)
}

func (s *DtAddStatementContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *DtAddStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *DtAddStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DtAddStatementContext) KW_FILE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FILE, 0)
}

func (s *DtAddStatementContext) KW_RENAME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RENAME, 0)
}

func (s *DtAddStatementContext) KW_PYTHON_FILES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_FILES, 0)
}

func (s *DtAddStatementContext) KW_PYTHON_REQUIREMENTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_REQUIREMENTS, 0)
}

func (s *DtAddStatementContext) KW_PYTHON_DEPENDENCIES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_DEPENDENCIES, 0)
}

func (s *DtAddStatementContext) KW_PYTHON_JAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_JAR, 0)
}

func (s *DtAddStatementContext) KW_PYTHON_ARCHIVES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_ARCHIVES, 0)
}

func (s *DtAddStatementContext) KW_PYTHON_PARAMETER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_PARAMETER, 0)
}

func (s *DtAddStatementContext) KW_ENGINE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ENGINE, 0)
}

func (s *DtAddStatementContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_KEY, 0)
}

func (s *DtAddStatementContext) KW_CONFIG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONFIG, 0)
}

func (s *DtAddStatementContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FOR, 0)
}

func (s *DtAddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtAddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtAddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDtAddStatement(s)
	}
}

func (s *DtAddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDtAddStatement(s)
	}
}

func (p *FlinkSqlParser) DtAddStatement() (localctx IDtAddStatementContext) {
	localctx = NewDtAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, FlinkSqlParserRULE_dtAddStatement)
	var _la int

	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(546)
			p.Match(FlinkSqlParserKW_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(547)
			p.Match(FlinkSqlParserKW_JAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.Match(FlinkSqlParserKW_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(549)
			p.DtFilePath()
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_AS {
			{
				p.SetState(550)
				p.Match(FlinkSqlParserKW_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(551)
				p.Uid()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(554)
			p.Match(FlinkSqlParserKW_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(555)
			p.Match(FlinkSqlParserKW_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(556)
			p.Match(FlinkSqlParserKW_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)
			p.DtFilePath()
		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_AS {
			{
				p.SetState(558)
				p.Match(FlinkSqlParserKW_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(559)
				p.Uid()
			}

		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_RENAME {
			{
				p.SetState(562)
				p.Match(FlinkSqlParserKW_RENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(563)
				p.Uid()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(566)
			p.Match(FlinkSqlParserKW_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(567)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-484)) & ^0x3f) == 0 && ((int64(1)<<(_la-484))&47) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(568)
			p.Match(FlinkSqlParserKW_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(569)
			p.DtFilePath()
		}
		{
			p.SetState(570)
			p.Match(FlinkSqlParserKW_RENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(571)
			p.Uid()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(573)
			p.Match(FlinkSqlParserKW_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(574)
			p.Match(FlinkSqlParserKW_PYTHON_PARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(575)
			p.DtFilePath()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(576)
			p.Match(FlinkSqlParserKW_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(577)
			p.Match(FlinkSqlParserKW_ENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(578)
			p.Match(FlinkSqlParserKW_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(579)
			p.Match(FlinkSqlParserKW_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(580)
			p.DtFilePath()
		}
		{
			p.SetState(581)
			p.Match(FlinkSqlParserKW_RENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)
			p.Uid()
		}
		{
			p.SetState(583)
			p.Match(FlinkSqlParserKW_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(584)
			p.Uid()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(586)
			p.Match(FlinkSqlParserKW_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(587)
			p.Match(FlinkSqlParserKW_CONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(588)
			p.Match(FlinkSqlParserKW_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(589)
			p.Match(FlinkSqlParserKW_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(590)
			p.DtFilePath()
		}
		{
			p.SetState(591)
			p.Match(FlinkSqlParserKW_FOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(592)
			p.Uid()
		}
		{
			p.SetState(593)
			p.Match(FlinkSqlParserKW_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtFilePathContext is an interface to support dynamic dispatch.
type IDtFilePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllSLASH_SIGN() []antlr.TerminalNode
	SLASH_SIGN(i int) antlr.TerminalNode

	// IsDtFilePathContext differentiates from other interfaces.
	IsDtFilePathContext()
}

type DtFilePathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtFilePathContext() *DtFilePathContext {
	var p = new(DtFilePathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dtFilePath
	return p
}

func InitEmptyDtFilePathContext(p *DtFilePathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dtFilePath
}

func (*DtFilePathContext) IsDtFilePathContext() {}

func NewDtFilePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtFilePathContext {
	var p = new(DtFilePathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dtFilePath

	return p
}

func (s *DtFilePathContext) GetParser() antlr.Parser { return s.parser }

func (s *DtFilePathContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *DtFilePathContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DtFilePathContext) AllSLASH_SIGN() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserSLASH_SIGN)
}

func (s *DtFilePathContext) SLASH_SIGN(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSLASH_SIGN, i)
}

func (s *DtFilePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtFilePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtFilePathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDtFilePath(s)
	}
}

func (s *DtFilePathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDtFilePath(s)
	}
}

func (p *FlinkSqlParser) DtFilePath() (localctx IDtFilePathContext) {
	localctx = NewDtFilePathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, FlinkSqlParserRULE_dtFilePath)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(599)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == FlinkSqlParserSLASH_SIGN {
				{
					p.SetState(598)
					p.Match(FlinkSqlParserSLASH_SIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(601)
				p.Uid()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(604)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleCreateTable() ISimpleCreateTableContext
	CreateTableAsSelect() ICreateTableAsSelectContext

	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createTable
	return p
}

func InitEmptyCreateTableContext(p *CreateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createTable
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) SimpleCreateTable() ISimpleCreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleCreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleCreateTableContext)
}

func (s *CreateTableContext) CreateTableAsSelect() ICreateTableAsSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (p *FlinkSqlParser) CreateTable() (localctx ICreateTableContext) {
	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, FlinkSqlParserRULE_createTable)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(606)
			p.SimpleCreateTable()
		}

	case 2:
		{
			p.SetState(607)
			p.CreateTableAsSelect()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleCreateTableContext is an interface to support dynamic dispatch.
type ISimpleCreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TablePathCreate() ITablePathCreateContext
	LR_BRACKET() antlr.TerminalNode
	AllColumnOptionDefinition() []IColumnOptionDefinitionContext
	ColumnOptionDefinition(i int) IColumnOptionDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	WithOption() IWithOptionContext
	KW_TEMPORARY() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WatermarkDefinition() IWatermarkDefinitionContext
	TableConstraint() ITableConstraintContext
	SelfDefinitionClause() ISelfDefinitionClauseContext
	KW_COMMENT() antlr.TerminalNode
	PartitionDefinition() IPartitionDefinitionContext
	LikeDefinition() ILikeDefinitionContext
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleCreateTableContext differentiates from other interfaces.
	IsSimpleCreateTableContext()
}

type SimpleCreateTableContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	comment antlr.Token
}

func NewEmptySimpleCreateTableContext() *SimpleCreateTableContext {
	var p = new(SimpleCreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_simpleCreateTable
	return p
}

func InitEmptySimpleCreateTableContext(p *SimpleCreateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_simpleCreateTable
}

func (*SimpleCreateTableContext) IsSimpleCreateTableContext() {}

func NewSimpleCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleCreateTableContext {
	var p = new(SimpleCreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_simpleCreateTable

	return p
}

func (s *SimpleCreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleCreateTableContext) GetComment() antlr.Token { return s.comment }

func (s *SimpleCreateTableContext) SetComment(v antlr.Token) { s.comment = v }

func (s *SimpleCreateTableContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CREATE, 0)
}

func (s *SimpleCreateTableContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *SimpleCreateTableContext) TablePathCreate() ITablePathCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathCreateContext)
}

func (s *SimpleCreateTableContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *SimpleCreateTableContext) AllColumnOptionDefinition() []IColumnOptionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnOptionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnOptionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnOptionDefinitionContext); ok {
			tst[i] = t.(IColumnOptionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCreateTableContext) ColumnOptionDefinition(i int) IColumnOptionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnOptionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnOptionDefinitionContext)
}

func (s *SimpleCreateTableContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *SimpleCreateTableContext) WithOption() IWithOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithOptionContext)
}

func (s *SimpleCreateTableContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *SimpleCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *SimpleCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *SimpleCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *SimpleCreateTableContext) WatermarkDefinition() IWatermarkDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWatermarkDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWatermarkDefinitionContext)
}

func (s *SimpleCreateTableContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *SimpleCreateTableContext) SelfDefinitionClause() ISelfDefinitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelfDefinitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelfDefinitionClauseContext)
}

func (s *SimpleCreateTableContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COMMENT, 0)
}

func (s *SimpleCreateTableContext) PartitionDefinition() IPartitionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *SimpleCreateTableContext) LikeDefinition() ILikeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeDefinitionContext)
}

func (s *SimpleCreateTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *SimpleCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSimpleCreateTable(s)
	}
}

func (s *SimpleCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSimpleCreateTable(s)
	}
}

func (p *FlinkSqlParser) SimpleCreateTable() (localctx ISimpleCreateTableContext) {
	localctx = NewSimpleCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, FlinkSqlParserRULE_simpleCreateTable)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(FlinkSqlParserKW_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_TEMPORARY {
		{
			p.SetState(611)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(614)
		p.Match(FlinkSqlParserKW_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(615)
			p.IfNotExists()
		}

	}
	{
		p.SetState(618)
		p.TablePathCreate()
	}
	{
		p.SetState(619)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(620)
		p.ColumnOptionDefinition()
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(621)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(622)
				p.ColumnOptionDefinition()
			}

		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(628)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(629)
			p.WatermarkDefinition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(632)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(633)
			p.TableConstraint()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserCOMMA {
		{
			p.SetState(636)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(637)
			p.SelfDefinitionClause()
		}

	}
	{
		p.SetState(640)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_COMMENT {
		{
			p.SetState(641)
			p.Match(FlinkSqlParserKW_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(642)

			var _m = p.Match(FlinkSqlParserSTRING_LITERAL)

			localctx.(*SimpleCreateTableContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_PARTITIONED {
		{
			p.SetState(645)
			p.PartitionDefinition()
		}

	}
	{
		p.SetState(648)
		p.WithOption()
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_LIKE {
		{
			p.SetState(649)
			p.LikeDefinition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableAsSelectContext is an interface to support dynamic dispatch.
type ICreateTableAsSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TablePathCreate() ITablePathCreateContext
	WithOption() IWithOptionContext
	IfNotExists() IIfNotExistsContext
	KW_AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext

	// IsCreateTableAsSelectContext differentiates from other interfaces.
	IsCreateTableAsSelectContext()
}

type CreateTableAsSelectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableAsSelectContext() *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createTableAsSelect
	return p
}

func InitEmptyCreateTableAsSelectContext(p *CreateTableAsSelectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createTableAsSelect
}

func (*CreateTableAsSelectContext) IsCreateTableAsSelectContext() {}

func NewCreateTableAsSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_createTableAsSelect

	return p
}

func (s *CreateTableAsSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableAsSelectContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CREATE, 0)
}

func (s *CreateTableAsSelectContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *CreateTableAsSelectContext) TablePathCreate() ITablePathCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathCreateContext)
}

func (s *CreateTableAsSelectContext) WithOption() IWithOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithOptionContext)
}

func (s *CreateTableAsSelectContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateTableAsSelectContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *CreateTableAsSelectContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCreateTableAsSelect(s)
	}
}

func (p *FlinkSqlParser) CreateTableAsSelect() (localctx ICreateTableAsSelectContext) {
	localctx = NewCreateTableAsSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, FlinkSqlParserRULE_createTableAsSelect)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(FlinkSqlParserKW_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.Match(FlinkSqlParserKW_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(654)
			p.IfNotExists()
		}

	}
	{
		p.SetState(657)
		p.TablePathCreate()
	}
	{
		p.SetState(658)
		p.WithOption()
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_AS {
		{
			p.SetState(659)
			p.Match(FlinkSqlParserKW_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(660)
			p.queryStatement(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnOptionDefinitionContext is an interface to support dynamic dispatch.
type IColumnOptionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PhysicalColumnDefinition() IPhysicalColumnDefinitionContext
	MetadataColumnDefinition() IMetadataColumnDefinitionContext
	ComputedColumnDefinition() IComputedColumnDefinitionContext

	// IsColumnOptionDefinitionContext differentiates from other interfaces.
	IsColumnOptionDefinitionContext()
}

type ColumnOptionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnOptionDefinitionContext() *ColumnOptionDefinitionContext {
	var p = new(ColumnOptionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnOptionDefinition
	return p
}

func InitEmptyColumnOptionDefinitionContext(p *ColumnOptionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnOptionDefinition
}

func (*ColumnOptionDefinitionContext) IsColumnOptionDefinitionContext() {}

func NewColumnOptionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnOptionDefinitionContext {
	var p = new(ColumnOptionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnOptionDefinition

	return p
}

func (s *ColumnOptionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnOptionDefinitionContext) PhysicalColumnDefinition() IPhysicalColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPhysicalColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPhysicalColumnDefinitionContext)
}

func (s *ColumnOptionDefinitionContext) MetadataColumnDefinition() IMetadataColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetadataColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetadataColumnDefinitionContext)
}

func (s *ColumnOptionDefinitionContext) ComputedColumnDefinition() IComputedColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComputedColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComputedColumnDefinitionContext)
}

func (s *ColumnOptionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnOptionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnOptionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnOptionDefinition(s)
	}
}

func (s *ColumnOptionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnOptionDefinition(s)
	}
}

func (p *FlinkSqlParser) ColumnOptionDefinition() (localctx IColumnOptionDefinitionContext) {
	localctx = NewColumnOptionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, FlinkSqlParserRULE_columnOptionDefinition)
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(663)
			p.PhysicalColumnDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(664)
			p.MetadataColumnDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(665)
			p.ComputedColumnDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPhysicalColumnDefinitionContext is an interface to support dynamic dispatch.
type IPhysicalColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// Getter signatures
	ColumnNameCreate() IColumnNameCreateContext
	ColumnType() IColumnTypeContext
	ColumnConstraint() IColumnConstraintContext
	KW_COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsPhysicalColumnDefinitionContext differentiates from other interfaces.
	IsPhysicalColumnDefinitionContext()
}

type PhysicalColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	comment antlr.Token
}

func NewEmptyPhysicalColumnDefinitionContext() *PhysicalColumnDefinitionContext {
	var p = new(PhysicalColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_physicalColumnDefinition
	return p
}

func InitEmptyPhysicalColumnDefinitionContext(p *PhysicalColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_physicalColumnDefinition
}

func (*PhysicalColumnDefinitionContext) IsPhysicalColumnDefinitionContext() {}

func NewPhysicalColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PhysicalColumnDefinitionContext {
	var p = new(PhysicalColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_physicalColumnDefinition

	return p
}

func (s *PhysicalColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PhysicalColumnDefinitionContext) GetComment() antlr.Token { return s.comment }

func (s *PhysicalColumnDefinitionContext) SetComment(v antlr.Token) { s.comment = v }

func (s *PhysicalColumnDefinitionContext) ColumnNameCreate() IColumnNameCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameCreateContext)
}

func (s *PhysicalColumnDefinitionContext) ColumnType() IColumnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeContext)
}

func (s *PhysicalColumnDefinitionContext) ColumnConstraint() IColumnConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *PhysicalColumnDefinitionContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COMMENT, 0)
}

func (s *PhysicalColumnDefinitionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *PhysicalColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PhysicalColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PhysicalColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPhysicalColumnDefinition(s)
	}
}

func (s *PhysicalColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPhysicalColumnDefinition(s)
	}
}

func (p *FlinkSqlParser) PhysicalColumnDefinition() (localctx IPhysicalColumnDefinitionContext) {
	localctx = NewPhysicalColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, FlinkSqlParserRULE_physicalColumnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.ColumnNameCreate()
	}
	{
		p.SetState(669)
		p.ColumnType()
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_CONSTRAINT || ((int64((_la-242)) & ^0x3f) == 0 && ((int64(1)<<(_la-242))&281474976710665) != 0) {
		{
			p.SetState(670)
			p.ColumnConstraint()
		}

	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_COMMENT {
		{
			p.SetState(673)
			p.Match(FlinkSqlParserKW_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)

			var _m = p.Match(FlinkSqlParserSTRING_LITERAL)

			localctx.(*PhysicalColumnDefinitionContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameCreateContext is an interface to support dynamic dispatch.
type IColumnNameCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	Expression() IExpressionContext

	// IsColumnNameCreateContext differentiates from other interfaces.
	IsColumnNameCreateContext()
}

type ColumnNameCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameCreateContext() *ColumnNameCreateContext {
	var p = new(ColumnNameCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnNameCreate
	return p
}

func InitEmptyColumnNameCreateContext(p *ColumnNameCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnNameCreate
}

func (*ColumnNameCreateContext) IsColumnNameCreateContext() {}

func NewColumnNameCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameCreateContext {
	var p = new(ColumnNameCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnNameCreate

	return p
}

func (s *ColumnNameCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameCreateContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ColumnNameCreateContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColumnNameCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnNameCreate(s)
	}
}

func (s *ColumnNameCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnNameCreate(s)
	}
}

func (p *FlinkSqlParser) ColumnNameCreate() (localctx IColumnNameCreateContext) {
	localctx = NewColumnNameCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, FlinkSqlParserRULE_columnNameCreate)
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(677)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(678)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameContext is an interface to support dynamic dispatch.
type IColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsColumnNameContext differentiates from other interfaces.
	IsColumnNameContext()
}

type ColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameContext() *ColumnNameContext {
	var p = new(ColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnName
	return p
}

func InitEmptyColumnNameContext(p *ColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnName
}

func (*ColumnNameContext) IsColumnNameContext() {}

func NewColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameContext {
	var p = new(ColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnName

	return p
}

func (s *ColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnName(s)
	}
}

func (s *ColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnName(s)
	}
}

func (p *FlinkSqlParser) ColumnName() (localctx IColumnNameContext) {
	localctx = NewColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, FlinkSqlParserRULE_columnName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNamePathContext is an interface to support dynamic dispatch.
type IColumnNamePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsColumnNamePathContext differentiates from other interfaces.
	IsColumnNamePathContext()
}

type ColumnNamePathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNamePathContext() *ColumnNamePathContext {
	var p = new(ColumnNamePathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnNamePath
	return p
}

func InitEmptyColumnNamePathContext(p *ColumnNamePathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnNamePath
}

func (*ColumnNamePathContext) IsColumnNamePathContext() {}

func NewColumnNamePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNamePathContext {
	var p = new(ColumnNamePathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnNamePath

	return p
}

func (s *ColumnNamePathContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNamePathContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ColumnNamePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNamePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNamePathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnNamePath(s)
	}
}

func (s *ColumnNamePathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnNamePath(s)
	}
}

func (p *FlinkSqlParser) ColumnNamePath() (localctx IColumnNamePathContext) {
	localctx = NewColumnNamePathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, FlinkSqlParserRULE_columnNamePath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameListContext is an interface to support dynamic dispatch.
type IColumnNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllColumnName() []IColumnNameContext
	ColumnName(i int) IColumnNameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnNameListContext differentiates from other interfaces.
	IsColumnNameListContext()
}

type ColumnNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameListContext() *ColumnNameListContext {
	var p = new(ColumnNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnNameList
	return p
}

func InitEmptyColumnNameListContext(p *ColumnNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnNameList
}

func (*ColumnNameListContext) IsColumnNameListContext() {}

func NewColumnNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameListContext {
	var p = new(ColumnNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnNameList

	return p
}

func (s *ColumnNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *ColumnNameListContext) AllColumnName() []IColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameContext); ok {
			tst[i] = t.(IColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNameListContext) ColumnName(i int) IColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnNameListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *ColumnNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *ColumnNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *ColumnNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnNameList(s)
	}
}

func (s *ColumnNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnNameList(s)
	}
}

func (p *FlinkSqlParser) ColumnNameList() (localctx IColumnNameListContext) {
	localctx = NewColumnNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, FlinkSqlParserRULE_columnNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(686)
		p.ColumnName()
	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(687)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(688)
			p.ColumnName()
		}

		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(694)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnTypeContext is an interface to support dynamic dispatch.
type IColumnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColType returns the colType token.
	GetColType() antlr.Token

	// SetColType sets the colType token.
	SetColType(antlr.Token)

	// Getter signatures
	KW_DATE() antlr.TerminalNode
	KW_BOOLEAN() antlr.TerminalNode
	KW_NULL() antlr.TerminalNode
	KW_CHAR() antlr.TerminalNode
	KW_VARCHAR() antlr.TerminalNode
	KW_STRING() antlr.TerminalNode
	KW_BINARY() antlr.TerminalNode
	KW_VARBINARY() antlr.TerminalNode
	KW_BYTES() antlr.TerminalNode
	KW_TINYINT() antlr.TerminalNode
	KW_SMALLINT() antlr.TerminalNode
	KW_INT() antlr.TerminalNode
	KW_INTEGER() antlr.TerminalNode
	KW_BIGINT() antlr.TerminalNode
	KW_TIME() antlr.TerminalNode
	KW_TIMESTAMP_LTZ() antlr.TerminalNode
	KW_DATETIME() antlr.TerminalNode
	LengthOneDimension() ILengthOneDimensionContext
	KW_TIMESTAMP() antlr.TerminalNode
	KW_ZONE() antlr.TerminalNode
	KW_WITHOUT() antlr.TerminalNode
	KW_WITH() antlr.TerminalNode
	KW_LOCAL() antlr.TerminalNode
	KW_DECIMAL() antlr.TerminalNode
	KW_DEC() antlr.TerminalNode
	KW_NUMERIC() antlr.TerminalNode
	KW_FLOAT() antlr.TerminalNode
	KW_DOUBLE() antlr.TerminalNode
	LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext
	KW_ARRAY() antlr.TerminalNode
	KW_MULTISET() antlr.TerminalNode
	LengthOneTypeDimension() ILengthOneTypeDimensionContext
	KW_MAP() antlr.TerminalNode
	MapTypeDimension() IMapTypeDimensionContext
	KW_ROW() antlr.TerminalNode
	RowTypeDimension() IRowTypeDimensionContext
	KW_RAW() antlr.TerminalNode
	LengthTwoStringDimension() ILengthTwoStringDimensionContext

	// IsColumnTypeContext differentiates from other interfaces.
	IsColumnTypeContext()
}

type ColumnTypeContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	colType antlr.Token
}

func NewEmptyColumnTypeContext() *ColumnTypeContext {
	var p = new(ColumnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnType
	return p
}

func InitEmptyColumnTypeContext(p *ColumnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnType
}

func (*ColumnTypeContext) IsColumnTypeContext() {}

func NewColumnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnTypeContext {
	var p = new(ColumnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnType

	return p
}

func (s *ColumnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnTypeContext) GetColType() antlr.Token { return s.colType }

func (s *ColumnTypeContext) SetColType(v antlr.Token) { s.colType = v }

func (s *ColumnTypeContext) KW_DATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATE, 0)
}

func (s *ColumnTypeContext) KW_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BOOLEAN, 0)
}

func (s *ColumnTypeContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULL, 0)
}

func (s *ColumnTypeContext) KW_CHAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CHAR, 0)
}

func (s *ColumnTypeContext) KW_VARCHAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VARCHAR, 0)
}

func (s *ColumnTypeContext) KW_STRING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_STRING, 0)
}

func (s *ColumnTypeContext) KW_BINARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BINARY, 0)
}

func (s *ColumnTypeContext) KW_VARBINARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VARBINARY, 0)
}

func (s *ColumnTypeContext) KW_BYTES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BYTES, 0)
}

func (s *ColumnTypeContext) KW_TINYINT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TINYINT, 0)
}

func (s *ColumnTypeContext) KW_SMALLINT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SMALLINT, 0)
}

func (s *ColumnTypeContext) KW_INT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INT, 0)
}

func (s *ColumnTypeContext) KW_INTEGER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INTEGER, 0)
}

func (s *ColumnTypeContext) KW_BIGINT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BIGINT, 0)
}

func (s *ColumnTypeContext) KW_TIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIME, 0)
}

func (s *ColumnTypeContext) KW_TIMESTAMP_LTZ() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIMESTAMP_LTZ, 0)
}

func (s *ColumnTypeContext) KW_DATETIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATETIME, 0)
}

func (s *ColumnTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ColumnTypeContext) KW_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIMESTAMP, 0)
}

func (s *ColumnTypeContext) KW_ZONE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ZONE, 0)
}

func (s *ColumnTypeContext) KW_WITHOUT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WITHOUT, 0)
}

func (s *ColumnTypeContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WITH, 0)
}

func (s *ColumnTypeContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOCAL, 0)
}

func (s *ColumnTypeContext) KW_DECIMAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DECIMAL, 0)
}

func (s *ColumnTypeContext) KW_DEC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DEC, 0)
}

func (s *ColumnTypeContext) KW_NUMERIC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NUMERIC, 0)
}

func (s *ColumnTypeContext) KW_FLOAT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FLOAT, 0)
}

func (s *ColumnTypeContext) KW_DOUBLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DOUBLE, 0)
}

func (s *ColumnTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *ColumnTypeContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ARRAY, 0)
}

func (s *ColumnTypeContext) KW_MULTISET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MULTISET, 0)
}

func (s *ColumnTypeContext) LengthOneTypeDimension() ILengthOneTypeDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneTypeDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneTypeDimensionContext)
}

func (s *ColumnTypeContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MAP, 0)
}

func (s *ColumnTypeContext) MapTypeDimension() IMapTypeDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeDimensionContext)
}

func (s *ColumnTypeContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROW, 0)
}

func (s *ColumnTypeContext) RowTypeDimension() IRowTypeDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowTypeDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowTypeDimensionContext)
}

func (s *ColumnTypeContext) KW_RAW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RAW, 0)
}

func (s *ColumnTypeContext) LengthTwoStringDimension() ILengthTwoStringDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoStringDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoStringDimensionContext)
}

func (s *ColumnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnType(s)
	}
}

func (s *ColumnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnType(s)
	}
}

func (p *FlinkSqlParser) ColumnType() (localctx IColumnTypeContext) {
	localctx = NewColumnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, FlinkSqlParserRULE_columnType)
	var _la int

	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_BOOLEAN, FlinkSqlParserKW_DATE, FlinkSqlParserKW_NULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(696)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ColumnTypeContext).colType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_BOOLEAN || _la == FlinkSqlParserKW_DATE || _la == FlinkSqlParserKW_NULL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ColumnTypeContext).colType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case FlinkSqlParserKW_BIGINT, FlinkSqlParserKW_BINARY, FlinkSqlParserKW_BYTES, FlinkSqlParserKW_CHAR, FlinkSqlParserKW_DATETIME, FlinkSqlParserKW_INT, FlinkSqlParserKW_INTEGER, FlinkSqlParserKW_SMALLINT, FlinkSqlParserKW_STRING, FlinkSqlParserKW_TIME, FlinkSqlParserKW_TIMESTAMP_LTZ, FlinkSqlParserKW_TINYINT, FlinkSqlParserKW_VARBINARY, FlinkSqlParserKW_VARCHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(697)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ColumnTypeContext).colType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70403909222400) != 0) || _la == FlinkSqlParserKW_DATETIME || _la == FlinkSqlParserKW_INT || _la == FlinkSqlParserKW_INTEGER || ((int64((_la-346)) & ^0x3f) == 0 && ((int64(1)<<(_la-346))&8950711910401) != 0) || _la == FlinkSqlParserKW_VARBINARY || _la == FlinkSqlParserKW_VARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ColumnTypeContext).colType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserLR_BRACKET {
			{
				p.SetState(698)
				p.LengthOneDimension()
			}

		}

	case FlinkSqlParserKW_TIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(701)

			var _m = p.Match(FlinkSqlParserKW_TIMESTAMP)

			localctx.(*ColumnTypeContext).colType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserLR_BRACKET {
			{
				p.SetState(702)
				p.LengthOneDimension()
			}

		}
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_WITH || _la == FlinkSqlParserKW_WITHOUT {
			{
				p.SetState(705)
				_la = p.GetTokenStream().LA(1)

				if !(_la == FlinkSqlParserKW_WITH || _la == FlinkSqlParserKW_WITHOUT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(707)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == FlinkSqlParserKW_LOCAL {
				{
					p.SetState(706)
					p.Match(FlinkSqlParserKW_LOCAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(709)
				p.Match(FlinkSqlParserKW_TIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(710)
				p.Match(FlinkSqlParserKW_ZONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case FlinkSqlParserKW_DEC, FlinkSqlParserKW_DECIMAL, FlinkSqlParserKW_DOUBLE, FlinkSqlParserKW_FLOAT, FlinkSqlParserKW_NUMERIC:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(713)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ColumnTypeContext).colType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&8796093038595) != 0) || _la == FlinkSqlParserKW_NUMERIC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ColumnTypeContext).colType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserLR_BRACKET {
			{
				p.SetState(714)
				p.LengthTwoOptionalDimension()
			}

		}

	case FlinkSqlParserKW_ARRAY, FlinkSqlParserKW_MULTISET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(717)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ColumnTypeContext).colType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_ARRAY || _la == FlinkSqlParserKW_MULTISET) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ColumnTypeContext).colType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserLESS_SYMBOL {
			{
				p.SetState(718)
				p.LengthOneTypeDimension()
			}

		}

	case FlinkSqlParserKW_MAP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(721)

			var _m = p.Match(FlinkSqlParserKW_MAP)

			localctx.(*ColumnTypeContext).colType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserLESS_SYMBOL {
			{
				p.SetState(722)
				p.MapTypeDimension()
			}

		}

	case FlinkSqlParserKW_ROW:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(725)

			var _m = p.Match(FlinkSqlParserKW_ROW)

			localctx.(*ColumnTypeContext).colType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserLESS_SYMBOL || _la == FlinkSqlParserLR_BRACKET {
			{
				p.SetState(726)
				p.RowTypeDimension()
			}

		}

	case FlinkSqlParserKW_RAW:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(729)

			var _m = p.Match(FlinkSqlParserKW_RAW)

			localctx.(*ColumnTypeContext).colType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserLR_BRACKET {
			{
				p.SetState(730)
				p.LengthTwoStringDimension()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthOneDimension
	return p
}

func InitEmptyLengthOneDimensionContext(p *LengthOneDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthOneDimension
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (p *FlinkSqlParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, FlinkSqlParserRULE_lengthOneDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(735)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(736)
		p.DecimalLiteral()
	}
	{
		p.SetState(737)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthTwoOptionalDimension
	return p
}

func InitEmptyLengthTwoOptionalDimensionContext(p *LengthTwoOptionalDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthTwoOptionalDimension
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (p *FlinkSqlParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, FlinkSqlParserRULE_lengthTwoOptionalDimension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(740)
		p.DecimalLiteral()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserCOMMA {
		{
			p.SetState(741)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(742)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(745)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoStringDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoStringDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllStringLiteral() []IStringLiteralContext
	StringLiteral(i int) IStringLiteralContext
	RR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLengthTwoStringDimensionContext differentiates from other interfaces.
	IsLengthTwoStringDimensionContext()
}

type LengthTwoStringDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoStringDimensionContext() *LengthTwoStringDimensionContext {
	var p = new(LengthTwoStringDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthTwoStringDimension
	return p
}

func InitEmptyLengthTwoStringDimensionContext(p *LengthTwoStringDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthTwoStringDimension
}

func (*LengthTwoStringDimensionContext) IsLengthTwoStringDimensionContext() {}

func NewLengthTwoStringDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoStringDimensionContext {
	var p = new(LengthTwoStringDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_lengthTwoStringDimension

	return p
}

func (s *LengthTwoStringDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoStringDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *LengthTwoStringDimensionContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoStringDimensionContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LengthTwoStringDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *LengthTwoStringDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, 0)
}

func (s *LengthTwoStringDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoStringDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoStringDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLengthTwoStringDimension(s)
	}
}

func (s *LengthTwoStringDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLengthTwoStringDimension(s)
	}
}

func (p *FlinkSqlParser) LengthTwoStringDimension() (localctx ILengthTwoStringDimensionContext) {
	localctx = NewLengthTwoStringDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, FlinkSqlParserRULE_lengthTwoStringDimension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(748)
		p.StringLiteral()
	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserCOMMA {
		{
			p.SetState(749)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(750)
			p.StringLiteral()
		}

	}
	{
		p.SetState(753)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthOneTypeDimensionContext is an interface to support dynamic dispatch.
type ILengthOneTypeDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS_SYMBOL() antlr.TerminalNode
	ColumnType() IColumnTypeContext
	GREATER_SYMBOL() antlr.TerminalNode

	// IsLengthOneTypeDimensionContext differentiates from other interfaces.
	IsLengthOneTypeDimensionContext()
}

type LengthOneTypeDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneTypeDimensionContext() *LengthOneTypeDimensionContext {
	var p = new(LengthOneTypeDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthOneTypeDimension
	return p
}

func InitEmptyLengthOneTypeDimensionContext(p *LengthOneTypeDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_lengthOneTypeDimension
}

func (*LengthOneTypeDimensionContext) IsLengthOneTypeDimensionContext() {}

func NewLengthOneTypeDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneTypeDimensionContext {
	var p = new(LengthOneTypeDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_lengthOneTypeDimension

	return p
}

func (s *LengthOneTypeDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneTypeDimensionContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLESS_SYMBOL, 0)
}

func (s *LengthOneTypeDimensionContext) ColumnType() IColumnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeContext)
}

func (s *LengthOneTypeDimensionContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserGREATER_SYMBOL, 0)
}

func (s *LengthOneTypeDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneTypeDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneTypeDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLengthOneTypeDimension(s)
	}
}

func (s *LengthOneTypeDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLengthOneTypeDimension(s)
	}
}

func (p *FlinkSqlParser) LengthOneTypeDimension() (localctx ILengthOneTypeDimensionContext) {
	localctx = NewLengthOneTypeDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, FlinkSqlParserRULE_lengthOneTypeDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(FlinkSqlParserLESS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(756)
		p.ColumnType()
	}
	{
		p.SetState(757)
		p.Match(FlinkSqlParserGREATER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeDimensionContext is an interface to support dynamic dispatch.
type IMapTypeDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS_SYMBOL() antlr.TerminalNode
	AllColumnType() []IColumnTypeContext
	ColumnType(i int) IColumnTypeContext
	GREATER_SYMBOL() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsMapTypeDimensionContext differentiates from other interfaces.
	IsMapTypeDimensionContext()
}

type MapTypeDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeDimensionContext() *MapTypeDimensionContext {
	var p = new(MapTypeDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_mapTypeDimension
	return p
}

func InitEmptyMapTypeDimensionContext(p *MapTypeDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_mapTypeDimension
}

func (*MapTypeDimensionContext) IsMapTypeDimensionContext() {}

func NewMapTypeDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeDimensionContext {
	var p = new(MapTypeDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_mapTypeDimension

	return p
}

func (s *MapTypeDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeDimensionContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLESS_SYMBOL, 0)
}

func (s *MapTypeDimensionContext) AllColumnType() []IColumnTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnTypeContext); ok {
			len++
		}
	}

	tst := make([]IColumnTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnTypeContext); ok {
			tst[i] = t.(IColumnTypeContext)
			i++
		}
	}

	return tst
}

func (s *MapTypeDimensionContext) ColumnType(i int) IColumnTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeContext)
}

func (s *MapTypeDimensionContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserGREATER_SYMBOL, 0)
}

func (s *MapTypeDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, 0)
}

func (s *MapTypeDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterMapTypeDimension(s)
	}
}

func (s *MapTypeDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitMapTypeDimension(s)
	}
}

func (p *FlinkSqlParser) MapTypeDimension() (localctx IMapTypeDimensionContext) {
	localctx = NewMapTypeDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, FlinkSqlParserRULE_mapTypeDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(FlinkSqlParserLESS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(760)
		p.ColumnType()
	}

	{
		p.SetState(761)
		p.Match(FlinkSqlParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(762)
		p.ColumnType()
	}

	{
		p.SetState(764)
		p.Match(FlinkSqlParserGREATER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowTypeDimensionContext is an interface to support dynamic dispatch.
type IRowTypeDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS_SYMBOL() antlr.TerminalNode
	AllColumnName() []IColumnNameContext
	ColumnName(i int) IColumnNameContext
	AllColumnType() []IColumnTypeContext
	ColumnType(i int) IColumnTypeContext
	GREATER_SYMBOL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsRowTypeDimensionContext differentiates from other interfaces.
	IsRowTypeDimensionContext()
}

type RowTypeDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowTypeDimensionContext() *RowTypeDimensionContext {
	var p = new(RowTypeDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_rowTypeDimension
	return p
}

func InitEmptyRowTypeDimensionContext(p *RowTypeDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_rowTypeDimension
}

func (*RowTypeDimensionContext) IsRowTypeDimensionContext() {}

func NewRowTypeDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowTypeDimensionContext {
	var p = new(RowTypeDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_rowTypeDimension

	return p
}

func (s *RowTypeDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *RowTypeDimensionContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLESS_SYMBOL, 0)
}

func (s *RowTypeDimensionContext) AllColumnName() []IColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameContext); ok {
			tst[i] = t.(IColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *RowTypeDimensionContext) ColumnName(i int) IColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *RowTypeDimensionContext) AllColumnType() []IColumnTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnTypeContext); ok {
			len++
		}
	}

	tst := make([]IColumnTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnTypeContext); ok {
			tst[i] = t.(IColumnTypeContext)
			i++
		}
	}

	return tst
}

func (s *RowTypeDimensionContext) ColumnType(i int) IColumnTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeContext)
}

func (s *RowTypeDimensionContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserGREATER_SYMBOL, 0)
}

func (s *RowTypeDimensionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *RowTypeDimensionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *RowTypeDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *RowTypeDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *RowTypeDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowTypeDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowTypeDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterRowTypeDimension(s)
	}
}

func (s *RowTypeDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitRowTypeDimension(s)
	}
}

func (p *FlinkSqlParser) RowTypeDimension() (localctx IRowTypeDimensionContext) {
	localctx = NewRowTypeDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, FlinkSqlParserRULE_rowTypeDimension)
	var _la int

	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(766)
			p.Match(FlinkSqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(767)
			p.ColumnName()
		}
		{
			p.SetState(768)
			p.ColumnType()
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(769)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(770)
				p.ColumnName()
			}
			{
				p.SetState(771)
				p.ColumnType()
			}

			p.SetState(777)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(778)
			p.Match(FlinkSqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(780)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(781)
			p.ColumnName()
		}
		{
			p.SetState(782)
			p.ColumnType()
		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(783)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(784)
				p.ColumnName()
			}
			{
				p.SetState(785)
				p.ColumnType()
			}

			p.SetState(791)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(792)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PRIMARY() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintName() IConstraintNameContext
	KW_NOT() antlr.TerminalNode
	KW_ENFORCED() antlr.TerminalNode
	KW_NULL() antlr.TerminalNode

	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) KW_PRIMARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PRIMARY, 0)
}

func (s *ColumnConstraintContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_KEY, 0)
}

func (s *ColumnConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONSTRAINT, 0)
}

func (s *ColumnConstraintContext) ConstraintName() IConstraintNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *ColumnConstraintContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *ColumnConstraintContext) KW_ENFORCED() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ENFORCED, 0)
}

func (s *ColumnConstraintContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULL, 0)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnConstraint(s)
	}
}

func (p *FlinkSqlParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, FlinkSqlParserRULE_columnConstraint)
	var _la int

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_CONSTRAINT, FlinkSqlParserKW_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_CONSTRAINT {
			{
				p.SetState(796)
				p.Match(FlinkSqlParserKW_CONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(797)
				p.ConstraintName()
			}

		}
		{
			p.SetState(800)
			p.Match(FlinkSqlParserKW_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.Match(FlinkSqlParserKW_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(802)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(803)
				p.Match(FlinkSqlParserKW_ENFORCED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case FlinkSqlParserKW_NOT, FlinkSqlParserKW_NULL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(806)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(809)
			p.Match(FlinkSqlParserKW_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetadataColumnDefinitionContext is an interface to support dynamic dispatch.
type IMetadataColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnNameCreate() IColumnNameCreateContext
	ColumnType() IColumnTypeContext
	KW_METADATA() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	MetadataKey() IMetadataKeyContext
	KW_VIRTUAL() antlr.TerminalNode

	// IsMetadataColumnDefinitionContext differentiates from other interfaces.
	IsMetadataColumnDefinitionContext()
}

type MetadataColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetadataColumnDefinitionContext() *MetadataColumnDefinitionContext {
	var p = new(MetadataColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_metadataColumnDefinition
	return p
}

func InitEmptyMetadataColumnDefinitionContext(p *MetadataColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_metadataColumnDefinition
}

func (*MetadataColumnDefinitionContext) IsMetadataColumnDefinitionContext() {}

func NewMetadataColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetadataColumnDefinitionContext {
	var p = new(MetadataColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_metadataColumnDefinition

	return p
}

func (s *MetadataColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MetadataColumnDefinitionContext) ColumnNameCreate() IColumnNameCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameCreateContext)
}

func (s *MetadataColumnDefinitionContext) ColumnType() IColumnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeContext)
}

func (s *MetadataColumnDefinitionContext) KW_METADATA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_METADATA, 0)
}

func (s *MetadataColumnDefinitionContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FROM, 0)
}

func (s *MetadataColumnDefinitionContext) MetadataKey() IMetadataKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetadataKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetadataKeyContext)
}

func (s *MetadataColumnDefinitionContext) KW_VIRTUAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VIRTUAL, 0)
}

func (s *MetadataColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetadataColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetadataColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterMetadataColumnDefinition(s)
	}
}

func (s *MetadataColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitMetadataColumnDefinition(s)
	}
}

func (p *FlinkSqlParser) MetadataColumnDefinition() (localctx IMetadataColumnDefinitionContext) {
	localctx = NewMetadataColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, FlinkSqlParserRULE_metadataColumnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.ColumnNameCreate()
	}
	{
		p.SetState(813)
		p.ColumnType()
	}
	{
		p.SetState(814)
		p.Match(FlinkSqlParserKW_METADATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_FROM {
		{
			p.SetState(815)
			p.Match(FlinkSqlParserKW_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(816)
			p.MetadataKey()
		}

	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_VIRTUAL {
		{
			p.SetState(819)
			p.Match(FlinkSqlParserKW_VIRTUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetadataKeyContext is an interface to support dynamic dispatch.
type IMetadataKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsMetadataKeyContext differentiates from other interfaces.
	IsMetadataKeyContext()
}

type MetadataKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetadataKeyContext() *MetadataKeyContext {
	var p = new(MetadataKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_metadataKey
	return p
}

func InitEmptyMetadataKeyContext(p *MetadataKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_metadataKey
}

func (*MetadataKeyContext) IsMetadataKeyContext() {}

func NewMetadataKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetadataKeyContext {
	var p = new(MetadataKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_metadataKey

	return p
}

func (s *MetadataKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *MetadataKeyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *MetadataKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetadataKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetadataKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterMetadataKey(s)
	}
}

func (s *MetadataKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitMetadataKey(s)
	}
}

func (p *FlinkSqlParser) MetadataKey() (localctx IMetadataKeyContext) {
	localctx = NewMetadataKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, FlinkSqlParserRULE_metadataKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		p.Match(FlinkSqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComputedColumnDefinitionContext is an interface to support dynamic dispatch.
type IComputedColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// Getter signatures
	ColumnNameCreate() IColumnNameCreateContext
	KW_AS() antlr.TerminalNode
	ComputedColumnExpression() IComputedColumnExpressionContext
	KW_COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsComputedColumnDefinitionContext differentiates from other interfaces.
	IsComputedColumnDefinitionContext()
}

type ComputedColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	comment antlr.Token
}

func NewEmptyComputedColumnDefinitionContext() *ComputedColumnDefinitionContext {
	var p = new(ComputedColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_computedColumnDefinition
	return p
}

func InitEmptyComputedColumnDefinitionContext(p *ComputedColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_computedColumnDefinition
}

func (*ComputedColumnDefinitionContext) IsComputedColumnDefinitionContext() {}

func NewComputedColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputedColumnDefinitionContext {
	var p = new(ComputedColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_computedColumnDefinition

	return p
}

func (s *ComputedColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputedColumnDefinitionContext) GetComment() antlr.Token { return s.comment }

func (s *ComputedColumnDefinitionContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ComputedColumnDefinitionContext) ColumnNameCreate() IColumnNameCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameCreateContext)
}

func (s *ComputedColumnDefinitionContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *ComputedColumnDefinitionContext) ComputedColumnExpression() IComputedColumnExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComputedColumnExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComputedColumnExpressionContext)
}

func (s *ComputedColumnDefinitionContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COMMENT, 0)
}

func (s *ComputedColumnDefinitionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *ComputedColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputedColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterComputedColumnDefinition(s)
	}
}

func (s *ComputedColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitComputedColumnDefinition(s)
	}
}

func (p *FlinkSqlParser) ComputedColumnDefinition() (localctx IComputedColumnDefinitionContext) {
	localctx = NewComputedColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, FlinkSqlParserRULE_computedColumnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.ColumnNameCreate()
	}
	{
		p.SetState(825)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(826)
		p.ComputedColumnExpression()
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_COMMENT {
		{
			p.SetState(827)
			p.Match(FlinkSqlParserKW_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(828)

			var _m = p.Match(FlinkSqlParserSTRING_LITERAL)

			localctx.(*ComputedColumnDefinitionContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComputedColumnExpressionContext is an interface to support dynamic dispatch.
type IComputedColumnExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsComputedColumnExpressionContext differentiates from other interfaces.
	IsComputedColumnExpressionContext()
}

type ComputedColumnExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputedColumnExpressionContext() *ComputedColumnExpressionContext {
	var p = new(ComputedColumnExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_computedColumnExpression
	return p
}

func InitEmptyComputedColumnExpressionContext(p *ComputedColumnExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_computedColumnExpression
}

func (*ComputedColumnExpressionContext) IsComputedColumnExpressionContext() {}

func NewComputedColumnExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputedColumnExpressionContext {
	var p = new(ComputedColumnExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_computedColumnExpression

	return p
}

func (s *ComputedColumnExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputedColumnExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ComputedColumnExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedColumnExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputedColumnExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterComputedColumnExpression(s)
	}
}

func (s *ComputedColumnExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitComputedColumnExpression(s)
	}
}

func (p *FlinkSqlParser) ComputedColumnExpression() (localctx IComputedColumnExpressionContext) {
	localctx = NewComputedColumnExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, FlinkSqlParserRULE_computedColumnExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(831)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWatermarkDefinitionContext is an interface to support dynamic dispatch.
type IWatermarkDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WATERMARK() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode
	ColumnName() IColumnNameContext
	KW_AS() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWatermarkDefinitionContext differentiates from other interfaces.
	IsWatermarkDefinitionContext()
}

type WatermarkDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWatermarkDefinitionContext() *WatermarkDefinitionContext {
	var p = new(WatermarkDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_watermarkDefinition
	return p
}

func InitEmptyWatermarkDefinitionContext(p *WatermarkDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_watermarkDefinition
}

func (*WatermarkDefinitionContext) IsWatermarkDefinitionContext() {}

func NewWatermarkDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WatermarkDefinitionContext {
	var p = new(WatermarkDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_watermarkDefinition

	return p
}

func (s *WatermarkDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *WatermarkDefinitionContext) KW_WATERMARK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WATERMARK, 0)
}

func (s *WatermarkDefinitionContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FOR, 0)
}

func (s *WatermarkDefinitionContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *WatermarkDefinitionContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *WatermarkDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WatermarkDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WatermarkDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WatermarkDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWatermarkDefinition(s)
	}
}

func (s *WatermarkDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWatermarkDefinition(s)
	}
}

func (p *FlinkSqlParser) WatermarkDefinition() (localctx IWatermarkDefinitionContext) {
	localctx = NewWatermarkDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, FlinkSqlParserRULE_watermarkDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.Match(FlinkSqlParserKW_WATERMARK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(834)
		p.Match(FlinkSqlParserKW_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(835)
		p.ColumnName()
	}
	{
		p.SetState(836)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(837)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PRIMARY() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	KW_NOT() antlr.TerminalNode
	KW_ENFORCED() antlr.TerminalNode
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintName() IConstraintNameContext

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) KW_PRIMARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PRIMARY, 0)
}

func (s *TableConstraintContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_KEY, 0)
}

func (s *TableConstraintContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *TableConstraintContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *TableConstraintContext) KW_ENFORCED() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ENFORCED, 0)
}

func (s *TableConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONSTRAINT, 0)
}

func (s *TableConstraintContext) ConstraintName() IConstraintNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (p *FlinkSqlParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, FlinkSqlParserRULE_tableConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_CONSTRAINT {
		{
			p.SetState(839)
			p.Match(FlinkSqlParserKW_CONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(840)
			p.ConstraintName()
		}

	}
	{
		p.SetState(843)
		p.Match(FlinkSqlParserKW_PRIMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(844)
		p.Match(FlinkSqlParserKW_KEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(845)
		p.ColumnNameList()
	}
	{
		p.SetState(846)
		p.Match(FlinkSqlParserKW_NOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(847)
		p.Match(FlinkSqlParserKW_ENFORCED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintNameContext is an interface to support dynamic dispatch.
type IConstraintNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsConstraintNameContext differentiates from other interfaces.
	IsConstraintNameContext()
}

type ConstraintNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintNameContext() *ConstraintNameContext {
	var p = new(ConstraintNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_constraintName
	return p
}

func InitEmptyConstraintNameContext(p *ConstraintNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_constraintName
}

func (*ConstraintNameContext) IsConstraintNameContext() {}

func NewConstraintNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintNameContext {
	var p = new(ConstraintNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_constraintName

	return p
}

func (s *ConstraintNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstraintNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterConstraintName(s)
	}
}

func (s *ConstraintNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitConstraintName(s)
	}
}

func (p *FlinkSqlParser) ConstraintName() (localctx IConstraintNameContext) {
	localctx = NewConstraintNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, FlinkSqlParserRULE_constraintName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelfDefinitionClauseContext is an interface to support dynamic dispatch.
type ISelfDefinitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PERIOD() antlr.TerminalNode
	KW_FOR() antlr.TerminalNode
	KW_SYSTEM_TIME() antlr.TerminalNode

	// IsSelfDefinitionClauseContext differentiates from other interfaces.
	IsSelfDefinitionClauseContext()
}

type SelfDefinitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelfDefinitionClauseContext() *SelfDefinitionClauseContext {
	var p = new(SelfDefinitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_selfDefinitionClause
	return p
}

func InitEmptySelfDefinitionClauseContext(p *SelfDefinitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_selfDefinitionClause
}

func (*SelfDefinitionClauseContext) IsSelfDefinitionClauseContext() {}

func NewSelfDefinitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelfDefinitionClauseContext {
	var p = new(SelfDefinitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_selfDefinitionClause

	return p
}

func (s *SelfDefinitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelfDefinitionClauseContext) KW_PERIOD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PERIOD, 0)
}

func (s *SelfDefinitionClauseContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FOR, 0)
}

func (s *SelfDefinitionClauseContext) KW_SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SYSTEM_TIME, 0)
}

func (s *SelfDefinitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelfDefinitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelfDefinitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSelfDefinitionClause(s)
	}
}

func (s *SelfDefinitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSelfDefinitionClause(s)
	}
}

func (p *FlinkSqlParser) SelfDefinitionClause() (localctx ISelfDefinitionClauseContext) {
	localctx = NewSelfDefinitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, FlinkSqlParserRULE_selfDefinitionClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Match(FlinkSqlParserKW_PERIOD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(852)
		p.Match(FlinkSqlParserKW_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(853)
		p.Match(FlinkSqlParserKW_SYSTEM_TIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PARTITIONED() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	TransformList() ITransformListContext

	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_partitionDefinition
	return p
}

func InitEmptyPartitionDefinitionContext(p *PartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_partitionDefinition
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) KW_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PARTITIONED, 0)
}

func (s *PartitionDefinitionContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BY, 0)
}

func (s *PartitionDefinitionContext) TransformList() ITransformListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransformListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransformListContext)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPartitionDefinition(s)
	}
}

func (s *PartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPartitionDefinition(s)
	}
}

func (p *FlinkSqlParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, FlinkSqlParserRULE_partitionDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(855)
		p.Match(FlinkSqlParserKW_PARTITIONED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(856)
		p.Match(FlinkSqlParserKW_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(857)
		p.TransformList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransformListContext is an interface to support dynamic dispatch.
type ITransformListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllTransform() []ITransformContext
	Transform(i int) ITransformContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTransformListContext differentiates from other interfaces.
	IsTransformListContext()
}

type TransformListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformListContext() *TransformListContext {
	var p = new(TransformListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_transformList
	return p
}

func InitEmptyTransformListContext(p *TransformListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_transformList
}

func (*TransformListContext) IsTransformListContext() {}

func NewTransformListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformListContext {
	var p = new(TransformListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_transformList

	return p
}

func (s *TransformListContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *TransformListContext) AllTransform() []ITransformContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransformContext); ok {
			len++
		}
	}

	tst := make([]ITransformContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransformContext); ok {
			tst[i] = t.(ITransformContext)
			i++
		}
	}

	return tst
}

func (s *TransformListContext) Transform(i int) ITransformContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransformContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *TransformListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *TransformListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *TransformListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *TransformListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTransformList(s)
	}
}

func (s *TransformListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTransformList(s)
	}
}

func (p *FlinkSqlParser) TransformList() (localctx ITransformListContext) {
	localctx = NewTransformListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, FlinkSqlParserRULE_transformList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(860)
		p.Transform()
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(861)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(862)
			p.Transform()
		}

		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(868)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransformContext is an interface to support dynamic dispatch.
type ITransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTransformContext differentiates from other interfaces.
	IsTransformContext()
}

type TransformContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformContext() *TransformContext {
	var p = new(TransformContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_transform
	return p
}

func InitEmptyTransformContext(p *TransformContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_transform
}

func (*TransformContext) IsTransformContext() {}

func NewTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformContext {
	var p = new(TransformContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_transform

	return p
}

func (s *TransformContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformContext) CopyAll(ctx *TransformContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IdentityTransformContext struct {
	TransformContext
}

func NewIdentityTransformContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentityTransformContext {
	var p = new(IdentityTransformContext)

	InitEmptyTransformContext(&p.TransformContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransformContext))

	return p
}

func (s *IdentityTransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityTransformContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *IdentityTransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterIdentityTransform(s)
	}
}

func (s *IdentityTransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitIdentityTransform(s)
	}
}

type ApplyTransformContext struct {
	TransformContext
}

func NewApplyTransformContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ApplyTransformContext {
	var p = new(ApplyTransformContext)

	InitEmptyTransformContext(&p.TransformContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransformContext))

	return p
}

func (s *ApplyTransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplyTransformContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *ApplyTransformContext) AllTransformArgument() []ITransformArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransformArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITransformArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransformArgumentContext); ok {
			tst[i] = t.(ITransformArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ApplyTransformContext) TransformArgument(i int) ITransformArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransformArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransformArgumentContext)
}

func (s *ApplyTransformContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *ApplyTransformContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *ApplyTransformContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *ApplyTransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterApplyTransform(s)
	}
}

func (s *ApplyTransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitApplyTransform(s)
	}
}

func (p *FlinkSqlParser) Transform() (localctx ITransformContext) {
	localctx = NewTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, FlinkSqlParserRULE_transform)
	var _la int

	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_ADD, FlinkSqlParserKW_AFTER, FlinkSqlParserKW_ASC, FlinkSqlParserKW_CASCADE, FlinkSqlParserKW_CATALOG, FlinkSqlParserKW_CENTURY, FlinkSqlParserKW_CONFIG, FlinkSqlParserKW_CONSTRAINTS, FlinkSqlParserKW_CUMULATE, FlinkSqlParserKW_DATA, FlinkSqlParserKW_DATABASE, FlinkSqlParserKW_DAYS, FlinkSqlParserKW_DECADE, FlinkSqlParserKW_DESC, FlinkSqlParserKW_DESCRIPTOR, FlinkSqlParserKW_DIV, FlinkSqlParserKW_ENGINE, FlinkSqlParserKW_EPOCH, FlinkSqlParserKW_EXCLUDING, FlinkSqlParserKW_FILE, FlinkSqlParserKW_FIRST, FlinkSqlParserKW_GENERATED, FlinkSqlParserKW_HOP, FlinkSqlParserKW_HOURS, FlinkSqlParserKW_IGNORE, FlinkSqlParserKW_INCLUDING, FlinkSqlParserKW_JAR, FlinkSqlParserKW_JARS, FlinkSqlParserKW_JAVA, FlinkSqlParserKW_KEY, FlinkSqlParserKW_LAST, FlinkSqlParserKW_LOAD, FlinkSqlParserKW_MAP, FlinkSqlParserKW_MICROSECOND, FlinkSqlParserKW_MILLENNIUM, FlinkSqlParserKW_MILLISECOND, FlinkSqlParserKW_MINUTES, FlinkSqlParserKW_MONTHS, FlinkSqlParserKW_NANOSECOND, FlinkSqlParserKW_NULLS, FlinkSqlParserKW_OPTIONS, FlinkSqlParserKW_PAST, FlinkSqlParserKW_PLAN, FlinkSqlParserKW_PRECEDING, FlinkSqlParserKW_PYTHON, FlinkSqlParserKW_PYTHON_ARCHIVES, FlinkSqlParserKW_PYTHON_DEPENDENCIES, FlinkSqlParserKW_PYTHON_FILES, FlinkSqlParserKW_PYTHON_JAR, FlinkSqlParserKW_PYTHON_PARAMETER, FlinkSqlParserKW_PYTHON_REQUIREMENTS, FlinkSqlParserKW_QUARTER, FlinkSqlParserKW_REMOVE, FlinkSqlParserKW_RESTRICT, FlinkSqlParserKW_SECONDS, FlinkSqlParserKW_SESSION, FlinkSqlParserKW_SETS, FlinkSqlParserKW_SIZE, FlinkSqlParserKW_SLIDE, FlinkSqlParserKW_STEP, FlinkSqlParserKW_TEMPORARY, FlinkSqlParserKW_TIMECOL, FlinkSqlParserKW_TUMBLE, FlinkSqlParserKW_UNLOAD, FlinkSqlParserKW_VIEW, FlinkSqlParserKW_WEEK, FlinkSqlParserKW_YEARS, FlinkSqlParserKW_ZONE, FlinkSqlParserSTRING_LITERAL, FlinkSqlParserDIG_LITERAL, FlinkSqlParserID_LITERAL:
		localctx = NewIdentityTransformContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(870)
			p.ColumnName()
		}

	case FlinkSqlParserLR_BRACKET:
		localctx = NewApplyTransformContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(871)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(872)
			p.TransformArgument()
		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(873)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(874)
				p.TransformArgument()
			}

			p.SetState(879)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(880)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransformArgumentContext is an interface to support dynamic dispatch.
type ITransformArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	Constant() IConstantContext

	// IsTransformArgumentContext differentiates from other interfaces.
	IsTransformArgumentContext()
}

type TransformArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformArgumentContext() *TransformArgumentContext {
	var p = new(TransformArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_transformArgument
	return p
}

func InitEmptyTransformArgumentContext(p *TransformArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_transformArgument
}

func (*TransformArgumentContext) IsTransformArgumentContext() {}

func NewTransformArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformArgumentContext {
	var p = new(TransformArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_transformArgument

	return p
}

func (s *TransformArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformArgumentContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TransformArgumentContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *TransformArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTransformArgument(s)
	}
}

func (s *TransformArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTransformArgument(s)
	}
}

func (p *FlinkSqlParser) TransformArgument() (localctx ITransformArgumentContext) {
	localctx = NewTransformArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, FlinkSqlParserRULE_transformArgument)
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(884)
			p.QualifiedName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(885)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeDefinitionContext is an interface to support dynamic dispatch.
type ILikeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LIKE() antlr.TerminalNode
	TablePath() ITablePathContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllLikeOption() []ILikeOptionContext
	LikeOption(i int) ILikeOptionContext

	// IsLikeDefinitionContext differentiates from other interfaces.
	IsLikeDefinitionContext()
}

type LikeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeDefinitionContext() *LikeDefinitionContext {
	var p = new(LikeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_likeDefinition
	return p
}

func InitEmptyLikeDefinitionContext(p *LikeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_likeDefinition
}

func (*LikeDefinitionContext) IsLikeDefinitionContext() {}

func NewLikeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeDefinitionContext {
	var p = new(LikeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_likeDefinition

	return p
}

func (s *LikeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeDefinitionContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LIKE, 0)
}

func (s *LikeDefinitionContext) TablePath() ITablePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathContext)
}

func (s *LikeDefinitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *LikeDefinitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *LikeDefinitionContext) AllLikeOption() []ILikeOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILikeOptionContext); ok {
			len++
		}
	}

	tst := make([]ILikeOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILikeOptionContext); ok {
			tst[i] = t.(ILikeOptionContext)
			i++
		}
	}

	return tst
}

func (s *LikeDefinitionContext) LikeOption(i int) ILikeOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeOptionContext)
}

func (s *LikeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLikeDefinition(s)
	}
}

func (s *LikeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLikeDefinition(s)
	}
}

func (p *FlinkSqlParser) LikeDefinition() (localctx ILikeDefinitionContext) {
	localctx = NewLikeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, FlinkSqlParserRULE_likeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.Match(FlinkSqlParserKW_LIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(889)
		p.TablePath()
	}
	p.SetState(898)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(890)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserKW_OVERWRITING || _la == FlinkSqlParserKW_EXCLUDING || _la == FlinkSqlParserKW_INCLUDING {
			{
				p.SetState(891)
				p.LikeOption()
			}

			p.SetState(896)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(897)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeOptionContext is an interface to support dynamic dispatch.
type ILikeOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_INCLUDING() antlr.TerminalNode
	KW_EXCLUDING() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode
	KW_CONSTRAINTS() antlr.TerminalNode
	KW_PARTITIONS() antlr.TerminalNode
	KW_OVERWRITING() antlr.TerminalNode
	KW_GENERATED() antlr.TerminalNode
	KW_OPTIONS() antlr.TerminalNode
	KW_WATERMARKS() antlr.TerminalNode

	// IsLikeOptionContext differentiates from other interfaces.
	IsLikeOptionContext()
}

type LikeOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeOptionContext() *LikeOptionContext {
	var p = new(LikeOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_likeOption
	return p
}

func InitEmptyLikeOptionContext(p *LikeOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_likeOption
}

func (*LikeOptionContext) IsLikeOptionContext() {}

func NewLikeOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeOptionContext {
	var p = new(LikeOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_likeOption

	return p
}

func (s *LikeOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeOptionContext) KW_INCLUDING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INCLUDING, 0)
}

func (s *LikeOptionContext) KW_EXCLUDING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXCLUDING, 0)
}

func (s *LikeOptionContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALL, 0)
}

func (s *LikeOptionContext) KW_CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONSTRAINTS, 0)
}

func (s *LikeOptionContext) KW_PARTITIONS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PARTITIONS, 0)
}

func (s *LikeOptionContext) KW_OVERWRITING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OVERWRITING, 0)
}

func (s *LikeOptionContext) KW_GENERATED() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_GENERATED, 0)
}

func (s *LikeOptionContext) KW_OPTIONS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OPTIONS, 0)
}

func (s *LikeOptionContext) KW_WATERMARKS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WATERMARKS, 0)
}

func (s *LikeOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLikeOption(s)
	}
}

func (s *LikeOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLikeOption(s)
	}
}

func (p *FlinkSqlParser) LikeOption() (localctx ILikeOptionContext) {
	localctx = NewLikeOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, FlinkSqlParserRULE_likeOption)
	var _la int

	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(900)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_EXCLUDING || _la == FlinkSqlParserKW_INCLUDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(901)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_ALL || _la == FlinkSqlParserKW_PARTITIONS || _la == FlinkSqlParserKW_CONSTRAINTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(902)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_OVERWRITING || _la == FlinkSqlParserKW_EXCLUDING || _la == FlinkSqlParserKW_INCLUDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(903)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-427)) & ^0x3f) == 0 && ((int64(1)<<(_la-427))&4503608217305089) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateCatalogContext is an interface to support dynamic dispatch.
type ICreateCatalogContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_CATALOG() antlr.TerminalNode
	CatalogPathCreate() ICatalogPathCreateContext
	WithOption() IWithOptionContext

	// IsCreateCatalogContext differentiates from other interfaces.
	IsCreateCatalogContext()
}

type CreateCatalogContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateCatalogContext() *CreateCatalogContext {
	var p = new(CreateCatalogContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createCatalog
	return p
}

func InitEmptyCreateCatalogContext(p *CreateCatalogContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createCatalog
}

func (*CreateCatalogContext) IsCreateCatalogContext() {}

func NewCreateCatalogContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateCatalogContext {
	var p = new(CreateCatalogContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_createCatalog

	return p
}

func (s *CreateCatalogContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateCatalogContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CREATE, 0)
}

func (s *CreateCatalogContext) KW_CATALOG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CATALOG, 0)
}

func (s *CreateCatalogContext) CatalogPathCreate() ICatalogPathCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogPathCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogPathCreateContext)
}

func (s *CreateCatalogContext) WithOption() IWithOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithOptionContext)
}

func (s *CreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCatalogContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCreateCatalog(s)
	}
}

func (s *CreateCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCreateCatalog(s)
	}
}

func (p *FlinkSqlParser) CreateCatalog() (localctx ICreateCatalogContext) {
	localctx = NewCreateCatalogContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, FlinkSqlParserRULE_createCatalog)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.Match(FlinkSqlParserKW_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(907)
		p.Match(FlinkSqlParserKW_CATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(908)
		p.CatalogPathCreate()
	}
	{
		p.SetState(909)
		p.WithOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_DATABASE() antlr.TerminalNode
	DatabasePathCreate() IDatabasePathCreateContext
	WithOption() IWithOptionContext
	IfNotExists() IIfNotExistsContext
	KW_COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	comment antlr.Token
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createDatabase
	return p
}

func InitEmptyCreateDatabaseContext(p *CreateDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createDatabase
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) GetComment() antlr.Token { return s.comment }

func (s *CreateDatabaseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateDatabaseContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CREATE, 0)
}

func (s *CreateDatabaseContext) KW_DATABASE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATABASE, 0)
}

func (s *CreateDatabaseContext) DatabasePathCreate() IDatabasePathCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabasePathCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabasePathCreateContext)
}

func (s *CreateDatabaseContext) WithOption() IWithOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithOptionContext)
}

func (s *CreateDatabaseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COMMENT, 0)
}

func (s *CreateDatabaseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (p *FlinkSqlParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, FlinkSqlParserRULE_createDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(FlinkSqlParserKW_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(912)
		p.Match(FlinkSqlParserKW_DATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(913)
			p.IfNotExists()
		}

	}
	{
		p.SetState(916)
		p.DatabasePathCreate()
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_COMMENT {
		{
			p.SetState(917)
			p.Match(FlinkSqlParserKW_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(918)

			var _m = p.Match(FlinkSqlParserSTRING_LITERAL)

			localctx.(*CreateDatabaseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(921)
		p.WithOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	ViewPathCreate() IViewPathCreateContext
	KW_AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	KW_TEMPORARY() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	ColumnNameList() IColumnNameListContext
	KW_COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	comment antlr.Token
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createView
	return p
}

func InitEmptyCreateViewContext(p *CreateViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createView
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) GetComment() antlr.Token { return s.comment }

func (s *CreateViewContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateViewContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CREATE, 0)
}

func (s *CreateViewContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VIEW, 0)
}

func (s *CreateViewContext) ViewPathCreate() IViewPathCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewPathCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewPathCreateContext)
}

func (s *CreateViewContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *CreateViewContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateViewContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *CreateViewContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateViewContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *CreateViewContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COMMENT, 0)
}

func (s *CreateViewContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (p *FlinkSqlParser) CreateView() (localctx ICreateViewContext) {
	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, FlinkSqlParserRULE_createView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.Match(FlinkSqlParserKW_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_TEMPORARY {
		{
			p.SetState(924)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(927)
		p.Match(FlinkSqlParserKW_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(928)
			p.IfNotExists()
		}

	}
	{
		p.SetState(931)
		p.ViewPathCreate()
	}
	p.SetState(933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserLR_BRACKET {
		{
			p.SetState(932)
			p.ColumnNameList()
		}

	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_COMMENT {
		{
			p.SetState(935)
			p.Match(FlinkSqlParserKW_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(936)

			var _m = p.Match(FlinkSqlParserSTRING_LITERAL)

			localctx.(*CreateViewContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(939)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(940)
		p.queryStatement(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CREATE() antlr.TerminalNode
	KW_FUNCTION() antlr.TerminalNode
	FunctionNameCreate() IFunctionNameCreateContext
	KW_AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	KW_TEMPORARY() antlr.TerminalNode
	KW_SYSTEM() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	KW_LANGUAGE() antlr.TerminalNode
	UsingClause() IUsingClauseContext
	KW_JAVA() antlr.TerminalNode
	KW_SCALA() antlr.TerminalNode
	KW_PYTHON() antlr.TerminalNode

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createFunction
	return p
}

func InitEmptyCreateFunctionContext(p *CreateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_createFunction
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) KW_CREATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CREATE, 0)
}

func (s *CreateFunctionContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FUNCTION, 0)
}

func (s *CreateFunctionContext) FunctionNameCreate() IFunctionNameCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameCreateContext)
}

func (s *CreateFunctionContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *CreateFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateFunctionContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *CreateFunctionContext) KW_SYSTEM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SYSTEM, 0)
}

func (s *CreateFunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionContext) KW_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LANGUAGE, 0)
}

func (s *CreateFunctionContext) UsingClause() IUsingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingClauseContext)
}

func (s *CreateFunctionContext) KW_JAVA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JAVA, 0)
}

func (s *CreateFunctionContext) KW_SCALA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SCALA, 0)
}

func (s *CreateFunctionContext) KW_PYTHON() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON, 0)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (p *FlinkSqlParser) CreateFunction() (localctx ICreateFunctionContext) {
	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, FlinkSqlParserRULE_createFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(942)
		p.Match(FlinkSqlParserKW_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(946)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(943)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(944)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(945)
			p.Match(FlinkSqlParserKW_SYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(948)
		p.Match(FlinkSqlParserKW_FUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(949)
			p.IfNotExists()
		}

	}
	{
		p.SetState(952)
		p.FunctionNameCreate()
	}
	{
		p.SetState(953)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(954)
		p.Identifier()
	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_LANGUAGE {
		{
			p.SetState(955)
			p.Match(FlinkSqlParserKW_LANGUAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(956)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_SCALA || _la == FlinkSqlParserKW_JAVA || _la == FlinkSqlParserKW_PYTHON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_USING {
		{
			p.SetState(959)
			p.UsingClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingClauseContext is an interface to support dynamic dispatch.
type IUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_USING() antlr.TerminalNode
	AllKW_JAR() []antlr.TerminalNode
	KW_JAR(i int) antlr.TerminalNode
	AllJarFileName() []IJarFileNameContext
	JarFileName(i int) IJarFileNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUsingClauseContext differentiates from other interfaces.
	IsUsingClauseContext()
}

type UsingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingClauseContext() *UsingClauseContext {
	var p = new(UsingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_usingClause
	return p
}

func InitEmptyUsingClauseContext(p *UsingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_usingClause
}

func (*UsingClauseContext) IsUsingClauseContext() {}

func NewUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingClauseContext {
	var p = new(UsingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_usingClause

	return p
}

func (s *UsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingClauseContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_USING, 0)
}

func (s *UsingClauseContext) AllKW_JAR() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserKW_JAR)
}

func (s *UsingClauseContext) KW_JAR(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JAR, i)
}

func (s *UsingClauseContext) AllJarFileName() []IJarFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJarFileNameContext); ok {
			len++
		}
	}

	tst := make([]IJarFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJarFileNameContext); ok {
			tst[i] = t.(IJarFileNameContext)
			i++
		}
	}

	return tst
}

func (s *UsingClauseContext) JarFileName(i int) IJarFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJarFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJarFileNameContext)
}

func (s *UsingClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *UsingClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *UsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUsingClause(s)
	}
}

func (s *UsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUsingClause(s)
	}
}

func (p *FlinkSqlParser) UsingClause() (localctx IUsingClauseContext) {
	localctx = NewUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, FlinkSqlParserRULE_usingClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(962)
		p.Match(FlinkSqlParserKW_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(963)
		p.Match(FlinkSqlParserKW_JAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(964)
		p.JarFileName()
	}
	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(965)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(966)
			p.Match(FlinkSqlParserKW_JAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(967)
			p.JarFileName()
		}

		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJarFileNameContext is an interface to support dynamic dispatch.
type IJarFileNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsJarFileNameContext differentiates from other interfaces.
	IsJarFileNameContext()
}

type JarFileNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJarFileNameContext() *JarFileNameContext {
	var p = new(JarFileNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_jarFileName
	return p
}

func InitEmptyJarFileNameContext(p *JarFileNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_jarFileName
}

func (*JarFileNameContext) IsJarFileNameContext() {}

func NewJarFileNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JarFileNameContext {
	var p = new(JarFileNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_jarFileName

	return p
}

func (s *JarFileNameContext) GetParser() antlr.Parser { return s.parser }

func (s *JarFileNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *JarFileNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JarFileNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JarFileNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterJarFileName(s)
	}
}

func (s *JarFileNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitJarFileName(s)
	}
}

func (p *FlinkSqlParser) JarFileName() (localctx IJarFileNameContext) {
	localctx = NewJarFileNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, FlinkSqlParserRULE_jarFileName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(973)
		p.Match(FlinkSqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TablePath() ITablePathContext
	RenameDefinition() IRenameDefinitionContext
	SetKeyValueDefinition() ISetKeyValueDefinitionContext
	AddConstraint() IAddConstraintContext
	DropConstraint() IDropConstraintContext
	AddUnique() IAddUniqueContext
	IfExists() IIfExistsContext

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterTable
	return p
}

func InitEmptyAlterTableContext(p *AlterTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterTable
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALTER, 0)
}

func (s *AlterTableContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *AlterTableContext) TablePath() ITablePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathContext)
}

func (s *AlterTableContext) RenameDefinition() IRenameDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameDefinitionContext)
}

func (s *AlterTableContext) SetKeyValueDefinition() ISetKeyValueDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetKeyValueDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetKeyValueDefinitionContext)
}

func (s *AlterTableContext) AddConstraint() IAddConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddConstraintContext)
}

func (s *AlterTableContext) DropConstraint() IDropConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropConstraintContext)
}

func (s *AlterTableContext) AddUnique() IAddUniqueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddUniqueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddUniqueContext)
}

func (s *AlterTableContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (p *FlinkSqlParser) AlterTable() (localctx IAlterTableContext) {
	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, FlinkSqlParserRULE_alterTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)
		p.Match(FlinkSqlParserKW_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(976)
		p.Match(FlinkSqlParserKW_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(977)
			p.IfExists()
		}

	}
	{
		p.SetState(980)
		p.TablePath()
	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(981)
			p.RenameDefinition()
		}

	case 2:
		{
			p.SetState(982)
			p.SetKeyValueDefinition()
		}

	case 3:
		{
			p.SetState(983)
			p.AddConstraint()
		}

	case 4:
		{
			p.SetState(984)
			p.DropConstraint()
		}

	case 5:
		{
			p.SetState(985)
			p.AddUnique()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameDefinitionContext is an interface to support dynamic dispatch.
type IRenameDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RENAME() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext

	// IsRenameDefinitionContext differentiates from other interfaces.
	IsRenameDefinitionContext()
}

type RenameDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameDefinitionContext() *RenameDefinitionContext {
	var p = new(RenameDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_renameDefinition
	return p
}

func InitEmptyRenameDefinitionContext(p *RenameDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_renameDefinition
}

func (*RenameDefinitionContext) IsRenameDefinitionContext() {}

func NewRenameDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameDefinitionContext {
	var p = new(RenameDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_renameDefinition

	return p
}

func (s *RenameDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameDefinitionContext) KW_RENAME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RENAME, 0)
}

func (s *RenameDefinitionContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TO, 0)
}

func (s *RenameDefinitionContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RenameDefinitionContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RenameDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterRenameDefinition(s)
	}
}

func (s *RenameDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitRenameDefinition(s)
	}
}

func (p *FlinkSqlParser) RenameDefinition() (localctx IRenameDefinitionContext) {
	localctx = NewRenameDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, FlinkSqlParserRULE_renameDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Match(FlinkSqlParserKW_RENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-439)) & ^0x3f) == 0 && ((int64(1)<<(_la-439))&-1) != 0) || ((int64((_la-503)) & ^0x3f) == 0 && ((int64(1)<<(_la-503))&1305670057999) != 0) {
		{
			p.SetState(989)
			p.Uid()
		}

	}
	{
		p.SetState(992)
		p.Match(FlinkSqlParserKW_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(993)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetKeyValueDefinitionContext is an interface to support dynamic dispatch.
type ISetKeyValueDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SET() antlr.TerminalNode
	TablePropertyList() ITablePropertyListContext

	// IsSetKeyValueDefinitionContext differentiates from other interfaces.
	IsSetKeyValueDefinitionContext()
}

type SetKeyValueDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetKeyValueDefinitionContext() *SetKeyValueDefinitionContext {
	var p = new(SetKeyValueDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_setKeyValueDefinition
	return p
}

func InitEmptySetKeyValueDefinitionContext(p *SetKeyValueDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_setKeyValueDefinition
}

func (*SetKeyValueDefinitionContext) IsSetKeyValueDefinitionContext() {}

func NewSetKeyValueDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetKeyValueDefinitionContext {
	var p = new(SetKeyValueDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_setKeyValueDefinition

	return p
}

func (s *SetKeyValueDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetKeyValueDefinitionContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SET, 0)
}

func (s *SetKeyValueDefinitionContext) TablePropertyList() ITablePropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyListContext)
}

func (s *SetKeyValueDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetKeyValueDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetKeyValueDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSetKeyValueDefinition(s)
	}
}

func (s *SetKeyValueDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSetKeyValueDefinition(s)
	}
}

func (p *FlinkSqlParser) SetKeyValueDefinition() (localctx ISetKeyValueDefinitionContext) {
	localctx = NewSetKeyValueDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, FlinkSqlParserRULE_setKeyValueDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Match(FlinkSqlParserKW_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(996)
		p.TablePropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddConstraintContext is an interface to support dynamic dispatch.
type IAddConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ADD() antlr.TerminalNode
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintName() IConstraintNameContext
	KW_PRIMARY() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext
	NotForced() INotForcedContext

	// IsAddConstraintContext differentiates from other interfaces.
	IsAddConstraintContext()
}

type AddConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddConstraintContext() *AddConstraintContext {
	var p = new(AddConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_addConstraint
	return p
}

func InitEmptyAddConstraintContext(p *AddConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_addConstraint
}

func (*AddConstraintContext) IsAddConstraintContext() {}

func NewAddConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddConstraintContext {
	var p = new(AddConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_addConstraint

	return p
}

func (s *AddConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AddConstraintContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ADD, 0)
}

func (s *AddConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONSTRAINT, 0)
}

func (s *AddConstraintContext) ConstraintName() IConstraintNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *AddConstraintContext) KW_PRIMARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PRIMARY, 0)
}

func (s *AddConstraintContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_KEY, 0)
}

func (s *AddConstraintContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *AddConstraintContext) NotForced() INotForcedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotForcedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotForcedContext)
}

func (s *AddConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterAddConstraint(s)
	}
}

func (s *AddConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitAddConstraint(s)
	}
}

func (p *FlinkSqlParser) AddConstraint() (localctx IAddConstraintContext) {
	localctx = NewAddConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, FlinkSqlParserRULE_addConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		p.Match(FlinkSqlParserKW_ADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(999)
		p.Match(FlinkSqlParserKW_CONSTRAINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1000)
		p.ConstraintName()
	}
	{
		p.SetState(1001)
		p.Match(FlinkSqlParserKW_PRIMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1002)
		p.Match(FlinkSqlParserKW_KEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1003)
		p.ColumnNameList()
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_NOT {
		{
			p.SetState(1004)
			p.NotForced()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropConstraintContext is an interface to support dynamic dispatch.
type IDropConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_CONSTRAINT() antlr.TerminalNode
	ConstraintName() IConstraintNameContext

	// IsDropConstraintContext differentiates from other interfaces.
	IsDropConstraintContext()
}

type DropConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropConstraintContext() *DropConstraintContext {
	var p = new(DropConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropConstraint
	return p
}

func InitEmptyDropConstraintContext(p *DropConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropConstraint
}

func (*DropConstraintContext) IsDropConstraintContext() {}

func NewDropConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropConstraintContext {
	var p = new(DropConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dropConstraint

	return p
}

func (s *DropConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *DropConstraintContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DROP, 0)
}

func (s *DropConstraintContext) KW_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONSTRAINT, 0)
}

func (s *DropConstraintContext) ConstraintName() IConstraintNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *DropConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDropConstraint(s)
	}
}

func (s *DropConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDropConstraint(s)
	}
}

func (p *FlinkSqlParser) DropConstraint() (localctx IDropConstraintContext) {
	localctx = NewDropConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, FlinkSqlParserRULE_dropConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1007)
		p.Match(FlinkSqlParserKW_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1008)
		p.Match(FlinkSqlParserKW_CONSTRAINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1009)
		p.ConstraintName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddUniqueContext is an interface to support dynamic dispatch.
type IAddUniqueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ADD() antlr.TerminalNode
	KW_UNIQUE() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsAddUniqueContext differentiates from other interfaces.
	IsAddUniqueContext()
}

type AddUniqueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddUniqueContext() *AddUniqueContext {
	var p = new(AddUniqueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_addUnique
	return p
}

func InitEmptyAddUniqueContext(p *AddUniqueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_addUnique
}

func (*AddUniqueContext) IsAddUniqueContext() {}

func NewAddUniqueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddUniqueContext {
	var p = new(AddUniqueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_addUnique

	return p
}

func (s *AddUniqueContext) GetParser() antlr.Parser { return s.parser }

func (s *AddUniqueContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ADD, 0)
}

func (s *AddUniqueContext) KW_UNIQUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UNIQUE, 0)
}

func (s *AddUniqueContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *AddUniqueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddUniqueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddUniqueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterAddUnique(s)
	}
}

func (s *AddUniqueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitAddUnique(s)
	}
}

func (p *FlinkSqlParser) AddUnique() (localctx IAddUniqueContext) {
	localctx = NewAddUniqueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, FlinkSqlParserRULE_addUnique)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Match(FlinkSqlParserKW_ADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1012)
		p.Match(FlinkSqlParserKW_UNIQUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1013)
		p.ColumnNameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotForcedContext is an interface to support dynamic dispatch.
type INotForcedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_NOT() antlr.TerminalNode
	KW_ENFORCED() antlr.TerminalNode

	// IsNotForcedContext differentiates from other interfaces.
	IsNotForcedContext()
}

type NotForcedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotForcedContext() *NotForcedContext {
	var p = new(NotForcedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_notForced
	return p
}

func InitEmptyNotForcedContext(p *NotForcedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_notForced
}

func (*NotForcedContext) IsNotForcedContext() {}

func NewNotForcedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotForcedContext {
	var p = new(NotForcedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_notForced

	return p
}

func (s *NotForcedContext) GetParser() antlr.Parser { return s.parser }

func (s *NotForcedContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *NotForcedContext) KW_ENFORCED() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ENFORCED, 0)
}

func (s *NotForcedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotForcedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotForcedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterNotForced(s)
	}
}

func (s *NotForcedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitNotForced(s)
	}
}

func (p *FlinkSqlParser) NotForced() (localctx INotForcedContext) {
	localctx = NewNotForcedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, FlinkSqlParserRULE_notForced)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(FlinkSqlParserKW_NOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1016)
		p.Match(FlinkSqlParserKW_ENFORCED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewContext is an interface to support dynamic dispatch.
type IAlterViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	ViewPath() IViewPathContext
	RenameDefinition() IRenameDefinitionContext
	KW_AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext

	// IsAlterViewContext differentiates from other interfaces.
	IsAlterViewContext()
}

type AlterViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewContext() *AlterViewContext {
	var p = new(AlterViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterView
	return p
}

func InitEmptyAlterViewContext(p *AlterViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterView
}

func (*AlterViewContext) IsAlterViewContext() {}

func NewAlterViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewContext {
	var p = new(AlterViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_alterView

	return p
}

func (s *AlterViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALTER, 0)
}

func (s *AlterViewContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VIEW, 0)
}

func (s *AlterViewContext) ViewPath() IViewPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewPathContext)
}

func (s *AlterViewContext) RenameDefinition() IRenameDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameDefinitionContext)
}

func (s *AlterViewContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *AlterViewContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

func (p *FlinkSqlParser) AlterView() (localctx IAlterViewContext) {
	localctx = NewAlterViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, FlinkSqlParserRULE_alterView)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1018)
		p.Match(FlinkSqlParserKW_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1019)
		p.Match(FlinkSqlParserKW_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1020)
		p.ViewPath()
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_RENAME:
		{
			p.SetState(1021)
			p.RenameDefinition()
		}

	case FlinkSqlParserKW_AS:
		{
			p.SetState(1022)
			p.Match(FlinkSqlParserKW_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1023)
			p.queryStatement(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseContext is an interface to support dynamic dispatch.
type IAlterDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_DATABASE() antlr.TerminalNode
	DatabasePath() IDatabasePathContext
	SetKeyValueDefinition() ISetKeyValueDefinitionContext

	// IsAlterDatabaseContext differentiates from other interfaces.
	IsAlterDatabaseContext()
}

type AlterDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseContext() *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterDatabase
	return p
}

func InitEmptyAlterDatabaseContext(p *AlterDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterDatabase
}

func (*AlterDatabaseContext) IsAlterDatabaseContext() {}

func NewAlterDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_alterDatabase

	return p
}

func (s *AlterDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALTER, 0)
}

func (s *AlterDatabaseContext) KW_DATABASE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATABASE, 0)
}

func (s *AlterDatabaseContext) DatabasePath() IDatabasePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabasePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabasePathContext)
}

func (s *AlterDatabaseContext) SetKeyValueDefinition() ISetKeyValueDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetKeyValueDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetKeyValueDefinitionContext)
}

func (s *AlterDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterAlterDatabase(s)
	}
}

func (s *AlterDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitAlterDatabase(s)
	}
}

func (p *FlinkSqlParser) AlterDatabase() (localctx IAlterDatabaseContext) {
	localctx = NewAlterDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, FlinkSqlParserRULE_alterDatabase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(FlinkSqlParserKW_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1027)
		p.Match(FlinkSqlParserKW_DATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1028)
		p.DatabasePath()
	}
	{
		p.SetState(1029)
		p.SetKeyValueDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterFunctionContext is an interface to support dynamic dispatch.
type IAlterFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALTER() antlr.TerminalNode
	KW_FUNCTION() antlr.TerminalNode
	FunctionName() IFunctionNameContext
	KW_AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	KW_TEMPORARY() antlr.TerminalNode
	KW_SYSTEM() antlr.TerminalNode
	IfExists() IIfExistsContext
	KW_LANGUAGE() antlr.TerminalNode
	KW_JAVA() antlr.TerminalNode
	KW_SCALA() antlr.TerminalNode
	KW_PYTHON() antlr.TerminalNode

	// IsAlterFunctionContext differentiates from other interfaces.
	IsAlterFunctionContext()
}

type AlterFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterFunctionContext() *AlterFunctionContext {
	var p = new(AlterFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterFunction
	return p
}

func InitEmptyAlterFunctionContext(p *AlterFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_alterFunction
}

func (*AlterFunctionContext) IsAlterFunctionContext() {}

func NewAlterFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_alterFunction

	return p
}

func (s *AlterFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterFunctionContext) KW_ALTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALTER, 0)
}

func (s *AlterFunctionContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FUNCTION, 0)
}

func (s *AlterFunctionContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *AlterFunctionContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *AlterFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterFunctionContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *AlterFunctionContext) KW_SYSTEM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SYSTEM, 0)
}

func (s *AlterFunctionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterFunctionContext) KW_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LANGUAGE, 0)
}

func (s *AlterFunctionContext) KW_JAVA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JAVA, 0)
}

func (s *AlterFunctionContext) KW_SCALA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SCALA, 0)
}

func (s *AlterFunctionContext) KW_PYTHON() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON, 0)
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

func (p *FlinkSqlParser) AlterFunction() (localctx IAlterFunctionContext) {
	localctx = NewAlterFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, FlinkSqlParserRULE_alterFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Match(FlinkSqlParserKW_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1032)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1033)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1034)
			p.Match(FlinkSqlParserKW_SYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1037)
		p.Match(FlinkSqlParserKW_FUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1038)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1041)
		p.FunctionName()
	}
	{
		p.SetState(1042)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1043)
		p.Identifier()
	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_LANGUAGE {
		{
			p.SetState(1044)
			p.Match(FlinkSqlParserKW_LANGUAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1045)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_SCALA || _la == FlinkSqlParserKW_JAVA || _la == FlinkSqlParserKW_PYTHON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropCatalogContext is an interface to support dynamic dispatch.
type IDropCatalogContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_CATALOG() antlr.TerminalNode
	CatalogPath() ICatalogPathContext
	IfExists() IIfExistsContext

	// IsDropCatalogContext differentiates from other interfaces.
	IsDropCatalogContext()
}

type DropCatalogContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropCatalogContext() *DropCatalogContext {
	var p = new(DropCatalogContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropCatalog
	return p
}

func InitEmptyDropCatalogContext(p *DropCatalogContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropCatalog
}

func (*DropCatalogContext) IsDropCatalogContext() {}

func NewDropCatalogContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropCatalogContext {
	var p = new(DropCatalogContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dropCatalog

	return p
}

func (s *DropCatalogContext) GetParser() antlr.Parser { return s.parser }

func (s *DropCatalogContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DROP, 0)
}

func (s *DropCatalogContext) KW_CATALOG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CATALOG, 0)
}

func (s *DropCatalogContext) CatalogPath() ICatalogPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogPathContext)
}

func (s *DropCatalogContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDropCatalog(s)
	}
}

func (s *DropCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDropCatalog(s)
	}
}

func (p *FlinkSqlParser) DropCatalog() (localctx IDropCatalogContext) {
	localctx = NewDropCatalogContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, FlinkSqlParserRULE_dropCatalog)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.Match(FlinkSqlParserKW_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1049)
		p.Match(FlinkSqlParserKW_CATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(1050)
			p.IfExists()
		}

	}
	{
		p.SetState(1053)
		p.CatalogPath()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_TABLE() antlr.TerminalNode
	TablePath() ITablePathContext
	KW_TEMPORARY() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropTable
	return p
}

func InitEmptyDropTableContext(p *DropTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropTable
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DROP, 0)
}

func (s *DropTableContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *DropTableContext) TablePath() ITablePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathContext)
}

func (s *DropTableContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *DropTableContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (p *FlinkSqlParser) DropTable() (localctx IDropTableContext) {
	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, FlinkSqlParserRULE_dropTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(FlinkSqlParserKW_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_TEMPORARY {
		{
			p.SetState(1056)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1059)
		p.Match(FlinkSqlParserKW_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(1060)
			p.IfExists()
		}

	}
	{
		p.SetState(1063)
		p.TablePath()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token

	// SetDropType sets the dropType token.
	SetDropType(antlr.Token)

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_DATABASE() antlr.TerminalNode
	DatabasePath() IDatabasePathContext
	IfExists() IIfExistsContext
	KW_RESTRICT() antlr.TerminalNode
	KW_CASCADE() antlr.TerminalNode

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropDatabase
	return p
}

func InitEmptyDropDatabaseContext(p *DropDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropDatabase
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) GetDropType() antlr.Token { return s.dropType }

func (s *DropDatabaseContext) SetDropType(v antlr.Token) { s.dropType = v }

func (s *DropDatabaseContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DROP, 0)
}

func (s *DropDatabaseContext) KW_DATABASE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATABASE, 0)
}

func (s *DropDatabaseContext) DatabasePath() IDatabasePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabasePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabasePathContext)
}

func (s *DropDatabaseContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseContext) KW_RESTRICT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RESTRICT, 0)
}

func (s *DropDatabaseContext) KW_CASCADE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CASCADE, 0)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (p *FlinkSqlParser) DropDatabase() (localctx IDropDatabaseContext) {
	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, FlinkSqlParserRULE_dropDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		p.Match(FlinkSqlParserKW_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1066)
		p.Match(FlinkSqlParserKW_DATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(1067)
			p.IfExists()
		}

	}
	{
		p.SetState(1070)
		p.DatabasePath()
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_CASCADE || _la == FlinkSqlParserKW_RESTRICT {
		{
			p.SetState(1071)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropDatabaseContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_CASCADE || _la == FlinkSqlParserKW_RESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropDatabaseContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	ViewPath() IViewPathContext
	KW_TEMPORARY() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropView
	return p
}

func InitEmptyDropViewContext(p *DropViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropView
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DROP, 0)
}

func (s *DropViewContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VIEW, 0)
}

func (s *DropViewContext) ViewPath() IViewPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewPathContext)
}

func (s *DropViewContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *DropViewContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (p *FlinkSqlParser) DropView() (localctx IDropViewContext) {
	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, FlinkSqlParserRULE_dropView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.Match(FlinkSqlParserKW_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_TEMPORARY {
		{
			p.SetState(1075)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1078)
		p.Match(FlinkSqlParserKW_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_IF {
		{
			p.SetState(1079)
			p.IfExists()
		}

	}
	{
		p.SetState(1082)
		p.ViewPath()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DROP() antlr.TerminalNode
	KW_FUNCTION() antlr.TerminalNode
	FunctionName() IFunctionNameContext
	KW_TEMPORARY() antlr.TerminalNode
	KW_SYSTEM() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropFunction
	return p
}

func InitEmptyDropFunctionContext(p *DropFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dropFunction
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) KW_DROP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DROP, 0)
}

func (s *DropFunctionContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FUNCTION, 0)
}

func (s *DropFunctionContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *DropFunctionContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *DropFunctionContext) KW_SYSTEM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SYSTEM, 0)
}

func (s *DropFunctionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (p *FlinkSqlParser) DropFunction() (localctx IDropFunctionContext) {
	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, FlinkSqlParserRULE_dropFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		p.Match(FlinkSqlParserKW_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1085)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1086)
			p.Match(FlinkSqlParserKW_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)
			p.Match(FlinkSqlParserKW_SYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1090)
		p.Match(FlinkSqlParserKW_FUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1091)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1094)
		p.FunctionName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertSimpleStatement() IInsertSimpleStatementContext
	KW_EXECUTE() antlr.TerminalNode
	InsertMulStatementCompatibility() IInsertMulStatementCompatibilityContext
	InsertMulStatement() IInsertMulStatementContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) InsertSimpleStatement() IInsertSimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertSimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertSimpleStatementContext)
}

func (s *InsertStatementContext) KW_EXECUTE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXECUTE, 0)
}

func (s *InsertStatementContext) InsertMulStatementCompatibility() IInsertMulStatementCompatibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertMulStatementCompatibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertMulStatementCompatibilityContext)
}

func (s *InsertStatementContext) InsertMulStatement() IInsertMulStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertMulStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertMulStatementContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (p *FlinkSqlParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, FlinkSqlParserRULE_insertStatement)
	var _la int

	p.SetState(1103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_EXECUTE {
			{
				p.SetState(1096)
				p.Match(FlinkSqlParserKW_EXECUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1099)
			p.InsertSimpleStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1100)
			p.InsertMulStatementCompatibility()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1101)
			p.Match(FlinkSqlParserKW_EXECUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1102)
			p.InsertMulStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertSimpleStatementContext is an interface to support dynamic dispatch.
type IInsertSimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_INSERT() antlr.TerminalNode
	TablePath() ITablePathContext
	KW_INTO() antlr.TerminalNode
	KW_OVERWRITE() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	ValuesDefinition() IValuesDefinitionContext
	InsertPartitionDefinition() IInsertPartitionDefinitionContext
	ColumnNameList() IColumnNameListContext

	// IsInsertSimpleStatementContext differentiates from other interfaces.
	IsInsertSimpleStatementContext()
}

type InsertSimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertSimpleStatementContext() *InsertSimpleStatementContext {
	var p = new(InsertSimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertSimpleStatement
	return p
}

func InitEmptyInsertSimpleStatementContext(p *InsertSimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertSimpleStatement
}

func (*InsertSimpleStatementContext) IsInsertSimpleStatementContext() {}

func NewInsertSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertSimpleStatementContext {
	var p = new(InsertSimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_insertSimpleStatement

	return p
}

func (s *InsertSimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertSimpleStatementContext) KW_INSERT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INSERT, 0)
}

func (s *InsertSimpleStatementContext) TablePath() ITablePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathContext)
}

func (s *InsertSimpleStatementContext) KW_INTO() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INTO, 0)
}

func (s *InsertSimpleStatementContext) KW_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OVERWRITE, 0)
}

func (s *InsertSimpleStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *InsertSimpleStatementContext) ValuesDefinition() IValuesDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesDefinitionContext)
}

func (s *InsertSimpleStatementContext) InsertPartitionDefinition() IInsertPartitionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertPartitionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertPartitionDefinitionContext)
}

func (s *InsertSimpleStatementContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *InsertSimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertSimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertSimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterInsertSimpleStatement(s)
	}
}

func (s *InsertSimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitInsertSimpleStatement(s)
	}
}

func (p *FlinkSqlParser) InsertSimpleStatement() (localctx IInsertSimpleStatementContext) {
	localctx = NewInsertSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, FlinkSqlParserRULE_insertSimpleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.Match(FlinkSqlParserKW_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1106)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_INTO || _la == FlinkSqlParserKW_OVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1107)
		p.TablePath()
	}
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_PARTITION {
			{
				p.SetState(1108)
				p.InsertPartitionDefinition()
			}

		}
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1111)
				p.ColumnNameList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1114)
			p.queryStatement(0)
		}

	case 2:
		{
			p.SetState(1115)
			p.ValuesDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertPartitionDefinitionContext is an interface to support dynamic dispatch.
type IInsertPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PARTITION() antlr.TerminalNode
	TablePropertyList() ITablePropertyListContext

	// IsInsertPartitionDefinitionContext differentiates from other interfaces.
	IsInsertPartitionDefinitionContext()
}

type InsertPartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertPartitionDefinitionContext() *InsertPartitionDefinitionContext {
	var p = new(InsertPartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertPartitionDefinition
	return p
}

func InitEmptyInsertPartitionDefinitionContext(p *InsertPartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertPartitionDefinition
}

func (*InsertPartitionDefinitionContext) IsInsertPartitionDefinitionContext() {}

func NewInsertPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertPartitionDefinitionContext {
	var p = new(InsertPartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_insertPartitionDefinition

	return p
}

func (s *InsertPartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertPartitionDefinitionContext) KW_PARTITION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PARTITION, 0)
}

func (s *InsertPartitionDefinitionContext) TablePropertyList() ITablePropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyListContext)
}

func (s *InsertPartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertPartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertPartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterInsertPartitionDefinition(s)
	}
}

func (s *InsertPartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitInsertPartitionDefinition(s)
	}
}

func (p *FlinkSqlParser) InsertPartitionDefinition() (localctx IInsertPartitionDefinitionContext) {
	localctx = NewInsertPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, FlinkSqlParserRULE_insertPartitionDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Match(FlinkSqlParserKW_PARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1119)
		p.TablePropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesDefinitionContext is an interface to support dynamic dispatch.
type IValuesDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_VALUES() antlr.TerminalNode
	AllValuesRowDefinition() []IValuesRowDefinitionContext
	ValuesRowDefinition(i int) IValuesRowDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesDefinitionContext differentiates from other interfaces.
	IsValuesDefinitionContext()
}

type ValuesDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesDefinitionContext() *ValuesDefinitionContext {
	var p = new(ValuesDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valuesDefinition
	return p
}

func InitEmptyValuesDefinitionContext(p *ValuesDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valuesDefinition
}

func (*ValuesDefinitionContext) IsValuesDefinitionContext() {}

func NewValuesDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesDefinitionContext {
	var p = new(ValuesDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_valuesDefinition

	return p
}

func (s *ValuesDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesDefinitionContext) KW_VALUES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VALUES, 0)
}

func (s *ValuesDefinitionContext) AllValuesRowDefinition() []IValuesRowDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValuesRowDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IValuesRowDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValuesRowDefinitionContext); ok {
			tst[i] = t.(IValuesRowDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ValuesDefinitionContext) ValuesRowDefinition(i int) IValuesRowDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesRowDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesRowDefinitionContext)
}

func (s *ValuesDefinitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *ValuesDefinitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *ValuesDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterValuesDefinition(s)
	}
}

func (s *ValuesDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitValuesDefinition(s)
	}
}

func (p *FlinkSqlParser) ValuesDefinition() (localctx IValuesDefinitionContext) {
	localctx = NewValuesDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, FlinkSqlParserRULE_valuesDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Match(FlinkSqlParserKW_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1122)
		p.ValuesRowDefinition()
	}
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(1123)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1124)
			p.ValuesRowDefinition()
		}

		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesRowDefinitionContext is an interface to support dynamic dispatch.
type IValuesRowDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesRowDefinitionContext differentiates from other interfaces.
	IsValuesRowDefinitionContext()
}

type ValuesRowDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesRowDefinitionContext() *ValuesRowDefinitionContext {
	var p = new(ValuesRowDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valuesRowDefinition
	return p
}

func InitEmptyValuesRowDefinitionContext(p *ValuesRowDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valuesRowDefinition
}

func (*ValuesRowDefinitionContext) IsValuesRowDefinitionContext() {}

func NewValuesRowDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesRowDefinitionContext {
	var p = new(ValuesRowDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_valuesRowDefinition

	return p
}

func (s *ValuesRowDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesRowDefinitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *ValuesRowDefinitionContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ValuesRowDefinitionContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ValuesRowDefinitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *ValuesRowDefinitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *ValuesRowDefinitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *ValuesRowDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesRowDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesRowDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterValuesRowDefinition(s)
	}
}

func (s *ValuesRowDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitValuesRowDefinition(s)
	}
}

func (p *FlinkSqlParser) ValuesRowDefinition() (localctx IValuesRowDefinitionContext) {
	localctx = NewValuesRowDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, FlinkSqlParserRULE_valuesRowDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1131)
		p.Constant()
	}
	p.SetState(1136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(1132)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1133)
			p.Constant()
		}

		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1139)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertMulStatementCompatibilityContext is an interface to support dynamic dispatch.
type IInsertMulStatementCompatibilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_BEGIN() antlr.TerminalNode
	KW_STATEMENT() antlr.TerminalNode
	KW_SET() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	KW_END() antlr.TerminalNode
	AllInsertSimpleStatement() []IInsertSimpleStatementContext
	InsertSimpleStatement(i int) IInsertSimpleStatementContext

	// IsInsertMulStatementCompatibilityContext differentiates from other interfaces.
	IsInsertMulStatementCompatibilityContext()
}

type InsertMulStatementCompatibilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertMulStatementCompatibilityContext() *InsertMulStatementCompatibilityContext {
	var p = new(InsertMulStatementCompatibilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertMulStatementCompatibility
	return p
}

func InitEmptyInsertMulStatementCompatibilityContext(p *InsertMulStatementCompatibilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertMulStatementCompatibility
}

func (*InsertMulStatementCompatibilityContext) IsInsertMulStatementCompatibilityContext() {}

func NewInsertMulStatementCompatibilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertMulStatementCompatibilityContext {
	var p = new(InsertMulStatementCompatibilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_insertMulStatementCompatibility

	return p
}

func (s *InsertMulStatementCompatibilityContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertMulStatementCompatibilityContext) KW_BEGIN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BEGIN, 0)
}

func (s *InsertMulStatementCompatibilityContext) KW_STATEMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_STATEMENT, 0)
}

func (s *InsertMulStatementCompatibilityContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SET, 0)
}

func (s *InsertMulStatementCompatibilityContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserSEMICOLON)
}

func (s *InsertMulStatementCompatibilityContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSEMICOLON, i)
}

func (s *InsertMulStatementCompatibilityContext) KW_END() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_END, 0)
}

func (s *InsertMulStatementCompatibilityContext) AllInsertSimpleStatement() []IInsertSimpleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertSimpleStatementContext); ok {
			len++
		}
	}

	tst := make([]IInsertSimpleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertSimpleStatementContext); ok {
			tst[i] = t.(IInsertSimpleStatementContext)
			i++
		}
	}

	return tst
}

func (s *InsertMulStatementCompatibilityContext) InsertSimpleStatement(i int) IInsertSimpleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertSimpleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertSimpleStatementContext)
}

func (s *InsertMulStatementCompatibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertMulStatementCompatibilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertMulStatementCompatibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterInsertMulStatementCompatibility(s)
	}
}

func (s *InsertMulStatementCompatibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitInsertMulStatementCompatibility(s)
	}
}

func (p *FlinkSqlParser) InsertMulStatementCompatibility() (localctx IInsertMulStatementCompatibilityContext) {
	localctx = NewInsertMulStatementCompatibilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, FlinkSqlParserRULE_insertMulStatementCompatibility)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.Match(FlinkSqlParserKW_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1142)
		p.Match(FlinkSqlParserKW_STATEMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1143)
		p.Match(FlinkSqlParserKW_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1144)
		p.Match(FlinkSqlParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == FlinkSqlParserKW_INSERT {
		{
			p.SetState(1145)
			p.InsertSimpleStatement()
		}
		{
			p.SetState(1146)
			p.Match(FlinkSqlParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1152)
		p.Match(FlinkSqlParserKW_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertMulStatementContext is an interface to support dynamic dispatch.
type IInsertMulStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_STATEMENT() antlr.TerminalNode
	KW_SET() antlr.TerminalNode
	KW_BEGIN() antlr.TerminalNode
	KW_END() antlr.TerminalNode
	AllInsertSimpleStatement() []IInsertSimpleStatementContext
	InsertSimpleStatement(i int) IInsertSimpleStatementContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode

	// IsInsertMulStatementContext differentiates from other interfaces.
	IsInsertMulStatementContext()
}

type InsertMulStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertMulStatementContext() *InsertMulStatementContext {
	var p = new(InsertMulStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertMulStatement
	return p
}

func InitEmptyInsertMulStatementContext(p *InsertMulStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_insertMulStatement
}

func (*InsertMulStatementContext) IsInsertMulStatementContext() {}

func NewInsertMulStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertMulStatementContext {
	var p = new(InsertMulStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_insertMulStatement

	return p
}

func (s *InsertMulStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertMulStatementContext) KW_STATEMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_STATEMENT, 0)
}

func (s *InsertMulStatementContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SET, 0)
}

func (s *InsertMulStatementContext) KW_BEGIN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BEGIN, 0)
}

func (s *InsertMulStatementContext) KW_END() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_END, 0)
}

func (s *InsertMulStatementContext) AllInsertSimpleStatement() []IInsertSimpleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertSimpleStatementContext); ok {
			len++
		}
	}

	tst := make([]IInsertSimpleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertSimpleStatementContext); ok {
			tst[i] = t.(IInsertSimpleStatementContext)
			i++
		}
	}

	return tst
}

func (s *InsertMulStatementContext) InsertSimpleStatement(i int) IInsertSimpleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertSimpleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertSimpleStatementContext)
}

func (s *InsertMulStatementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserSEMICOLON)
}

func (s *InsertMulStatementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSEMICOLON, i)
}

func (s *InsertMulStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertMulStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertMulStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterInsertMulStatement(s)
	}
}

func (s *InsertMulStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitInsertMulStatement(s)
	}
}

func (p *FlinkSqlParser) InsertMulStatement() (localctx IInsertMulStatementContext) {
	localctx = NewInsertMulStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, FlinkSqlParserRULE_insertMulStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		p.Match(FlinkSqlParserKW_STATEMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1155)
		p.Match(FlinkSqlParserKW_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1156)
		p.Match(FlinkSqlParserKW_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == FlinkSqlParserKW_INSERT {
		{
			p.SetState(1157)
			p.InsertSimpleStatement()
		}
		{
			p.SetState(1158)
			p.Match(FlinkSqlParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1164)
		p.Match(FlinkSqlParserKW_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryStatementContext is an interface to support dynamic dispatch.
type IQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOperator returns the operator token.
	GetOperator() antlr.Token

	// SetOperator sets the operator token.
	SetOperator(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IQueryStatementContext

	// GetRight returns the right rule contexts.
	GetRight() IQueryStatementContext

	// SetLeft sets the left rule contexts.
	SetLeft(IQueryStatementContext)

	// SetRight sets the right rule contexts.
	SetRight(IQueryStatementContext)

	// Getter signatures
	ValuesClause() IValuesClauseContext
	WithClause() IWithClauseContext
	AllQueryStatement() []IQueryStatementContext
	QueryStatement(i int) IQueryStatementContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	SelectClause() ISelectClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	SelectStatement() ISelectStatementContext
	KW_INTERSECT() antlr.TerminalNode
	KW_UNION() antlr.TerminalNode
	KW_EXCEPT() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode

	// IsQueryStatementContext differentiates from other interfaces.
	IsQueryStatementContext()
}

type QueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	left     IQueryStatementContext
	operator antlr.Token
	right    IQueryStatementContext
}

func NewEmptyQueryStatementContext() *QueryStatementContext {
	var p = new(QueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_queryStatement
	return p
}

func InitEmptyQueryStatementContext(p *QueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_queryStatement
}

func (*QueryStatementContext) IsQueryStatementContext() {}

func NewQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementContext {
	var p = new(QueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_queryStatement

	return p
}

func (s *QueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementContext) GetOperator() antlr.Token { return s.operator }

func (s *QueryStatementContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *QueryStatementContext) GetLeft() IQueryStatementContext { return s.left }

func (s *QueryStatementContext) GetRight() IQueryStatementContext { return s.right }

func (s *QueryStatementContext) SetLeft(v IQueryStatementContext) { s.left = v }

func (s *QueryStatementContext) SetRight(v IQueryStatementContext) { s.right = v }

func (s *QueryStatementContext) ValuesClause() IValuesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesClauseContext)
}

func (s *QueryStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryStatementContext) AllQueryStatement() []IQueryStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryStatementContext); ok {
			len++
		}
	}

	tst := make([]IQueryStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryStatementContext); ok {
			tst[i] = t.(IQueryStatementContext)
			i++
		}
	}

	return tst
}

func (s *QueryStatementContext) QueryStatement(i int) IQueryStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *QueryStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *QueryStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *QueryStatementContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *QueryStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QueryStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *QueryStatementContext) KW_INTERSECT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INTERSECT, 0)
}

func (s *QueryStatementContext) KW_UNION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UNION, 0)
}

func (s *QueryStatementContext) KW_EXCEPT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXCEPT, 0)
}

func (s *QueryStatementContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALL, 0)
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

func (p *FlinkSqlParser) QueryStatement() (localctx IQueryStatementContext) {
	return p.queryStatement(0)
}

func (p *FlinkSqlParser) queryStatement(_p int) (localctx IQueryStatementContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryStatementContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryStatementContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 158
	p.EnterRecursionRule(localctx, 158, FlinkSqlParserRULE_queryStatement, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1167)
			p.ValuesClause()
		}

	case 2:
		{
			p.SetState(1168)
			p.WithClause()
		}
		{
			p.SetState(1169)
			p.queryStatement(5)
		}

	case 3:
		{
			p.SetState(1171)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1172)
			p.queryStatement(0)
		}
		{
			p.SetState(1173)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1175)
			p.SelectClause()
		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1176)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1179)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		{
			p.SetState(1182)
			p.SelectStatement()
		}
		p.SetState(1184)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1183)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1187)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1186)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewQueryStatementContext(p, _parentctx, _parentState)
			localctx.(*QueryStatementContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_queryStatement)
			p.SetState(1191)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			{
				p.SetState(1192)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*QueryStatementContext).operator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == FlinkSqlParserKW_EXCEPT || _la == FlinkSqlParserKW_INTERSECT || _la == FlinkSqlParserKW_UNION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*QueryStatementContext).operator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(1194)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == FlinkSqlParserKW_ALL {
				{
					p.SetState(1193)
					p.Match(FlinkSqlParserKW_ALL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1196)

				var _x = p.queryStatement(0)

				localctx.(*QueryStatementContext).right = _x
			}
			p.SetState(1198)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1197)
					p.OrderByClause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(1201)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1200)
					p.LimitClause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(1207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesClauseContext is an interface to support dynamic dispatch.
type IValuesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_VALUES() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesClauseContext differentiates from other interfaces.
	IsValuesClauseContext()
}

type ValuesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesClauseContext() *ValuesClauseContext {
	var p = new(ValuesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valuesClause
	return p
}

func InitEmptyValuesClauseContext(p *ValuesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valuesClause
}

func (*ValuesClauseContext) IsValuesClauseContext() {}

func NewValuesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesClauseContext {
	var p = new(ValuesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_valuesClause

	return p
}

func (s *ValuesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesClauseContext) KW_VALUES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VALUES, 0)
}

func (s *ValuesClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ValuesClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ValuesClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *ValuesClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *ValuesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterValuesClause(s)
	}
}

func (s *ValuesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitValuesClause(s)
	}
}

func (p *FlinkSqlParser) ValuesClause() (localctx IValuesClauseContext) {
	localctx = NewValuesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, FlinkSqlParserRULE_valuesClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.Match(FlinkSqlParserKW_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1209)
		p.Expression()
	}
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1210)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1211)
				p.Expression()
			}

		}
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WITH() antlr.TerminalNode
	AllWithItem() []IWithItemContext
	WithItem(i int) IWithItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WITH, 0)
}

func (s *WithClauseContext) AllWithItem() []IWithItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWithItemContext); ok {
			len++
		}
	}

	tst := make([]IWithItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWithItemContext); ok {
			tst[i] = t.(IWithItemContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) WithItem(i int) IWithItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithItemContext)
}

func (s *WithClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *WithClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (p *FlinkSqlParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, FlinkSqlParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(FlinkSqlParserKW_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1218)
		p.WithItem()
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(1219)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1220)
			p.WithItem()
		}

		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithItemContext is an interface to support dynamic dispatch.
type IWithItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WithItemName() IWithItemNameContext
	KW_AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllColumnName() []IColumnNameContext
	ColumnName(i int) IColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithItemContext differentiates from other interfaces.
	IsWithItemContext()
}

type WithItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithItemContext() *WithItemContext {
	var p = new(WithItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withItem
	return p
}

func InitEmptyWithItemContext(p *WithItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withItem
}

func (*WithItemContext) IsWithItemContext() {}

func NewWithItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithItemContext {
	var p = new(WithItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_withItem

	return p
}

func (s *WithItemContext) GetParser() antlr.Parser { return s.parser }

func (s *WithItemContext) WithItemName() IWithItemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithItemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithItemNameContext)
}

func (s *WithItemContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *WithItemContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserLR_BRACKET)
}

func (s *WithItemContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, i)
}

func (s *WithItemContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *WithItemContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserRR_BRACKET)
}

func (s *WithItemContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, i)
}

func (s *WithItemContext) AllColumnName() []IColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameContext); ok {
			tst[i] = t.(IColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *WithItemContext) ColumnName(i int) IColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *WithItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *WithItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *WithItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWithItem(s)
	}
}

func (s *WithItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWithItem(s)
	}
}

func (p *FlinkSqlParser) WithItem() (localctx IWithItemContext) {
	localctx = NewWithItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, FlinkSqlParserRULE_withItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.WithItemName()
	}
	p.SetState(1238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserLR_BRACKET {
		{
			p.SetState(1227)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1228)
			p.ColumnName()
		}
		p.SetState(1233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(1229)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1230)
				p.ColumnName()
			}

			p.SetState(1235)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1236)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1240)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1241)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1242)
		p.queryStatement(0)
	}
	{
		p.SetState(1243)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithItemNameContext is an interface to support dynamic dispatch.
type IWithItemNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsWithItemNameContext differentiates from other interfaces.
	IsWithItemNameContext()
}

type WithItemNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithItemNameContext() *WithItemNameContext {
	var p = new(WithItemNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withItemName
	return p
}

func InitEmptyWithItemNameContext(p *WithItemNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withItemName
}

func (*WithItemNameContext) IsWithItemNameContext() {}

func NewWithItemNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithItemNameContext {
	var p = new(WithItemNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_withItemName

	return p
}

func (s *WithItemNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WithItemNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WithItemNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithItemNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithItemNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWithItemName(s)
	}
}

func (s *WithItemNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWithItemName(s)
	}
}

func (p *FlinkSqlParser) WithItemName() (localctx IWithItemNameContext) {
	localctx = NewWithItemNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, FlinkSqlParserRULE_withItemName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1245)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectClause() ISelectClauseContext
	FromClause() IFromClauseContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	MatchRecognizeClause() IMatchRecognizeClauseContext

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *SelectStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SelectStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectStatementContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectStatementContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *SelectStatementContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *SelectStatementContext) MatchRecognizeClause() IMatchRecognizeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchRecognizeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchRecognizeClauseContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSelectStatement(s)
	}
}

func (s *SelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSelectStatement(s)
	}
}

func (p *FlinkSqlParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, FlinkSqlParserRULE_selectStatement)
	p.SetState(1267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1247)
			p.SelectClause()
		}
		p.SetState(1249)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1248)
				p.FromClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1252)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1251)
				p.WhereClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1255)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1254)
				p.GroupByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1258)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1257)
				p.HavingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1260)
				p.WindowClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1263)
			p.SelectClause()
		}
		{
			p.SetState(1264)
			p.FromClause()
		}
		{
			p.SetState(1265)
			p.MatchRecognizeClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SELECT() antlr.TerminalNode
	ASTERISK_SIGN() antlr.TerminalNode
	AllProjectItemDefinition() []IProjectItemDefinitionContext
	ProjectItemDefinition(i int) IProjectItemDefinitionContext
	SetQuantifier() ISetQuantifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) KW_SELECT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SELECT, 0)
}

func (s *SelectClauseContext) ASTERISK_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserASTERISK_SIGN, 0)
}

func (s *SelectClauseContext) AllProjectItemDefinition() []IProjectItemDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProjectItemDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IProjectItemDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProjectItemDefinitionContext); ok {
			tst[i] = t.(IProjectItemDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SelectClauseContext) ProjectItemDefinition(i int) IProjectItemDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemDefinitionContext)
}

func (s *SelectClauseContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SelectClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *SelectClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (p *FlinkSqlParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, FlinkSqlParserRULE_selectClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1269)
		p.Match(FlinkSqlParserKW_SELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_ALL || _la == FlinkSqlParserKW_DISTINCT {
		{
			p.SetState(1270)
			p.SetQuantifier()
		}

	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1273)
			p.Match(FlinkSqlParserASTERISK_SIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1274)
			p.ProjectItemDefinition()
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1275)
					p.Match(FlinkSqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1276)
					p.ProjectItemDefinition()
				}

			}
			p.SetState(1281)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectItemDefinitionContext is an interface to support dynamic dispatch.
type IProjectItemDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OverWindowItem() IOverWindowItemContext
	Expression() IExpressionContext
	ColumnName() IColumnNameContext
	KW_AS() antlr.TerminalNode

	// IsProjectItemDefinitionContext differentiates from other interfaces.
	IsProjectItemDefinitionContext()
}

type ProjectItemDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectItemDefinitionContext() *ProjectItemDefinitionContext {
	var p = new(ProjectItemDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_projectItemDefinition
	return p
}

func InitEmptyProjectItemDefinitionContext(p *ProjectItemDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_projectItemDefinition
}

func (*ProjectItemDefinitionContext) IsProjectItemDefinitionContext() {}

func NewProjectItemDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectItemDefinitionContext {
	var p = new(ProjectItemDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_projectItemDefinition

	return p
}

func (s *ProjectItemDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectItemDefinitionContext) OverWindowItem() IOverWindowItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverWindowItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverWindowItemContext)
}

func (s *ProjectItemDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ProjectItemDefinitionContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ProjectItemDefinitionContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *ProjectItemDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectItemDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectItemDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterProjectItemDefinition(s)
	}
}

func (s *ProjectItemDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitProjectItemDefinition(s)
	}
}

func (p *FlinkSqlParser) ProjectItemDefinition() (localctx IProjectItemDefinitionContext) {
	localctx = NewProjectItemDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, FlinkSqlParserRULE_projectItemDefinition)
	var _la int

	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1284)
			p.OverWindowItem()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1285)
			p.Expression()
		}
		p.SetState(1290)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			p.SetState(1287)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == FlinkSqlParserKW_AS {
				{
					p.SetState(1286)
					p.Match(FlinkSqlParserKW_AS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1289)
				p.ColumnName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1292)
			p.ColumnName()
		}
		p.SetState(1297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
			p.SetState(1294)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == FlinkSqlParserKW_AS {
				{
					p.SetState(1293)
					p.Match(FlinkSqlParserKW_AS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1296)
				p.Expression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverWindowItemContext is an interface to support dynamic dispatch.
type IOverWindowItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	KW_OVER() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	KW_AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsOverWindowItemContext differentiates from other interfaces.
	IsOverWindowItemContext()
}

type OverWindowItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverWindowItemContext() *OverWindowItemContext {
	var p = new(OverWindowItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_overWindowItem
	return p
}

func InitEmptyOverWindowItemContext(p *OverWindowItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_overWindowItem
}

func (*OverWindowItemContext) IsOverWindowItemContext() {}

func NewOverWindowItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverWindowItemContext {
	var p = new(OverWindowItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_overWindowItem

	return p
}

func (s *OverWindowItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OverWindowItemContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *OverWindowItemContext) KW_OVER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OVER, 0)
}

func (s *OverWindowItemContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *OverWindowItemContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *OverWindowItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OverWindowItemContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *OverWindowItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverWindowItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverWindowItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterOverWindowItem(s)
	}
}

func (s *OverWindowItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitOverWindowItem(s)
	}
}

func (p *FlinkSqlParser) OverWindowItem() (localctx IOverWindowItemContext) {
	localctx = NewOverWindowItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, FlinkSqlParserRULE_overWindowItem)
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1301)
			p.primaryExpression(0)
		}
		{
			p.SetState(1302)
			p.Match(FlinkSqlParserKW_OVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1303)
			p.WindowSpec()
		}
		{
			p.SetState(1304)
			p.Match(FlinkSqlParserKW_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1305)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1307)
			p.primaryExpression(0)
		}
		{
			p.SetState(1308)
			p.Match(FlinkSqlParserKW_OVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1309)
			p.ErrorCapturingIdentifier()
		}
		{
			p.SetState(1310)
			p.Match(FlinkSqlParserKW_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1311)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_FROM() antlr.TerminalNode
	TableExpression() ITableExpressionContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FROM, 0)
}

func (s *FromClauseContext) TableExpression() ITableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableExpressionContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *FlinkSqlParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, FlinkSqlParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Match(FlinkSqlParserKW_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1316)
		p.tableExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableExpressionContext is an interface to support dynamic dispatch.
type ITableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableReference() []ITableReferenceContext
	TableReference(i int) ITableReferenceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	InlineDataValueClause() IInlineDataValueClauseContext
	WindowTVFClause() IWindowTVFClauseContext
	AllTableExpression() []ITableExpressionContext
	TableExpression(i int) ITableExpressionContext
	KW_CROSS() antlr.TerminalNode
	KW_JOIN() antlr.TerminalNode
	KW_NATURAL() antlr.TerminalNode
	KW_OUTER() antlr.TerminalNode
	JoinCondition() IJoinConditionContext
	KW_LEFT() antlr.TerminalNode
	KW_RIGHT() antlr.TerminalNode
	KW_FULL() antlr.TerminalNode
	KW_INNER() antlr.TerminalNode

	// IsTableExpressionContext differentiates from other interfaces.
	IsTableExpressionContext()
}

type TableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableExpressionContext() *TableExpressionContext {
	var p = new(TableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableExpression
	return p
}

func InitEmptyTableExpressionContext(p *TableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableExpression
}

func (*TableExpressionContext) IsTableExpressionContext() {}

func NewTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableExpressionContext {
	var p = new(TableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tableExpression

	return p
}

func (s *TableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableExpressionContext) AllTableReference() []ITableReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableReferenceContext); ok {
			len++
		}
	}

	tst := make([]ITableReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableReferenceContext); ok {
			tst[i] = t.(ITableReferenceContext)
			i++
		}
	}

	return tst
}

func (s *TableExpressionContext) TableReference(i int) ITableReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *TableExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *TableExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *TableExpressionContext) InlineDataValueClause() IInlineDataValueClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineDataValueClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineDataValueClauseContext)
}

func (s *TableExpressionContext) WindowTVFClause() IWindowTVFClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowTVFClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowTVFClauseContext)
}

func (s *TableExpressionContext) AllTableExpression() []ITableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableExpressionContext); ok {
			len++
		}
	}

	tst := make([]ITableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableExpressionContext); ok {
			tst[i] = t.(ITableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TableExpressionContext) TableExpression(i int) ITableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableExpressionContext)
}

func (s *TableExpressionContext) KW_CROSS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CROSS, 0)
}

func (s *TableExpressionContext) KW_JOIN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JOIN, 0)
}

func (s *TableExpressionContext) KW_NATURAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NATURAL, 0)
}

func (s *TableExpressionContext) KW_OUTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OUTER, 0)
}

func (s *TableExpressionContext) JoinCondition() IJoinConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinConditionContext)
}

func (s *TableExpressionContext) KW_LEFT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LEFT, 0)
}

func (s *TableExpressionContext) KW_RIGHT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RIGHT, 0)
}

func (s *TableExpressionContext) KW_FULL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FULL, 0)
}

func (s *TableExpressionContext) KW_INNER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INNER, 0)
}

func (s *TableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTableExpression(s)
	}
}

func (s *TableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTableExpression(s)
	}
}

func (p *FlinkSqlParser) TableExpression() (localctx ITableExpressionContext) {
	return p.tableExpression(0)
}

func (p *FlinkSqlParser) tableExpression(_p int) (localctx ITableExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTableExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITableExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 178
	p.EnterRecursionRule(localctx, 178, FlinkSqlParserRULE_tableExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1319)
			p.TableReference()
		}
		p.SetState(1324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1320)
					p.Match(FlinkSqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1321)
					p.TableReference()
				}

			}
			p.SetState(1326)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1327)
			p.InlineDataValueClause()
		}

	case 3:
		{
			p.SetState(1328)
			p.WindowTVFClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1350)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
			case 1:
				localctx = NewTableExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_tableExpression)
				p.SetState(1331)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1332)
					p.Match(FlinkSqlParserKW_CROSS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1333)
					p.Match(FlinkSqlParserKW_JOIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1334)
					p.tableExpression(4)
				}

			case 2:
				localctx = NewTableExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_tableExpression)
				p.SetState(1335)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(1337)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == FlinkSqlParserKW_NATURAL {
					{
						p.SetState(1336)
						p.Match(FlinkSqlParserKW_NATURAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1340)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64((_la-152)) & ^0x3f) == 0 && ((int64(1)<<(_la-152))&1125899911036929) != 0) || _la == FlinkSqlParserKW_RIGHT {
					{
						p.SetState(1339)
						_la = p.GetTokenStream().LA(1)

						if !(((int64((_la-152)) & ^0x3f) == 0 && ((int64(1)<<(_la-152))&1125899911036929) != 0) || _la == FlinkSqlParserKW_RIGHT) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				p.SetState(1343)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == FlinkSqlParserKW_OUTER {
					{
						p.SetState(1342)
						p.Match(FlinkSqlParserKW_OUTER)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1345)
					p.Match(FlinkSqlParserKW_JOIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1346)
					p.tableExpression(0)
				}
				p.SetState(1348)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1347)
						p.JoinCondition()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceContext is an interface to support dynamic dispatch.
type ITableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TablePrimary() ITablePrimaryContext
	TableAlias() ITableAliasContext

	// IsTableReferenceContext differentiates from other interfaces.
	IsTableReferenceContext()
}

type TableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceContext() *TableReferenceContext {
	var p = new(TableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableReference
	return p
}

func InitEmptyTableReferenceContext(p *TableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableReference
}

func (*TableReferenceContext) IsTableReferenceContext() {}

func NewTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceContext {
	var p = new(TableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tableReference

	return p
}

func (s *TableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceContext) TablePrimary() ITablePrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePrimaryContext)
}

func (s *TableReferenceContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTableReference(s)
	}
}

func (s *TableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTableReference(s)
	}
}

func (p *FlinkSqlParser) TableReference() (localctx ITableReferenceContext) {
	localctx = NewTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, FlinkSqlParserRULE_tableReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1355)
		p.TablePrimary()
	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1356)
			p.TableAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePrimaryContext is an interface to support dynamic dispatch.
type ITablePrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TablePath() ITablePathContext
	KW_TABLE() antlr.TerminalNode
	SystemTimePeriod() ISystemTimePeriodContext
	ViewPath() IViewPathContext
	KW_LATERAL() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	FunctionCallExpression() IFunctionCallExpressionContext
	RR_BRACKET() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	KW_UNNEST() antlr.TerminalNode
	Expression() IExpressionContext

	// IsTablePrimaryContext differentiates from other interfaces.
	IsTablePrimaryContext()
}

type TablePrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePrimaryContext() *TablePrimaryContext {
	var p = new(TablePrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePrimary
	return p
}

func InitEmptyTablePrimaryContext(p *TablePrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePrimary
}

func (*TablePrimaryContext) IsTablePrimaryContext() {}

func NewTablePrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePrimaryContext {
	var p = new(TablePrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tablePrimary

	return p
}

func (s *TablePrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePrimaryContext) TablePath() ITablePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePathContext)
}

func (s *TablePrimaryContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *TablePrimaryContext) SystemTimePeriod() ISystemTimePeriodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemTimePeriodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemTimePeriodContext)
}

func (s *TablePrimaryContext) ViewPath() IViewPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewPathContext)
}

func (s *TablePrimaryContext) KW_LATERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LATERAL, 0)
}

func (s *TablePrimaryContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *TablePrimaryContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *TablePrimaryContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *TablePrimaryContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *TablePrimaryContext) KW_UNNEST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UNNEST, 0)
}

func (s *TablePrimaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TablePrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTablePrimary(s)
	}
}

func (s *TablePrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTablePrimary(s)
	}
}

func (p *FlinkSqlParser) TablePrimary() (localctx ITablePrimaryContext) {
	localctx = NewTablePrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, FlinkSqlParserRULE_tablePrimary)
	var _la int

	p.SetState(1388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_TABLE {
			{
				p.SetState(1359)
				p.Match(FlinkSqlParserKW_TABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1362)
			p.TablePath()
		}
		p.SetState(1364)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1363)
				p.SystemTimePeriod()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1366)
			p.ViewPath()
		}
		p.SetState(1368)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1367)
				p.SystemTimePeriod()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1370)
			p.Match(FlinkSqlParserKW_LATERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1371)
			p.Match(FlinkSqlParserKW_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1372)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1373)
			p.FunctionCallExpression()
		}
		{
			p.SetState(1374)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_LATERAL {
			{
				p.SetState(1376)
				p.Match(FlinkSqlParserKW_LATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1379)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1380)
			p.queryStatement(0)
		}
		{
			p.SetState(1381)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1383)
			p.Match(FlinkSqlParserKW_UNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1384)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1385)
			p.Expression()
		}
		{
			p.SetState(1386)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemTimePeriodContext is an interface to support dynamic dispatch.
type ISystemTimePeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_FOR() antlr.TerminalNode
	KW_SYSTEM_TIME() antlr.TerminalNode
	KW_AS() antlr.TerminalNode
	KW_OF() antlr.TerminalNode
	DateTimeExpression() IDateTimeExpressionContext

	// IsSystemTimePeriodContext differentiates from other interfaces.
	IsSystemTimePeriodContext()
}

type SystemTimePeriodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemTimePeriodContext() *SystemTimePeriodContext {
	var p = new(SystemTimePeriodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_systemTimePeriod
	return p
}

func InitEmptySystemTimePeriodContext(p *SystemTimePeriodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_systemTimePeriod
}

func (*SystemTimePeriodContext) IsSystemTimePeriodContext() {}

func NewSystemTimePeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemTimePeriodContext {
	var p = new(SystemTimePeriodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_systemTimePeriod

	return p
}

func (s *SystemTimePeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemTimePeriodContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FOR, 0)
}

func (s *SystemTimePeriodContext) KW_SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SYSTEM_TIME, 0)
}

func (s *SystemTimePeriodContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *SystemTimePeriodContext) KW_OF() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OF, 0)
}

func (s *SystemTimePeriodContext) DateTimeExpression() IDateTimeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimeExpressionContext)
}

func (s *SystemTimePeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemTimePeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemTimePeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSystemTimePeriod(s)
	}
}

func (s *SystemTimePeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSystemTimePeriod(s)
	}
}

func (p *FlinkSqlParser) SystemTimePeriod() (localctx ISystemTimePeriodContext) {
	localctx = NewSystemTimePeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, FlinkSqlParserRULE_systemTimePeriod)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1390)
		p.Match(FlinkSqlParserKW_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1391)
		p.Match(FlinkSqlParserKW_SYSTEM_TIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1392)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1393)
		p.Match(FlinkSqlParserKW_OF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1394)
		p.DateTimeExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateTimeExpressionContext is an interface to support dynamic dispatch.
type IDateTimeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsDateTimeExpressionContext differentiates from other interfaces.
	IsDateTimeExpressionContext()
}

type DateTimeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeExpressionContext() *DateTimeExpressionContext {
	var p = new(DateTimeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dateTimeExpression
	return p
}

func InitEmptyDateTimeExpressionContext(p *DateTimeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dateTimeExpression
}

func (*DateTimeExpressionContext) IsDateTimeExpressionContext() {}

func NewDateTimeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeExpressionContext {
	var p = new(DateTimeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dateTimeExpression

	return p
}

func (s *DateTimeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DateTimeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDateTimeExpression(s)
	}
}

func (s *DateTimeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDateTimeExpression(s)
	}
}

func (p *FlinkSqlParser) DateTimeExpression() (localctx IDateTimeExpressionContext) {
	localctx = NewDateTimeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, FlinkSqlParserRULE_dateTimeExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1396)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineDataValueClauseContext is an interface to support dynamic dispatch.
type IInlineDataValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	ValuesDefinition() IValuesDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	TableAlias() ITableAliasContext

	// IsInlineDataValueClauseContext differentiates from other interfaces.
	IsInlineDataValueClauseContext()
}

type InlineDataValueClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineDataValueClauseContext() *InlineDataValueClauseContext {
	var p = new(InlineDataValueClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_inlineDataValueClause
	return p
}

func InitEmptyInlineDataValueClauseContext(p *InlineDataValueClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_inlineDataValueClause
}

func (*InlineDataValueClauseContext) IsInlineDataValueClauseContext() {}

func NewInlineDataValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineDataValueClauseContext {
	var p = new(InlineDataValueClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_inlineDataValueClause

	return p
}

func (s *InlineDataValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineDataValueClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *InlineDataValueClauseContext) ValuesDefinition() IValuesDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesDefinitionContext)
}

func (s *InlineDataValueClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *InlineDataValueClauseContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *InlineDataValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineDataValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineDataValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterInlineDataValueClause(s)
	}
}

func (s *InlineDataValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitInlineDataValueClause(s)
	}
}

func (p *FlinkSqlParser) InlineDataValueClause() (localctx IInlineDataValueClauseContext) {
	localctx = NewInlineDataValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, FlinkSqlParserRULE_inlineDataValueClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1398)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1399)
		p.ValuesDefinition()
	}
	{
		p.SetState(1400)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1401)
		p.TableAlias()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowTVFClauseContext is an interface to support dynamic dispatch.
type IWindowTVFClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TABLE() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	WindowTVFExpression() IWindowTVFExpressionContext
	RR_BRACKET() antlr.TerminalNode

	// IsWindowTVFClauseContext differentiates from other interfaces.
	IsWindowTVFClauseContext()
}

type WindowTVFClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowTVFClauseContext() *WindowTVFClauseContext {
	var p = new(WindowTVFClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFClause
	return p
}

func InitEmptyWindowTVFClauseContext(p *WindowTVFClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFClause
}

func (*WindowTVFClauseContext) IsWindowTVFClauseContext() {}

func NewWindowTVFClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowTVFClauseContext {
	var p = new(WindowTVFClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_windowTVFClause

	return p
}

func (s *WindowTVFClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowTVFClauseContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *WindowTVFClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *WindowTVFClauseContext) WindowTVFExpression() IWindowTVFExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowTVFExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowTVFExpressionContext)
}

func (s *WindowTVFClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *WindowTVFClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowTVFClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowTVFClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWindowTVFClause(s)
	}
}

func (s *WindowTVFClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWindowTVFClause(s)
	}
}

func (p *FlinkSqlParser) WindowTVFClause() (localctx IWindowTVFClauseContext) {
	localctx = NewWindowTVFClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, FlinkSqlParserRULE_windowTVFClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1403)
		p.Match(FlinkSqlParserKW_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1404)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1405)
		p.WindowTVFExpression()
	}
	{
		p.SetState(1406)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowTVFExpressionContext is an interface to support dynamic dispatch.
type IWindowTVFExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowTVFName() IWindowTVFNameContext
	LR_BRACKET() antlr.TerminalNode
	AllWindowTVFParam() []IWindowTVFParamContext
	WindowTVFParam(i int) IWindowTVFParamContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowTVFExpressionContext differentiates from other interfaces.
	IsWindowTVFExpressionContext()
}

type WindowTVFExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowTVFExpressionContext() *WindowTVFExpressionContext {
	var p = new(WindowTVFExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFExpression
	return p
}

func InitEmptyWindowTVFExpressionContext(p *WindowTVFExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFExpression
}

func (*WindowTVFExpressionContext) IsWindowTVFExpressionContext() {}

func NewWindowTVFExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowTVFExpressionContext {
	var p = new(WindowTVFExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_windowTVFExpression

	return p
}

func (s *WindowTVFExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowTVFExpressionContext) WindowTVFName() IWindowTVFNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowTVFNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowTVFNameContext)
}

func (s *WindowTVFExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *WindowTVFExpressionContext) AllWindowTVFParam() []IWindowTVFParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowTVFParamContext); ok {
			len++
		}
	}

	tst := make([]IWindowTVFParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowTVFParamContext); ok {
			tst[i] = t.(IWindowTVFParamContext)
			i++
		}
	}

	return tst
}

func (s *WindowTVFExpressionContext) WindowTVFParam(i int) IWindowTVFParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowTVFParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowTVFParamContext)
}

func (s *WindowTVFExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *WindowTVFExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *WindowTVFExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *WindowTVFExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowTVFExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowTVFExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWindowTVFExpression(s)
	}
}

func (s *WindowTVFExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWindowTVFExpression(s)
	}
}

func (p *FlinkSqlParser) WindowTVFExpression() (localctx IWindowTVFExpressionContext) {
	localctx = NewWindowTVFExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, FlinkSqlParserRULE_windowTVFExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1408)
		p.WindowTVFName()
	}
	{
		p.SetState(1409)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1410)
		p.WindowTVFParam()
	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(1411)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.WindowTVFParam()
		}

		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1418)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowTVFNameContext is an interface to support dynamic dispatch.
type IWindowTVFNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TUMBLE() antlr.TerminalNode
	KW_HOP() antlr.TerminalNode
	KW_CUMULATE() antlr.TerminalNode

	// IsWindowTVFNameContext differentiates from other interfaces.
	IsWindowTVFNameContext()
}

type WindowTVFNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowTVFNameContext() *WindowTVFNameContext {
	var p = new(WindowTVFNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFName
	return p
}

func InitEmptyWindowTVFNameContext(p *WindowTVFNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFName
}

func (*WindowTVFNameContext) IsWindowTVFNameContext() {}

func NewWindowTVFNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowTVFNameContext {
	var p = new(WindowTVFNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_windowTVFName

	return p
}

func (s *WindowTVFNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowTVFNameContext) KW_TUMBLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TUMBLE, 0)
}

func (s *WindowTVFNameContext) KW_HOP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOP, 0)
}

func (s *WindowTVFNameContext) KW_CUMULATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CUMULATE, 0)
}

func (s *WindowTVFNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowTVFNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowTVFNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWindowTVFName(s)
	}
}

func (s *WindowTVFNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWindowTVFName(s)
	}
}

func (p *FlinkSqlParser) WindowTVFName() (localctx IWindowTVFNameContext) {
	localctx = NewWindowTVFNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, FlinkSqlParserRULE_windowTVFName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-447)) & ^0x3f) == 0 && ((int64(1)<<(_la-447))&18014398509498369) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowTVFParamContext is an interface to support dynamic dispatch.
type IWindowTVFParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TABLE() antlr.TerminalNode
	TimeAttrColumn() ITimeAttrColumnContext
	ColumnDescriptor() IColumnDescriptorContext
	TimeIntervalExpression() ITimeIntervalExpressionContext
	KW_DATA() antlr.TerminalNode
	DOUBLE_RIGHT_ARROW() antlr.TerminalNode
	KW_TIMECOL() antlr.TerminalNode
	TimeIntervalParamName() ITimeIntervalParamNameContext

	// IsWindowTVFParamContext differentiates from other interfaces.
	IsWindowTVFParamContext()
}

type WindowTVFParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowTVFParamContext() *WindowTVFParamContext {
	var p = new(WindowTVFParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFParam
	return p
}

func InitEmptyWindowTVFParamContext(p *WindowTVFParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowTVFParam
}

func (*WindowTVFParamContext) IsWindowTVFParamContext() {}

func NewWindowTVFParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowTVFParamContext {
	var p = new(WindowTVFParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_windowTVFParam

	return p
}

func (s *WindowTVFParamContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowTVFParamContext) KW_TABLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TABLE, 0)
}

func (s *WindowTVFParamContext) TimeAttrColumn() ITimeAttrColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeAttrColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeAttrColumnContext)
}

func (s *WindowTVFParamContext) ColumnDescriptor() IColumnDescriptorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescriptorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescriptorContext)
}

func (s *WindowTVFParamContext) TimeIntervalExpression() ITimeIntervalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalExpressionContext)
}

func (s *WindowTVFParamContext) KW_DATA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATA, 0)
}

func (s *WindowTVFParamContext) DOUBLE_RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOUBLE_RIGHT_ARROW, 0)
}

func (s *WindowTVFParamContext) KW_TIMECOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIMECOL, 0)
}

func (s *WindowTVFParamContext) TimeIntervalParamName() ITimeIntervalParamNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalParamNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalParamNameContext)
}

func (s *WindowTVFParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowTVFParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowTVFParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWindowTVFParam(s)
	}
}

func (s *WindowTVFParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWindowTVFParam(s)
	}
}

func (p *FlinkSqlParser) WindowTVFParam() (localctx IWindowTVFParamContext) {
	localctx = NewWindowTVFParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, FlinkSqlParserRULE_windowTVFParam)
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1422)
			p.Match(FlinkSqlParserKW_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1423)
			p.TimeAttrColumn()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1424)
			p.ColumnDescriptor()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1425)
			p.TimeIntervalExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1426)
			p.Match(FlinkSqlParserKW_DATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.Match(FlinkSqlParserDOUBLE_RIGHT_ARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1428)
			p.Match(FlinkSqlParserKW_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1429)
			p.TimeAttrColumn()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1430)
			p.Match(FlinkSqlParserKW_TIMECOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1431)
			p.Match(FlinkSqlParserDOUBLE_RIGHT_ARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1432)
			p.ColumnDescriptor()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1433)
			p.TimeIntervalParamName()
		}
		{
			p.SetState(1434)
			p.Match(FlinkSqlParserDOUBLE_RIGHT_ARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1435)
			p.TimeIntervalExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeIntervalParamNameContext is an interface to support dynamic dispatch.
type ITimeIntervalParamNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DATA() antlr.TerminalNode
	KW_TIMECOL() antlr.TerminalNode
	KW_SIZE() antlr.TerminalNode
	KW_OFFSET() antlr.TerminalNode
	KW_STEP() antlr.TerminalNode
	KW_SLIDE() antlr.TerminalNode

	// IsTimeIntervalParamNameContext differentiates from other interfaces.
	IsTimeIntervalParamNameContext()
}

type TimeIntervalParamNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeIntervalParamNameContext() *TimeIntervalParamNameContext {
	var p = new(TimeIntervalParamNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalParamName
	return p
}

func InitEmptyTimeIntervalParamNameContext(p *TimeIntervalParamNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalParamName
}

func (*TimeIntervalParamNameContext) IsTimeIntervalParamNameContext() {}

func NewTimeIntervalParamNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeIntervalParamNameContext {
	var p = new(TimeIntervalParamNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalParamName

	return p
}

func (s *TimeIntervalParamNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeIntervalParamNameContext) KW_DATA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATA, 0)
}

func (s *TimeIntervalParamNameContext) KW_TIMECOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIMECOL, 0)
}

func (s *TimeIntervalParamNameContext) KW_SIZE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SIZE, 0)
}

func (s *TimeIntervalParamNameContext) KW_OFFSET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OFFSET, 0)
}

func (s *TimeIntervalParamNameContext) KW_STEP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_STEP, 0)
}

func (s *TimeIntervalParamNameContext) KW_SLIDE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SLIDE, 0)
}

func (s *TimeIntervalParamNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeIntervalParamNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeIntervalParamNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTimeIntervalParamName(s)
	}
}

func (s *TimeIntervalParamNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTimeIntervalParamName(s)
	}
}

func (p *FlinkSqlParser) TimeIntervalParamName() (localctx ITimeIntervalParamNameContext) {
	localctx = NewTimeIntervalParamNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, FlinkSqlParserRULE_timeIntervalParamName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1439)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_OFFSET || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&6473924464345089) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDescriptorContext is an interface to support dynamic dispatch.
type IColumnDescriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DESCRIPTOR() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	ColumnName() IColumnNameContext
	RR_BRACKET() antlr.TerminalNode

	// IsColumnDescriptorContext differentiates from other interfaces.
	IsColumnDescriptorContext()
}

type ColumnDescriptorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDescriptorContext() *ColumnDescriptorContext {
	var p = new(ColumnDescriptorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnDescriptor
	return p
}

func InitEmptyColumnDescriptorContext(p *ColumnDescriptorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_columnDescriptor
}

func (*ColumnDescriptorContext) IsColumnDescriptorContext() {}

func NewColumnDescriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDescriptorContext {
	var p = new(ColumnDescriptorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_columnDescriptor

	return p
}

func (s *ColumnDescriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDescriptorContext) KW_DESCRIPTOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DESCRIPTOR, 0)
}

func (s *ColumnDescriptorContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *ColumnDescriptorContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnDescriptorContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *ColumnDescriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDescriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDescriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnDescriptor(s)
	}
}

func (s *ColumnDescriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnDescriptor(s)
	}
}

func (p *FlinkSqlParser) ColumnDescriptor() (localctx IColumnDescriptorContext) {
	localctx = NewColumnDescriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, FlinkSqlParserRULE_columnDescriptor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1441)
		p.Match(FlinkSqlParserKW_DESCRIPTOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1442)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1443)
		p.ColumnName()
	}
	{
		p.SetState(1444)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinConditionContext is an interface to support dynamic dispatch.
type IJoinConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	KW_USING() antlr.TerminalNode
	ColumnNameList() IColumnNameListContext

	// IsJoinConditionContext differentiates from other interfaces.
	IsJoinConditionContext()
}

type JoinConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinConditionContext() *JoinConditionContext {
	var p = new(JoinConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_joinCondition
	return p
}

func InitEmptyJoinConditionContext(p *JoinConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_joinCondition
}

func (*JoinConditionContext) IsJoinConditionContext() {}

func NewJoinConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinConditionContext {
	var p = new(JoinConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_joinCondition

	return p
}

func (s *JoinConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinConditionContext) KW_ON() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ON, 0)
}

func (s *JoinConditionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinConditionContext) KW_USING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_USING, 0)
}

func (s *JoinConditionContext) ColumnNameList() IColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameListContext)
}

func (s *JoinConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterJoinCondition(s)
	}
}

func (s *JoinConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitJoinCondition(s)
	}
}

func (p *FlinkSqlParser) JoinCondition() (localctx IJoinConditionContext) {
	localctx = NewJoinConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, FlinkSqlParserRULE_joinCondition)
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_ON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1446)
			p.Match(FlinkSqlParserKW_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1447)
			p.booleanExpression(0)
		}

	case FlinkSqlParserKW_USING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1448)
			p.Match(FlinkSqlParserKW_USING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1449)
			p.ColumnNameList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) KW_WHERE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WHERE, 0)
}

func (s *WhereClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *FlinkSqlParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, FlinkSqlParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1452)
		p.Match(FlinkSqlParserKW_WHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1453)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_GROUP() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	AllGroupItemDefinition() []IGroupItemDefinitionContext
	GroupItemDefinition(i int) IGroupItemDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) KW_GROUP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_GROUP, 0)
}

func (s *GroupByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BY, 0)
}

func (s *GroupByClauseContext) AllGroupItemDefinition() []IGroupItemDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupItemDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IGroupItemDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupItemDefinitionContext); ok {
			tst[i] = t.(IGroupItemDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *GroupByClauseContext) GroupItemDefinition(i int) IGroupItemDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupItemDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupItemDefinitionContext)
}

func (s *GroupByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *GroupByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (p *FlinkSqlParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, FlinkSqlParserRULE_groupByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1455)
		p.Match(FlinkSqlParserKW_GROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1456)
		p.Match(FlinkSqlParserKW_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1457)
		p.GroupItemDefinition()
	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1458)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1459)
				p.GroupItemDefinition()
			}

		}
		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupItemDefinitionContext is an interface to support dynamic dispatch.
type IGroupItemDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnName() IColumnNameContext
	GroupWindowFunction() IGroupWindowFunctionContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	GroupingSetsNotationName() IGroupingSetsNotationNameContext
	GroupingSets() IGroupingSetsContext
	AllGroupItemDefinition() []IGroupItemDefinitionContext
	GroupItemDefinition(i int) IGroupItemDefinitionContext

	// IsGroupItemDefinitionContext differentiates from other interfaces.
	IsGroupItemDefinitionContext()
}

type GroupItemDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupItemDefinitionContext() *GroupItemDefinitionContext {
	var p = new(GroupItemDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupItemDefinition
	return p
}

func InitEmptyGroupItemDefinitionContext(p *GroupItemDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupItemDefinition
}

func (*GroupItemDefinitionContext) IsGroupItemDefinitionContext() {}

func NewGroupItemDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupItemDefinitionContext {
	var p = new(GroupItemDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_groupItemDefinition

	return p
}

func (s *GroupItemDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupItemDefinitionContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *GroupItemDefinitionContext) GroupWindowFunction() IGroupWindowFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupWindowFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupWindowFunctionContext)
}

func (s *GroupItemDefinitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *GroupItemDefinitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *GroupItemDefinitionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupItemDefinitionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupItemDefinitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *GroupItemDefinitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *GroupItemDefinitionContext) GroupingSetsNotationName() IGroupingSetsNotationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetsNotationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetsNotationNameContext)
}

func (s *GroupItemDefinitionContext) GroupingSets() IGroupingSetsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetsContext)
}

func (s *GroupItemDefinitionContext) AllGroupItemDefinition() []IGroupItemDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupItemDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IGroupItemDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupItemDefinitionContext); ok {
			tst[i] = t.(IGroupItemDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *GroupItemDefinitionContext) GroupItemDefinition(i int) IGroupItemDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupItemDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupItemDefinitionContext)
}

func (s *GroupItemDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupItemDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupItemDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterGroupItemDefinition(s)
	}
}

func (s *GroupItemDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitGroupItemDefinition(s)
	}
}

func (p *FlinkSqlParser) GroupItemDefinition() (localctx IGroupItemDefinitionContext) {
	localctx = NewGroupItemDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, FlinkSqlParserRULE_groupItemDefinition)
	var _la int

	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1465)
			p.ColumnName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1466)
			p.GroupWindowFunction()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1467)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1468)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1469)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.Expression()
		}
		p.SetState(1475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(1471)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1472)
				p.Expression()
			}

			p.SetState(1477)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1478)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1480)
			p.GroupingSetsNotationName()
		}
		{
			p.SetState(1481)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1482)
			p.Expression()
		}
		p.SetState(1487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(1483)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1484)
				p.Expression()
			}

			p.SetState(1489)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1490)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1492)
			p.GroupingSets()
		}
		{
			p.SetState(1493)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1494)
			p.GroupItemDefinition()
		}
		p.SetState(1499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(1495)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1496)
				p.GroupItemDefinition()
			}

			p.SetState(1501)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1502)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1504)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetsContext is an interface to support dynamic dispatch.
type IGroupingSetsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_GROUPING() antlr.TerminalNode
	KW_SETS() antlr.TerminalNode

	// IsGroupingSetsContext differentiates from other interfaces.
	IsGroupingSetsContext()
}

type GroupingSetsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetsContext() *GroupingSetsContext {
	var p = new(GroupingSetsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupingSets
	return p
}

func InitEmptyGroupingSetsContext(p *GroupingSetsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupingSets
}

func (*GroupingSetsContext) IsGroupingSetsContext() {}

func NewGroupingSetsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetsContext {
	var p = new(GroupingSetsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_groupingSets

	return p
}

func (s *GroupingSetsContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetsContext) KW_GROUPING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_GROUPING, 0)
}

func (s *GroupingSetsContext) KW_SETS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SETS, 0)
}

func (s *GroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterGroupingSets(s)
	}
}

func (s *GroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitGroupingSets(s)
	}
}

func (p *FlinkSqlParser) GroupingSets() (localctx IGroupingSetsContext) {
	localctx = NewGroupingSetsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, FlinkSqlParserRULE_groupingSets)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1507)
		p.Match(FlinkSqlParserKW_GROUPING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1508)
		p.Match(FlinkSqlParserKW_SETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetsNotationNameContext is an interface to support dynamic dispatch.
type IGroupingSetsNotationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CUBE() antlr.TerminalNode
	KW_ROLLUP() antlr.TerminalNode

	// IsGroupingSetsNotationNameContext differentiates from other interfaces.
	IsGroupingSetsNotationNameContext()
}

type GroupingSetsNotationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetsNotationNameContext() *GroupingSetsNotationNameContext {
	var p = new(GroupingSetsNotationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupingSetsNotationName
	return p
}

func InitEmptyGroupingSetsNotationNameContext(p *GroupingSetsNotationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupingSetsNotationName
}

func (*GroupingSetsNotationNameContext) IsGroupingSetsNotationNameContext() {}

func NewGroupingSetsNotationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetsNotationNameContext {
	var p = new(GroupingSetsNotationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_groupingSetsNotationName

	return p
}

func (s *GroupingSetsNotationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetsNotationNameContext) KW_CUBE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CUBE, 0)
}

func (s *GroupingSetsNotationNameContext) KW_ROLLUP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROLLUP, 0)
}

func (s *GroupingSetsNotationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetsNotationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetsNotationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterGroupingSetsNotationName(s)
	}
}

func (s *GroupingSetsNotationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitGroupingSetsNotationName(s)
	}
}

func (p *FlinkSqlParser) GroupingSetsNotationName() (localctx IGroupingSetsNotationNameContext) {
	localctx = NewGroupingSetsNotationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, FlinkSqlParserRULE_groupingSetsNotationName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_CUBE || _la == FlinkSqlParserKW_ROLLUP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupWindowFunctionContext is an interface to support dynamic dispatch.
type IGroupWindowFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GroupWindowFunctionName() IGroupWindowFunctionNameContext
	LR_BRACKET() antlr.TerminalNode
	TimeAttrColumn() ITimeAttrColumnContext
	COMMA() antlr.TerminalNode
	TimeIntervalExpression() ITimeIntervalExpressionContext
	RR_BRACKET() antlr.TerminalNode

	// IsGroupWindowFunctionContext differentiates from other interfaces.
	IsGroupWindowFunctionContext()
}

type GroupWindowFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupWindowFunctionContext() *GroupWindowFunctionContext {
	var p = new(GroupWindowFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupWindowFunction
	return p
}

func InitEmptyGroupWindowFunctionContext(p *GroupWindowFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupWindowFunction
}

func (*GroupWindowFunctionContext) IsGroupWindowFunctionContext() {}

func NewGroupWindowFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupWindowFunctionContext {
	var p = new(GroupWindowFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_groupWindowFunction

	return p
}

func (s *GroupWindowFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupWindowFunctionContext) GroupWindowFunctionName() IGroupWindowFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupWindowFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupWindowFunctionNameContext)
}

func (s *GroupWindowFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *GroupWindowFunctionContext) TimeAttrColumn() ITimeAttrColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeAttrColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeAttrColumnContext)
}

func (s *GroupWindowFunctionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, 0)
}

func (s *GroupWindowFunctionContext) TimeIntervalExpression() ITimeIntervalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalExpressionContext)
}

func (s *GroupWindowFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *GroupWindowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupWindowFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupWindowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterGroupWindowFunction(s)
	}
}

func (s *GroupWindowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitGroupWindowFunction(s)
	}
}

func (p *FlinkSqlParser) GroupWindowFunction() (localctx IGroupWindowFunctionContext) {
	localctx = NewGroupWindowFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, FlinkSqlParserRULE_groupWindowFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1512)
		p.GroupWindowFunctionName()
	}
	{
		p.SetState(1513)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1514)
		p.TimeAttrColumn()
	}
	{
		p.SetState(1515)
		p.Match(FlinkSqlParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1516)
		p.TimeIntervalExpression()
	}
	{
		p.SetState(1517)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupWindowFunctionNameContext is an interface to support dynamic dispatch.
type IGroupWindowFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TUMBLE() antlr.TerminalNode
	KW_HOP() antlr.TerminalNode
	KW_SESSION() antlr.TerminalNode

	// IsGroupWindowFunctionNameContext differentiates from other interfaces.
	IsGroupWindowFunctionNameContext()
}

type GroupWindowFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupWindowFunctionNameContext() *GroupWindowFunctionNameContext {
	var p = new(GroupWindowFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupWindowFunctionName
	return p
}

func InitEmptyGroupWindowFunctionNameContext(p *GroupWindowFunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_groupWindowFunctionName
}

func (*GroupWindowFunctionNameContext) IsGroupWindowFunctionNameContext() {}

func NewGroupWindowFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupWindowFunctionNameContext {
	var p = new(GroupWindowFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_groupWindowFunctionName

	return p
}

func (s *GroupWindowFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupWindowFunctionNameContext) KW_TUMBLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TUMBLE, 0)
}

func (s *GroupWindowFunctionNameContext) KW_HOP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOP, 0)
}

func (s *GroupWindowFunctionNameContext) KW_SESSION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SESSION, 0)
}

func (s *GroupWindowFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupWindowFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupWindowFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterGroupWindowFunctionName(s)
	}
}

func (s *GroupWindowFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitGroupWindowFunctionName(s)
	}
}

func (p *FlinkSqlParser) GroupWindowFunctionName() (localctx IGroupWindowFunctionNameContext) {
	localctx = NewGroupWindowFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, FlinkSqlParserRULE_groupWindowFunctionName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-461)) & ^0x3f) == 0 && ((int64(1)<<(_la-461))&1108101562369) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeAttrColumnContext is an interface to support dynamic dispatch.
type ITimeAttrColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsTimeAttrColumnContext differentiates from other interfaces.
	IsTimeAttrColumnContext()
}

type TimeAttrColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeAttrColumnContext() *TimeAttrColumnContext {
	var p = new(TimeAttrColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeAttrColumn
	return p
}

func InitEmptyTimeAttrColumnContext(p *TimeAttrColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeAttrColumn
}

func (*TimeAttrColumnContext) IsTimeAttrColumnContext() {}

func NewTimeAttrColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeAttrColumnContext {
	var p = new(TimeAttrColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_timeAttrColumn

	return p
}

func (s *TimeAttrColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeAttrColumnContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *TimeAttrColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeAttrColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeAttrColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTimeAttrColumn(s)
	}
}

func (s *TimeAttrColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTimeAttrColumn(s)
	}
}

func (p *FlinkSqlParser) TimeAttrColumn() (localctx ITimeAttrColumnContext) {
	localctx = NewTimeAttrColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, FlinkSqlParserRULE_timeAttrColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_HAVING() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) KW_HAVING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HAVING, 0)
}

func (s *HavingClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *FlinkSqlParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, FlinkSqlParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1523)
		p.Match(FlinkSqlParserKW_HAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1524)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WINDOW() antlr.TerminalNode
	AllNamedWindow() []INamedWindowContext
	NamedWindow(i int) INamedWindowContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) KW_WINDOW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WINDOW, 0)
}

func (s *WindowClauseContext) AllNamedWindow() []INamedWindowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedWindowContext); ok {
			len++
		}
	}

	tst := make([]INamedWindowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedWindowContext); ok {
			tst[i] = t.(INamedWindowContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) NamedWindow(i int) INamedWindowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedWindowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedWindowContext)
}

func (s *WindowClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *WindowClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (p *FlinkSqlParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, FlinkSqlParserRULE_windowClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		p.Match(FlinkSqlParserKW_WINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1527)
		p.NamedWindow()
	}
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1528)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1529)
				p.NamedWindow()
			}

		}
		p.SetState(1534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedWindowContext is an interface to support dynamic dispatch.
type INamedWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IErrorCapturingIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IErrorCapturingIdentifierContext)

	// Getter signatures
	KW_AS() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsNamedWindowContext differentiates from other interfaces.
	IsNamedWindowContext()
}

type NamedWindowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IErrorCapturingIdentifierContext
}

func NewEmptyNamedWindowContext() *NamedWindowContext {
	var p = new(NamedWindowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_namedWindow
	return p
}

func InitEmptyNamedWindowContext(p *NamedWindowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_namedWindow
}

func (*NamedWindowContext) IsNamedWindowContext() {}

func NewNamedWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedWindowContext {
	var p = new(NamedWindowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_namedWindow

	return p
}

func (s *NamedWindowContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedWindowContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *NamedWindowContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *NamedWindowContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *NamedWindowContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *NamedWindowContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *NamedWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedWindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterNamedWindow(s)
	}
}

func (s *NamedWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitNamedWindow(s)
	}
}

func (p *FlinkSqlParser) NamedWindow() (localctx INamedWindowContext) {
	localctx = NewNamedWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, FlinkSqlParserRULE_namedWindow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1535)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*NamedWindowContext).name = _x
	}
	{
		p.SetState(1536)
		p.Match(FlinkSqlParserKW_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1537)
		p.WindowSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IErrorCapturingIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IErrorCapturingIdentifierContext)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	PartitionByClause() IPartitionByClauseContext
	OrderByClause() IOrderByClauseContext
	WindowFrame() IWindowFrameContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IErrorCapturingIdentifierContext
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *WindowSpecContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *WindowSpecContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *WindowSpecContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *WindowSpecContext) PartitionByClause() IPartitionByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByClauseContext)
}

func (s *WindowSpecContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *WindowSpecContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowSpecContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (p *FlinkSqlParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, FlinkSqlParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-439)) & ^0x3f) == 0 && ((int64(1)<<(_la-439))&-1) != 0) || ((int64((_la-503)) & ^0x3f) == 0 && ((int64(1)<<(_la-503))&1305670057999) != 0) {
		{
			p.SetState(1539)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*WindowSpecContext).name = _x
		}

	}
	{
		p.SetState(1542)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_PARTITION {
		{
			p.SetState(1543)
			p.PartitionByClause()
		}

	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_ORDER {
		{
			p.SetState(1546)
			p.OrderByClause()
		}

	}
	p.SetState(1550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_RANGE || _la == FlinkSqlParserKW_ROWS {
		{
			p.SetState(1549)
			p.WindowFrame()
		}

	}
	{
		p.SetState(1552)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchRecognizeClauseContext is an interface to support dynamic dispatch.
type IMatchRecognizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MATCH_RECOGNIZE() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	PatternVariablesDefinition() IPatternVariablesDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	PartitionByClause() IPartitionByClauseContext
	OrderByClause() IOrderByClauseContext
	MeasuresClause() IMeasuresClauseContext
	OutputMode() IOutputModeContext
	AfterMatchStrategy() IAfterMatchStrategyContext
	PatternDefinition() IPatternDefinitionContext
	Identifier() IIdentifierContext
	KW_AS() antlr.TerminalNode

	// IsMatchRecognizeClauseContext differentiates from other interfaces.
	IsMatchRecognizeClauseContext()
}

type MatchRecognizeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchRecognizeClauseContext() *MatchRecognizeClauseContext {
	var p = new(MatchRecognizeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_matchRecognizeClause
	return p
}

func InitEmptyMatchRecognizeClauseContext(p *MatchRecognizeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_matchRecognizeClause
}

func (*MatchRecognizeClauseContext) IsMatchRecognizeClauseContext() {}

func NewMatchRecognizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchRecognizeClauseContext {
	var p = new(MatchRecognizeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_matchRecognizeClause

	return p
}

func (s *MatchRecognizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchRecognizeClauseContext) KW_MATCH_RECOGNIZE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MATCH_RECOGNIZE, 0)
}

func (s *MatchRecognizeClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *MatchRecognizeClauseContext) PatternVariablesDefinition() IPatternVariablesDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternVariablesDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternVariablesDefinitionContext)
}

func (s *MatchRecognizeClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *MatchRecognizeClauseContext) PartitionByClause() IPartitionByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByClauseContext)
}

func (s *MatchRecognizeClauseContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *MatchRecognizeClauseContext) MeasuresClause() IMeasuresClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasuresClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasuresClauseContext)
}

func (s *MatchRecognizeClauseContext) OutputMode() IOutputModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutputModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutputModeContext)
}

func (s *MatchRecognizeClauseContext) AfterMatchStrategy() IAfterMatchStrategyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAfterMatchStrategyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAfterMatchStrategyContext)
}

func (s *MatchRecognizeClauseContext) PatternDefinition() IPatternDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternDefinitionContext)
}

func (s *MatchRecognizeClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MatchRecognizeClauseContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *MatchRecognizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchRecognizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchRecognizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterMatchRecognizeClause(s)
	}
}

func (s *MatchRecognizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitMatchRecognizeClause(s)
	}
}

func (p *FlinkSqlParser) MatchRecognizeClause() (localctx IMatchRecognizeClauseContext) {
	localctx = NewMatchRecognizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, FlinkSqlParserRULE_matchRecognizeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1554)
		p.Match(FlinkSqlParserKW_MATCH_RECOGNIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1555)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_PARTITION {
		{
			p.SetState(1556)
			p.PartitionByClause()
		}

	}
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_ORDER {
		{
			p.SetState(1559)
			p.OrderByClause()
		}

	}
	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_MEASURES {
		{
			p.SetState(1562)
			p.MeasuresClause()
		}

	}
	p.SetState(1566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_ALL || _la == FlinkSqlParserKW_ONE {
		{
			p.SetState(1565)
			p.OutputMode()
		}

	}
	p.SetState(1569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_AFTER {
		{
			p.SetState(1568)
			p.AfterMatchStrategy()
		}

	}
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_PATTERN {
		{
			p.SetState(1571)
			p.PatternDefinition()
		}

	}
	{
		p.SetState(1574)
		p.PatternVariablesDefinition()
	}
	{
		p.SetState(1575)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1580)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		p.SetState(1577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_AS {
			{
				p.SetState(1576)
				p.Match(FlinkSqlParserKW_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1579)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ORDER() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	AllOrderItemDefinition() []IOrderItemDefinitionContext
	OrderItemDefinition(i int) IOrderItemDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) KW_ORDER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ORDER, 0)
}

func (s *OrderByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BY, 0)
}

func (s *OrderByClauseContext) AllOrderItemDefinition() []IOrderItemDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderItemDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IOrderItemDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderItemDefinitionContext); ok {
			tst[i] = t.(IOrderItemDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderItemDefinition(i int) IOrderItemDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderItemDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderItemDefinitionContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (p *FlinkSqlParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, FlinkSqlParserRULE_orderByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1582)
		p.Match(FlinkSqlParserKW_ORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1583)
		p.Match(FlinkSqlParserKW_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1584)
		p.OrderItemDefinition()
	}
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1585)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1586)
				p.OrderItemDefinition()
			}

		}
		p.SetState(1591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderItemDefinitionContext is an interface to support dynamic dispatch.
type IOrderItemDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrder returns the nullOrder token.
	GetNullOrder() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrder sets the nullOrder token.
	SetNullOrder(antlr.Token)

	// Getter signatures
	ColumnName() IColumnNameContext
	KW_NULLS() antlr.TerminalNode
	KW_ASC() antlr.TerminalNode
	KW_DESC() antlr.TerminalNode
	KW_LAST() antlr.TerminalNode
	KW_FIRST() antlr.TerminalNode

	// IsOrderItemDefinitionContext differentiates from other interfaces.
	IsOrderItemDefinitionContext()
}

type OrderItemDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	ordering  antlr.Token
	nullOrder antlr.Token
}

func NewEmptyOrderItemDefinitionContext() *OrderItemDefinitionContext {
	var p = new(OrderItemDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_orderItemDefinition
	return p
}

func InitEmptyOrderItemDefinitionContext(p *OrderItemDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_orderItemDefinition
}

func (*OrderItemDefinitionContext) IsOrderItemDefinitionContext() {}

func NewOrderItemDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderItemDefinitionContext {
	var p = new(OrderItemDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_orderItemDefinition

	return p
}

func (s *OrderItemDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderItemDefinitionContext) GetOrdering() antlr.Token { return s.ordering }

func (s *OrderItemDefinitionContext) GetNullOrder() antlr.Token { return s.nullOrder }

func (s *OrderItemDefinitionContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *OrderItemDefinitionContext) SetNullOrder(v antlr.Token) { s.nullOrder = v }

func (s *OrderItemDefinitionContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *OrderItemDefinitionContext) KW_NULLS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULLS, 0)
}

func (s *OrderItemDefinitionContext) KW_ASC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ASC, 0)
}

func (s *OrderItemDefinitionContext) KW_DESC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DESC, 0)
}

func (s *OrderItemDefinitionContext) KW_LAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LAST, 0)
}

func (s *OrderItemDefinitionContext) KW_FIRST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FIRST, 0)
}

func (s *OrderItemDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderItemDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderItemDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterOrderItemDefinition(s)
	}
}

func (s *OrderItemDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitOrderItemDefinition(s)
	}
}

func (p *FlinkSqlParser) OrderItemDefinition() (localctx IOrderItemDefinitionContext) {
	localctx = NewOrderItemDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, FlinkSqlParserRULE_orderItemDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1592)
		p.ColumnName()
	}
	p.SetState(1594)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1593)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderItemDefinitionContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_ASC || _la == FlinkSqlParserKW_DESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderItemDefinitionContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1598)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1596)
			p.Match(FlinkSqlParserKW_NULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1597)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderItemDefinitionContext).nullOrder = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_FIRST || _la == FlinkSqlParserKW_LAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderItemDefinitionContext).nullOrder = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit rule contexts.
	GetLimit() IExpressionContext

	// SetLimit sets the limit rule contexts.
	SetLimit(IExpressionContext)

	// Getter signatures
	KW_LIMIT() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  IExpressionContext
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetLimit() IExpressionContext { return s.limit }

func (s *LimitClauseContext) SetLimit(v IExpressionContext) { s.limit = v }

func (s *LimitClauseContext) KW_LIMIT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LIMIT, 0)
}

func (s *LimitClauseContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALL, 0)
}

func (s *LimitClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *FlinkSqlParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, FlinkSqlParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1600)
		p.Match(FlinkSqlParserKW_LIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_ALL:
		{
			p.SetState(1601)
			p.Match(FlinkSqlParserKW_ALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserKW_ABS, FlinkSqlParserKW_ARRAY, FlinkSqlParserKW_AVG, FlinkSqlParserKW_CARDINALITY, FlinkSqlParserKW_CASE, FlinkSqlParserKW_CAST, FlinkSqlParserKW_CEIL, FlinkSqlParserKW_CEILING, FlinkSqlParserKW_COALESCE, FlinkSqlParserKW_COLLECT, FlinkSqlParserKW_COUNT, FlinkSqlParserKW_CUME_DIST, FlinkSqlParserKW_CURRENT_DATE, FlinkSqlParserKW_CURRENT_TIME, FlinkSqlParserKW_CURRENT_TIMESTAMP, FlinkSqlParserKW_DATE, FlinkSqlParserKW_DAY, FlinkSqlParserKW_DAYOFWEEK, FlinkSqlParserKW_DAYOFYEAR, FlinkSqlParserKW_DENSE_RANK, FlinkSqlParserKW_ELEMENT, FlinkSqlParserKW_EXISTS, FlinkSqlParserKW_EXP, FlinkSqlParserKW_EXTRACT, FlinkSqlParserKW_FALSE, FlinkSqlParserKW_FIRST_VALUE, FlinkSqlParserKW_FLOOR, FlinkSqlParserKW_GROUPING, FlinkSqlParserKW_HOUR, FlinkSqlParserKW_IF, FlinkSqlParserKW_INTERVAL, FlinkSqlParserKW_JSON_ARRAY, FlinkSqlParserKW_JSON_ARRAYAGG, FlinkSqlParserKW_JSON_EXISTS, FlinkSqlParserKW_JSON_OBJECT, FlinkSqlParserKW_JSON_OBJECTAGG, FlinkSqlParserKW_JSON_QUERY, FlinkSqlParserKW_JSON_VALUE, FlinkSqlParserKW_LAG, FlinkSqlParserKW_LAST_VALUE, FlinkSqlParserKW_LEAD, FlinkSqlParserKW_LEFT, FlinkSqlParserKW_LN, FlinkSqlParserKW_LOCALTIME, FlinkSqlParserKW_LOCALTIMESTAMP, FlinkSqlParserKW_LOWER, FlinkSqlParserKW_MAX, FlinkSqlParserKW_MIN, FlinkSqlParserKW_MINUTE, FlinkSqlParserKW_MOD, FlinkSqlParserKW_MONTH, FlinkSqlParserKW_NOT, FlinkSqlParserKW_NTILE, FlinkSqlParserKW_NULL, FlinkSqlParserKW_NULLIF, FlinkSqlParserKW_OVERLAY, FlinkSqlParserKW_PERCENT_RANK, FlinkSqlParserKW_POSITION, FlinkSqlParserKW_POWER, FlinkSqlParserKW_RANK, FlinkSqlParserKW_RIGHT, FlinkSqlParserKW_ROW, FlinkSqlParserKW_ROWS, FlinkSqlParserKW_ROW_NUMBER, FlinkSqlParserKW_SECOND, FlinkSqlParserKW_STDDEV_POP, FlinkSqlParserKW_STDDEV_SAMP, FlinkSqlParserKW_SUBSTRING, FlinkSqlParserKW_SUM, FlinkSqlParserKW_TIME, FlinkSqlParserKW_TIMESTAMP, FlinkSqlParserKW_TIMESTAMP_DIFF, FlinkSqlParserKW_TRIM, FlinkSqlParserKW_TRUE, FlinkSqlParserKW_TRUNCATE, FlinkSqlParserKW_TRY_CAST, FlinkSqlParserKW_UPPER, FlinkSqlParserKW_VAR_POP, FlinkSqlParserKW_VAR_SAMP, FlinkSqlParserKW_YEAR, FlinkSqlParserKW_ADD, FlinkSqlParserKW_AFTER, FlinkSqlParserKW_ASC, FlinkSqlParserKW_CASCADE, FlinkSqlParserKW_CATALOG, FlinkSqlParserKW_CENTURY, FlinkSqlParserKW_CONFIG, FlinkSqlParserKW_CONSTRAINTS, FlinkSqlParserKW_CUMULATE, FlinkSqlParserKW_DATA, FlinkSqlParserKW_DATABASE, FlinkSqlParserKW_DAYS, FlinkSqlParserKW_DECADE, FlinkSqlParserKW_DESC, FlinkSqlParserKW_DESCRIPTOR, FlinkSqlParserKW_DIV, FlinkSqlParserKW_ENGINE, FlinkSqlParserKW_EPOCH, FlinkSqlParserKW_EXCLUDING, FlinkSqlParserKW_FILE, FlinkSqlParserKW_FIRST, FlinkSqlParserKW_GENERATED, FlinkSqlParserKW_HOP, FlinkSqlParserKW_HOURS, FlinkSqlParserKW_IGNORE, FlinkSqlParserKW_INCLUDING, FlinkSqlParserKW_JAR, FlinkSqlParserKW_JARS, FlinkSqlParserKW_JAVA, FlinkSqlParserKW_KEY, FlinkSqlParserKW_LAST, FlinkSqlParserKW_LOAD, FlinkSqlParserKW_MAP, FlinkSqlParserKW_MICROSECOND, FlinkSqlParserKW_MILLENNIUM, FlinkSqlParserKW_MILLISECOND, FlinkSqlParserKW_MINUTES, FlinkSqlParserKW_MONTHS, FlinkSqlParserKW_NANOSECOND, FlinkSqlParserKW_NULLS, FlinkSqlParserKW_OPTIONS, FlinkSqlParserKW_PAST, FlinkSqlParserKW_PLAN, FlinkSqlParserKW_PRECEDING, FlinkSqlParserKW_PYTHON, FlinkSqlParserKW_PYTHON_ARCHIVES, FlinkSqlParserKW_PYTHON_DEPENDENCIES, FlinkSqlParserKW_PYTHON_FILES, FlinkSqlParserKW_PYTHON_JAR, FlinkSqlParserKW_PYTHON_PARAMETER, FlinkSqlParserKW_PYTHON_REQUIREMENTS, FlinkSqlParserKW_QUARTER, FlinkSqlParserKW_REMOVE, FlinkSqlParserKW_RESTRICT, FlinkSqlParserKW_SECONDS, FlinkSqlParserKW_SESSION, FlinkSqlParserKW_SETS, FlinkSqlParserKW_SIZE, FlinkSqlParserKW_SLIDE, FlinkSqlParserKW_STEP, FlinkSqlParserKW_TEMPORARY, FlinkSqlParserKW_TIMECOL, FlinkSqlParserKW_TUMBLE, FlinkSqlParserKW_UNLOAD, FlinkSqlParserKW_VIEW, FlinkSqlParserKW_WEEK, FlinkSqlParserKW_YEARS, FlinkSqlParserKW_ZONE, FlinkSqlParserBIT_NOT_OP, FlinkSqlParserLR_BRACKET, FlinkSqlParserASTERISK_SIGN, FlinkSqlParserHYPHEN_SIGN, FlinkSqlParserADD_SIGN, FlinkSqlParserSTRING_LITERAL, FlinkSqlParserDIG_LITERAL, FlinkSqlParserREAL_LITERAL, FlinkSqlParserBIT_STRING, FlinkSqlParserID_LITERAL:
		{
			p.SetState(1602)

			var _x = p.Expression()

			localctx.(*LimitClauseContext).limit = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionByClauseContext is an interface to support dynamic dispatch.
type IPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PARTITION() antlr.TerminalNode
	KW_BY() antlr.TerminalNode
	AllColumnName() []IColumnNameContext
	ColumnName(i int) IColumnNameContext
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionByClauseContext differentiates from other interfaces.
	IsPartitionByClauseContext()
}

type PartitionByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByClauseContext() *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_partitionByClause
	return p
}

func InitEmptyPartitionByClauseContext(p *PartitionByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_partitionByClause
}

func (*PartitionByClauseContext) IsPartitionByClauseContext() {}

func NewPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_partitionByClause

	return p
}

func (s *PartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByClauseContext) KW_PARTITION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PARTITION, 0)
}

func (s *PartitionByClauseContext) KW_BY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BY, 0)
}

func (s *PartitionByClauseContext) AllColumnName() []IColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameContext); ok {
			tst[i] = t.(IColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *PartitionByClauseContext) ColumnName(i int) IColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *PartitionByClauseContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionByClauseContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PartitionByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *PartitionByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *PartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPartitionByClause(s)
	}
}

func (p *FlinkSqlParser) PartitionByClause() (localctx IPartitionByClauseContext) {
	localctx = NewPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, FlinkSqlParserRULE_partitionByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1605)
		p.Match(FlinkSqlParserKW_PARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1606)
		p.Match(FlinkSqlParserKW_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1607)
			p.ColumnName()
		}

	case 2:
		{
			p.SetState(1608)
			p.primaryExpression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(1611)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1612)
				p.ColumnName()
			}

		case 2:
			{
				p.SetState(1613)
				p.primaryExpression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantifiersContext is an interface to support dynamic dispatch.
type IQuantifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK_SIGN() antlr.TerminalNode
	ADD_SIGN() antlr.TerminalNode
	QUESTION_MARK_SIGN() antlr.TerminalNode
	LB_BRACKET() antlr.TerminalNode
	AllDIG_LITERAL() []antlr.TerminalNode
	DIG_LITERAL(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RB_BRACKET() antlr.TerminalNode

	// IsQuantifiersContext differentiates from other interfaces.
	IsQuantifiersContext()
}

type QuantifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiersContext() *QuantifiersContext {
	var p = new(QuantifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_quantifiers
	return p
}

func InitEmptyQuantifiersContext(p *QuantifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_quantifiers
}

func (*QuantifiersContext) IsQuantifiersContext() {}

func NewQuantifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiersContext {
	var p = new(QuantifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_quantifiers

	return p
}

func (s *QuantifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiersContext) ASTERISK_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserASTERISK_SIGN, 0)
}

func (s *QuantifiersContext) ADD_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserADD_SIGN, 0)
}

func (s *QuantifiersContext) QUESTION_MARK_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserQUESTION_MARK_SIGN, 0)
}

func (s *QuantifiersContext) LB_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLB_BRACKET, 0)
}

func (s *QuantifiersContext) AllDIG_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserDIG_LITERAL)
}

func (s *QuantifiersContext) DIG_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDIG_LITERAL, i)
}

func (s *QuantifiersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, 0)
}

func (s *QuantifiersContext) RB_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRB_BRACKET, 0)
}

func (s *QuantifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterQuantifiers(s)
	}
}

func (s *QuantifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitQuantifiers(s)
	}
}

func (p *FlinkSqlParser) Quantifiers() (localctx IQuantifiersContext) {
	localctx = NewQuantifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, FlinkSqlParserRULE_quantifiers)
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1621)
			p.Match(FlinkSqlParserASTERISK_SIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1622)
			p.Match(FlinkSqlParserADD_SIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1623)
			p.Match(FlinkSqlParserQUESTION_MARK_SIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1624)
			p.Match(FlinkSqlParserLB_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1625)
			p.Match(FlinkSqlParserDIG_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1626)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1627)
			p.Match(FlinkSqlParserDIG_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1628)
			p.Match(FlinkSqlParserRB_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1629)
			p.Match(FlinkSqlParserLB_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1630)
			p.Match(FlinkSqlParserDIG_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1631)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.Match(FlinkSqlParserRB_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1633)
			p.Match(FlinkSqlParserLB_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1634)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.Match(FlinkSqlParserDIG_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1636)
			p.Match(FlinkSqlParserRB_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMeasuresClauseContext is an interface to support dynamic dispatch.
type IMeasuresClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MEASURES() antlr.TerminalNode
	AllProjectItemDefinition() []IProjectItemDefinitionContext
	ProjectItemDefinition(i int) IProjectItemDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMeasuresClauseContext differentiates from other interfaces.
	IsMeasuresClauseContext()
}

type MeasuresClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeasuresClauseContext() *MeasuresClauseContext {
	var p = new(MeasuresClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_measuresClause
	return p
}

func InitEmptyMeasuresClauseContext(p *MeasuresClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_measuresClause
}

func (*MeasuresClauseContext) IsMeasuresClauseContext() {}

func NewMeasuresClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeasuresClauseContext {
	var p = new(MeasuresClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_measuresClause

	return p
}

func (s *MeasuresClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MeasuresClauseContext) KW_MEASURES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MEASURES, 0)
}

func (s *MeasuresClauseContext) AllProjectItemDefinition() []IProjectItemDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProjectItemDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IProjectItemDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProjectItemDefinitionContext); ok {
			tst[i] = t.(IProjectItemDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *MeasuresClauseContext) ProjectItemDefinition(i int) IProjectItemDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemDefinitionContext)
}

func (s *MeasuresClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *MeasuresClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *MeasuresClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeasuresClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeasuresClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterMeasuresClause(s)
	}
}

func (s *MeasuresClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitMeasuresClause(s)
	}
}

func (p *FlinkSqlParser) MeasuresClause() (localctx IMeasuresClauseContext) {
	localctx = NewMeasuresClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, FlinkSqlParserRULE_measuresClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1639)
		p.Match(FlinkSqlParserKW_MEASURES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1640)
		p.ProjectItemDefinition()
	}
	p.SetState(1645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(1641)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1642)
			p.ProjectItemDefinition()
		}

		p.SetState(1647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternDefinitionContext is an interface to support dynamic dispatch.
type IPatternDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PATTERN() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllPatternVariable() []IPatternVariableContext
	PatternVariable(i int) IPatternVariableContext
	WithinClause() IWithinClauseContext

	// IsPatternDefinitionContext differentiates from other interfaces.
	IsPatternDefinitionContext()
}

type PatternDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternDefinitionContext() *PatternDefinitionContext {
	var p = new(PatternDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_patternDefinition
	return p
}

func InitEmptyPatternDefinitionContext(p *PatternDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_patternDefinition
}

func (*PatternDefinitionContext) IsPatternDefinitionContext() {}

func NewPatternDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternDefinitionContext {
	var p = new(PatternDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_patternDefinition

	return p
}

func (s *PatternDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternDefinitionContext) KW_PATTERN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PATTERN, 0)
}

func (s *PatternDefinitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *PatternDefinitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *PatternDefinitionContext) AllPatternVariable() []IPatternVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternVariableContext); ok {
			len++
		}
	}

	tst := make([]IPatternVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternVariableContext); ok {
			tst[i] = t.(IPatternVariableContext)
			i++
		}
	}

	return tst
}

func (s *PatternDefinitionContext) PatternVariable(i int) IPatternVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternVariableContext)
}

func (s *PatternDefinitionContext) WithinClause() IWithinClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithinClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithinClauseContext)
}

func (s *PatternDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPatternDefinition(s)
	}
}

func (s *PatternDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPatternDefinition(s)
	}
}

func (p *FlinkSqlParser) PatternDefinition() (localctx IPatternDefinitionContext) {
	localctx = NewPatternDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, FlinkSqlParserRULE_patternDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1648)
		p.Match(FlinkSqlParserKW_PATTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1649)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == FlinkSqlParserDIG_LITERAL || _la == FlinkSqlParserID_LITERAL {
		{
			p.SetState(1650)
			p.PatternVariable()
		}

		p.SetState(1653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1655)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_WITHIN {
		{
			p.SetState(1656)
			p.WithinClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternVariableContext is an interface to support dynamic dispatch.
type IPatternVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnquotedIdentifier() IUnquotedIdentifierContext
	Quantifiers() IQuantifiersContext

	// IsPatternVariableContext differentiates from other interfaces.
	IsPatternVariableContext()
}

type PatternVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternVariableContext() *PatternVariableContext {
	var p = new(PatternVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_patternVariable
	return p
}

func InitEmptyPatternVariableContext(p *PatternVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_patternVariable
}

func (*PatternVariableContext) IsPatternVariableContext() {}

func NewPatternVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternVariableContext {
	var p = new(PatternVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_patternVariable

	return p
}

func (s *PatternVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternVariableContext) UnquotedIdentifier() IUnquotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnquotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnquotedIdentifierContext)
}

func (s *PatternVariableContext) Quantifiers() IQuantifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiersContext)
}

func (s *PatternVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPatternVariable(s)
	}
}

func (s *PatternVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPatternVariable(s)
	}
}

func (p *FlinkSqlParser) PatternVariable() (localctx IPatternVariableContext) {
	localctx = NewPatternVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, FlinkSqlParserRULE_patternVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		p.UnquotedIdentifier()
	}
	p.SetState(1661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-520)) & ^0x3f) == 0 && ((int64(1)<<(_la-520))&135681) != 0 {
		{
			p.SetState(1660)
			p.Quantifiers()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutputModeContext is an interface to support dynamic dispatch.
type IOutputModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALL() antlr.TerminalNode
	KW_ROWS() antlr.TerminalNode
	KW_PER() antlr.TerminalNode
	KW_MATCH() antlr.TerminalNode
	KW_ONE() antlr.TerminalNode
	KW_ROW() antlr.TerminalNode

	// IsOutputModeContext differentiates from other interfaces.
	IsOutputModeContext()
}

type OutputModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputModeContext() *OutputModeContext {
	var p = new(OutputModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_outputMode
	return p
}

func InitEmptyOutputModeContext(p *OutputModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_outputMode
}

func (*OutputModeContext) IsOutputModeContext() {}

func NewOutputModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputModeContext {
	var p = new(OutputModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_outputMode

	return p
}

func (s *OutputModeContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputModeContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALL, 0)
}

func (s *OutputModeContext) KW_ROWS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROWS, 0)
}

func (s *OutputModeContext) KW_PER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PER, 0)
}

func (s *OutputModeContext) KW_MATCH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MATCH, 0)
}

func (s *OutputModeContext) KW_ONE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ONE, 0)
}

func (s *OutputModeContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROW, 0)
}

func (s *OutputModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterOutputMode(s)
	}
}

func (s *OutputModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitOutputMode(s)
	}
}

func (p *FlinkSqlParser) OutputMode() (localctx IOutputModeContext) {
	localctx = NewOutputModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, FlinkSqlParserRULE_outputMode)
	p.SetState(1671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_ALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1663)
			p.Match(FlinkSqlParserKW_ALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1664)
			p.Match(FlinkSqlParserKW_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1665)
			p.Match(FlinkSqlParserKW_PER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1666)
			p.Match(FlinkSqlParserKW_MATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserKW_ONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1667)
			p.Match(FlinkSqlParserKW_ONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1668)
			p.Match(FlinkSqlParserKW_ROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1669)
			p.Match(FlinkSqlParserKW_PER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1670)
			p.Match(FlinkSqlParserKW_MATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAfterMatchStrategyContext is an interface to support dynamic dispatch.
type IAfterMatchStrategyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_AFTER() antlr.TerminalNode
	KW_MATCH() antlr.TerminalNode
	KW_SKIP() antlr.TerminalNode
	KW_PAST() antlr.TerminalNode
	KW_LAST() antlr.TerminalNode
	KW_ROW() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	KW_NEXT() antlr.TerminalNode
	UnquotedIdentifier() IUnquotedIdentifierContext
	KW_FIRST() antlr.TerminalNode

	// IsAfterMatchStrategyContext differentiates from other interfaces.
	IsAfterMatchStrategyContext()
}

type AfterMatchStrategyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAfterMatchStrategyContext() *AfterMatchStrategyContext {
	var p = new(AfterMatchStrategyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_afterMatchStrategy
	return p
}

func InitEmptyAfterMatchStrategyContext(p *AfterMatchStrategyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_afterMatchStrategy
}

func (*AfterMatchStrategyContext) IsAfterMatchStrategyContext() {}

func NewAfterMatchStrategyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AfterMatchStrategyContext {
	var p = new(AfterMatchStrategyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_afterMatchStrategy

	return p
}

func (s *AfterMatchStrategyContext) GetParser() antlr.Parser { return s.parser }

func (s *AfterMatchStrategyContext) KW_AFTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AFTER, 0)
}

func (s *AfterMatchStrategyContext) KW_MATCH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MATCH, 0)
}

func (s *AfterMatchStrategyContext) KW_SKIP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SKIP, 0)
}

func (s *AfterMatchStrategyContext) KW_PAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PAST, 0)
}

func (s *AfterMatchStrategyContext) KW_LAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LAST, 0)
}

func (s *AfterMatchStrategyContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROW, 0)
}

func (s *AfterMatchStrategyContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TO, 0)
}

func (s *AfterMatchStrategyContext) KW_NEXT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NEXT, 0)
}

func (s *AfterMatchStrategyContext) UnquotedIdentifier() IUnquotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnquotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnquotedIdentifierContext)
}

func (s *AfterMatchStrategyContext) KW_FIRST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FIRST, 0)
}

func (s *AfterMatchStrategyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AfterMatchStrategyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AfterMatchStrategyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterAfterMatchStrategy(s)
	}
}

func (s *AfterMatchStrategyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitAfterMatchStrategy(s)
	}
}

func (p *FlinkSqlParser) AfterMatchStrategy() (localctx IAfterMatchStrategyContext) {
	localctx = NewAfterMatchStrategyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, FlinkSqlParserRULE_afterMatchStrategy)
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1673)
			p.Match(FlinkSqlParserKW_AFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1674)
			p.Match(FlinkSqlParserKW_MATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1675)
			p.Match(FlinkSqlParserKW_SKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.Match(FlinkSqlParserKW_PAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1677)
			p.Match(FlinkSqlParserKW_LAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1678)
			p.Match(FlinkSqlParserKW_ROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1679)
			p.Match(FlinkSqlParserKW_AFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1680)
			p.Match(FlinkSqlParserKW_MATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1681)
			p.Match(FlinkSqlParserKW_SKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1682)
			p.Match(FlinkSqlParserKW_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1683)
			p.Match(FlinkSqlParserKW_NEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1684)
			p.Match(FlinkSqlParserKW_ROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1685)
			p.Match(FlinkSqlParserKW_AFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1686)
			p.Match(FlinkSqlParserKW_MATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Match(FlinkSqlParserKW_SKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.Match(FlinkSqlParserKW_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1689)
			p.Match(FlinkSqlParserKW_LAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1690)
			p.UnquotedIdentifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1691)
			p.Match(FlinkSqlParserKW_AFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1692)
			p.Match(FlinkSqlParserKW_MATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1693)
			p.Match(FlinkSqlParserKW_SKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1694)
			p.Match(FlinkSqlParserKW_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Match(FlinkSqlParserKW_FIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1696)
			p.UnquotedIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternVariablesDefinitionContext is an interface to support dynamic dispatch.
type IPatternVariablesDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DEFINE() antlr.TerminalNode
	AllProjectItemDefinition() []IProjectItemDefinitionContext
	ProjectItemDefinition(i int) IProjectItemDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPatternVariablesDefinitionContext differentiates from other interfaces.
	IsPatternVariablesDefinitionContext()
}

type PatternVariablesDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternVariablesDefinitionContext() *PatternVariablesDefinitionContext {
	var p = new(PatternVariablesDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_patternVariablesDefinition
	return p
}

func InitEmptyPatternVariablesDefinitionContext(p *PatternVariablesDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_patternVariablesDefinition
}

func (*PatternVariablesDefinitionContext) IsPatternVariablesDefinitionContext() {}

func NewPatternVariablesDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternVariablesDefinitionContext {
	var p = new(PatternVariablesDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_patternVariablesDefinition

	return p
}

func (s *PatternVariablesDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternVariablesDefinitionContext) KW_DEFINE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DEFINE, 0)
}

func (s *PatternVariablesDefinitionContext) AllProjectItemDefinition() []IProjectItemDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProjectItemDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IProjectItemDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProjectItemDefinitionContext); ok {
			tst[i] = t.(IProjectItemDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PatternVariablesDefinitionContext) ProjectItemDefinition(i int) IProjectItemDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemDefinitionContext)
}

func (s *PatternVariablesDefinitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *PatternVariablesDefinitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *PatternVariablesDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternVariablesDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternVariablesDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPatternVariablesDefinition(s)
	}
}

func (s *PatternVariablesDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPatternVariablesDefinition(s)
	}
}

func (p *FlinkSqlParser) PatternVariablesDefinition() (localctx IPatternVariablesDefinitionContext) {
	localctx = NewPatternVariablesDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, FlinkSqlParserRULE_patternVariablesDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1699)
		p.Match(FlinkSqlParserKW_DEFINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1700)
		p.ProjectItemDefinition()
	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(1701)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1702)
			p.ProjectItemDefinition()
		}

		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RANGE() antlr.TerminalNode
	KW_BETWEEN() antlr.TerminalNode
	TimeIntervalExpression() ITimeIntervalExpressionContext
	FrameBound() IFrameBoundContext
	KW_ROWS() antlr.TerminalNode
	DIG_LITERAL() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) KW_RANGE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RANGE, 0)
}

func (s *WindowFrameContext) KW_BETWEEN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BETWEEN, 0)
}

func (s *WindowFrameContext) TimeIntervalExpression() ITimeIntervalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalExpressionContext)
}

func (s *WindowFrameContext) FrameBound() IFrameBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) KW_ROWS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROWS, 0)
}

func (s *WindowFrameContext) DIG_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDIG_LITERAL, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *FlinkSqlParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, FlinkSqlParserRULE_windowFrame)
	p.SetState(1717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_RANGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1708)
			p.Match(FlinkSqlParserKW_RANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1709)
			p.Match(FlinkSqlParserKW_BETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1710)
			p.TimeIntervalExpression()
		}
		{
			p.SetState(1711)
			p.FrameBound()
		}

	case FlinkSqlParserKW_ROWS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1713)
			p.Match(FlinkSqlParserKW_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1714)
			p.Match(FlinkSqlParserKW_BETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1715)
			p.Match(FlinkSqlParserDIG_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1716)
			p.FrameBound()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PRECEDING() antlr.TerminalNode
	KW_AND() antlr.TerminalNode
	KW_CURRENT() antlr.TerminalNode
	KW_ROW() antlr.TerminalNode

	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) KW_PRECEDING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PRECEDING, 0)
}

func (s *FrameBoundContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AND, 0)
}

func (s *FrameBoundContext) KW_CURRENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT, 0)
}

func (s *FrameBoundContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROW, 0)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFrameBound(s)
	}
}

func (s *FrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFrameBound(s)
	}
}

func (p *FlinkSqlParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, FlinkSqlParserRULE_frameBound)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1719)
		p.Match(FlinkSqlParserKW_PRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1720)
		p.Match(FlinkSqlParserKW_AND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1721)
		p.Match(FlinkSqlParserKW_CURRENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1722)
		p.Match(FlinkSqlParserKW_ROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithinClauseContext is an interface to support dynamic dispatch.
type IWithinClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WITHIN() antlr.TerminalNode
	TimeIntervalExpression() ITimeIntervalExpressionContext

	// IsWithinClauseContext differentiates from other interfaces.
	IsWithinClauseContext()
}

type WithinClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithinClauseContext() *WithinClauseContext {
	var p = new(WithinClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withinClause
	return p
}

func InitEmptyWithinClauseContext(p *WithinClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withinClause
}

func (*WithinClauseContext) IsWithinClauseContext() {}

func NewWithinClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithinClauseContext {
	var p = new(WithinClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_withinClause

	return p
}

func (s *WithinClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithinClauseContext) KW_WITHIN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WITHIN, 0)
}

func (s *WithinClauseContext) TimeIntervalExpression() ITimeIntervalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalExpressionContext)
}

func (s *WithinClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithinClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithinClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWithinClause(s)
	}
}

func (s *WithinClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWithinClause(s)
	}
}

func (p *FlinkSqlParser) WithinClause() (localctx IWithinClauseContext) {
	localctx = NewWithinClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, FlinkSqlParserRULE_withinClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1724)
		p.Match(FlinkSqlParserKW_WITHIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1725)
		p.TimeIntervalExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *FlinkSqlParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, FlinkSqlParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1727)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type ExistsContext struct {
	BooleanExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) KW_EXISTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXISTS, 0)
}

func (s *ExistsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *ExistsContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *ExistsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitExists(s)
	}
}

type LogicalNestedContext struct {
	BooleanExpressionContext
	kind antlr.Token
}

func NewLogicalNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNestedContext {
	var p = new(LogicalNestedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNestedContext) GetKind() antlr.Token { return s.kind }

func (s *LogicalNestedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *LogicalNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNestedContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNestedContext) KW_IS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IS, 0)
}

func (s *LogicalNestedContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TRUE, 0)
}

func (s *LogicalNestedContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FALSE, 0)
}

func (s *LogicalNestedContext) KW_UNKNOWN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UNKNOWN, 0)
}

func (s *LogicalNestedContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULL, 0)
}

func (s *LogicalNestedContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *LogicalNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLogicalNested(s)
	}
}

func (s *LogicalNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLogicalNested(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AND, 0)
}

func (s *LogicalBinaryContext) KW_OR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *FlinkSqlParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *FlinkSqlParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 260
	p.EnterRecursionRule(localctx, 260, FlinkSqlParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1730)
			p.Match(FlinkSqlParserKW_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1731)
			p.booleanExpression(6)
		}

	case 2:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1732)
			p.Match(FlinkSqlParserKW_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1734)
			p.queryStatement(0)
		}
		{
			p.SetState(1735)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1737)
			p.valueExpression(0)
		}
		p.SetState(1739)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1738)
				p.Predicate()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1755)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_booleanExpression)
				p.SetState(1743)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1744)

					var _m = p.Match(FlinkSqlParserKW_AND)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1745)

					var _x = p.booleanExpression(4)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_booleanExpression)
				p.SetState(1746)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1747)

					var _m = p.Match(FlinkSqlParserKW_OR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1748)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 3:
				localctx = NewLogicalNestedContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_booleanExpression)
				p.SetState(1749)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1750)
					p.Match(FlinkSqlParserKW_IS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1752)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == FlinkSqlParserKW_NOT {
					{
						p.SetState(1751)
						p.Match(FlinkSqlParserKW_NOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1754)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalNestedContext).kind = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == FlinkSqlParserKW_FALSE || _la == FlinkSqlParserKW_NULL || _la == FlinkSqlParserKW_TRUE || _la == FlinkSqlParserKW_UNKNOWN) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalNestedContext).kind = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetLower returns the lower rule contexts.
	GetLower() IValueExpressionContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IValueExpressionContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IValueExpressionContext

	// GetRight returns the right rule contexts.
	GetRight() IValueExpressionContext

	// SetLower sets the lower rule contexts.
	SetLower(IValueExpressionContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IValueExpressionContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IValueExpressionContext)

	// SetRight sets the right rule contexts.
	SetRight(IValueExpressionContext)

	// Getter signatures
	KW_AND() antlr.TerminalNode
	KW_BETWEEN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	KW_NOT() antlr.TerminalNode
	KW_ASYMMETRIC() antlr.TerminalNode
	KW_SYMMETRIC() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RR_BRACKET() antlr.TerminalNode
	KW_IN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	KW_EXISTS() antlr.TerminalNode
	KW_RLIKE() antlr.TerminalNode
	LikePredicate() ILikePredicateContext
	KW_IS() antlr.TerminalNode
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode
	KW_UNKNOWN() antlr.TerminalNode
	KW_NULL() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	KW_DISTINCT() antlr.TerminalNode
	KW_TO() antlr.TerminalNode
	KW_SIMILAR() antlr.TerminalNode
	KW_ESCAPE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	KW_JSON() antlr.TerminalNode
	KW_VALUE() antlr.TerminalNode
	KW_ARRAY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	kind    antlr.Token
	lower   IValueExpressionContext
	upper   IValueExpressionContext
	pattern IValueExpressionContext
	right   IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetKind() antlr.Token { return s.kind }

func (s *PredicateContext) SetKind(v antlr.Token) { s.kind = v }

func (s *PredicateContext) GetLower() IValueExpressionContext { return s.lower }

func (s *PredicateContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *PredicateContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *PredicateContext) GetRight() IValueExpressionContext { return s.right }

func (s *PredicateContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *PredicateContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *PredicateContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *PredicateContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *PredicateContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AND, 0)
}

func (s *PredicateContext) KW_BETWEEN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BETWEEN, 0)
}

func (s *PredicateContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *PredicateContext) KW_ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ASYMMETRIC, 0)
}

func (s *PredicateContext) KW_SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SYMMETRIC, 0)
}

func (s *PredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *PredicateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *PredicateContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IN, 0)
}

func (s *PredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *PredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *PredicateContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *PredicateContext) KW_EXISTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXISTS, 0)
}

func (s *PredicateContext) KW_RLIKE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RLIKE, 0)
}

func (s *PredicateContext) LikePredicate() ILikePredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikePredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikePredicateContext)
}

func (s *PredicateContext) KW_IS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IS, 0)
}

func (s *PredicateContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TRUE, 0)
}

func (s *PredicateContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FALSE, 0)
}

func (s *PredicateContext) KW_UNKNOWN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UNKNOWN, 0)
}

func (s *PredicateContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULL, 0)
}

func (s *PredicateContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FROM, 0)
}

func (s *PredicateContext) KW_DISTINCT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DISTINCT, 0)
}

func (s *PredicateContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TO, 0)
}

func (s *PredicateContext) KW_SIMILAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SIMILAR, 0)
}

func (s *PredicateContext) KW_ESCAPE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ESCAPE, 0)
}

func (s *PredicateContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PredicateContext) KW_JSON() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON, 0)
}

func (s *PredicateContext) KW_VALUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VALUE, 0)
}

func (s *PredicateContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ARRAY, 0)
}

func (s *PredicateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *FlinkSqlParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, FlinkSqlParserRULE_predicate)
	var _la int

	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1760)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1763)

			var _m = p.Match(FlinkSqlParserKW_BETWEEN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_ASYMMETRIC || _la == FlinkSqlParserKW_SYMMETRIC {
			{
				p.SetState(1764)
				_la = p.GetTokenStream().LA(1)

				if !(_la == FlinkSqlParserKW_ASYMMETRIC || _la == FlinkSqlParserKW_SYMMETRIC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1767)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).lower = _x
		}
		{
			p.SetState(1768)
			p.Match(FlinkSqlParserKW_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1769)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).upper = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1771)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1774)

			var _m = p.Match(FlinkSqlParserKW_IN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1775)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1776)
			p.Expression()
		}
		p.SetState(1781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlinkSqlParserCOMMA {
			{
				p.SetState(1777)
				p.Match(FlinkSqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1778)
				p.Expression()
			}

			p.SetState(1783)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1784)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1787)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1786)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1789)

			var _m = p.Match(FlinkSqlParserKW_IN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1790)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1791)
			p.queryStatement(0)
		}
		{
			p.SetState(1792)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1794)

			var _m = p.Match(FlinkSqlParserKW_EXISTS)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1795)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1796)
			p.queryStatement(0)
		}
		{
			p.SetState(1797)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1799)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1802)

			var _m = p.Match(FlinkSqlParserKW_RLIKE)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1803)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1804)
			p.LikePredicate()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1805)
			p.Match(FlinkSqlParserKW_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1806)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1809)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_FALSE || _la == FlinkSqlParserKW_NULL || _la == FlinkSqlParserKW_TRUE || _la == FlinkSqlParserKW_UNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1810)
			p.Match(FlinkSqlParserKW_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1811)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1814)

			var _m = p.Match(FlinkSqlParserKW_DISTINCT)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1815)
			p.Match(FlinkSqlParserKW_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1816)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).right = _x
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(1818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1817)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1820)

			var _m = p.Match(FlinkSqlParserKW_SIMILAR)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1821)
			p.Match(FlinkSqlParserKW_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1822)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).right = _x
		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1823)
				p.Match(FlinkSqlParserKW_ESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1824)
				p.StringLiteral()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1827)
			p.Match(FlinkSqlParserKW_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1828)
			p.Match(FlinkSqlParserKW_JSON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1832)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1829)
				p.Match(FlinkSqlParserKW_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1830)
				p.Match(FlinkSqlParserKW_ARRAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1831)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikePredicateContext is an interface to support dynamic dispatch.
type ILikePredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// GetQuantifier returns the quantifier token.
	GetQuantifier() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// SetQuantifier sets the quantifier token.
	SetQuantifier(antlr.Token)

	// GetPattern returns the pattern rule contexts.
	GetPattern() IValueExpressionContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IValueExpressionContext)

	// Getter signatures
	KW_LIKE() antlr.TerminalNode
	KW_ANY() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	KW_NOT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	KW_ESCAPE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsLikePredicateContext differentiates from other interfaces.
	IsLikePredicateContext()
}

type LikePredicateContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	kind       antlr.Token
	quantifier antlr.Token
	pattern    IValueExpressionContext
}

func NewEmptyLikePredicateContext() *LikePredicateContext {
	var p = new(LikePredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_likePredicate
	return p
}

func InitEmptyLikePredicateContext(p *LikePredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_likePredicate
}

func (*LikePredicateContext) IsLikePredicateContext() {}

func NewLikePredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikePredicateContext {
	var p = new(LikePredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_likePredicate

	return p
}

func (s *LikePredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *LikePredicateContext) GetKind() antlr.Token { return s.kind }

func (s *LikePredicateContext) GetQuantifier() antlr.Token { return s.quantifier }

func (s *LikePredicateContext) SetKind(v antlr.Token) { s.kind = v }

func (s *LikePredicateContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *LikePredicateContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikePredicateContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikePredicateContext) KW_LIKE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LIKE, 0)
}

func (s *LikePredicateContext) KW_ANY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ANY, 0)
}

func (s *LikePredicateContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALL, 0)
}

func (s *LikePredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *LikePredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *LikePredicateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LikePredicateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LikePredicateContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *LikePredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *LikePredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *LikePredicateContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikePredicateContext) KW_ESCAPE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ESCAPE, 0)
}

func (s *LikePredicateContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

func (p *FlinkSqlParser) LikePredicate() (localctx ILikePredicateContext) {
	localctx = NewLikePredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, FlinkSqlParserRULE_likePredicate)
	var _la int

	p.SetState(1865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1836)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1839)

			var _m = p.Match(FlinkSqlParserKW_LIKE)

			localctx.(*LikePredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1840)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikePredicateContext).quantifier = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserKW_ALL || _la == FlinkSqlParserKW_ANY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikePredicateContext).quantifier = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1841)
				p.Match(FlinkSqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1842)
				p.Match(FlinkSqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1843)
				p.Match(FlinkSqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1844)
				p.Expression()
			}
			p.SetState(1849)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == FlinkSqlParserCOMMA {
				{
					p.SetState(1845)
					p.Match(FlinkSqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1846)
					p.Expression()
				}

				p.SetState(1851)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1852)
				p.Match(FlinkSqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(1856)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1859)

			var _m = p.Match(FlinkSqlParserKW_LIKE)

			localctx.(*LikePredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1860)

			var _x = p.valueExpression(0)

			localctx.(*LikePredicateContext).pattern = _x
		}
		p.SetState(1863)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1861)
				p.Match(FlinkSqlParserKW_ESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1862)
				p.StringLiteral()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ComparisonContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserASTERISK_SIGN, 0)
}

func (s *ArithmeticBinaryContext) SLASH_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSLASH_SIGN, 0)
}

func (s *ArithmeticBinaryContext) PERCENT_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserPERCENT_SIGN, 0)
}

func (s *ArithmeticBinaryContext) KW_DIV() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DIV, 0)
}

func (s *ArithmeticBinaryContext) ADD_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserADD_SIGN, 0)
}

func (s *ArithmeticBinaryContext) HYPHEN_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserHYPHEN_SIGN, 0)
}

func (s *ArithmeticBinaryContext) DOUBLE_VERTICAL_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOUBLE_VERTICAL_SIGN, 0)
}

func (s *ArithmeticBinaryContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_AND_OP, 0)
}

func (s *ArithmeticBinaryContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_XOR_OP, 0)
}

func (s *ArithmeticBinaryContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_OR_OP, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) HYPHEN_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserHYPHEN_SIGN, 0)
}

func (s *ArithmeticUnaryContext) ADD_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserADD_SIGN, 0)
}

func (s *ArithmeticUnaryContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_NOT_OP, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (p *FlinkSqlParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *FlinkSqlParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 266
	p.EnterRecursionRule(localctx, 266, FlinkSqlParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1868)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1869)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-511)) & ^0x3f) == 0 && ((int64(1)<<(_la-511))&3145729) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1870)
			p.valueExpression(7)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1892)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_valueExpression)
				p.SetState(1873)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1874)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == FlinkSqlParserKW_DIV || ((int64((_la-529)) & ^0x3f) == 0 && ((int64(1)<<(_la-529))&145) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1875)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_valueExpression)
				p.SetState(1876)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1877)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&11) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1878)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_valueExpression)
				p.SetState(1879)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1880)

					var _m = p.Match(FlinkSqlParserBIT_AND_OP)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1881)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_valueExpression)
				p.SetState(1882)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1883)

					var _m = p.Match(FlinkSqlParserBIT_XOR_OP)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1884)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_valueExpression)
				p.SetState(1885)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1886)

					var _m = p.Match(FlinkSqlParserBIT_OR_OP)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1887)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewComparisonContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_valueExpression)
				p.SetState(1888)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1889)
					p.ComparisonOperator()
				}
				{
					p.SetState(1890)

					var _x = p.valueExpression(2)

					localctx.(*ComparisonContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallExpressionContext is an interface to support dynamic dispatch.
type IFunctionCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReservedKeywordsNoParamsUsedAsFuncName() IReservedKeywordsNoParamsUsedAsFuncNameContext
	FunctionNameAndParams() IFunctionNameAndParamsContext
	FunctionNameWithParams() IFunctionNameWithParamsContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllFunctionParam() []IFunctionParamContext
	FunctionParam(i int) IFunctionParamContext
	SetQuantifier() ISetQuantifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionCallExpressionContext differentiates from other interfaces.
	IsFunctionCallExpressionContext()
}

type FunctionCallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallExpressionContext() *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionCallExpression
	return p
}

func InitEmptyFunctionCallExpressionContext(p *FunctionCallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionCallExpression
}

func (*FunctionCallExpressionContext) IsFunctionCallExpressionContext() {}

func NewFunctionCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_functionCallExpression

	return p
}

func (s *FunctionCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallExpressionContext) ReservedKeywordsNoParamsUsedAsFuncName() IReservedKeywordsNoParamsUsedAsFuncNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordsNoParamsUsedAsFuncNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordsNoParamsUsedAsFuncNameContext)
}

func (s *FunctionCallExpressionContext) FunctionNameAndParams() IFunctionNameAndParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameAndParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameAndParamsContext)
}

func (s *FunctionCallExpressionContext) FunctionNameWithParams() IFunctionNameWithParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameWithParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameWithParamsContext)
}

func (s *FunctionCallExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *FunctionCallExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *FunctionCallExpressionContext) AllFunctionParam() []IFunctionParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParamContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParamContext); ok {
			tst[i] = t.(IFunctionParamContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) FunctionParam(i int) IFunctionParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParamContext)
}

func (s *FunctionCallExpressionContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *FunctionCallExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (p *FlinkSqlParser) FunctionCallExpression() (localctx IFunctionCallExpressionContext) {
	localctx = NewFunctionCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, FlinkSqlParserRULE_functionCallExpression)
	var _la int

	p.SetState(1916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_CURRENT_DATE, FlinkSqlParserKW_CURRENT_TIME, FlinkSqlParserKW_CURRENT_TIMESTAMP, FlinkSqlParserKW_LOCALTIME, FlinkSqlParserKW_LOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1897)
			p.ReservedKeywordsNoParamsUsedAsFuncName()
		}

	case FlinkSqlParserKW_DATE, FlinkSqlParserKW_INTERVAL, FlinkSqlParserKW_TIME, FlinkSqlParserKW_TIMESTAMP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1898)
			p.FunctionNameAndParams()
		}

	case FlinkSqlParserKW_ABS, FlinkSqlParserKW_ARRAY, FlinkSqlParserKW_AVG, FlinkSqlParserKW_CARDINALITY, FlinkSqlParserKW_CAST, FlinkSqlParserKW_CEIL, FlinkSqlParserKW_CEILING, FlinkSqlParserKW_COALESCE, FlinkSqlParserKW_COLLECT, FlinkSqlParserKW_COUNT, FlinkSqlParserKW_CUME_DIST, FlinkSqlParserKW_DAYOFWEEK, FlinkSqlParserKW_DAYOFYEAR, FlinkSqlParserKW_DENSE_RANK, FlinkSqlParserKW_ELEMENT, FlinkSqlParserKW_EXP, FlinkSqlParserKW_EXTRACT, FlinkSqlParserKW_FIRST_VALUE, FlinkSqlParserKW_FLOOR, FlinkSqlParserKW_GROUPING, FlinkSqlParserKW_HOUR, FlinkSqlParserKW_IF, FlinkSqlParserKW_JSON_ARRAY, FlinkSqlParserKW_JSON_ARRAYAGG, FlinkSqlParserKW_JSON_EXISTS, FlinkSqlParserKW_JSON_OBJECT, FlinkSqlParserKW_JSON_OBJECTAGG, FlinkSqlParserKW_JSON_QUERY, FlinkSqlParserKW_JSON_VALUE, FlinkSqlParserKW_LAG, FlinkSqlParserKW_LAST_VALUE, FlinkSqlParserKW_LEAD, FlinkSqlParserKW_LEFT, FlinkSqlParserKW_LN, FlinkSqlParserKW_LOWER, FlinkSqlParserKW_MAX, FlinkSqlParserKW_MIN, FlinkSqlParserKW_MINUTE, FlinkSqlParserKW_MOD, FlinkSqlParserKW_MONTH, FlinkSqlParserKW_NTILE, FlinkSqlParserKW_NULLIF, FlinkSqlParserKW_OVERLAY, FlinkSqlParserKW_PERCENT_RANK, FlinkSqlParserKW_POSITION, FlinkSqlParserKW_POWER, FlinkSqlParserKW_RANK, FlinkSqlParserKW_RIGHT, FlinkSqlParserKW_ROW, FlinkSqlParserKW_ROWS, FlinkSqlParserKW_ROW_NUMBER, FlinkSqlParserKW_SECOND, FlinkSqlParserKW_STDDEV_POP, FlinkSqlParserKW_STDDEV_SAMP, FlinkSqlParserKW_SUBSTRING, FlinkSqlParserKW_SUM, FlinkSqlParserKW_TIMESTAMP_DIFF, FlinkSqlParserKW_TRIM, FlinkSqlParserKW_TRUNCATE, FlinkSqlParserKW_TRY_CAST, FlinkSqlParserKW_UPPER, FlinkSqlParserKW_VAR_POP, FlinkSqlParserKW_VAR_SAMP, FlinkSqlParserKW_YEAR, FlinkSqlParserKW_ADD, FlinkSqlParserKW_AFTER, FlinkSqlParserKW_ASC, FlinkSqlParserKW_CASCADE, FlinkSqlParserKW_CATALOG, FlinkSqlParserKW_CENTURY, FlinkSqlParserKW_CONFIG, FlinkSqlParserKW_CONSTRAINTS, FlinkSqlParserKW_CUMULATE, FlinkSqlParserKW_DATA, FlinkSqlParserKW_DATABASE, FlinkSqlParserKW_DAYS, FlinkSqlParserKW_DECADE, FlinkSqlParserKW_DESC, FlinkSqlParserKW_DESCRIPTOR, FlinkSqlParserKW_DIV, FlinkSqlParserKW_ENGINE, FlinkSqlParserKW_EPOCH, FlinkSqlParserKW_EXCLUDING, FlinkSqlParserKW_FILE, FlinkSqlParserKW_FIRST, FlinkSqlParserKW_GENERATED, FlinkSqlParserKW_HOP, FlinkSqlParserKW_HOURS, FlinkSqlParserKW_IGNORE, FlinkSqlParserKW_INCLUDING, FlinkSqlParserKW_JAR, FlinkSqlParserKW_JARS, FlinkSqlParserKW_JAVA, FlinkSqlParserKW_KEY, FlinkSqlParserKW_LAST, FlinkSqlParserKW_LOAD, FlinkSqlParserKW_MAP, FlinkSqlParserKW_MICROSECOND, FlinkSqlParserKW_MILLENNIUM, FlinkSqlParserKW_MILLISECOND, FlinkSqlParserKW_MINUTES, FlinkSqlParserKW_MONTHS, FlinkSqlParserKW_NANOSECOND, FlinkSqlParserKW_NULLS, FlinkSqlParserKW_OPTIONS, FlinkSqlParserKW_PAST, FlinkSqlParserKW_PLAN, FlinkSqlParserKW_PRECEDING, FlinkSqlParserKW_PYTHON, FlinkSqlParserKW_PYTHON_ARCHIVES, FlinkSqlParserKW_PYTHON_DEPENDENCIES, FlinkSqlParserKW_PYTHON_FILES, FlinkSqlParserKW_PYTHON_JAR, FlinkSqlParserKW_PYTHON_PARAMETER, FlinkSqlParserKW_PYTHON_REQUIREMENTS, FlinkSqlParserKW_QUARTER, FlinkSqlParserKW_REMOVE, FlinkSqlParserKW_RESTRICT, FlinkSqlParserKW_SECONDS, FlinkSqlParserKW_SESSION, FlinkSqlParserKW_SETS, FlinkSqlParserKW_SIZE, FlinkSqlParserKW_SLIDE, FlinkSqlParserKW_STEP, FlinkSqlParserKW_TEMPORARY, FlinkSqlParserKW_TIMECOL, FlinkSqlParserKW_TUMBLE, FlinkSqlParserKW_UNLOAD, FlinkSqlParserKW_VIEW, FlinkSqlParserKW_WEEK, FlinkSqlParserKW_YEARS, FlinkSqlParserKW_ZONE, FlinkSqlParserSTRING_LITERAL, FlinkSqlParserDIG_LITERAL, FlinkSqlParserID_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1899)
			p.FunctionNameWithParams()
		}
		{
			p.SetState(1900)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90101962837598256) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&1143768854135361) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&9133863015869846723) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&510177799445789) != 0) || ((int64((_la-265)) & ^0x3f) == 0 && ((int64(1)<<(_la-265))&2035627032646520833) != 0) || ((int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&-6881377075630964735) != 0) || ((int64((_la-400)) & ^0x3f) == 0 && ((int64(1)<<(_la-400))&-274334710781) != 0) || ((int64((_la-464)) & ^0x3f) == 0 && ((int64(1)<<(_la-464))&18163932090859519) != 0) || ((int64((_la-529)) & ^0x3f) == 0 && ((int64(1)<<(_la-529))&31757) != 0) {
			p.SetState(1902)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1901)
					p.SetQuantifier()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1904)
				p.FunctionParam()
			}
			p.SetState(1909)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == FlinkSqlParserCOMMA {
				{
					p.SetState(1905)
					p.Match(FlinkSqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1906)
					p.FunctionParam()
				}

				p.SetState(1911)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1914)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) DereferenceDefinition() IDereferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDereferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDereferenceDefinitionContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	value          IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetValue() IExpressionContext { return s.value }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetValue(v IExpressionContext) { s.value = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) KW_CASE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CASE, 0)
}

func (s *SimpleCaseContext) KW_END() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_END, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) KW_ELSE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) ColumnNamePath() IColumnNamePathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNamePathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNamePathContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type LastContext struct {
	PrimaryExpressionContext
}

func NewLastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LastContext {
	var p = new(LastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastContext) KW_LAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LAST, 0)
}

func (s *LastContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *LastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LastContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *LastContext) KW_IGNORE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IGNORE, 0)
}

func (s *LastContext) KW_NULLS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULLS, 0)
}

func (s *LastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLast(s)
	}
}

func (s *LastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLast(s)
	}
}

type StarContext struct {
	PrimaryExpressionContext
}

func NewStarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StarContext {
	var p = new(StarContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarContext) ASTERISK_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserASTERISK_SIGN, 0)
}

func (s *StarContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *StarContext) DOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, 0)
}

func (s *StarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterStar(s)
	}
}

func (s *StarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitStar(s)
	}
}

type SubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) LS_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLS_BRACKET, 0)
}

func (s *SubscriptContext) RS_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRS_BRACKET, 0)
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *SubqueryExpressionContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *SubqueryExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) KW_CAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CAST, 0)
}

func (s *CastContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *CastContext) ColumnType() IColumnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeContext)
}

func (s *CastContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCast(s)
	}
}

type ConstantDefaultContext struct {
	PrimaryExpressionContext
}

func NewConstantDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantDefaultContext {
	var p = new(ConstantDefaultContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConstantDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefaultContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterConstantDefault(s)
	}
}

func (s *ConstantDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitConstantDefault(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) KW_CASE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CASE, 0)
}

func (s *SearchedCaseContext) KW_END() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_END, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) KW_ELSE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type PositionContext struct {
	PrimaryExpressionContext
	substr IValueExpressionContext
	str    IValueExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetSubstr() IValueExpressionContext { return s.substr }

func (s *PositionContext) GetStr() IValueExpressionContext { return s.str }

func (s *PositionContext) SetSubstr(v IValueExpressionContext) { s.substr = v }

func (s *PositionContext) SetStr(v IValueExpressionContext) { s.str = v }

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) KW_POSITION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_POSITION, 0)
}

func (s *PositionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *PositionContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IN, 0)
}

func (s *PositionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitPosition(s)
	}
}

type FirstContext struct {
	PrimaryExpressionContext
}

func NewFirstContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FirstContext {
	var p = new(FirstContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FirstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FirstContext) KW_FIRST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FIRST, 0)
}

func (s *FirstContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *FirstContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FirstContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *FirstContext) KW_IGNORE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IGNORE, 0)
}

func (s *FirstContext) KW_NULLS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULLS, 0)
}

func (s *FirstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFirst(s)
	}
}

func (s *FirstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFirst(s)
	}
}

func (p *FlinkSqlParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *FlinkSqlParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 270
	p.EnterRecursionRule(localctx, 270, FlinkSqlParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1919)
			p.Match(FlinkSqlParserKW_CASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == FlinkSqlParserKW_WHEN {
			{
				p.SetState(1920)
				p.WhenClause()
			}

			p.SetState(1923)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_ELSE {
			{
				p.SetState(1925)
				p.Match(FlinkSqlParserKW_ELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1926)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1929)
			p.Match(FlinkSqlParserKW_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1931)
			p.Match(FlinkSqlParserKW_CASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1932)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).value = _x
		}
		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == FlinkSqlParserKW_WHEN {
			{
				p.SetState(1933)
				p.WhenClause()
			}

			p.SetState(1936)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_ELSE {
			{
				p.SetState(1938)
				p.Match(FlinkSqlParserKW_ELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1939)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1942)
			p.Match(FlinkSqlParserKW_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1944)
			p.Match(FlinkSqlParserKW_CAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1945)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1946)
			p.Expression()
		}
		{
			p.SetState(1947)
			p.Match(FlinkSqlParserKW_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1948)
			p.ColumnType()
		}
		{
			p.SetState(1949)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewFirstContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1951)
			p.Match(FlinkSqlParserKW_FIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1952)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1953)
			p.Expression()
		}
		p.SetState(1956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_IGNORE {
			{
				p.SetState(1954)
				p.Match(FlinkSqlParserKW_IGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1955)
				p.Match(FlinkSqlParserKW_NULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1958)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewLastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1960)
			p.Match(FlinkSqlParserKW_LAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1961)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1962)
			p.Expression()
		}
		p.SetState(1965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_IGNORE {
			{
				p.SetState(1963)
				p.Match(FlinkSqlParserKW_IGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1964)
				p.Match(FlinkSqlParserKW_NULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1967)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1969)
			p.Match(FlinkSqlParserKW_POSITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1970)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1971)

			var _x = p.valueExpression(0)

			localctx.(*PositionContext).substr = _x
		}
		{
			p.SetState(1972)
			p.Match(FlinkSqlParserKW_IN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1973)

			var _x = p.valueExpression(0)

			localctx.(*PositionContext).str = _x
		}
		{
			p.SetState(1974)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewConstantDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1976)
			p.Constant()
		}

	case 8:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1977)
			p.Match(FlinkSqlParserASTERISK_SIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1978)
			p.Uid()
		}
		{
			p.SetState(1979)
			p.Match(FlinkSqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1980)
			p.Match(FlinkSqlParserASTERISK_SIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1982)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1983)
			p.queryStatement(0)
		}
		{
			p.SetState(1984)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1986)
			p.FunctionCallExpression()
		}

	case 12:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1987)
			p.ColumnNamePath()
		}

	case 13:
		localctx = NewDereferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1988)
			p.DereferenceDefinition()
		}

	case 14:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1989)
			p.Match(FlinkSqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1990)
			p.Expression()
		}
		{
			p.SetState(1991)
			p.Match(FlinkSqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
			localctx.(*SubscriptContext).value = _prevctx

			p.PushNewRecursionContext(localctx, _startState, FlinkSqlParserRULE_primaryExpression)
			p.SetState(1995)

			if !(p.Precpred(p.GetParserRuleContext(), 4)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				goto errorExit
			}
			{
				p.SetState(1996)
				p.Match(FlinkSqlParserLS_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1997)

				var _x = p.valueExpression(0)

				localctx.(*SubscriptContext).index = _x
			}
			{
				p.SetState(1998)
				p.Match(FlinkSqlParserRS_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameCreateContext is an interface to support dynamic dispatch.
type IFunctionNameCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsFunctionNameCreateContext differentiates from other interfaces.
	IsFunctionNameCreateContext()
}

type FunctionNameCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameCreateContext() *FunctionNameCreateContext {
	var p = new(FunctionNameCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionNameCreate
	return p
}

func InitEmptyFunctionNameCreateContext(p *FunctionNameCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionNameCreate
}

func (*FunctionNameCreateContext) IsFunctionNameCreateContext() {}

func NewFunctionNameCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameCreateContext {
	var p = new(FunctionNameCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_functionNameCreate

	return p
}

func (s *FunctionNameCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameCreateContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FunctionNameCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFunctionNameCreate(s)
	}
}

func (s *FunctionNameCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFunctionNameCreate(s)
	}
}

func (p *FlinkSqlParser) FunctionNameCreate() (localctx IFunctionNameCreateContext) {
	localctx = NewFunctionNameCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, FlinkSqlParserRULE_functionNameCreate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2005)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReservedKeywordsUsedAsFuncName() IReservedKeywordsUsedAsFuncNameContext
	ReservedKeywordsNoParamsUsedAsFuncName() IReservedKeywordsNoParamsUsedAsFuncNameContext
	ReservedKeywordsFollowParamsUsedAsFuncName() IReservedKeywordsFollowParamsUsedAsFuncNameContext
	Uid() IUidContext

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) ReservedKeywordsUsedAsFuncName() IReservedKeywordsUsedAsFuncNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordsUsedAsFuncNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordsUsedAsFuncNameContext)
}

func (s *FunctionNameContext) ReservedKeywordsNoParamsUsedAsFuncName() IReservedKeywordsNoParamsUsedAsFuncNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordsNoParamsUsedAsFuncNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordsNoParamsUsedAsFuncNameContext)
}

func (s *FunctionNameContext) ReservedKeywordsFollowParamsUsedAsFuncName() IReservedKeywordsFollowParamsUsedAsFuncNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordsFollowParamsUsedAsFuncNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordsFollowParamsUsedAsFuncNameContext)
}

func (s *FunctionNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (p *FlinkSqlParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, FlinkSqlParserRULE_functionName)
	p.SetState(2011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2007)
			p.ReservedKeywordsUsedAsFuncName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2008)
			p.ReservedKeywordsNoParamsUsedAsFuncName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2009)
			p.ReservedKeywordsFollowParamsUsedAsFuncName()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2010)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameAndParamsContext is an interface to support dynamic dispatch.
type IFunctionNameAndParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReservedKeywordsFollowParamsUsedAsFuncName() IReservedKeywordsFollowParamsUsedAsFuncNameContext
	STRING_LITERAL() antlr.TerminalNode
	TimeIntervalExpression() ITimeIntervalExpressionContext

	// IsFunctionNameAndParamsContext differentiates from other interfaces.
	IsFunctionNameAndParamsContext()
}

type FunctionNameAndParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameAndParamsContext() *FunctionNameAndParamsContext {
	var p = new(FunctionNameAndParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionNameAndParams
	return p
}

func InitEmptyFunctionNameAndParamsContext(p *FunctionNameAndParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionNameAndParams
}

func (*FunctionNameAndParamsContext) IsFunctionNameAndParamsContext() {}

func NewFunctionNameAndParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameAndParamsContext {
	var p = new(FunctionNameAndParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_functionNameAndParams

	return p
}

func (s *FunctionNameAndParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameAndParamsContext) ReservedKeywordsFollowParamsUsedAsFuncName() IReservedKeywordsFollowParamsUsedAsFuncNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordsFollowParamsUsedAsFuncNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordsFollowParamsUsedAsFuncNameContext)
}

func (s *FunctionNameAndParamsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *FunctionNameAndParamsContext) TimeIntervalExpression() ITimeIntervalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalExpressionContext)
}

func (s *FunctionNameAndParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameAndParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameAndParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFunctionNameAndParams(s)
	}
}

func (s *FunctionNameAndParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFunctionNameAndParams(s)
	}
}

func (p *FlinkSqlParser) FunctionNameAndParams() (localctx IFunctionNameAndParamsContext) {
	localctx = NewFunctionNameAndParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, FlinkSqlParserRULE_functionNameAndParams)
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_DATE, FlinkSqlParserKW_TIME, FlinkSqlParserKW_TIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2013)
			p.ReservedKeywordsFollowParamsUsedAsFuncName()
		}
		{
			p.SetState(2014)
			p.Match(FlinkSqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserKW_INTERVAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2016)
			p.TimeIntervalExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameWithParamsContext is an interface to support dynamic dispatch.
type IFunctionNameWithParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReservedKeywordsUsedAsFuncName() IReservedKeywordsUsedAsFuncNameContext
	Uid() IUidContext

	// IsFunctionNameWithParamsContext differentiates from other interfaces.
	IsFunctionNameWithParamsContext()
}

type FunctionNameWithParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameWithParamsContext() *FunctionNameWithParamsContext {
	var p = new(FunctionNameWithParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionNameWithParams
	return p
}

func InitEmptyFunctionNameWithParamsContext(p *FunctionNameWithParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionNameWithParams
}

func (*FunctionNameWithParamsContext) IsFunctionNameWithParamsContext() {}

func NewFunctionNameWithParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameWithParamsContext {
	var p = new(FunctionNameWithParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_functionNameWithParams

	return p
}

func (s *FunctionNameWithParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameWithParamsContext) ReservedKeywordsUsedAsFuncName() IReservedKeywordsUsedAsFuncNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordsUsedAsFuncNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordsUsedAsFuncNameContext)
}

func (s *FunctionNameWithParamsContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FunctionNameWithParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameWithParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameWithParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFunctionNameWithParams(s)
	}
}

func (s *FunctionNameWithParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFunctionNameWithParams(s)
	}
}

func (p *FlinkSqlParser) FunctionNameWithParams() (localctx IFunctionNameWithParamsContext) {
	localctx = NewFunctionNameWithParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, FlinkSqlParserRULE_functionNameWithParams)
	p.SetState(2021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2019)
			p.ReservedKeywordsUsedAsFuncName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2020)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParamContext is an interface to support dynamic dispatch.
type IFunctionParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReservedKeywordsUsedAsFuncParam() IReservedKeywordsUsedAsFuncParamContext
	TimeIntervalUnit() ITimeIntervalUnitContext
	TimePointUnit() ITimePointUnitContext
	Expression() IExpressionContext

	// IsFunctionParamContext differentiates from other interfaces.
	IsFunctionParamContext()
}

type FunctionParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParamContext() *FunctionParamContext {
	var p = new(FunctionParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionParam
	return p
}

func InitEmptyFunctionParamContext(p *FunctionParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_functionParam
}

func (*FunctionParamContext) IsFunctionParamContext() {}

func NewFunctionParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParamContext {
	var p = new(FunctionParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_functionParam

	return p
}

func (s *FunctionParamContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParamContext) ReservedKeywordsUsedAsFuncParam() IReservedKeywordsUsedAsFuncParamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordsUsedAsFuncParamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordsUsedAsFuncParamContext)
}

func (s *FunctionParamContext) TimeIntervalUnit() ITimeIntervalUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalUnitContext)
}

func (s *FunctionParamContext) TimePointUnit() ITimePointUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimePointUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimePointUnitContext)
}

func (s *FunctionParamContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterFunctionParam(s)
	}
}

func (s *FunctionParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitFunctionParam(s)
	}
}

func (p *FlinkSqlParser) FunctionParam() (localctx IFunctionParamContext) {
	localctx = NewFunctionParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, FlinkSqlParserRULE_functionParam)
	p.SetState(2027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2023)
			p.ReservedKeywordsUsedAsFuncParam()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2024)
			p.TimeIntervalUnit()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2025)
			p.TimePointUnit()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2026)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDereferenceDefinitionContext is an interface to support dynamic dispatch.
type IDereferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsDereferenceDefinitionContext differentiates from other interfaces.
	IsDereferenceDefinitionContext()
}

type DereferenceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDereferenceDefinitionContext() *DereferenceDefinitionContext {
	var p = new(DereferenceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dereferenceDefinition
	return p
}

func InitEmptyDereferenceDefinitionContext(p *DereferenceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_dereferenceDefinition
}

func (*DereferenceDefinitionContext) IsDereferenceDefinitionContext() {}

func NewDereferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DereferenceDefinitionContext {
	var p = new(DereferenceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_dereferenceDefinition

	return p
}

func (s *DereferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DereferenceDefinitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DereferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DereferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDereferenceDefinition(s)
	}
}

func (s *DereferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDereferenceDefinition(s)
	}
}

func (p *FlinkSqlParser) DereferenceDefinition() (localctx IDereferenceDefinitionContext) {
	localctx = NewDereferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, FlinkSqlParserRULE_dereferenceDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2029)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICorrelationNameContext is an interface to support dynamic dispatch.
type ICorrelationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsCorrelationNameContext differentiates from other interfaces.
	IsCorrelationNameContext()
}

type CorrelationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCorrelationNameContext() *CorrelationNameContext {
	var p = new(CorrelationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_correlationName
	return p
}

func InitEmptyCorrelationNameContext(p *CorrelationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_correlationName
}

func (*CorrelationNameContext) IsCorrelationNameContext() {}

func NewCorrelationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CorrelationNameContext {
	var p = new(CorrelationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_correlationName

	return p
}

func (s *CorrelationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CorrelationNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CorrelationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CorrelationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CorrelationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCorrelationName(s)
	}
}

func (s *CorrelationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCorrelationName(s)
	}
}

func (p *FlinkSqlParser) CorrelationName() (localctx ICorrelationNameContext) {
	localctx = NewCorrelationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, FlinkSqlParserRULE_correlationName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2031)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DereferenceDefinition() IDereferenceDefinitionContext

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) DereferenceDefinition() IDereferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDereferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDereferenceDefinitionContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *FlinkSqlParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, FlinkSqlParserRULE_qualifiedName)
	p.SetState(2035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2033)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2034)
			p.DereferenceDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeIntervalExpressionContext is an interface to support dynamic dispatch.
type ITimeIntervalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_INTERVAL() antlr.TerminalNode
	ErrorCapturingMultiUnitsInterval() IErrorCapturingMultiUnitsIntervalContext
	ErrorCapturingUnitToUnitInterval() IErrorCapturingUnitToUnitIntervalContext

	// IsTimeIntervalExpressionContext differentiates from other interfaces.
	IsTimeIntervalExpressionContext()
}

type TimeIntervalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeIntervalExpressionContext() *TimeIntervalExpressionContext {
	var p = new(TimeIntervalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalExpression
	return p
}

func InitEmptyTimeIntervalExpressionContext(p *TimeIntervalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalExpression
}

func (*TimeIntervalExpressionContext) IsTimeIntervalExpressionContext() {}

func NewTimeIntervalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeIntervalExpressionContext {
	var p = new(TimeIntervalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalExpression

	return p
}

func (s *TimeIntervalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeIntervalExpressionContext) KW_INTERVAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INTERVAL, 0)
}

func (s *TimeIntervalExpressionContext) ErrorCapturingMultiUnitsInterval() IErrorCapturingMultiUnitsIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingMultiUnitsIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingMultiUnitsIntervalContext)
}

func (s *TimeIntervalExpressionContext) ErrorCapturingUnitToUnitInterval() IErrorCapturingUnitToUnitIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingUnitToUnitIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingUnitToUnitIntervalContext)
}

func (s *TimeIntervalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeIntervalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeIntervalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTimeIntervalExpression(s)
	}
}

func (s *TimeIntervalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTimeIntervalExpression(s)
	}
}

func (p *FlinkSqlParser) TimeIntervalExpression() (localctx ITimeIntervalExpressionContext) {
	localctx = NewTimeIntervalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, FlinkSqlParserRULE_timeIntervalExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2037)
		p.Match(FlinkSqlParserKW_INTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2040)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2038)
			p.ErrorCapturingMultiUnitsInterval()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2039)
			p.ErrorCapturingUnitToUnitInterval()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingMultiUnitsIntervalContext is an interface to support dynamic dispatch.
type IErrorCapturingMultiUnitsIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiUnitsInterval() IMultiUnitsIntervalContext
	UnitToUnitInterval() IUnitToUnitIntervalContext

	// IsErrorCapturingMultiUnitsIntervalContext differentiates from other interfaces.
	IsErrorCapturingMultiUnitsIntervalContext()
}

type ErrorCapturingMultiUnitsIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingMultiUnitsIntervalContext() *ErrorCapturingMultiUnitsIntervalContext {
	var p = new(ErrorCapturingMultiUnitsIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingMultiUnitsInterval
	return p
}

func InitEmptyErrorCapturingMultiUnitsIntervalContext(p *ErrorCapturingMultiUnitsIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingMultiUnitsInterval
}

func (*ErrorCapturingMultiUnitsIntervalContext) IsErrorCapturingMultiUnitsIntervalContext() {}

func NewErrorCapturingMultiUnitsIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingMultiUnitsIntervalContext {
	var p = new(ErrorCapturingMultiUnitsIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingMultiUnitsInterval

	return p
}

func (s *ErrorCapturingMultiUnitsIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingMultiUnitsIntervalContext) MultiUnitsInterval() IMultiUnitsIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiUnitsIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiUnitsIntervalContext)
}

func (s *ErrorCapturingMultiUnitsIntervalContext) UnitToUnitInterval() IUnitToUnitIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitToUnitIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitToUnitIntervalContext)
}

func (s *ErrorCapturingMultiUnitsIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingMultiUnitsIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingMultiUnitsIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterErrorCapturingMultiUnitsInterval(s)
	}
}

func (s *ErrorCapturingMultiUnitsIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitErrorCapturingMultiUnitsInterval(s)
	}
}

func (p *FlinkSqlParser) ErrorCapturingMultiUnitsInterval() (localctx IErrorCapturingMultiUnitsIntervalContext) {
	localctx = NewErrorCapturingMultiUnitsIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, FlinkSqlParserRULE_errorCapturingMultiUnitsInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2042)
		p.MultiUnitsInterval()
	}
	p.SetState(2044)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2043)
			p.UnitToUnitInterval()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiUnitsIntervalContext is an interface to support dynamic dispatch.
type IMultiUnitsIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIntervalValue() []IIntervalValueContext
	IntervalValue(i int) IIntervalValueContext
	AllTimeIntervalUnit() []ITimeIntervalUnitContext
	TimeIntervalUnit(i int) ITimeIntervalUnitContext

	// IsMultiUnitsIntervalContext differentiates from other interfaces.
	IsMultiUnitsIntervalContext()
}

type MultiUnitsIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiUnitsIntervalContext() *MultiUnitsIntervalContext {
	var p = new(MultiUnitsIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_multiUnitsInterval
	return p
}

func InitEmptyMultiUnitsIntervalContext(p *MultiUnitsIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_multiUnitsInterval
}

func (*MultiUnitsIntervalContext) IsMultiUnitsIntervalContext() {}

func NewMultiUnitsIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiUnitsIntervalContext {
	var p = new(MultiUnitsIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_multiUnitsInterval

	return p
}

func (s *MultiUnitsIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiUnitsIntervalContext) AllIntervalValue() []IIntervalValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalValueContext); ok {
			len++
		}
	}

	tst := make([]IIntervalValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalValueContext); ok {
			tst[i] = t.(IIntervalValueContext)
			i++
		}
	}

	return tst
}

func (s *MultiUnitsIntervalContext) IntervalValue(i int) IIntervalValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalValueContext)
}

func (s *MultiUnitsIntervalContext) AllTimeIntervalUnit() []ITimeIntervalUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITimeIntervalUnitContext); ok {
			len++
		}
	}

	tst := make([]ITimeIntervalUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITimeIntervalUnitContext); ok {
			tst[i] = t.(ITimeIntervalUnitContext)
			i++
		}
	}

	return tst
}

func (s *MultiUnitsIntervalContext) TimeIntervalUnit(i int) ITimeIntervalUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalUnitContext)
}

func (s *MultiUnitsIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiUnitsIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiUnitsIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterMultiUnitsInterval(s)
	}
}

func (s *MultiUnitsIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitMultiUnitsInterval(s)
	}
}

func (p *FlinkSqlParser) MultiUnitsInterval() (localctx IMultiUnitsIntervalContext) {
	localctx = NewMultiUnitsIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, FlinkSqlParserRULE_multiUnitsInterval)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2046)
				p.IntervalValue()
			}
			{
				p.SetState(2047)
				p.TimeIntervalUnit()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingUnitToUnitIntervalContext is an interface to support dynamic dispatch.
type IErrorCapturingUnitToUnitIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBody returns the body rule contexts.
	GetBody() IUnitToUnitIntervalContext

	// GetError1 returns the error1 rule contexts.
	GetError1() IMultiUnitsIntervalContext

	// GetError2 returns the error2 rule contexts.
	GetError2() IUnitToUnitIntervalContext

	// SetBody sets the body rule contexts.
	SetBody(IUnitToUnitIntervalContext)

	// SetError1 sets the error1 rule contexts.
	SetError1(IMultiUnitsIntervalContext)

	// SetError2 sets the error2 rule contexts.
	SetError2(IUnitToUnitIntervalContext)

	// Getter signatures
	AllUnitToUnitInterval() []IUnitToUnitIntervalContext
	UnitToUnitInterval(i int) IUnitToUnitIntervalContext
	MultiUnitsInterval() IMultiUnitsIntervalContext

	// IsErrorCapturingUnitToUnitIntervalContext differentiates from other interfaces.
	IsErrorCapturingUnitToUnitIntervalContext()
}

type ErrorCapturingUnitToUnitIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	body   IUnitToUnitIntervalContext
	error1 IMultiUnitsIntervalContext
	error2 IUnitToUnitIntervalContext
}

func NewEmptyErrorCapturingUnitToUnitIntervalContext() *ErrorCapturingUnitToUnitIntervalContext {
	var p = new(ErrorCapturingUnitToUnitIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingUnitToUnitInterval
	return p
}

func InitEmptyErrorCapturingUnitToUnitIntervalContext(p *ErrorCapturingUnitToUnitIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingUnitToUnitInterval
}

func (*ErrorCapturingUnitToUnitIntervalContext) IsErrorCapturingUnitToUnitIntervalContext() {}

func NewErrorCapturingUnitToUnitIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingUnitToUnitIntervalContext {
	var p = new(ErrorCapturingUnitToUnitIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingUnitToUnitInterval

	return p
}

func (s *ErrorCapturingUnitToUnitIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingUnitToUnitIntervalContext) GetBody() IUnitToUnitIntervalContext { return s.body }

func (s *ErrorCapturingUnitToUnitIntervalContext) GetError1() IMultiUnitsIntervalContext {
	return s.error1
}

func (s *ErrorCapturingUnitToUnitIntervalContext) GetError2() IUnitToUnitIntervalContext {
	return s.error2
}

func (s *ErrorCapturingUnitToUnitIntervalContext) SetBody(v IUnitToUnitIntervalContext) { s.body = v }

func (s *ErrorCapturingUnitToUnitIntervalContext) SetError1(v IMultiUnitsIntervalContext) {
	s.error1 = v
}

func (s *ErrorCapturingUnitToUnitIntervalContext) SetError2(v IUnitToUnitIntervalContext) {
	s.error2 = v
}

func (s *ErrorCapturingUnitToUnitIntervalContext) AllUnitToUnitInterval() []IUnitToUnitIntervalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnitToUnitIntervalContext); ok {
			len++
		}
	}

	tst := make([]IUnitToUnitIntervalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnitToUnitIntervalContext); ok {
			tst[i] = t.(IUnitToUnitIntervalContext)
			i++
		}
	}

	return tst
}

func (s *ErrorCapturingUnitToUnitIntervalContext) UnitToUnitInterval(i int) IUnitToUnitIntervalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitToUnitIntervalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitToUnitIntervalContext)
}

func (s *ErrorCapturingUnitToUnitIntervalContext) MultiUnitsInterval() IMultiUnitsIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiUnitsIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiUnitsIntervalContext)
}

func (s *ErrorCapturingUnitToUnitIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingUnitToUnitIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingUnitToUnitIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterErrorCapturingUnitToUnitInterval(s)
	}
}

func (s *ErrorCapturingUnitToUnitIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitErrorCapturingUnitToUnitInterval(s)
	}
}

func (p *FlinkSqlParser) ErrorCapturingUnitToUnitInterval() (localctx IErrorCapturingUnitToUnitIntervalContext) {
	localctx = NewErrorCapturingUnitToUnitIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, FlinkSqlParserRULE_errorCapturingUnitToUnitInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2053)

		var _x = p.UnitToUnitInterval()

		localctx.(*ErrorCapturingUnitToUnitIntervalContext).body = _x
	}
	p.SetState(2056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2054)

			var _x = p.MultiUnitsInterval()

			localctx.(*ErrorCapturingUnitToUnitIntervalContext).error1 = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2055)

			var _x = p.UnitToUnitInterval()

			localctx.(*ErrorCapturingUnitToUnitIntervalContext).error2 = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitToUnitIntervalContext is an interface to support dynamic dispatch.
type IUnitToUnitIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IIntervalValueContext

	// GetFrom returns the from rule contexts.
	GetFrom() ITimeIntervalUnitContext

	// GetTo returns the to rule contexts.
	GetTo() ITimeIntervalUnitContext

	// SetValue sets the value rule contexts.
	SetValue(IIntervalValueContext)

	// SetFrom sets the from rule contexts.
	SetFrom(ITimeIntervalUnitContext)

	// SetTo sets the to rule contexts.
	SetTo(ITimeIntervalUnitContext)

	// Getter signatures
	KW_TO() antlr.TerminalNode
	IntervalValue() IIntervalValueContext
	AllTimeIntervalUnit() []ITimeIntervalUnitContext
	TimeIntervalUnit(i int) ITimeIntervalUnitContext

	// IsUnitToUnitIntervalContext differentiates from other interfaces.
	IsUnitToUnitIntervalContext()
}

type UnitToUnitIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IIntervalValueContext
	from   ITimeIntervalUnitContext
	to     ITimeIntervalUnitContext
}

func NewEmptyUnitToUnitIntervalContext() *UnitToUnitIntervalContext {
	var p = new(UnitToUnitIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unitToUnitInterval
	return p
}

func InitEmptyUnitToUnitIntervalContext(p *UnitToUnitIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unitToUnitInterval
}

func (*UnitToUnitIntervalContext) IsUnitToUnitIntervalContext() {}

func NewUnitToUnitIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitToUnitIntervalContext {
	var p = new(UnitToUnitIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_unitToUnitInterval

	return p
}

func (s *UnitToUnitIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitToUnitIntervalContext) GetValue() IIntervalValueContext { return s.value }

func (s *UnitToUnitIntervalContext) GetFrom() ITimeIntervalUnitContext { return s.from }

func (s *UnitToUnitIntervalContext) GetTo() ITimeIntervalUnitContext { return s.to }

func (s *UnitToUnitIntervalContext) SetValue(v IIntervalValueContext) { s.value = v }

func (s *UnitToUnitIntervalContext) SetFrom(v ITimeIntervalUnitContext) { s.from = v }

func (s *UnitToUnitIntervalContext) SetTo(v ITimeIntervalUnitContext) { s.to = v }

func (s *UnitToUnitIntervalContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TO, 0)
}

func (s *UnitToUnitIntervalContext) IntervalValue() IIntervalValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalValueContext)
}

func (s *UnitToUnitIntervalContext) AllTimeIntervalUnit() []ITimeIntervalUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITimeIntervalUnitContext); ok {
			len++
		}
	}

	tst := make([]ITimeIntervalUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITimeIntervalUnitContext); ok {
			tst[i] = t.(ITimeIntervalUnitContext)
			i++
		}
	}

	return tst
}

func (s *UnitToUnitIntervalContext) TimeIntervalUnit(i int) ITimeIntervalUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalUnitContext)
}

func (s *UnitToUnitIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitToUnitIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitToUnitIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUnitToUnitInterval(s)
	}
}

func (s *UnitToUnitIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUnitToUnitInterval(s)
	}
}

func (p *FlinkSqlParser) UnitToUnitInterval() (localctx IUnitToUnitIntervalContext) {
	localctx = NewUnitToUnitIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, FlinkSqlParserRULE_unitToUnitInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2058)

		var _x = p.IntervalValue()

		localctx.(*UnitToUnitIntervalContext).value = _x
	}
	{
		p.SetState(2059)

		var _x = p.TimeIntervalUnit()

		localctx.(*UnitToUnitIntervalContext).from = _x
	}
	{
		p.SetState(2060)
		p.Match(FlinkSqlParserKW_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2061)

		var _x = p.TimeIntervalUnit()

		localctx.(*UnitToUnitIntervalContext).to = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalValueContext is an interface to support dynamic dispatch.
type IIntervalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIG_LITERAL() antlr.TerminalNode
	REAL_LITERAL() antlr.TerminalNode
	ADD_SIGN() antlr.TerminalNode
	HYPHEN_SIGN() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsIntervalValueContext differentiates from other interfaces.
	IsIntervalValueContext()
}

type IntervalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalValueContext() *IntervalValueContext {
	var p = new(IntervalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_intervalValue
	return p
}

func InitEmptyIntervalValueContext(p *IntervalValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_intervalValue
}

func (*IntervalValueContext) IsIntervalValueContext() {}

func NewIntervalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalValueContext {
	var p = new(IntervalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_intervalValue

	return p
}

func (s *IntervalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalValueContext) DIG_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDIG_LITERAL, 0)
}

func (s *IntervalValueContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserREAL_LITERAL, 0)
}

func (s *IntervalValueContext) ADD_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserADD_SIGN, 0)
}

func (s *IntervalValueContext) HYPHEN_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserHYPHEN_SIGN, 0)
}

func (s *IntervalValueContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *IntervalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterIntervalValue(s)
	}
}

func (s *IntervalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitIntervalValue(s)
	}
}

func (p *FlinkSqlParser) IntervalValue() (localctx IIntervalValueContext) {
	localctx = NewIntervalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, FlinkSqlParserRULE_intervalValue)
	var _la int

	p.SetState(2068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserHYPHEN_SIGN, FlinkSqlParserADD_SIGN, FlinkSqlParserDIG_LITERAL, FlinkSqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserHYPHEN_SIGN || _la == FlinkSqlParserADD_SIGN {
			{
				p.SetState(2063)
				_la = p.GetTokenStream().LA(1)

				if !(_la == FlinkSqlParserHYPHEN_SIGN || _la == FlinkSqlParserADD_SIGN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2066)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlinkSqlParserDIG_LITERAL || _la == FlinkSqlParserREAL_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case FlinkSqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2067)
			p.Match(FlinkSqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	KW_AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableAliasContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AS, 0)
}

func (s *TableAliasContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (p *FlinkSqlParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, FlinkSqlParserRULE_tableAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_AS {
		{
			p.SetState(2070)
			p.Match(FlinkSqlParserKW_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2073)

		var _x = p.Identifier()

		localctx.(*TableAliasContext).alias = _x
	}
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2074)
			p.IdentifierList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext

	// IsErrorCapturingIdentifierContext differentiates from other interfaces.
	IsErrorCapturingIdentifierContext()
}

type ErrorCapturingIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierContext() *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingIdentifier
	return p
}

func InitEmptyErrorCapturingIdentifierContext(p *ErrorCapturingIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingIdentifier
}

func (*ErrorCapturingIdentifierContext) IsErrorCapturingIdentifierContext() {}

func NewErrorCapturingIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingIdentifier

	return p
}

func (s *ErrorCapturingIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorCapturingIdentifierContext) ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierExtraContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierExtraContext)
}

func (s *ErrorCapturingIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterErrorCapturingIdentifier(s)
	}
}

func (s *ErrorCapturingIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitErrorCapturingIdentifier(s)
	}
}

func (p *FlinkSqlParser) ErrorCapturingIdentifier() (localctx IErrorCapturingIdentifierContext) {
	localctx = NewErrorCapturingIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, FlinkSqlParserRULE_errorCapturingIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2077)
		p.Identifier()
	}
	{
		p.SetState(2078)
		p.ErrorCapturingIdentifierExtra()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierExtraContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierExtraContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsErrorCapturingIdentifierExtraContext differentiates from other interfaces.
	IsErrorCapturingIdentifierExtraContext()
}

type ErrorCapturingIdentifierExtraContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierExtraContext() *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingIdentifierExtra
	return p
}

func InitEmptyErrorCapturingIdentifierExtraContext(p *ErrorCapturingIdentifierExtraContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingIdentifierExtra
}

func (*ErrorCapturingIdentifierExtraContext) IsErrorCapturingIdentifierExtraContext() {}

func NewErrorCapturingIdentifierExtraContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_errorCapturingIdentifierExtra

	return p
}

func (s *ErrorCapturingIdentifierExtraContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierExtraContext) CopyAll(ctx *ErrorCapturingIdentifierExtraContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ErrorCapturingIdentifierExtraContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierExtraContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ErrorIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewErrorIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorIdentContext {
	var p = new(ErrorIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *ErrorIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorIdentContext) AllKW_MINUS() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserKW_MINUS)
}

func (s *ErrorIdentContext) KW_MINUS(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MINUS, i)
}

func (s *ErrorIdentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ErrorIdentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterErrorIdent(s)
	}
}

func (s *ErrorIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitErrorIdent(s)
	}
}

type RealIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewRealIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RealIdentContext {
	var p = new(RealIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *RealIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterRealIdent(s)
	}
}

func (s *RealIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitRealIdent(s)
	}
}

func (p *FlinkSqlParser) ErrorCapturingIdentifierExtra() (localctx IErrorCapturingIdentifierExtraContext) {
	localctx = NewErrorCapturingIdentifierExtraContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, FlinkSqlParserRULE_errorCapturingIdentifierExtra)
	var _la int

	p.SetState(2087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_MINUS:
		localctx = NewErrorIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == FlinkSqlParserKW_MINUS {
			{
				p.SetState(2080)
				p.Match(FlinkSqlParserKW_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2081)
				p.Identifier()
			}

			p.SetState(2084)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case FlinkSqlParserKW_AS, FlinkSqlParserLR_BRACKET:
		localctx = NewRealIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	RR_BRACKET() antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *IdentifierListContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *IdentifierListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *FlinkSqlParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, FlinkSqlParserRULE_identifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2089)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2090)
		p.IdentifierSeq()
	}
	{
		p.SetState(2091)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSeqContext is an interface to support dynamic dispatch.
type IIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierSeqContext differentiates from other interfaces.
	IsIdentifierSeqContext()
}

type IdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierSeqContext() *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_identifierSeq
	return p
}

func InitEmptyIdentifierSeqContext(p *IdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_identifierSeq
}

func (*IdentifierSeqContext) IsIdentifierSeqContext() {}

func NewIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_identifierSeq

	return p
}

func (s *IdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSeqContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSeqContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *IdentifierSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *IdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterIdentifierSeq(s)
	}
}

func (s *IdentifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitIdentifierSeq(s)
	}
}

func (p *FlinkSqlParser) IdentifierSeq() (localctx IIdentifierSeqContext) {
	localctx = NewIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, FlinkSqlParserRULE_identifierSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2093)
		p.Identifier()
	}
	p.SetState(2098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(2094)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2095)
			p.Identifier()
		}

		p.SetState(2100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuotedIdentifierAlternativeContext struct {
	IdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type NonReservedKeywordsAlternativeContext struct {
	IdentifierContext
}

func NewNonReservedKeywordsAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonReservedKeywordsAlternativeContext {
	var p = new(NonReservedKeywordsAlternativeContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *NonReservedKeywordsAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedKeywordsAlternativeContext) NonReservedKeywords() INonReservedKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedKeywordsContext)
}

func (s *NonReservedKeywordsAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterNonReservedKeywordsAlternative(s)
	}
}

func (s *NonReservedKeywordsAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitNonReservedKeywordsAlternative(s)
	}
}

type UnquotedIdentifierAlternativeContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierAlternativeContext {
	var p = new(UnquotedIdentifierAlternativeContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierAlternativeContext) UnquotedIdentifier() IUnquotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnquotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnquotedIdentifierContext)
}

func (s *UnquotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUnquotedIdentifierAlternative(s)
	}
}

func (s *UnquotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUnquotedIdentifierAlternative(s)
	}
}

func (p *FlinkSqlParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, FlinkSqlParserRULE_identifier)
	p.SetState(2104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserDIG_LITERAL, FlinkSqlParserID_LITERAL:
		localctx = NewUnquotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2101)
			p.UnquotedIdentifier()
		}

	case FlinkSqlParserSTRING_LITERAL:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2102)
			p.QuotedIdentifier()
		}

	case FlinkSqlParserKW_ADD, FlinkSqlParserKW_AFTER, FlinkSqlParserKW_ASC, FlinkSqlParserKW_CASCADE, FlinkSqlParserKW_CATALOG, FlinkSqlParserKW_CENTURY, FlinkSqlParserKW_CONFIG, FlinkSqlParserKW_CONSTRAINTS, FlinkSqlParserKW_CUMULATE, FlinkSqlParserKW_DATA, FlinkSqlParserKW_DATABASE, FlinkSqlParserKW_DAYS, FlinkSqlParserKW_DECADE, FlinkSqlParserKW_DESC, FlinkSqlParserKW_DESCRIPTOR, FlinkSqlParserKW_DIV, FlinkSqlParserKW_ENGINE, FlinkSqlParserKW_EPOCH, FlinkSqlParserKW_EXCLUDING, FlinkSqlParserKW_FILE, FlinkSqlParserKW_FIRST, FlinkSqlParserKW_GENERATED, FlinkSqlParserKW_HOP, FlinkSqlParserKW_HOURS, FlinkSqlParserKW_IGNORE, FlinkSqlParserKW_INCLUDING, FlinkSqlParserKW_JAR, FlinkSqlParserKW_JARS, FlinkSqlParserKW_JAVA, FlinkSqlParserKW_KEY, FlinkSqlParserKW_LAST, FlinkSqlParserKW_LOAD, FlinkSqlParserKW_MAP, FlinkSqlParserKW_MICROSECOND, FlinkSqlParserKW_MILLENNIUM, FlinkSqlParserKW_MILLISECOND, FlinkSqlParserKW_MINUTES, FlinkSqlParserKW_MONTHS, FlinkSqlParserKW_NANOSECOND, FlinkSqlParserKW_NULLS, FlinkSqlParserKW_OPTIONS, FlinkSqlParserKW_PAST, FlinkSqlParserKW_PLAN, FlinkSqlParserKW_PRECEDING, FlinkSqlParserKW_PYTHON, FlinkSqlParserKW_PYTHON_ARCHIVES, FlinkSqlParserKW_PYTHON_DEPENDENCIES, FlinkSqlParserKW_PYTHON_FILES, FlinkSqlParserKW_PYTHON_JAR, FlinkSqlParserKW_PYTHON_PARAMETER, FlinkSqlParserKW_PYTHON_REQUIREMENTS, FlinkSqlParserKW_QUARTER, FlinkSqlParserKW_REMOVE, FlinkSqlParserKW_RESTRICT, FlinkSqlParserKW_SECONDS, FlinkSqlParserKW_SESSION, FlinkSqlParserKW_SETS, FlinkSqlParserKW_SIZE, FlinkSqlParserKW_SLIDE, FlinkSqlParserKW_STEP, FlinkSqlParserKW_TEMPORARY, FlinkSqlParserKW_TIMECOL, FlinkSqlParserKW_TUMBLE, FlinkSqlParserKW_UNLOAD, FlinkSqlParserKW_VIEW, FlinkSqlParserKW_WEEK, FlinkSqlParserKW_YEARS, FlinkSqlParserKW_ZONE:
		localctx = NewNonReservedKeywordsAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2103)
			p.NonReservedKeywords()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnquotedIdentifierContext is an interface to support dynamic dispatch.
type IUnquotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIG_LITERAL() antlr.TerminalNode
	ID_LITERAL() antlr.TerminalNode

	// IsUnquotedIdentifierContext differentiates from other interfaces.
	IsUnquotedIdentifierContext()
}

type UnquotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnquotedIdentifierContext() *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unquotedIdentifier
	return p
}

func InitEmptyUnquotedIdentifierContext(p *UnquotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unquotedIdentifier
}

func (*UnquotedIdentifierContext) IsUnquotedIdentifierContext() {}

func NewUnquotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_unquotedIdentifier

	return p
}

func (s *UnquotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnquotedIdentifierContext) DIG_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDIG_LITERAL, 0)
}

func (s *UnquotedIdentifierContext) ID_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserID_LITERAL, 0)
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *FlinkSqlParser) UnquotedIdentifier() (localctx IUnquotedIdentifierContext) {
	localctx = NewUnquotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, FlinkSqlParserRULE_unquotedIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2106)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserDIG_LITERAL || _la == FlinkSqlParserID_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedIdentifierContext is an interface to support dynamic dispatch.
type IQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsQuotedIdentifierContext differentiates from other interfaces.
	IsQuotedIdentifierContext()
}

type QuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedIdentifierContext() *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_quotedIdentifier
	return p
}

func InitEmptyQuotedIdentifierContext(p *QuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_quotedIdentifier
}

func (*QuotedIdentifierContext) IsQuotedIdentifierContext() {}

func NewQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_quotedIdentifier

	return p
}

func (s *QuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedIdentifierContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (p *FlinkSqlParser) QuotedIdentifier() (localctx IQuotedIdentifierContext) {
	localctx = NewQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, FlinkSqlParserRULE_quotedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2108)
		p.Match(FlinkSqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	KW_WHEN() antlr.TerminalNode
	KW_THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) KW_WHEN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WHEN, 0)
}

func (s *WhenClauseContext) KW_THEN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_THEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *FlinkSqlParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, FlinkSqlParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2110)
		p.Match(FlinkSqlParserKW_WHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2111)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(2112)
		p.Match(FlinkSqlParserKW_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2113)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogPathContext is an interface to support dynamic dispatch.
type ICatalogPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsCatalogPathContext differentiates from other interfaces.
	IsCatalogPathContext()
}

type CatalogPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogPathContext() *CatalogPathContext {
	var p = new(CatalogPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_catalogPath
	return p
}

func InitEmptyCatalogPathContext(p *CatalogPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_catalogPath
}

func (*CatalogPathContext) IsCatalogPathContext() {}

func NewCatalogPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogPathContext {
	var p = new(CatalogPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_catalogPath

	return p
}

func (s *CatalogPathContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogPathContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatalogPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCatalogPath(s)
	}
}

func (s *CatalogPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCatalogPath(s)
	}
}

func (p *FlinkSqlParser) CatalogPath() (localctx ICatalogPathContext) {
	localctx = NewCatalogPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, FlinkSqlParserRULE_catalogPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2115)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogPathCreateContext is an interface to support dynamic dispatch.
type ICatalogPathCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsCatalogPathCreateContext differentiates from other interfaces.
	IsCatalogPathCreateContext()
}

type CatalogPathCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogPathCreateContext() *CatalogPathCreateContext {
	var p = new(CatalogPathCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_catalogPathCreate
	return p
}

func InitEmptyCatalogPathCreateContext(p *CatalogPathCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_catalogPathCreate
}

func (*CatalogPathCreateContext) IsCatalogPathCreateContext() {}

func NewCatalogPathCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogPathCreateContext {
	var p = new(CatalogPathCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_catalogPathCreate

	return p
}

func (s *CatalogPathCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogPathCreateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatalogPathCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogPathCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogPathCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterCatalogPathCreate(s)
	}
}

func (s *CatalogPathCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitCatalogPathCreate(s)
	}
}

func (p *FlinkSqlParser) CatalogPathCreate() (localctx ICatalogPathCreateContext) {
	localctx = NewCatalogPathCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, FlinkSqlParserRULE_catalogPathCreate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2117)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabasePathContext is an interface to support dynamic dispatch.
type IDatabasePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	DOT() antlr.TerminalNode

	// IsDatabasePathContext differentiates from other interfaces.
	IsDatabasePathContext()
}

type DatabasePathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabasePathContext() *DatabasePathContext {
	var p = new(DatabasePathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_databasePath
	return p
}

func InitEmptyDatabasePathContext(p *DatabasePathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_databasePath
}

func (*DatabasePathContext) IsDatabasePathContext() {}

func NewDatabasePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabasePathContext {
	var p = new(DatabasePathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_databasePath

	return p
}

func (s *DatabasePathContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabasePathContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DatabasePathContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabasePathContext) DOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, 0)
}

func (s *DatabasePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabasePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabasePathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDatabasePath(s)
	}
}

func (s *DatabasePathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDatabasePath(s)
	}
}

func (p *FlinkSqlParser) DatabasePath() (localctx IDatabasePathContext) {
	localctx = NewDatabasePathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, FlinkSqlParserRULE_databasePath)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2119)
		p.Identifier()
	}
	p.SetState(2122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserDOT {
		{
			p.SetState(2120)
			p.Match(FlinkSqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabasePathCreateContext is an interface to support dynamic dispatch.
type IDatabasePathCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	DOT() antlr.TerminalNode

	// IsDatabasePathCreateContext differentiates from other interfaces.
	IsDatabasePathCreateContext()
}

type DatabasePathCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabasePathCreateContext() *DatabasePathCreateContext {
	var p = new(DatabasePathCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_databasePathCreate
	return p
}

func InitEmptyDatabasePathCreateContext(p *DatabasePathCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_databasePathCreate
}

func (*DatabasePathCreateContext) IsDatabasePathCreateContext() {}

func NewDatabasePathCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabasePathCreateContext {
	var p = new(DatabasePathCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_databasePathCreate

	return p
}

func (s *DatabasePathCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabasePathCreateContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DatabasePathCreateContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabasePathCreateContext) DOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, 0)
}

func (s *DatabasePathCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabasePathCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabasePathCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDatabasePathCreate(s)
	}
}

func (s *DatabasePathCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDatabasePathCreate(s)
	}
}

func (p *FlinkSqlParser) DatabasePathCreate() (localctx IDatabasePathCreateContext) {
	localctx = NewDatabasePathCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, FlinkSqlParserRULE_databasePathCreate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2124)
		p.Identifier()
	}
	p.SetState(2127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserDOT {
		{
			p.SetState(2125)
			p.Match(FlinkSqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2126)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePathCreateContext is an interface to support dynamic dispatch.
type ITablePathCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsTablePathCreateContext differentiates from other interfaces.
	IsTablePathCreateContext()
}

type TablePathCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePathCreateContext() *TablePathCreateContext {
	var p = new(TablePathCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePathCreate
	return p
}

func InitEmptyTablePathCreateContext(p *TablePathCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePathCreate
}

func (*TablePathCreateContext) IsTablePathCreateContext() {}

func NewTablePathCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePathCreateContext {
	var p = new(TablePathCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tablePathCreate

	return p
}

func (s *TablePathCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePathCreateContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TablePathCreateContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePathCreateContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserDOT)
}

func (s *TablePathCreateContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, i)
}

func (s *TablePathCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePathCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePathCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTablePathCreate(s)
	}
}

func (s *TablePathCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTablePathCreate(s)
	}
}

func (p *FlinkSqlParser) TablePathCreate() (localctx ITablePathCreateContext) {
	localctx = NewTablePathCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, FlinkSqlParserRULE_tablePathCreate)
	var _la int

	p.SetState(2141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2129)
			p.Identifier()
		}
		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserDOT {
			{
				p.SetState(2130)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2131)
				p.Identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2134)
			p.Identifier()
		}
		{
			p.SetState(2135)
			p.Match(FlinkSqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2136)
			p.Identifier()
		}
		p.SetState(2139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserDOT {
			{
				p.SetState(2137)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2138)
				p.Identifier()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePathContext is an interface to support dynamic dispatch.
type ITablePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsTablePathContext differentiates from other interfaces.
	IsTablePathContext()
}

type TablePathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePathContext() *TablePathContext {
	var p = new(TablePathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePath
	return p
}

func InitEmptyTablePathContext(p *TablePathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePath
}

func (*TablePathContext) IsTablePathContext() {}

func NewTablePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePathContext {
	var p = new(TablePathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tablePath

	return p
}

func (s *TablePathContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePathContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TablePathContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePathContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserDOT)
}

func (s *TablePathContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, i)
}

func (s *TablePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTablePath(s)
	}
}

func (s *TablePathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTablePath(s)
	}
}

func (p *FlinkSqlParser) TablePath() (localctx ITablePathContext) {
	localctx = NewTablePathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, FlinkSqlParserRULE_tablePath)
	p.SetState(2155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2143)
			p.Identifier()
		}
		p.SetState(2146)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2144)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2145)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2148)
			p.Identifier()
		}
		{
			p.SetState(2149)
			p.Match(FlinkSqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2150)
			p.Identifier()
		}
		p.SetState(2153)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2151)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2152)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewPathContext is an interface to support dynamic dispatch.
type IViewPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsViewPathContext differentiates from other interfaces.
	IsViewPathContext()
}

type ViewPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewPathContext() *ViewPathContext {
	var p = new(ViewPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_viewPath
	return p
}

func InitEmptyViewPathContext(p *ViewPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_viewPath
}

func (*ViewPathContext) IsViewPathContext() {}

func NewViewPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewPathContext {
	var p = new(ViewPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_viewPath

	return p
}

func (s *ViewPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewPathContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ViewPathContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ViewPathContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserDOT)
}

func (s *ViewPathContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, i)
}

func (s *ViewPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterViewPath(s)
	}
}

func (s *ViewPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitViewPath(s)
	}
}

func (p *FlinkSqlParser) ViewPath() (localctx IViewPathContext) {
	localctx = NewViewPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, FlinkSqlParserRULE_viewPath)
	p.SetState(2169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2157)
			p.Identifier()
		}
		p.SetState(2160)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2158)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2159)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2162)
			p.Identifier()
		}
		{
			p.SetState(2163)
			p.Match(FlinkSqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2164)
			p.Identifier()
		}
		p.SetState(2167)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2165)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2166)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewPathCreateContext is an interface to support dynamic dispatch.
type IViewPathCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsViewPathCreateContext differentiates from other interfaces.
	IsViewPathCreateContext()
}

type ViewPathCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewPathCreateContext() *ViewPathCreateContext {
	var p = new(ViewPathCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_viewPathCreate
	return p
}

func InitEmptyViewPathCreateContext(p *ViewPathCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_viewPathCreate
}

func (*ViewPathCreateContext) IsViewPathCreateContext() {}

func NewViewPathCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewPathCreateContext {
	var p = new(ViewPathCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_viewPathCreate

	return p
}

func (s *ViewPathCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewPathCreateContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ViewPathCreateContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ViewPathCreateContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserDOT)
}

func (s *ViewPathCreateContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, i)
}

func (s *ViewPathCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewPathCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewPathCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterViewPathCreate(s)
	}
}

func (s *ViewPathCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitViewPathCreate(s)
	}
}

func (p *FlinkSqlParser) ViewPathCreate() (localctx IViewPathCreateContext) {
	localctx = NewViewPathCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, FlinkSqlParserRULE_viewPathCreate)
	var _la int

	p.SetState(2183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2171)
			p.Identifier()
		}
		p.SetState(2174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserDOT {
			{
				p.SetState(2172)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2173)
				p.Identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2176)
			p.Identifier()
		}
		{
			p.SetState(2177)
			p.Match(FlinkSqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2178)
			p.Identifier()
		}
		p.SetState(2181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserDOT {
			{
				p.SetState(2179)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2180)
				p.Identifier()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_uid
	return p
}

func InitEmptyUidContext(p *UidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_uid
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UidContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UidContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserDOT)
}

func (s *UidContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOT, i)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (p *FlinkSqlParser) Uid() (localctx IUidContext) {
	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, FlinkSqlParserRULE_uid)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2185)
		p.Identifier()
	}
	p.SetState(2190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(2186)
				p.Match(FlinkSqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2187)
				p.Identifier()
			}

		}
		p.SetState(2192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithOptionContext is an interface to support dynamic dispatch.
type IWithOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_WITH() antlr.TerminalNode
	TablePropertyList() ITablePropertyListContext

	// IsWithOptionContext differentiates from other interfaces.
	IsWithOptionContext()
}

type WithOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithOptionContext() *WithOptionContext {
	var p = new(WithOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withOption
	return p
}

func InitEmptyWithOptionContext(p *WithOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_withOption
}

func (*WithOptionContext) IsWithOptionContext() {}

func NewWithOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithOptionContext {
	var p = new(WithOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_withOption

	return p
}

func (s *WithOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithOptionContext) KW_WITH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WITH, 0)
}

func (s *WithOptionContext) TablePropertyList() ITablePropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyListContext)
}

func (s *WithOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterWithOption(s)
	}
}

func (s *WithOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitWithOption(s)
	}
}

func (p *FlinkSqlParser) WithOption() (localctx IWithOptionContext) {
	localctx = NewWithOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, FlinkSqlParserRULE_withOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2193)
		p.Match(FlinkSqlParserKW_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2194)
		p.TablePropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_IF() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode
	KW_EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IF, 0)
}

func (s *IfNotExistsContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *IfNotExistsContext) KW_EXISTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (p *FlinkSqlParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, FlinkSqlParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		p.Match(FlinkSqlParserKW_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2197)
		p.Match(FlinkSqlParserKW_NOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2198)
		p.Match(FlinkSqlParserKW_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_IF() antlr.TerminalNode
	KW_EXISTS() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IF, 0)
}

func (s *IfExistsContext) KW_EXISTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (p *FlinkSqlParser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, FlinkSqlParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2200)
		p.Match(FlinkSqlParserKW_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2201)
		p.Match(FlinkSqlParserKW_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertyListContext is an interface to support dynamic dispatch.
type ITablePropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllTableProperty() []ITablePropertyContext
	TableProperty(i int) ITablePropertyContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTablePropertyListContext differentiates from other interfaces.
	IsTablePropertyListContext()
}

type TablePropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyListContext() *TablePropertyListContext {
	var p = new(TablePropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyList
	return p
}

func InitEmptyTablePropertyListContext(p *TablePropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyList
}

func (*TablePropertyListContext) IsTablePropertyListContext() {}

func NewTablePropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyListContext {
	var p = new(TablePropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyList

	return p
}

func (s *TablePropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLR_BRACKET, 0)
}

func (s *TablePropertyListContext) AllTableProperty() []ITablePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePropertyContext); ok {
			len++
		}
	}

	tst := make([]ITablePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePropertyContext); ok {
			tst[i] = t.(ITablePropertyContext)
			i++
		}
	}

	return tst
}

func (s *TablePropertyListContext) TableProperty(i int) ITablePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *TablePropertyListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserRR_BRACKET, 0)
}

func (s *TablePropertyListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserCOMMA)
}

func (s *TablePropertyListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserCOMMA, i)
}

func (s *TablePropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTablePropertyList(s)
	}
}

func (s *TablePropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTablePropertyList(s)
	}
}

func (p *FlinkSqlParser) TablePropertyList() (localctx ITablePropertyListContext) {
	localctx = NewTablePropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, FlinkSqlParserRULE_tablePropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2203)
		p.Match(FlinkSqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2204)
		p.TableProperty()
	}
	p.SetState(2209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlinkSqlParserCOMMA {
		{
			p.SetState(2205)
			p.Match(FlinkSqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2206)
			p.TableProperty()
		}

		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2212)
		p.Match(FlinkSqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertyContext is an interface to support dynamic dispatch.
type ITablePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() ITablePropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() ITablePropertyValueContext

	// SetKey sets the key rule contexts.
	SetKey(ITablePropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(ITablePropertyValueContext)

	// Getter signatures
	TablePropertyKey() ITablePropertyKeyContext
	TablePropertyValue() ITablePropertyValueContext
	EQUAL_SYMBOL() antlr.TerminalNode

	// IsTablePropertyContext differentiates from other interfaces.
	IsTablePropertyContext()
}

type TablePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    ITablePropertyKeyContext
	value  ITablePropertyValueContext
}

func NewEmptyTablePropertyContext() *TablePropertyContext {
	var p = new(TablePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableProperty
	return p
}

func InitEmptyTablePropertyContext(p *TablePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tableProperty
}

func (*TablePropertyContext) IsTablePropertyContext() {}

func NewTablePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyContext {
	var p = new(TablePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tableProperty

	return p
}

func (s *TablePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyContext) GetKey() ITablePropertyKeyContext { return s.key }

func (s *TablePropertyContext) GetValue() ITablePropertyValueContext { return s.value }

func (s *TablePropertyContext) SetKey(v ITablePropertyKeyContext) { s.key = v }

func (s *TablePropertyContext) SetValue(v ITablePropertyValueContext) { s.value = v }

func (s *TablePropertyContext) TablePropertyKey() ITablePropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyKeyContext)
}

func (s *TablePropertyContext) TablePropertyValue() ITablePropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyValueContext)
}

func (s *TablePropertyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserEQUAL_SYMBOL, 0)
}

func (s *TablePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTableProperty(s)
	}
}

func (s *TablePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTableProperty(s)
	}
}

func (p *FlinkSqlParser) TableProperty() (localctx ITablePropertyContext) {
	localctx = NewTablePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, FlinkSqlParserRULE_tableProperty)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2214)

		var _x = p.TablePropertyKey()

		localctx.(*TablePropertyContext).key = _x
	}
	p.SetState(2219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlinkSqlParserKW_FALSE || _la == FlinkSqlParserKW_TRUE || ((int64((_la-507)) & ^0x3f) == 0 && ((int64(1)<<(_la-507))&30064771073) != 0) {
		p.SetState(2216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserEQUAL_SYMBOL {
			{
				p.SetState(2215)
				p.Match(FlinkSqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2218)

			var _x = p.TablePropertyValue()

			localctx.(*TablePropertyContext).value = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertyKeyContext is an interface to support dynamic dispatch.
type ITablePropertyKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DereferenceDefinition() IDereferenceDefinitionContext
	STRING_LITERAL() antlr.TerminalNode

	// IsTablePropertyKeyContext differentiates from other interfaces.
	IsTablePropertyKeyContext()
}

type TablePropertyKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyKeyContext() *TablePropertyKeyContext {
	var p = new(TablePropertyKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyKey
	return p
}

func InitEmptyTablePropertyKeyContext(p *TablePropertyKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyKey
}

func (*TablePropertyKeyContext) IsTablePropertyKeyContext() {}

func NewTablePropertyKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyKeyContext {
	var p = new(TablePropertyKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyKey

	return p
}

func (s *TablePropertyKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyKeyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePropertyKeyContext) DereferenceDefinition() IDereferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDereferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDereferenceDefinitionContext)
}

func (s *TablePropertyKeyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *TablePropertyKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTablePropertyKey(s)
	}
}

func (s *TablePropertyKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTablePropertyKey(s)
	}
}

func (p *FlinkSqlParser) TablePropertyKey() (localctx ITablePropertyKeyContext) {
	localctx = NewTablePropertyKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, FlinkSqlParserRULE_tablePropertyKey)
	p.SetState(2224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2221)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2222)
			p.DereferenceDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2223)
			p.Match(FlinkSqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertyValueContext is an interface to support dynamic dispatch.
type ITablePropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIG_LITERAL() antlr.TerminalNode
	REAL_LITERAL() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext
	STRING_LITERAL() antlr.TerminalNode

	// IsTablePropertyValueContext differentiates from other interfaces.
	IsTablePropertyValueContext()
}

type TablePropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyValueContext() *TablePropertyValueContext {
	var p = new(TablePropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyValue
	return p
}

func InitEmptyTablePropertyValueContext(p *TablePropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyValue
}

func (*TablePropertyValueContext) IsTablePropertyValueContext() {}

func NewTablePropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyValueContext {
	var p = new(TablePropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_tablePropertyValue

	return p
}

func (s *TablePropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyValueContext) DIG_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDIG_LITERAL, 0)
}

func (s *TablePropertyValueContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserREAL_LITERAL, 0)
}

func (s *TablePropertyValueContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *TablePropertyValueContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *TablePropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTablePropertyValue(s)
	}
}

func (s *TablePropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTablePropertyValue(s)
	}
}

func (p *FlinkSqlParser) TablePropertyValue() (localctx ITablePropertyValueContext) {
	localctx = NewTablePropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, FlinkSqlParserRULE_tablePropertyValue)
	p.SetState(2230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserDIG_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2226)
			p.Match(FlinkSqlParserDIG_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2227)
			p.Match(FlinkSqlParserREAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserKW_FALSE, FlinkSqlParserKW_TRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2228)
			p.BooleanLiteral()
		}

	case FlinkSqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2229)
			p.Match(FlinkSqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_AND() antlr.TerminalNode
	AllBIT_AND_OP() []antlr.TerminalNode
	BIT_AND_OP(i int) antlr.TerminalNode
	KW_OR() antlr.TerminalNode
	AllBIT_OR_OP() []antlr.TerminalNode
	BIT_OR_OP(i int) antlr.TerminalNode

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_logicalOperator
	return p
}

func InitEmptyLogicalOperatorContext(p *LogicalOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_logicalOperator
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) KW_OR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (p *FlinkSqlParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, FlinkSqlParserRULE_logicalOperator)
	p.SetState(2238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_AND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2232)
			p.Match(FlinkSqlParserKW_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2233)
			p.Match(FlinkSqlParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2234)
			p.Match(FlinkSqlParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserKW_OR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2235)
			p.Match(FlinkSqlParserKW_OR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2236)
			p.Match(FlinkSqlParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2237)
			p.Match(FlinkSqlParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	EXCLAMATION_SYMBOL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *FlinkSqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, FlinkSqlParserRULE_comparisonOperator)
	p.SetState(2254)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2240)
			p.Match(FlinkSqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2241)
			p.Match(FlinkSqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2242)
			p.Match(FlinkSqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2243)
			p.Match(FlinkSqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)
			p.Match(FlinkSqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2245)
			p.Match(FlinkSqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2246)
			p.Match(FlinkSqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2247)
			p.Match(FlinkSqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2248)
			p.Match(FlinkSqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2249)
			p.Match(FlinkSqlParserEXCLAMATION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2250)
			p.Match(FlinkSqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2251)
			p.Match(FlinkSqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2252)
			p.Match(FlinkSqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2253)
			p.Match(FlinkSqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLESS_SYMBOL() []antlr.TerminalNode
	LESS_SYMBOL(i int) antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode
	BIT_AND_OP() antlr.TerminalNode
	BIT_XOR_OP() antlr.TerminalNode
	BIT_OR_OP() antlr.TerminalNode

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_bitOperator
	return p
}

func InitEmptyBitOperatorContext(p *BitOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_bitOperator
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(FlinkSqlParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (p *FlinkSqlParser) BitOperator() (localctx IBitOperatorContext) {
	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, FlinkSqlParserRULE_bitOperator)
	p.SetState(2263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2256)
			p.Match(FlinkSqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2257)
			p.Match(FlinkSqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2258)
			p.Match(FlinkSqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2259)
			p.Match(FlinkSqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2260)
			p.Match(FlinkSqlParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2261)
			p.Match(FlinkSqlParserBIT_XOR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2262)
			p.Match(FlinkSqlParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMathOperatorContext is an interface to support dynamic dispatch.
type IMathOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK_SIGN() antlr.TerminalNode
	SLASH_SIGN() antlr.TerminalNode
	PERCENT_SIGN() antlr.TerminalNode
	KW_DIV() antlr.TerminalNode
	ADD_SIGN() antlr.TerminalNode
	HYPHEN_SIGN() antlr.TerminalNode
	DOUBLE_HYPHEN_SIGN() antlr.TerminalNode

	// IsMathOperatorContext differentiates from other interfaces.
	IsMathOperatorContext()
}

type MathOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMathOperatorContext() *MathOperatorContext {
	var p = new(MathOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_mathOperator
	return p
}

func InitEmptyMathOperatorContext(p *MathOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_mathOperator
}

func (*MathOperatorContext) IsMathOperatorContext() {}

func NewMathOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MathOperatorContext {
	var p = new(MathOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_mathOperator

	return p
}

func (s *MathOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MathOperatorContext) ASTERISK_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserASTERISK_SIGN, 0)
}

func (s *MathOperatorContext) SLASH_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSLASH_SIGN, 0)
}

func (s *MathOperatorContext) PERCENT_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserPERCENT_SIGN, 0)
}

func (s *MathOperatorContext) KW_DIV() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DIV, 0)
}

func (s *MathOperatorContext) ADD_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserADD_SIGN, 0)
}

func (s *MathOperatorContext) HYPHEN_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserHYPHEN_SIGN, 0)
}

func (s *MathOperatorContext) DOUBLE_HYPHEN_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDOUBLE_HYPHEN_SIGN, 0)
}

func (s *MathOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MathOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterMathOperator(s)
	}
}

func (s *MathOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitMathOperator(s)
	}
}

func (p *FlinkSqlParser) MathOperator() (localctx IMathOperatorContext) {
	localctx = NewMathOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, FlinkSqlParserRULE_mathOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2265)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_DIV || ((int64((_la-529)) & ^0x3f) == 0 && ((int64(1)<<(_la-529))&221) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLAMATION_SYMBOL() antlr.TerminalNode
	BIT_NOT_OP() antlr.TerminalNode
	ADD_SIGN() antlr.TerminalNode
	HYPHEN_SIGN() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unaryOperator
	return p
}

func InitEmptyUnaryOperatorContext(p *UnaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_unaryOperator
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) ADD_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserADD_SIGN, 0)
}

func (s *UnaryOperatorContext) HYPHEN_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserHYPHEN_SIGN, 0)
}

func (s *UnaryOperatorContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (p *FlinkSqlParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, FlinkSqlParserRULE_unaryOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2267)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_NOT || ((int64((_la-510)) & ^0x3f) == 0 && ((int64(1)<<(_la-510))&6291459) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TimeIntervalExpression() ITimeIntervalExpressionContext
	TimePointLiteral() ITimePointLiteralContext
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	HYPHEN_SIGN() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext
	REAL_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	KW_NULL() antlr.TerminalNode
	KW_NOT() antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) TimeIntervalExpression() ITimeIntervalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeIntervalExpressionContext)
}

func (s *ConstantContext) TimePointLiteral() ITimePointLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimePointLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimePointLiteralContext)
}

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) HYPHEN_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserHYPHEN_SIGN, 0)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserBIT_STRING, 0)
}

func (s *ConstantContext) KW_NULL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULL, 0)
}

func (s *ConstantContext) KW_NOT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NOT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *FlinkSqlParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, FlinkSqlParserRULE_constant)
	var _la int

	p.SetState(2283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlinkSqlParserKW_INTERVAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2269)
			p.TimeIntervalExpression()
		}

	case FlinkSqlParserKW_DAY, FlinkSqlParserKW_HOUR, FlinkSqlParserKW_MINUTE, FlinkSqlParserKW_MONTH, FlinkSqlParserKW_SECOND, FlinkSqlParserKW_YEAR, FlinkSqlParserKW_MICROSECOND, FlinkSqlParserKW_MILLISECOND, FlinkSqlParserKW_QUARTER, FlinkSqlParserKW_WEEK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2270)
			p.TimePointLiteral()
		}

	case FlinkSqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2271)
			p.StringLiteral()
		}

	case FlinkSqlParserHYPHEN_SIGN, FlinkSqlParserDIG_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserHYPHEN_SIGN {
			{
				p.SetState(2272)
				p.Match(FlinkSqlParserHYPHEN_SIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2275)
			p.DecimalLiteral()
		}

	case FlinkSqlParserKW_FALSE, FlinkSqlParserKW_TRUE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2276)
			p.BooleanLiteral()
		}

	case FlinkSqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2277)
			p.Match(FlinkSqlParserREAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserBIT_STRING:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2278)
			p.Match(FlinkSqlParserBIT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlinkSqlParserKW_NOT, FlinkSqlParserKW_NULL:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(2280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlinkSqlParserKW_NOT {
			{
				p.SetState(2279)
				p.Match(FlinkSqlParserKW_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2282)
			p.Match(FlinkSqlParserKW_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimePointLiteralContext is an interface to support dynamic dispatch.
type ITimePointLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TimePointUnit() ITimePointUnitContext
	StringLiteral() IStringLiteralContext

	// IsTimePointLiteralContext differentiates from other interfaces.
	IsTimePointLiteralContext()
}

type TimePointLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimePointLiteralContext() *TimePointLiteralContext {
	var p = new(TimePointLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timePointLiteral
	return p
}

func InitEmptyTimePointLiteralContext(p *TimePointLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timePointLiteral
}

func (*TimePointLiteralContext) IsTimePointLiteralContext() {}

func NewTimePointLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimePointLiteralContext {
	var p = new(TimePointLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_timePointLiteral

	return p
}

func (s *TimePointLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TimePointLiteralContext) TimePointUnit() ITimePointUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimePointUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimePointUnitContext)
}

func (s *TimePointLiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TimePointLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimePointLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimePointLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTimePointLiteral(s)
	}
}

func (s *TimePointLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTimePointLiteral(s)
	}
}

func (p *FlinkSqlParser) TimePointLiteral() (localctx ITimePointLiteralContext) {
	localctx = NewTimePointLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, FlinkSqlParserRULE_timePointLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2285)
		p.TimePointUnit()
	}
	{
		p.SetState(2286)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *FlinkSqlParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, FlinkSqlParserRULE_stringLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2288)
		p.Match(FlinkSqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIG_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_decimalLiteral
	return p
}

func InitEmptyDecimalLiteralContext(p *DecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_decimalLiteral
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DIG_LITERAL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserDIG_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (p *FlinkSqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, FlinkSqlParserRULE_decimalLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2290)
		p.Match(FlinkSqlParserDIG_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TRUE, 0)
}

func (s *BooleanLiteralContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *FlinkSqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, FlinkSqlParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2292)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_FALSE || _la == FlinkSqlParserKW_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DISTINCT() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) KW_DISTINCT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DISTINCT, 0)
}

func (s *SetQuantifierContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *FlinkSqlParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, FlinkSqlParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2294)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_ALL || _la == FlinkSqlParserKW_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimePointUnitContext is an interface to support dynamic dispatch.
type ITimePointUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_YEAR() antlr.TerminalNode
	KW_QUARTER() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_WEEK() antlr.TerminalNode
	KW_DAY() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	KW_MINUTE() antlr.TerminalNode
	KW_SECOND() antlr.TerminalNode
	KW_MILLISECOND() antlr.TerminalNode
	KW_MICROSECOND() antlr.TerminalNode

	// IsTimePointUnitContext differentiates from other interfaces.
	IsTimePointUnitContext()
}

type TimePointUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimePointUnitContext() *TimePointUnitContext {
	var p = new(TimePointUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timePointUnit
	return p
}

func InitEmptyTimePointUnitContext(p *TimePointUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timePointUnit
}

func (*TimePointUnitContext) IsTimePointUnitContext() {}

func NewTimePointUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimePointUnitContext {
	var p = new(TimePointUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_timePointUnit

	return p
}

func (s *TimePointUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimePointUnitContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_YEAR, 0)
}

func (s *TimePointUnitContext) KW_QUARTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_QUARTER, 0)
}

func (s *TimePointUnitContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MONTH, 0)
}

func (s *TimePointUnitContext) KW_WEEK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WEEK, 0)
}

func (s *TimePointUnitContext) KW_DAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DAY, 0)
}

func (s *TimePointUnitContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOUR, 0)
}

func (s *TimePointUnitContext) KW_MINUTE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MINUTE, 0)
}

func (s *TimePointUnitContext) KW_SECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SECOND, 0)
}

func (s *TimePointUnitContext) KW_MILLISECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MILLISECOND, 0)
}

func (s *TimePointUnitContext) KW_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MICROSECOND, 0)
}

func (s *TimePointUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimePointUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimePointUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTimePointUnit(s)
	}
}

func (s *TimePointUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTimePointUnit(s)
	}
}

func (p *FlinkSqlParser) TimePointUnit() (localctx ITimePointUnitContext) {
	localctx = NewTimePointUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, FlinkSqlParserRULE_timePointUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2296)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_DAY || _la == FlinkSqlParserKW_HOUR || _la == FlinkSqlParserKW_MINUTE || _la == FlinkSqlParserKW_MONTH || _la == FlinkSqlParserKW_SECOND || ((int64((_la-438)) & ^0x3f) == 0 && ((int64(1)<<(_la-438))&4503685526716417) != 0) || _la == FlinkSqlParserKW_WEEK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeIntervalUnitContext is an interface to support dynamic dispatch.
type ITimeIntervalUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MILLENNIUM() antlr.TerminalNode
	KW_CENTURY() antlr.TerminalNode
	KW_DECADE() antlr.TerminalNode
	KW_YEAR() antlr.TerminalNode
	KW_YEARS() antlr.TerminalNode
	KW_QUARTER() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_MONTHS() antlr.TerminalNode
	KW_WEEK() antlr.TerminalNode
	KW_WEEKS() antlr.TerminalNode
	KW_DAY() antlr.TerminalNode
	KW_DAYS() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	KW_HOURS() antlr.TerminalNode
	KW_MINUTE() antlr.TerminalNode
	KW_MINUTES() antlr.TerminalNode
	KW_SECOND() antlr.TerminalNode
	KW_SECONDS() antlr.TerminalNode
	KW_MILLISECOND() antlr.TerminalNode
	KW_MICROSECOND() antlr.TerminalNode
	KW_NANOSECOND() antlr.TerminalNode
	KW_EPOCH() antlr.TerminalNode

	// IsTimeIntervalUnitContext differentiates from other interfaces.
	IsTimeIntervalUnitContext()
}

type TimeIntervalUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeIntervalUnitContext() *TimeIntervalUnitContext {
	var p = new(TimeIntervalUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalUnit
	return p
}

func InitEmptyTimeIntervalUnitContext(p *TimeIntervalUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalUnit
}

func (*TimeIntervalUnitContext) IsTimeIntervalUnitContext() {}

func NewTimeIntervalUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeIntervalUnitContext {
	var p = new(TimeIntervalUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_timeIntervalUnit

	return p
}

func (s *TimeIntervalUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeIntervalUnitContext) KW_MILLENNIUM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MILLENNIUM, 0)
}

func (s *TimeIntervalUnitContext) KW_CENTURY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CENTURY, 0)
}

func (s *TimeIntervalUnitContext) KW_DECADE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DECADE, 0)
}

func (s *TimeIntervalUnitContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_YEAR, 0)
}

func (s *TimeIntervalUnitContext) KW_YEARS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_YEARS, 0)
}

func (s *TimeIntervalUnitContext) KW_QUARTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_QUARTER, 0)
}

func (s *TimeIntervalUnitContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MONTH, 0)
}

func (s *TimeIntervalUnitContext) KW_MONTHS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MONTHS, 0)
}

func (s *TimeIntervalUnitContext) KW_WEEK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WEEK, 0)
}

func (s *TimeIntervalUnitContext) KW_WEEKS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WEEKS, 0)
}

func (s *TimeIntervalUnitContext) KW_DAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DAY, 0)
}

func (s *TimeIntervalUnitContext) KW_DAYS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DAYS, 0)
}

func (s *TimeIntervalUnitContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOUR, 0)
}

func (s *TimeIntervalUnitContext) KW_HOURS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOURS, 0)
}

func (s *TimeIntervalUnitContext) KW_MINUTE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MINUTE, 0)
}

func (s *TimeIntervalUnitContext) KW_MINUTES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MINUTES, 0)
}

func (s *TimeIntervalUnitContext) KW_SECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SECOND, 0)
}

func (s *TimeIntervalUnitContext) KW_SECONDS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SECONDS, 0)
}

func (s *TimeIntervalUnitContext) KW_MILLISECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MILLISECOND, 0)
}

func (s *TimeIntervalUnitContext) KW_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MICROSECOND, 0)
}

func (s *TimeIntervalUnitContext) KW_NANOSECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NANOSECOND, 0)
}

func (s *TimeIntervalUnitContext) KW_EPOCH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EPOCH, 0)
}

func (s *TimeIntervalUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeIntervalUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeIntervalUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterTimeIntervalUnit(s)
	}
}

func (s *TimeIntervalUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitTimeIntervalUnit(s)
	}
}

func (p *FlinkSqlParser) TimeIntervalUnit() (localctx ITimeIntervalUnitContext) {
	localctx = NewTimeIntervalUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, FlinkSqlParserRULE_timeIntervalUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2298)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_DAY || _la == FlinkSqlParserKW_HOUR || _la == FlinkSqlParserKW_MINUTE || _la == FlinkSqlParserKW_MONTH || _la == FlinkSqlParserKW_SECOND || ((int64((_la-429)) & ^0x3f) == 0 && ((int64(1)<<(_la-429))&2306397171804570113) != 0) || ((int64((_la-493)) & ^0x3f) == 0 && ((int64(1)<<(_la-493))&6145) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedKeywordsUsedAsFuncParamContext is an interface to support dynamic dispatch.
type IReservedKeywordsUsedAsFuncParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ARRAY() antlr.TerminalNode
	KW_ALL() antlr.TerminalNode
	KW_BOTH() antlr.TerminalNode
	KW_CURRENT_TIMESTAMP() antlr.TerminalNode
	KW_CURRENT_DATE() antlr.TerminalNode
	KW_CURRENT_TIME() antlr.TerminalNode
	KW_LOCALTIME() antlr.TerminalNode
	KW_LOCALTIMESTAMP() antlr.TerminalNode
	KW_DISTINCT() antlr.TerminalNode
	KW_LEADING() antlr.TerminalNode
	KW_TRAILING() antlr.TerminalNode
	KW_VALUE() antlr.TerminalNode
	ASTERISK_SIGN() antlr.TerminalNode

	// IsReservedKeywordsUsedAsFuncParamContext differentiates from other interfaces.
	IsReservedKeywordsUsedAsFuncParamContext()
}

type ReservedKeywordsUsedAsFuncParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedKeywordsUsedAsFuncParamContext() *ReservedKeywordsUsedAsFuncParamContext {
	var p = new(ReservedKeywordsUsedAsFuncParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsUsedAsFuncParam
	return p
}

func InitEmptyReservedKeywordsUsedAsFuncParamContext(p *ReservedKeywordsUsedAsFuncParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsUsedAsFuncParam
}

func (*ReservedKeywordsUsedAsFuncParamContext) IsReservedKeywordsUsedAsFuncParamContext() {}

func NewReservedKeywordsUsedAsFuncParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedKeywordsUsedAsFuncParamContext {
	var p = new(ReservedKeywordsUsedAsFuncParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsUsedAsFuncParam

	return p
}

func (s *ReservedKeywordsUsedAsFuncParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ARRAY, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_ALL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ALL, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_BOTH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_BOTH, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT_TIMESTAMP, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT_DATE, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT_TIME, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_LOCALTIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOCALTIME, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOCALTIMESTAMP, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_DISTINCT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DISTINCT, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_LEADING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LEADING, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_TRAILING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TRAILING, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) KW_VALUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VALUE, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) ASTERISK_SIGN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserASTERISK_SIGN, 0)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedKeywordsUsedAsFuncParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedKeywordsUsedAsFuncParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterReservedKeywordsUsedAsFuncParam(s)
	}
}

func (s *ReservedKeywordsUsedAsFuncParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitReservedKeywordsUsedAsFuncParam(s)
	}
}

func (p *FlinkSqlParser) ReservedKeywordsUsedAsFuncParam() (localctx IReservedKeywordsUsedAsFuncParamContext) {
	localctx = NewReservedKeywordsUsedAsFuncParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, FlinkSqlParserRULE_reservedKeywordsUsedAsFuncParam)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8589942816) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&34359738561) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&385) != 0) || _la == FlinkSqlParserKW_TRAILING || _la == FlinkSqlParserKW_VALUE || _la == FlinkSqlParserASTERISK_SIGN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedKeywordsNoParamsUsedAsFuncNameContext is an interface to support dynamic dispatch.
type IReservedKeywordsNoParamsUsedAsFuncNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LOCALTIME() antlr.TerminalNode
	KW_LOCALTIMESTAMP() antlr.TerminalNode
	KW_CURRENT_TIME() antlr.TerminalNode
	KW_CURRENT_DATE() antlr.TerminalNode
	KW_CURRENT_TIMESTAMP() antlr.TerminalNode

	// IsReservedKeywordsNoParamsUsedAsFuncNameContext differentiates from other interfaces.
	IsReservedKeywordsNoParamsUsedAsFuncNameContext()
}

type ReservedKeywordsNoParamsUsedAsFuncNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedKeywordsNoParamsUsedAsFuncNameContext() *ReservedKeywordsNoParamsUsedAsFuncNameContext {
	var p = new(ReservedKeywordsNoParamsUsedAsFuncNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsNoParamsUsedAsFuncName
	return p
}

func InitEmptyReservedKeywordsNoParamsUsedAsFuncNameContext(p *ReservedKeywordsNoParamsUsedAsFuncNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsNoParamsUsedAsFuncName
}

func (*ReservedKeywordsNoParamsUsedAsFuncNameContext) IsReservedKeywordsNoParamsUsedAsFuncNameContext() {
}

func NewReservedKeywordsNoParamsUsedAsFuncNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedKeywordsNoParamsUsedAsFuncNameContext {
	var p = new(ReservedKeywordsNoParamsUsedAsFuncNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsNoParamsUsedAsFuncName

	return p
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) KW_LOCALTIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOCALTIME, 0)
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) KW_LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOCALTIMESTAMP, 0)
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) KW_CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT_TIME, 0)
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) KW_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT_DATE, 0)
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) KW_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CURRENT_TIMESTAMP, 0)
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterReservedKeywordsNoParamsUsedAsFuncName(s)
	}
}

func (s *ReservedKeywordsNoParamsUsedAsFuncNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitReservedKeywordsNoParamsUsedAsFuncName(s)
	}
}

func (p *FlinkSqlParser) ReservedKeywordsNoParamsUsedAsFuncName() (localctx IReservedKeywordsNoParamsUsedAsFuncNameContext) {
	localctx = NewReservedKeywordsNoParamsUsedAsFuncNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, FlinkSqlParserRULE_reservedKeywordsNoParamsUsedAsFuncName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2302)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&193) != 0) || _la == FlinkSqlParserKW_LOCALTIME || _la == FlinkSqlParserKW_LOCALTIMESTAMP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedKeywordsFollowParamsUsedAsFuncNameContext is an interface to support dynamic dispatch.
type IReservedKeywordsFollowParamsUsedAsFuncNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DATE() antlr.TerminalNode
	KW_TIME() antlr.TerminalNode
	KW_TIMESTAMP() antlr.TerminalNode

	// IsReservedKeywordsFollowParamsUsedAsFuncNameContext differentiates from other interfaces.
	IsReservedKeywordsFollowParamsUsedAsFuncNameContext()
}

type ReservedKeywordsFollowParamsUsedAsFuncNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedKeywordsFollowParamsUsedAsFuncNameContext() *ReservedKeywordsFollowParamsUsedAsFuncNameContext {
	var p = new(ReservedKeywordsFollowParamsUsedAsFuncNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsFollowParamsUsedAsFuncName
	return p
}

func InitEmptyReservedKeywordsFollowParamsUsedAsFuncNameContext(p *ReservedKeywordsFollowParamsUsedAsFuncNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsFollowParamsUsedAsFuncName
}

func (*ReservedKeywordsFollowParamsUsedAsFuncNameContext) IsReservedKeywordsFollowParamsUsedAsFuncNameContext() {
}

func NewReservedKeywordsFollowParamsUsedAsFuncNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedKeywordsFollowParamsUsedAsFuncNameContext {
	var p = new(ReservedKeywordsFollowParamsUsedAsFuncNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsFollowParamsUsedAsFuncName

	return p
}

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) KW_DATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATE, 0)
}

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) KW_TIME() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIME, 0)
}

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) KW_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIMESTAMP, 0)
}

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterReservedKeywordsFollowParamsUsedAsFuncName(s)
	}
}

func (s *ReservedKeywordsFollowParamsUsedAsFuncNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitReservedKeywordsFollowParamsUsedAsFuncName(s)
	}
}

func (p *FlinkSqlParser) ReservedKeywordsFollowParamsUsedAsFuncName() (localctx IReservedKeywordsFollowParamsUsedAsFuncNameContext) {
	localctx = NewReservedKeywordsFollowParamsUsedAsFuncNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, FlinkSqlParserRULE_reservedKeywordsFollowParamsUsedAsFuncName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2304)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlinkSqlParserKW_DATE || _la == FlinkSqlParserKW_TIME || _la == FlinkSqlParserKW_TIMESTAMP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedKeywordsUsedAsFuncNameContext is an interface to support dynamic dispatch.
type IReservedKeywordsUsedAsFuncNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ABS() antlr.TerminalNode
	KW_ARRAY() antlr.TerminalNode
	KW_AVG() antlr.TerminalNode
	KW_CARDINALITY() antlr.TerminalNode
	KW_CAST() antlr.TerminalNode
	KW_CEIL() antlr.TerminalNode
	KW_CEILING() antlr.TerminalNode
	KW_COALESCE() antlr.TerminalNode
	KW_COLLECT() antlr.TerminalNode
	KW_COUNT() antlr.TerminalNode
	KW_CUME_DIST() antlr.TerminalNode
	KW_DAYOFWEEK() antlr.TerminalNode
	KW_DAYOFYEAR() antlr.TerminalNode
	KW_DENSE_RANK() antlr.TerminalNode
	KW_ELEMENT() antlr.TerminalNode
	KW_EXP() antlr.TerminalNode
	KW_EXTRACT() antlr.TerminalNode
	KW_FIRST_VALUE() antlr.TerminalNode
	KW_FLOOR() antlr.TerminalNode
	KW_GROUPING() antlr.TerminalNode
	KW_HOUR() antlr.TerminalNode
	KW_IF() antlr.TerminalNode
	KW_LAG() antlr.TerminalNode
	KW_LAST_VALUE() antlr.TerminalNode
	KW_LEAD() antlr.TerminalNode
	KW_LEFT() antlr.TerminalNode
	KW_LN() antlr.TerminalNode
	KW_LOWER() antlr.TerminalNode
	KW_MAP() antlr.TerminalNode
	KW_MAX() antlr.TerminalNode
	KW_MIN() antlr.TerminalNode
	KW_MINUTE() antlr.TerminalNode
	KW_MOD() antlr.TerminalNode
	KW_MONTH() antlr.TerminalNode
	KW_NULLIF() antlr.TerminalNode
	KW_NTILE() antlr.TerminalNode
	KW_OVERLAY() antlr.TerminalNode
	KW_PERCENT_RANK() antlr.TerminalNode
	KW_POSITION() antlr.TerminalNode
	KW_POWER() antlr.TerminalNode
	KW_QUARTER() antlr.TerminalNode
	KW_ROW() antlr.TerminalNode
	KW_ROWS() antlr.TerminalNode
	KW_ROW_NUMBER() antlr.TerminalNode
	KW_RANK() antlr.TerminalNode
	KW_RIGHT() antlr.TerminalNode
	KW_SECOND() antlr.TerminalNode
	KW_STDDEV_POP() antlr.TerminalNode
	KW_STDDEV_SAMP() antlr.TerminalNode
	KW_SUBSTRING() antlr.TerminalNode
	KW_SUM() antlr.TerminalNode
	KW_TIMESTAMP_DIFF() antlr.TerminalNode
	KW_TRIM() antlr.TerminalNode
	KW_TRUNCATE() antlr.TerminalNode
	KW_TRY_CAST() antlr.TerminalNode
	KW_UPPER() antlr.TerminalNode
	KW_VAR_POP() antlr.TerminalNode
	KW_VAR_SAMP() antlr.TerminalNode
	KW_WEEK() antlr.TerminalNode
	KW_YEAR() antlr.TerminalNode
	KW_JSON_VALUE() antlr.TerminalNode
	KW_JSON_EXISTS() antlr.TerminalNode
	KW_JSON_QUERY() antlr.TerminalNode
	KW_JSON_OBJECT() antlr.TerminalNode
	KW_JSON_OBJECTAGG() antlr.TerminalNode
	KW_JSON_ARRAY() antlr.TerminalNode
	KW_JSON_ARRAYAGG() antlr.TerminalNode

	// IsReservedKeywordsUsedAsFuncNameContext differentiates from other interfaces.
	IsReservedKeywordsUsedAsFuncNameContext()
}

type ReservedKeywordsUsedAsFuncNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedKeywordsUsedAsFuncNameContext() *ReservedKeywordsUsedAsFuncNameContext {
	var p = new(ReservedKeywordsUsedAsFuncNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsUsedAsFuncName
	return p
}

func InitEmptyReservedKeywordsUsedAsFuncNameContext(p *ReservedKeywordsUsedAsFuncNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsUsedAsFuncName
}

func (*ReservedKeywordsUsedAsFuncNameContext) IsReservedKeywordsUsedAsFuncNameContext() {}

func NewReservedKeywordsUsedAsFuncNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedKeywordsUsedAsFuncNameContext {
	var p = new(ReservedKeywordsUsedAsFuncNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_reservedKeywordsUsedAsFuncName

	return p
}

func (s *ReservedKeywordsUsedAsFuncNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_ABS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ABS, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ARRAY, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_AVG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AVG, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_CARDINALITY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CARDINALITY, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_CAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CAST, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_CEIL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CEIL, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_CEILING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CEILING, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_COALESCE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COALESCE, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_COLLECT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COLLECT, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_COUNT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_COUNT, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CUME_DIST, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DAYOFWEEK, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DAYOFYEAR, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DENSE_RANK, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_ELEMENT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ELEMENT, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_EXP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXP, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_EXTRACT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXTRACT, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FIRST_VALUE, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_FLOOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FLOOR, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_GROUPING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_GROUPING, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_HOUR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOUR, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IF, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_LAG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LAG, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LAST_VALUE, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_LEAD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LEAD, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_LEFT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LEFT, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_LN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LN, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_LOWER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOWER, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MAP, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_MAX() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MAX, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_MIN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MIN, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_MINUTE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MINUTE, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_MOD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MOD, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_MONTH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MONTH, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_NULLIF() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULLIF, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_NTILE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NTILE, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_OVERLAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OVERLAY, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PERCENT_RANK, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_POSITION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_POSITION, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_POWER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_POWER, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_QUARTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_QUARTER, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_ROW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROW, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_ROWS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROWS, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ROW_NUMBER, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_RANK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RANK, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_RIGHT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RIGHT, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_SECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SECOND, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_STDDEV_POP, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_STDDEV_SAMP, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SUBSTRING, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_SUM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SUM, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_TIMESTAMP_DIFF() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIMESTAMP_DIFF, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_TRIM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TRIM, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TRUNCATE, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_TRY_CAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TRY_CAST, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_UPPER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UPPER, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_VAR_POP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VAR_POP, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VAR_SAMP, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_WEEK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WEEK, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_YEAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_YEAR, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_VALUE, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_JSON_EXISTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_EXISTS, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_JSON_QUERY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_QUERY, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_OBJECT, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_JSON_OBJECTAGG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_OBJECTAGG, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_ARRAY, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) KW_JSON_ARRAYAGG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JSON_ARRAYAGG, 0)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedKeywordsUsedAsFuncNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedKeywordsUsedAsFuncNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterReservedKeywordsUsedAsFuncName(s)
	}
}

func (s *ReservedKeywordsUsedAsFuncNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitReservedKeywordsUsedAsFuncName(s)
	}
}

func (p *FlinkSqlParser) ReservedKeywordsUsedAsFuncName() (localctx IReservedKeywordsUsedAsFuncNameContext) {
	localctx = NewReservedKeywordsUsedAsFuncNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, FlinkSqlParserRULE_reservedKeywordsUsedAsFuncName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2306)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90100854736035856) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&1126176395362369) != 0) || ((int64((_la-134)) & ^0x3f) == 0 && ((int64(1)<<(_la-134))&4566650032958212641) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&351848125042965) != 0) || ((int64((_la-265)) & ^0x3f) == 0 && ((int64(1)<<(_la-265))&2035627032646520833) != 0) || ((int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&2305913387646713857) != 0) || ((int64((_la-400)) & ^0x3f) == 0 && ((int64(1)<<(_la-400))&274884199427) != 0) || ((int64((_la-471)) & ^0x3f) == 0 && ((int64(1)<<(_la-471))&8590458881) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedKeywordsContext is an interface to support dynamic dispatch.
type INonReservedKeywordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ADD() antlr.TerminalNode
	KW_AFTER() antlr.TerminalNode
	KW_ASC() antlr.TerminalNode
	KW_CASCADE() antlr.TerminalNode
	KW_CATALOG() antlr.TerminalNode
	KW_CENTURY() antlr.TerminalNode
	KW_CONFIG() antlr.TerminalNode
	KW_CONSTRAINTS() antlr.TerminalNode
	KW_CUMULATE() antlr.TerminalNode
	KW_DATA() antlr.TerminalNode
	KW_DATABASE() antlr.TerminalNode
	KW_DAYS() antlr.TerminalNode
	KW_DECADE() antlr.TerminalNode
	KW_DESC() antlr.TerminalNode
	KW_DESCRIPTOR() antlr.TerminalNode
	KW_DIV() antlr.TerminalNode
	KW_ENGINE() antlr.TerminalNode
	KW_EPOCH() antlr.TerminalNode
	KW_EXCLUDING() antlr.TerminalNode
	KW_FILE() antlr.TerminalNode
	KW_FIRST() antlr.TerminalNode
	KW_GENERATED() antlr.TerminalNode
	KW_HOP() antlr.TerminalNode
	KW_HOURS() antlr.TerminalNode
	KW_IGNORE() antlr.TerminalNode
	KW_INCLUDING() antlr.TerminalNode
	KW_JAR() antlr.TerminalNode
	KW_JARS() antlr.TerminalNode
	KW_JAVA() antlr.TerminalNode
	KW_KEY() antlr.TerminalNode
	KW_LAST() antlr.TerminalNode
	KW_LOAD() antlr.TerminalNode
	KW_MAP() antlr.TerminalNode
	KW_MICROSECOND() antlr.TerminalNode
	KW_MILLENNIUM() antlr.TerminalNode
	KW_MILLISECOND() antlr.TerminalNode
	KW_MINUTES() antlr.TerminalNode
	KW_MONTHS() antlr.TerminalNode
	KW_NANOSECOND() antlr.TerminalNode
	KW_NULLS() antlr.TerminalNode
	KW_OPTIONS() antlr.TerminalNode
	KW_PAST() antlr.TerminalNode
	KW_PLAN() antlr.TerminalNode
	KW_PRECEDING() antlr.TerminalNode
	KW_PYTHON() antlr.TerminalNode
	KW_PYTHON_ARCHIVES() antlr.TerminalNode
	KW_PYTHON_DEPENDENCIES() antlr.TerminalNode
	KW_PYTHON_FILES() antlr.TerminalNode
	KW_PYTHON_JAR() antlr.TerminalNode
	KW_PYTHON_PARAMETER() antlr.TerminalNode
	KW_PYTHON_REQUIREMENTS() antlr.TerminalNode
	KW_QUARTER() antlr.TerminalNode
	KW_REMOVE() antlr.TerminalNode
	KW_RESTRICT() antlr.TerminalNode
	KW_SECONDS() antlr.TerminalNode
	KW_SESSION() antlr.TerminalNode
	KW_SETS() antlr.TerminalNode
	KW_SIZE() antlr.TerminalNode
	KW_SLIDE() antlr.TerminalNode
	KW_STEP() antlr.TerminalNode
	KW_TEMPORARY() antlr.TerminalNode
	KW_TIMECOL() antlr.TerminalNode
	KW_TUMBLE() antlr.TerminalNode
	KW_UNLOAD() antlr.TerminalNode
	KW_VIEW() antlr.TerminalNode
	KW_WEEK() antlr.TerminalNode
	KW_YEARS() antlr.TerminalNode
	KW_ZONE() antlr.TerminalNode

	// IsNonReservedKeywordsContext differentiates from other interfaces.
	IsNonReservedKeywordsContext()
}

type NonReservedKeywordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedKeywordsContext() *NonReservedKeywordsContext {
	var p = new(NonReservedKeywordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_nonReservedKeywords
	return p
}

func InitEmptyNonReservedKeywordsContext(p *NonReservedKeywordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlinkSqlParserRULE_nonReservedKeywords
}

func (*NonReservedKeywordsContext) IsNonReservedKeywordsContext() {}

func NewNonReservedKeywordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedKeywordsContext {
	var p = new(NonReservedKeywordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlinkSqlParserRULE_nonReservedKeywords

	return p
}

func (s *NonReservedKeywordsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedKeywordsContext) KW_ADD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ADD, 0)
}

func (s *NonReservedKeywordsContext) KW_AFTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_AFTER, 0)
}

func (s *NonReservedKeywordsContext) KW_ASC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ASC, 0)
}

func (s *NonReservedKeywordsContext) KW_CASCADE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CASCADE, 0)
}

func (s *NonReservedKeywordsContext) KW_CATALOG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CATALOG, 0)
}

func (s *NonReservedKeywordsContext) KW_CENTURY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CENTURY, 0)
}

func (s *NonReservedKeywordsContext) KW_CONFIG() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONFIG, 0)
}

func (s *NonReservedKeywordsContext) KW_CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CONSTRAINTS, 0)
}

func (s *NonReservedKeywordsContext) KW_CUMULATE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_CUMULATE, 0)
}

func (s *NonReservedKeywordsContext) KW_DATA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATA, 0)
}

func (s *NonReservedKeywordsContext) KW_DATABASE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DATABASE, 0)
}

func (s *NonReservedKeywordsContext) KW_DAYS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DAYS, 0)
}

func (s *NonReservedKeywordsContext) KW_DECADE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DECADE, 0)
}

func (s *NonReservedKeywordsContext) KW_DESC() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DESC, 0)
}

func (s *NonReservedKeywordsContext) KW_DESCRIPTOR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DESCRIPTOR, 0)
}

func (s *NonReservedKeywordsContext) KW_DIV() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_DIV, 0)
}

func (s *NonReservedKeywordsContext) KW_ENGINE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ENGINE, 0)
}

func (s *NonReservedKeywordsContext) KW_EPOCH() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EPOCH, 0)
}

func (s *NonReservedKeywordsContext) KW_EXCLUDING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_EXCLUDING, 0)
}

func (s *NonReservedKeywordsContext) KW_FILE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FILE, 0)
}

func (s *NonReservedKeywordsContext) KW_FIRST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_FIRST, 0)
}

func (s *NonReservedKeywordsContext) KW_GENERATED() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_GENERATED, 0)
}

func (s *NonReservedKeywordsContext) KW_HOP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOP, 0)
}

func (s *NonReservedKeywordsContext) KW_HOURS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_HOURS, 0)
}

func (s *NonReservedKeywordsContext) KW_IGNORE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_IGNORE, 0)
}

func (s *NonReservedKeywordsContext) KW_INCLUDING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_INCLUDING, 0)
}

func (s *NonReservedKeywordsContext) KW_JAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JAR, 0)
}

func (s *NonReservedKeywordsContext) KW_JARS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JARS, 0)
}

func (s *NonReservedKeywordsContext) KW_JAVA() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_JAVA, 0)
}

func (s *NonReservedKeywordsContext) KW_KEY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_KEY, 0)
}

func (s *NonReservedKeywordsContext) KW_LAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LAST, 0)
}

func (s *NonReservedKeywordsContext) KW_LOAD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_LOAD, 0)
}

func (s *NonReservedKeywordsContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MAP, 0)
}

func (s *NonReservedKeywordsContext) KW_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MICROSECOND, 0)
}

func (s *NonReservedKeywordsContext) KW_MILLENNIUM() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MILLENNIUM, 0)
}

func (s *NonReservedKeywordsContext) KW_MILLISECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MILLISECOND, 0)
}

func (s *NonReservedKeywordsContext) KW_MINUTES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MINUTES, 0)
}

func (s *NonReservedKeywordsContext) KW_MONTHS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_MONTHS, 0)
}

func (s *NonReservedKeywordsContext) KW_NANOSECOND() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NANOSECOND, 0)
}

func (s *NonReservedKeywordsContext) KW_NULLS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_NULLS, 0)
}

func (s *NonReservedKeywordsContext) KW_OPTIONS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_OPTIONS, 0)
}

func (s *NonReservedKeywordsContext) KW_PAST() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PAST, 0)
}

func (s *NonReservedKeywordsContext) KW_PLAN() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PLAN, 0)
}

func (s *NonReservedKeywordsContext) KW_PRECEDING() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PRECEDING, 0)
}

func (s *NonReservedKeywordsContext) KW_PYTHON() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON, 0)
}

func (s *NonReservedKeywordsContext) KW_PYTHON_ARCHIVES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_ARCHIVES, 0)
}

func (s *NonReservedKeywordsContext) KW_PYTHON_DEPENDENCIES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_DEPENDENCIES, 0)
}

func (s *NonReservedKeywordsContext) KW_PYTHON_FILES() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_FILES, 0)
}

func (s *NonReservedKeywordsContext) KW_PYTHON_JAR() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_JAR, 0)
}

func (s *NonReservedKeywordsContext) KW_PYTHON_PARAMETER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_PARAMETER, 0)
}

func (s *NonReservedKeywordsContext) KW_PYTHON_REQUIREMENTS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_PYTHON_REQUIREMENTS, 0)
}

func (s *NonReservedKeywordsContext) KW_QUARTER() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_QUARTER, 0)
}

func (s *NonReservedKeywordsContext) KW_REMOVE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_REMOVE, 0)
}

func (s *NonReservedKeywordsContext) KW_RESTRICT() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_RESTRICT, 0)
}

func (s *NonReservedKeywordsContext) KW_SECONDS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SECONDS, 0)
}

func (s *NonReservedKeywordsContext) KW_SESSION() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SESSION, 0)
}

func (s *NonReservedKeywordsContext) KW_SETS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SETS, 0)
}

func (s *NonReservedKeywordsContext) KW_SIZE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SIZE, 0)
}

func (s *NonReservedKeywordsContext) KW_SLIDE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_SLIDE, 0)
}

func (s *NonReservedKeywordsContext) KW_STEP() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_STEP, 0)
}

func (s *NonReservedKeywordsContext) KW_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TEMPORARY, 0)
}

func (s *NonReservedKeywordsContext) KW_TIMECOL() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TIMECOL, 0)
}

func (s *NonReservedKeywordsContext) KW_TUMBLE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_TUMBLE, 0)
}

func (s *NonReservedKeywordsContext) KW_UNLOAD() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_UNLOAD, 0)
}

func (s *NonReservedKeywordsContext) KW_VIEW() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_VIEW, 0)
}

func (s *NonReservedKeywordsContext) KW_WEEK() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_WEEK, 0)
}

func (s *NonReservedKeywordsContext) KW_YEARS() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_YEARS, 0)
}

func (s *NonReservedKeywordsContext) KW_ZONE() antlr.TerminalNode {
	return s.GetToken(FlinkSqlParserKW_ZONE, 0)
}

func (s *NonReservedKeywordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedKeywordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedKeywordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.EnterNonReservedKeywords(s)
	}
}

func (s *NonReservedKeywordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlinkSqlParserListener); ok {
		listenerT.ExitNonReservedKeywords(s)
	}
}

func (p *FlinkSqlParser) NonReservedKeywords() (localctx INonReservedKeywordsContext) {
	localctx = NewNonReservedKeywordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, FlinkSqlParserRULE_nonReservedKeywords)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2308)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-439)) & ^0x3f) == 0 && ((int64(1)<<(_la-439))&-1) != 0) || ((int64((_la-503)) & ^0x3f) == 0 && ((int64(1)<<(_la-503))&15) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *FlinkSqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 79:
		var t *QueryStatementContext = nil
		if localctx != nil {
			t = localctx.(*QueryStatementContext)
		}
		return p.QueryStatement_Sempred(t, predIndex)

	case 89:
		var t *TableExpressionContext = nil
		if localctx != nil {
			t = localctx.(*TableExpressionContext)
		}
		return p.TableExpression_Sempred(t, predIndex)

	case 130:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 133:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 135:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *FlinkSqlParser) QueryStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlinkSqlParser) TableExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlinkSqlParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlinkSqlParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlinkSqlParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
