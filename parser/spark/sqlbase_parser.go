// Code generated from SqlBaseParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // SqlBaseParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SqlBaseParser struct {
	*antlr.BaseParser
}

var SqlBaseParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func sqlbaseparserParserInit() {
	staticData := &SqlBaseParserParserStaticData
	staticData.LiteralNames = []string{
		"", "';'", "'('", "')'", "','", "'.'", "'['", "']'", "'!'", "'ADD'",
		"'AFTER'", "'AGGREGATE'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ANTI'", "'ANY'", "'ANY_VALUE'", "'ARCHIVE'", "'ARRAY'", "'AS'",
		"'ASC'", "'AT'", "'ATOMIC'", "'AUTHORIZATION'", "'BEGIN'", "'BETWEEN'",
		"'BIGINT'", "'BINARY'", "'BINDING'", "'BOOLEAN'", "'BOTH'", "'BUCKET'",
		"'BUCKETS'", "'BY'", "'BYTE'", "'CACHE'", "'CALL'", "'CALLED'", "'CASCADE'",
		"'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CHANGE'", "'CHAR'",
		"'CHARACTER'", "'CHECK'", "'CLEAR'", "'CLUSTER'", "'CLUSTERED'", "'CODEGEN'",
		"'COLLATE'", "'COLLATION'", "'COLLECTION'", "'COLUMN'", "'COLUMNS'",
		"'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPACTIONS'", "'COMPENSATION'",
		"'COMPUTE'", "'CONCATENATE'", "'CONDITION'", "'CONSTRAINT'", "'CONTAINS'",
		"'CONTINUE'", "'COST'", "'CREATE'", "'CROSS'", "'CUBE'", "'CURRENT'",
		"'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'",
		"'DAY'", "'DAYS'", "'DAYOFYEAR'", "'DATA'", "'DATE'", "'DATABASE'",
		"'DATABASES'", "'DATEADD'", "'DATE_ADD'", "'DATEDIFF'", "'DATE_DIFF'",
		"'DBPROPERTIES'", "'DEC'", "'DECIMAL'", "'DECLARE'", "'DEFAULT'", "'DEFINED'",
		"'DEFINER'", "'DELETE'", "'DELIMITED'", "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'",
		"'DFS'", "'DIRECTORIES'", "'DIRECTORY'", "'DISTINCT'", "'DISTRIBUTE'",
		"'DIV'", "'DO'", "'DOUBLE'", "'DROP'", "'ELSE'", "'ELSEIF'", "'END'",
		"'ENFORCED'", "'ESCAPE'", "'ESCAPED'", "'EVOLUTION'", "'EXCEPT'", "'EXCHANGE'",
		"'EXCLUDE'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'EXPORT'", "'EXTEND'",
		"'EXTENDED'", "'EXTERNAL'", "'EXTRACT'", "'FALSE'", "'FETCH'", "'FIELDS'",
		"'FILTER'", "'FILEFORMAT'", "'FIRST'", "'FLOAT'", "'FLOW'", "'FOLLOWING'",
		"'FOR'", "'FOREIGN'", "'FORMAT'", "'FORMATTED'", "'FOUND'", "'FROM'",
		"'FULL'", "'FUNCTION'", "'FUNCTIONS'", "'GENERATED'", "'GLOBAL'", "'GRANT'",
		"'GROUP'", "'GROUPING'", "'HANDLER'", "'HAVING'", "'X'", "'HOUR'", "'HOURS'",
		"'IDENTIFIER'", "'IDENTITY'", "'IF'", "'IGNORE'", "'IMMEDIATE'", "'IMPORT'",
		"'IN'", "'INCLUDE'", "'INCREMENT'", "'INDEX'", "'INDEXES'", "'INNER'",
		"'INPATH'", "'INPUT'", "'INPUTFORMAT'", "'INSERT'", "'INTERSECT'", "'INTERVAL'",
		"'INT'", "'INTEGER'", "'INTO'", "'INVOKER'", "'IS'", "'ITEMS'", "'ITERATE'",
		"'JOIN'", "'JSON'", "'KEY'", "'KEYS'", "'LANGUAGE'", "'LAST'", "'LATERAL'",
		"'LAZY'", "'LEADING'", "'LEAVE'", "'LEFT'", "'LEVEL'", "'LIKE'", "'ILIKE'",
		"'LIMIT'", "'LINES'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCATION'", "'LOCK'",
		"'LOCKS'", "'LOGICAL'", "'LONG'", "'LOOP'", "'MACRO'", "'MAP'", "'MATCHED'",
		"'MATERIALIZED'", "'MAX'", "'MERGE'", "'MICROSECOND'", "'MICROSECONDS'",
		"'MILLISECOND'", "'MILLISECONDS'", "'MINUTE'", "'MINUTES'", "'MODIFIES'",
		"'MONTH'", "'MONTHS'", "'MSCK'", "'NAME'", "'NAMESPACE'", "'NAMESPACES'",
		"'NANOSECOND'", "'NANOSECONDS'", "'NATURAL'", "'NO'", "'NONE'", "'NOT'",
		"'NULL'", "'NULLS'", "'NUMERIC'", "'NORELY'", "'OF'", "'OFFSET'", "'ON'",
		"'ONLY'", "'OPTION'", "'OPTIONS'", "'OR'", "'ORDER'", "'OUT'", "'OUTER'",
		"'OUTPUTFORMAT'", "'OVER'", "'OVERLAPS'", "'OVERLAY'", "'OVERWRITE'",
		"'PARTITION'", "'PARTITIONED'", "'PARTITIONS'", "'PERCENT'", "'PIVOT'",
		"'PLACING'", "'POSITION'", "'PRECEDING'", "'PRIMARY'", "'PRINCIPALS'",
		"'PROCEDURE'", "'PROCEDURES'", "'PROPERTIES'", "'PURGE'", "'QUARTER'",
		"'QUERY'", "'RANGE'", "'READS'", "'REAL'", "'RECORDREADER'", "'RECORDWRITER'",
		"'RECOVER'", "'RECURSION'", "'RECURSIVE'", "'REDUCE'", "'REFERENCES'",
		"'REFRESH'", "'RELY'", "'RENAME'", "'REPAIR'", "'REPEAT'", "'REPEATABLE'",
		"'REPLACE'", "'RESET'", "'RESPECT'", "'RESTRICT'", "'RETURN'", "'RETURNS'",
		"'REVOKE'", "'RIGHT'", "", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'",
		"'ROW'", "'ROWS'", "'SECOND'", "'SECONDS'", "'SCHEMA'", "'SCHEMAS'",
		"'SECURITY'", "'SELECT'", "'SEMI'", "'SEPARATED'", "'SERDE'", "'SERDEPROPERTIES'",
		"'SESSION_USER'", "'SET'", "'MINUS'", "'SETS'", "'SHORT'", "'SHOW'",
		"'SINGLE'", "'SKEWED'", "'SMALLINT'", "'SOME'", "'SORT'", "'SORTED'",
		"'SOURCE'", "'SPECIFIC'", "'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", "'START'",
		"'STATISTICS'", "'STORED'", "'STRATIFY'", "'STREAM'", "'STREAMING'",
		"'STRING'", "'STRUCT'", "'SUBSTR'", "'SUBSTRING'", "'SYNC'", "'SYSTEM_TIME'",
		"'SYSTEM_VERSION'", "'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TARGET'",
		"'TBLPROPERTIES'", "", "'TERMINATED'", "'THEN'", "'TIME'", "'TIMEDIFF'",
		"'TIMESTAMP'", "'TIMESTAMP_LTZ'", "'TIMESTAMP_NTZ'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TINYINT'", "'TO'", "'EXECUTE'", "'TOUCH'", "'TRAILING'",
		"'TRANSACTION'", "'TRANSACTIONS'", "'TRANSFORM'", "'TRIM'", "'TRUE'",
		"'TRUNCATE'", "'TRY_CAST'", "'TYPE'", "'UNARCHIVE'", "'UNBOUNDED'",
		"'UNCACHE'", "'UNION'", "'UNIQUE'", "'UNKNOWN'", "'UNLOCK'", "'UNPIVOT'",
		"'UNSET'", "'UNTIL'", "'UPDATE'", "'USE'", "'USER'", "'USING'", "'VALUE'",
		"'VALUES'", "'VARCHAR'", "'VAR'", "'VARIABLE'", "'VARIANT'", "'VERSION'",
		"'VIEW'", "'VIEWS'", "'VOID'", "'WEEK'", "'WEEKS'", "'WHEN'", "'WHERE'",
		"'WHILE'", "'WINDOW'", "'WITH'", "'WITHIN'", "'WITHOUT'", "'YEAR'",
		"'YEARS'", "'ZONE'", "", "'<=>'", "'<>'", "'!='", "'<'", "", "'>'",
		"", "'<<'", "'>>'", "'>>>'", "'+'", "'-'", "'*'", "'/'", "'%'", "'~'",
		"'&'", "'|'", "'||'", "'|>'", "'^'", "':'", "'::'", "'->'", "'=>'",
		"'/*+'", "'*/'", "'?'",
	}
	staticData.SymbolicNames = []string{
		"", "SEMICOLON", "LEFT_PAREN", "RIGHT_PAREN", "COMMA", "DOT", "LEFT_BRACKET",
		"RIGHT_BRACKET", "BANG", "ADD", "AFTER", "AGGREGATE", "ALL", "ALTER",
		"ALWAYS", "ANALYZE", "AND", "ANTI", "ANY", "ANY_VALUE", "ARCHIVE", "ARRAY",
		"AS", "ASC", "AT", "ATOMIC", "AUTHORIZATION", "BEGIN", "BETWEEN", "BIGINT",
		"BINARY", "BINDING", "BOOLEAN", "BOTH", "BUCKET", "BUCKETS", "BY", "BYTE",
		"CACHE", "CALL", "CALLED", "CASCADE", "CASE", "CAST", "CATALOG", "CATALOGS",
		"CHANGE", "CHAR", "CHARACTER", "CHECK", "CLEAR", "CLUSTER", "CLUSTERED",
		"CODEGEN", "COLLATE", "COLLATION", "COLLECTION", "COLUMN", "COLUMNS",
		"COMMENT", "COMMIT", "COMPACT", "COMPACTIONS", "COMPENSATION", "COMPUTE",
		"CONCATENATE", "CONDITION", "CONSTRAINT", "CONTAINS", "CONTINUE", "COST",
		"CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "CURRENT_USER", "DAY", "DAYS", "DAYOFYEAR", "DATA",
		"DATE", "DATABASE", "DATABASES", "DATEADD", "DATE_ADD", "DATEDIFF",
		"DATE_DIFF", "DBPROPERTIES", "DEC", "DECIMAL", "DECLARE", "DEFAULT",
		"DEFINED", "DEFINER", "DELETE", "DELIMITED", "DESC", "DESCRIBE", "DETERMINISTIC",
		"DFS", "DIRECTORIES", "DIRECTORY", "DISTINCT", "DISTRIBUTE", "DIV",
		"DO", "DOUBLE", "DROP", "ELSE", "ELSEIF", "END", "ENFORCED", "ESCAPE",
		"ESCAPED", "EVOLUTION", "EXCEPT", "EXCHANGE", "EXCLUDE", "EXISTS", "EXIT",
		"EXPLAIN", "EXPORT", "EXTEND", "EXTENDED", "EXTERNAL", "EXTRACT", "FALSE",
		"FETCH", "FIELDS", "FILTER", "FILEFORMAT", "FIRST", "FLOAT", "FLOW",
		"FOLLOWING", "FOR", "FOREIGN", "FORMAT", "FORMATTED", "FOUND", "FROM",
		"FULL", "FUNCTION", "FUNCTIONS", "GENERATED", "GLOBAL", "GRANT", "GROUP",
		"GROUPING", "HANDLER", "HAVING", "BINARY_HEX", "HOUR", "HOURS", "IDENTIFIER_KW",
		"IDENTITY", "IF", "IGNORE", "IMMEDIATE", "IMPORT", "IN", "INCLUDE",
		"INCREMENT", "INDEX", "INDEXES", "INNER", "INPATH", "INPUT", "INPUTFORMAT",
		"INSERT", "INTERSECT", "INTERVAL", "INT", "INTEGER", "INTO", "INVOKER",
		"IS", "ITEMS", "ITERATE", "JOIN", "JSON", "KEY", "KEYS", "LANGUAGE",
		"LAST", "LATERAL", "LAZY", "LEADING", "LEAVE", "LEFT", "LEVEL", "LIKE",
		"ILIKE", "LIMIT", "LINES", "LIST", "LOAD", "LOCAL", "LOCATION", "LOCK",
		"LOCKS", "LOGICAL", "LONG", "LOOP", "MACRO", "MAP", "MATCHED", "MATERIALIZED",
		"MAX", "MERGE", "MICROSECOND", "MICROSECONDS", "MILLISECOND", "MILLISECONDS",
		"MINUTE", "MINUTES", "MODIFIES", "MONTH", "MONTHS", "MSCK", "NAME",
		"NAMESPACE", "NAMESPACES", "NANOSECOND", "NANOSECONDS", "NATURAL", "NO",
		"NONE", "NOT", "NULL", "NULLS", "NUMERIC", "NORELY", "OF", "OFFSET",
		"ON", "ONLY", "OPTION", "OPTIONS", "OR", "ORDER", "OUT", "OUTER", "OUTPUTFORMAT",
		"OVER", "OVERLAPS", "OVERLAY", "OVERWRITE", "PARTITION", "PARTITIONED",
		"PARTITIONS", "PERCENTLIT", "PIVOT", "PLACING", "POSITION", "PRECEDING",
		"PRIMARY", "PRINCIPALS", "PROCEDURE", "PROCEDURES", "PROPERTIES", "PURGE",
		"QUARTER", "QUERY", "RANGE", "READS", "REAL", "RECORDREADER", "RECORDWRITER",
		"RECOVER", "RECURSION", "RECURSIVE", "REDUCE", "REFERENCES", "REFRESH",
		"RELY", "RENAME", "REPAIR", "REPEAT", "REPEATABLE", "REPLACE", "RESET",
		"RESPECT", "RESTRICT", "RETURN", "RETURNS", "REVOKE", "RIGHT", "RLIKE",
		"ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "SECOND", "SECONDS",
		"SCHEMA", "SCHEMAS", "SECURITY", "SELECT", "SEMI", "SEPARATED", "SERDE",
		"SERDEPROPERTIES", "SESSION_USER", "SET", "SETMINUS", "SETS", "SHORT",
		"SHOW", "SINGLE", "SKEWED", "SMALLINT", "SOME", "SORT", "SORTED", "SOURCE",
		"SPECIFIC", "SQL", "SQLEXCEPTION", "SQLSTATE", "START", "STATISTICS",
		"STORED", "STRATIFY", "STREAM", "STREAMING", "STRING", "STRUCT", "SUBSTR",
		"SUBSTRING", "SYNC", "SYSTEM_TIME", "SYSTEM_VERSION", "TABLE", "TABLES",
		"TABLESAMPLE", "TARGET", "TBLPROPERTIES", "TEMPORARY", "TERMINATED",
		"THEN", "TIME", "TIMEDIFF", "TIMESTAMP", "TIMESTAMP_LTZ", "TIMESTAMP_NTZ",
		"TIMESTAMPADD", "TIMESTAMPDIFF", "TINYINT", "TO", "EXECUTE", "TOUCH",
		"TRAILING", "TRANSACTION", "TRANSACTIONS", "TRANSFORM", "TRIM", "TRUE",
		"TRUNCATE", "TRY_CAST", "TYPE", "UNARCHIVE", "UNBOUNDED", "UNCACHE",
		"UNION", "UNIQUE", "UNKNOWN", "UNLOCK", "UNPIVOT", "UNSET", "UNTIL",
		"UPDATE", "USE", "USER", "USING", "VALUE", "VALUES", "VARCHAR", "VAR",
		"VARIABLE", "VARIANT", "VERSION", "VIEW", "VIEWS", "VOID", "WEEK", "WEEKS",
		"WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "YEAR",
		"YEARS", "ZONE", "EQ", "NSEQ", "NEQ", "NEQJ", "LT", "LTE", "GT", "GTE",
		"SHIFT_LEFT", "SHIFT_RIGHT", "SHIFT_RIGHT_UNSIGNED", "PLUS", "MINUS",
		"ASTERISK", "SLASH", "PERCENT", "TILDE", "AMPERSAND", "PIPE", "CONCAT_PIPE",
		"OPERATOR_PIPE", "HAT", "COLON", "DOUBLE_COLON", "ARROW", "FAT_ARROW",
		"HENT_START", "HENT_END", "QUESTION", "STRING_LITERAL", "DOUBLEQUOTED_STRING",
		"BIGINT_LITERAL", "SMALLINT_LITERAL", "TINYINT_LITERAL", "INTEGER_VALUE",
		"EXPONENT_VALUE", "DECIMAL_VALUE", "FLOAT_LITERAL", "DOUBLE_LITERAL",
		"BIGDECIMAL_LITERAL", "IDENTIFIER", "BACKQUOTED_IDENTIFIER", "SIMPLE_COMMENT",
		"BRACKETED_COMMENT", "WS", "UNRECOGNIZED",
	}
	staticData.RuleNames = []string{
		"program", "compoundOrSingleStatement", "singleCompoundStatement", "beginEndCompoundBlock",
		"compoundBody", "compoundStatement", "setStatementInsideSqlScript",
		"sqlStateValue", "declareConditionStatement", "conditionValue", "conditionValues",
		"declareHandlerStatement", "whileStatement", "ifElseStatement", "repeatStatement",
		"leaveStatement", "iterateStatement", "caseStatement", "loopStatement",
		"forStatement", "singleStatement", "beginLabel", "endLabel", "singleExpression",
		"singleTableIdentifier", "singleMultipartIdentifier", "singleFunctionIdentifier",
		"singleDataType", "singleTableSchema", "singleRoutineParamList", "statement",
		"materializedView", "streamingTable", "createPipelineDatasetHeader",
		"streamRelationPrimary", "setResetStatement", "executeImmediate", "executeImmediateUsing",
		"timezone", "configKey", "configValue", "unsupportedHiveNativeCommands",
		"createTableHeader", "replaceTableHeader", "clusterBySpec", "bucketSpec",
		"skewSpec", "locationSpec", "schemaBinding", "commentSpec", "singleQuery",
		"query", "insertInto", "partitionSpecLocation", "partitionSpec", "partitionVal",
		"createPipelineFlowHeader", "namespace", "namespaces", "variable", "describeFuncName",
		"describeColName", "ctes", "namedQuery", "tableProvider", "createTableClauses",
		"propertyList", "property", "propertyKey", "propertyValue", "expressionPropertyList",
		"expressionProperty", "constantList", "nestedConstantList", "createFileFormat",
		"fileFormat", "storageHandler", "resource", "dmlStatementNoWith", "identifierReference",
		"catalogIdentifierReference", "queryOrganization", "multiInsertQueryBody",
		"queryTerm", "queryPrimary", "sortItem", "fromStatement", "fromStatementBody",
		"querySpecification", "transformClause", "selectClause", "setClause",
		"matchedClause", "notMatchedClause", "notMatchedBySourceClause", "matchedAction",
		"notMatchedAction", "notMatchedBySourceAction", "exceptClause", "assignmentList",
		"assignment", "whereClause", "havingClause", "hint", "hintStatement",
		"fromClause", "temporalClause", "aggregationClause", "groupByClause",
		"groupingAnalytics", "groupingElement", "groupingSet", "pivotClause",
		"pivotColumn", "pivotValue", "unpivotClause", "unpivotNullClause", "unpivotOperator",
		"unpivotSingleValueColumnClause", "unpivotMultiValueColumnClause", "unpivotColumnSet",
		"unpivotValueColumn", "unpivotNameColumn", "unpivotColumnAndAlias",
		"unpivotColumn", "unpivotAlias", "lateralView", "setQuantifier", "relation",
		"relationExtension", "joinRelation", "joinType", "joinCriteria", "sample",
		"sampleMethod", "identifierList", "identifierSeq", "orderedIdentifierList",
		"orderedIdentifier", "identifierCommentList", "identifierComment", "relationPrimary",
		"optionsClause", "inlineTable", "functionTableSubqueryArgument", "tableArgumentPartitioning",
		"functionTableNamedArgumentExpression", "functionTableReferenceArgument",
		"functionTableArgument", "functionTable", "tableAlias", "rowFormat",
		"multipartIdentifierList", "multipartIdentifier", "multipartIdentifierPropertyList",
		"multipartIdentifierProperty", "tableIdentifier", "functionIdentifier",
		"namedExpression", "namedExpressionSeq", "partitionFieldList", "partitionField",
		"transform", "transformArgument", "expression", "namedArgumentExpression",
		"functionArgument", "expressionSeq", "booleanExpression", "predicate",
		"errorCapturingNot", "valueExpression", "shiftOperator", "datetimeUnit",
		"primaryExpression", "semiStructuredExtractionPath", "jsonPathIdentifier",
		"jsonPathBracketedIdentifier", "jsonPathFirstPart", "jsonPathParts",
		"literalType", "constant", "comparisonOperator", "arithmeticOperator",
		"predicateOperator", "booleanValue", "interval", "errorCapturingMultiUnitsInterval",
		"multiUnitsInterval", "errorCapturingUnitToUnitInterval", "unitToUnitInterval",
		"intervalValue", "unitInMultiUnits", "unitInUnitToUnit", "colPosition",
		"collationSpec", "collateClause", "nonTrivialPrimitiveType", "trivialPrimitiveType",
		"primitiveType", "dataType", "qualifiedColTypeWithPositionList", "qualifiedColTypeWithPosition",
		"colDefinitionDescriptorWithPosition", "defaultExpression", "variableDefaultExpression",
		"colTypeList", "colType", "tableElementList", "tableElement", "colDefinitionList",
		"colDefinition", "colDefinitionOption", "generationExpression", "identityColSpec",
		"sequenceGeneratorOption", "sequenceGeneratorStartOrStep", "complexColTypeList",
		"complexColType", "routineCharacteristics", "routineLanguage", "specificName",
		"deterministic", "sqlDataAccess", "nullCall", "rightsClause", "whenClause",
		"windowClause", "namedWindow", "windowSpec", "windowFrame", "frameBound",
		"qualifiedNameList", "functionName", "qualifiedName", "errorCapturingIdentifier",
		"errorCapturingIdentifierExtra", "identifier", "strictIdentifier", "quotedIdentifier",
		"backQuotedIdentifier", "number", "columnConstraintDefinition", "columnConstraint",
		"tableConstraintDefinition", "tableConstraint", "checkConstraint", "uniqueSpec",
		"uniqueConstraint", "referenceSpec", "foreignKeyConstraint", "constraintCharacteristic",
		"enforcedCharacteristic", "relyCharacteristic", "alterColumnSpecList",
		"alterColumnSpec", "alterColumnAction", "stringLit", "comment", "version",
		"operatorPipeRightSide", "operatorPipeSetAssignmentSeq", "ansiNonReserved",
		"strictNonReserved", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 447, 4847, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 1, 0, 4, 0, 532, 8,
		0, 11, 0, 12, 0, 533, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 540, 8, 1, 1, 2, 1,
		2, 1, 2, 3, 2, 545, 8, 2, 1, 2, 3, 2, 548, 8, 2, 1, 2, 1, 2, 3, 2, 552,
		8, 2, 1, 3, 3, 3, 555, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3, 560, 8, 3, 1, 3, 3,
		3, 563, 8, 3, 1, 3, 1, 3, 3, 3, 567, 8, 3, 1, 4, 1, 4, 1, 4, 4, 4, 572,
		8, 4, 11, 4, 12, 4, 573, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 589, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 602, 8, 6, 1, 7, 1, 7,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 612, 8, 8, 1, 8, 3, 8, 615, 8,
		8, 1, 9, 1, 9, 3, 9, 619, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 626,
		8, 9, 1, 10, 1, 10, 1, 10, 5, 10, 631, 8, 10, 10, 10, 12, 10, 634, 9, 10,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 644, 8,
		11, 1, 12, 3, 12, 647, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 3, 12, 656, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 5, 13, 667, 8, 13, 10, 13, 12, 13, 670, 9, 13, 1, 13,
		1, 13, 3, 13, 674, 8, 13, 1, 13, 1, 13, 1, 13, 1, 14, 3, 14, 680, 8, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 689, 8, 14, 1,
		15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 4, 17, 703, 8, 17, 11, 17, 12, 17, 704, 1, 17, 1, 17, 3, 17, 709,
		8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 4, 17, 721, 8, 17, 11, 17, 12, 17, 722, 1, 17, 1, 17, 3, 17, 727, 8,
		17, 1, 17, 1, 17, 1, 17, 3, 17, 732, 8, 17, 1, 18, 3, 18, 735, 8, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 742, 8, 18, 1, 19, 3, 19, 745, 8,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 751, 8, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 3, 19, 759, 8, 19, 1, 20, 1, 20, 3, 20, 763, 8, 20,
		1, 20, 3, 20, 766, 8, 20, 1, 20, 3, 20, 769, 8, 20, 1, 21, 1, 21, 1, 21,
		1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1,
		25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 29,
		1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 3, 30, 800, 8, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 3, 30, 818, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 5, 30, 827, 8, 30, 10, 30, 12, 30, 830, 9, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 861, 8, 30, 1,
		30, 1, 30, 3, 30, 865, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 871, 8,
		30, 1, 30, 3, 30, 874, 8, 30, 1, 30, 3, 30, 877, 8, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 884, 8, 30, 1, 30, 3, 30, 887, 8, 30, 1, 30, 1,
		30, 3, 30, 891, 8, 30, 1, 30, 3, 30, 894, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 902, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 913, 8, 30, 10, 30, 12, 30, 916, 9,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 923, 8, 30, 1, 30, 3, 30,
		926, 8, 30, 1, 30, 1, 30, 3, 30, 930, 8, 30, 1, 30, 3, 30, 933, 8, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 939, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 950, 8, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 3, 30, 956, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 961, 8, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 995, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1008, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1033,
		8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1042, 8,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1050, 8, 30, 1, 30,
		1, 30, 3, 30, 1054, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1059, 8, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 3, 30, 1065, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1077, 8, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1085, 8, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 1091, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1105, 8, 30, 1, 30, 4, 30,
		1108, 8, 30, 11, 30, 12, 30, 1109, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1126,
		8, 30, 1, 30, 1, 30, 1, 30, 5, 30, 1131, 8, 30, 10, 30, 12, 30, 1134, 9,
		30, 1, 30, 3, 30, 1137, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1143,
		8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1161, 8, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1181, 8, 30, 1, 30,
		1, 30, 3, 30, 1185, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1191, 8,
		30, 1, 30, 1, 30, 3, 30, 1195, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30,
		1201, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1207, 8, 30, 1, 30, 3,
		30, 1210, 8, 30, 1, 30, 3, 30, 1213, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 1220, 8, 30, 1, 30, 1, 30, 3, 30, 1224, 8, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 1234, 8, 30, 10, 30,
		12, 30, 1237, 9, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1245,
		8, 30, 1, 30, 3, 30, 1248, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 3, 30, 1257, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1262, 8, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1268, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1280, 8, 30, 1, 30,
		3, 30, 1283, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1290, 8,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 1299, 8, 30,
		10, 30, 12, 30, 1302, 9, 30, 3, 30, 1304, 8, 30, 1, 30, 1, 30, 1, 30, 3,
		30, 1309, 8, 30, 1, 30, 3, 30, 1312, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 1319, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1324, 8, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1334, 8, 30,
		3, 30, 1336, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1342, 8, 30, 1,
		30, 1, 30, 3, 30, 1346, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1351, 8, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1357, 8, 30, 1, 30, 3, 30, 1360, 8,
		30, 1, 30, 1, 30, 1, 30, 5, 30, 1365, 8, 30, 10, 30, 12, 30, 1368, 9, 30,
		1, 30, 3, 30, 1371, 8, 30, 1, 30, 3, 30, 1374, 8, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 1381, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30,
		1387, 8, 30, 1, 30, 1, 30, 3, 30, 1391, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1397, 8, 30, 1, 30, 3, 30, 1400, 8, 30, 1, 30, 3, 30, 1403,
		8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1410, 8, 30, 1, 30, 1,
		30, 1, 30, 3, 30, 1415, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 1424, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3,
		30, 1432, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1438, 8, 30, 1, 30,
		3, 30, 1441, 8, 30, 1, 30, 3, 30, 1444, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1450, 8, 30, 1, 30, 1, 30, 3, 30, 1454, 8, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 1459, 8, 30, 1, 30, 3, 30, 1462, 8, 30, 1, 30, 1, 30, 3,
		30, 1466, 8, 30, 3, 30, 1468, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30,
		1474, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1482, 8,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1490, 8, 30, 1, 30,
		3, 30, 1493, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1498, 8, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1507, 8, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 3, 30, 1513, 8, 30, 1, 30, 3, 30, 1516, 8, 30, 1, 30, 1,
		30, 3, 30, 1520, 8, 30, 1, 30, 3, 30, 1523, 8, 30, 1, 30, 1, 30, 3, 30,
		1527, 8, 30, 1, 30, 1, 30, 3, 30, 1531, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5,
		30, 1557, 8, 30, 10, 30, 12, 30, 1560, 9, 30, 3, 30, 1562, 8, 30, 1, 30,
		1, 30, 3, 30, 1566, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1572, 8,
		30, 1, 30, 3, 30, 1575, 8, 30, 1, 30, 3, 30, 1578, 8, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 3, 30, 1584, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1592, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1597, 8, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 3, 30, 1603, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3,
		30, 1609, 8, 30, 1, 30, 3, 30, 1612, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 1619, 8, 30, 1, 30, 1, 30, 1, 30, 5, 30, 1624, 8, 30, 10,
		30, 12, 30, 1627, 9, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30,
		1635, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1640, 8, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1645, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1652,
		8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1658, 8, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1663, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 5, 30, 1673, 8, 30, 10, 30, 12, 30, 1676, 9, 30, 3, 30, 1678, 8,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 1684, 8, 30, 10, 30, 12, 30, 1687,
		9, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1692, 8, 30, 1, 30, 3, 30, 1695, 8,
		30, 1, 30, 3, 30, 1698, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1703, 8, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1709, 8, 30, 1, 31, 1, 31, 1, 31, 1,
		32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 3, 33, 1720, 8, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 3, 33, 1726, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 3,
		34, 1733, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34,
		1742, 8, 34, 1, 34, 1, 34, 3, 34, 1746, 8, 34, 1, 35, 1, 35, 1, 35, 5,
		35, 1751, 8, 35, 10, 35, 12, 35, 1754, 9, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 1768, 8,
		35, 10, 35, 12, 35, 1771, 9, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 1796, 8, 35, 10,
		35, 12, 35, 1799, 9, 35, 3, 35, 1801, 8, 35, 1, 35, 1, 35, 5, 35, 1805,
		8, 35, 10, 35, 12, 35, 1808, 9, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35,
		1814, 8, 35, 10, 35, 12, 35, 1817, 9, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5,
		35, 1823, 8, 35, 10, 35, 12, 35, 1826, 9, 35, 3, 35, 1828, 8, 35, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 1835, 8, 36, 1, 36, 3, 36, 1838, 8,
		36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1847, 8, 37,
		1, 38, 1, 38, 3, 38, 1851, 8, 38, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1863, 8, 41, 1, 41, 1, 41, 3, 41,
		1867, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1874, 8, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1990,
		8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1998, 8, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2006, 8, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2015, 8, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2025, 8, 41, 1, 42, 1, 42,
		3, 42, 2029, 8, 42, 1, 42, 3, 42, 2032, 8, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 3, 42, 2039, 8, 42, 1, 42, 1, 42, 1, 43, 1, 43, 3, 43, 2045,
		8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 2063, 8, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 2075,
		8, 46, 1, 46, 1, 46, 1, 46, 3, 46, 2080, 8, 46, 1, 47, 1, 47, 1, 47, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 2092, 8, 48, 1, 49,
		1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 51, 3, 51, 2101, 8, 51, 1, 51, 1,
		51, 1, 51, 1, 52, 1, 52, 1, 52, 3, 52, 2109, 8, 52, 1, 52, 1, 52, 3, 52,
		2113, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2120, 8, 52, 3,
		52, 2122, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2127, 8, 52, 1, 52, 1, 52,
		1, 52, 3, 52, 2132, 8, 52, 1, 52, 1, 52, 3, 52, 2136, 8, 52, 1, 52, 3,
		52, 2139, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2145, 8, 52, 1, 52,
		1, 52, 1, 52, 3, 52, 2150, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2155, 8,
		52, 1, 52, 1, 52, 3, 52, 2159, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 3, 52, 2167, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2172, 8, 52, 1,
		52, 3, 52, 2175, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2180, 8, 52, 1, 52,
		1, 52, 3, 52, 2184, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2189, 8, 52, 3,
		52, 2191, 8, 52, 1, 53, 1, 53, 3, 53, 2195, 8, 53, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 5, 54, 2202, 8, 54, 10, 54, 12, 54, 2205, 9, 54, 1, 54, 1,
		54, 1, 55, 1, 55, 1, 55, 3, 55, 2212, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		3, 55, 2218, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2224, 8, 56, 1,
		56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 2241, 8, 60, 1, 61, 1, 61, 1, 61, 5,
		61, 2246, 8, 61, 10, 61, 12, 61, 2249, 9, 61, 1, 62, 1, 62, 3, 62, 2253,
		8, 62, 1, 62, 1, 62, 1, 62, 5, 62, 2258, 8, 62, 10, 62, 12, 62, 2261, 9,
		62, 1, 63, 1, 63, 3, 63, 2265, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63,
		2271, 8, 63, 1, 63, 3, 63, 2274, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 2298, 8, 65, 10,
		65, 12, 65, 2301, 9, 65, 1, 66, 1, 66, 1, 66, 1, 66, 5, 66, 2307, 8, 66,
		10, 66, 12, 66, 2310, 9, 66, 1, 66, 1, 66, 1, 67, 1, 67, 3, 67, 2316, 8,
		67, 1, 67, 3, 67, 2319, 8, 67, 1, 68, 1, 68, 1, 68, 5, 68, 2324, 8, 68,
		10, 68, 12, 68, 2327, 9, 68, 1, 68, 3, 68, 2330, 8, 68, 1, 69, 1, 69, 1,
		69, 1, 69, 3, 69, 2336, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 2342,
		8, 70, 10, 70, 12, 70, 2345, 9, 70, 1, 70, 1, 70, 1, 71, 1, 71, 3, 71,
		2351, 8, 71, 1, 71, 3, 71, 2354, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 5,
		72, 2360, 8, 72, 10, 72, 12, 72, 2363, 9, 72, 1, 72, 1, 72, 1, 73, 1, 73,
		1, 73, 1, 73, 5, 73, 2371, 8, 73, 10, 73, 12, 73, 2374, 9, 73, 1, 73, 1,
		73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2384, 8, 74, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2392, 8, 75, 1, 76, 1, 76, 1,
		76, 1, 76, 3, 76, 2398, 8, 76, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 4, 78, 2408, 8, 78, 11, 78, 12, 78, 2409, 1, 78, 1, 78, 1,
		78, 1, 78, 1, 78, 3, 78, 2417, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		3, 78, 2424, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2430, 8, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2441,
		8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 2447, 8, 78, 10, 78, 12, 78,
		2450, 9, 78, 1, 78, 5, 78, 2453, 8, 78, 10, 78, 12, 78, 2456, 9, 78, 1,
		78, 5, 78, 2459, 8, 78, 10, 78, 12, 78, 2462, 9, 78, 3, 78, 2464, 8, 78,
		1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 2472, 8, 79, 1, 80, 1,
		80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 2481, 8, 80, 1, 81, 1, 81,
		1, 81, 1, 81, 1, 81, 5, 81, 2488, 8, 81, 10, 81, 12, 81, 2491, 9, 81, 3,
		81, 2493, 8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 2500, 8, 81,
		10, 81, 12, 81, 2503, 9, 81, 3, 81, 2505, 8, 81, 1, 81, 1, 81, 1, 81, 1,
		81, 1, 81, 5, 81, 2512, 8, 81, 10, 81, 12, 81, 2515, 9, 81, 3, 81, 2517,
		8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 2524, 8, 81, 10, 81, 12,
		81, 2527, 9, 81, 3, 81, 2529, 8, 81, 1, 81, 3, 81, 2532, 8, 81, 1, 81,
		1, 81, 1, 81, 3, 81, 2537, 8, 81, 3, 81, 2539, 8, 81, 1, 81, 1, 81, 3,
		81, 2543, 8, 81, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 3, 83, 2555, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3,
		83, 2562, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 2569, 8, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 2575, 8, 83, 10, 83, 12, 83, 2578, 9,
		83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84,
		2589, 8, 84, 1, 85, 1, 85, 3, 85, 2593, 8, 85, 1, 85, 1, 85, 3, 85, 2597,
		8, 85, 1, 86, 1, 86, 5, 86, 2601, 8, 86, 10, 86, 12, 86, 2604, 9, 86, 1,
		87, 1, 87, 3, 87, 2608, 8, 87, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 2614,
		8, 87, 10, 87, 12, 87, 2617, 9, 87, 1, 87, 3, 87, 2620, 8, 87, 1, 87, 3,
		87, 2623, 8, 87, 1, 87, 3, 87, 2626, 8, 87, 1, 87, 3, 87, 2629, 8, 87,
		1, 87, 1, 87, 3, 87, 2633, 8, 87, 1, 88, 1, 88, 3, 88, 2637, 8, 88, 1,
		88, 5, 88, 2640, 8, 88, 10, 88, 12, 88, 2643, 9, 88, 1, 88, 3, 88, 2646,
		8, 88, 1, 88, 3, 88, 2649, 8, 88, 1, 88, 3, 88, 2652, 8, 88, 1, 88, 3,
		88, 2655, 8, 88, 1, 88, 1, 88, 3, 88, 2659, 8, 88, 1, 88, 5, 88, 2662,
		8, 88, 10, 88, 12, 88, 2665, 9, 88, 1, 88, 3, 88, 2668, 8, 88, 1, 88, 3,
		88, 2671, 8, 88, 1, 88, 3, 88, 2674, 8, 88, 1, 88, 3, 88, 2677, 8, 88,
		3, 88, 2679, 8, 88, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 2685, 8, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 2692, 8, 89, 1, 89, 1, 89, 1, 89,
		3, 89, 2697, 8, 89, 1, 89, 3, 89, 2700, 8, 89, 1, 89, 3, 89, 2703, 8, 89,
		1, 89, 1, 89, 3, 89, 2707, 8, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 3, 89, 2717, 8, 89, 1, 89, 1, 89, 3, 89, 2721, 8, 89,
		3, 89, 2723, 8, 89, 1, 89, 3, 89, 2726, 8, 89, 1, 89, 1, 89, 3, 89, 2730,
		8, 89, 1, 90, 1, 90, 5, 90, 2734, 8, 90, 10, 90, 12, 90, 2737, 9, 90, 1,
		90, 3, 90, 2740, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92,
		1, 92, 1, 92, 3, 92, 2751, 8, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1,
		93, 1, 93, 1, 93, 3, 93, 2761, 8, 93, 1, 93, 1, 93, 3, 93, 2765, 8, 93,
		1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3,
		94, 2777, 8, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95,
		1, 95, 1, 95, 3, 95, 2789, 8, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1,
		96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 2802, 8, 96, 10, 96, 12,
		96, 2805, 9, 96, 1, 96, 1, 96, 3, 96, 2809, 8, 96, 1, 97, 1, 97, 1, 97,
		1, 97, 3, 97, 2815, 8, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1,
		99, 1, 99, 5, 99, 2825, 8, 99, 10, 99, 12, 99, 2828, 9, 99, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1,
		103, 1, 103, 1, 103, 3, 103, 2843, 8, 103, 1, 103, 5, 103, 2846, 8, 103,
		10, 103, 12, 103, 2849, 9, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104,
		1, 104, 1, 104, 1, 104, 5, 104, 2859, 8, 104, 10, 104, 12, 104, 2862, 9,
		104, 1, 104, 1, 104, 3, 104, 2866, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105,
		5, 105, 2872, 8, 105, 10, 105, 12, 105, 2875, 9, 105, 1, 105, 5, 105, 2878,
		8, 105, 10, 105, 12, 105, 2881, 9, 105, 1, 105, 3, 105, 2884, 8, 105, 1,
		105, 3, 105, 2887, 8, 105, 1, 106, 3, 106, 2890, 8, 106, 1, 106, 1, 106,
		1, 106, 1, 106, 1, 106, 3, 106, 2897, 8, 106, 1, 106, 1, 106, 1, 106, 1,
		106, 3, 106, 2903, 8, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 5, 107,
		2910, 8, 107, 10, 107, 12, 107, 2913, 9, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 5, 107, 2920, 8, 107, 10, 107, 12, 107, 2923, 9, 107, 1, 107,
		1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		5, 107, 2935, 8, 107, 10, 107, 12, 107, 2938, 9, 107, 1, 107, 1, 107, 3,
		107, 2942, 8, 107, 3, 107, 2944, 8, 107, 1, 108, 1, 108, 3, 108, 2948,
		8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 5, 109, 2955, 8, 109, 10,
		109, 12, 109, 2958, 9, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 5, 109, 2968, 8, 109, 10, 109, 12, 109, 2971, 9, 109,
		1, 109, 1, 109, 3, 109, 2975, 8, 109, 1, 110, 1, 110, 3, 110, 2979, 8,
		110, 1, 111, 1, 111, 1, 111, 1, 111, 5, 111, 2985, 8, 111, 10, 111, 12,
		111, 2988, 9, 111, 3, 111, 2990, 8, 111, 1, 111, 1, 111, 3, 111, 2994,
		8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112,
		1, 112, 1, 112, 5, 112, 3006, 8, 112, 10, 112, 12, 112, 3009, 9, 112, 1,
		112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 5, 113, 3019,
		8, 113, 10, 113, 12, 113, 3022, 9, 113, 1, 113, 1, 113, 3, 113, 3026, 8,
		113, 1, 114, 1, 114, 3, 114, 3030, 8, 114, 1, 114, 3, 114, 3033, 8, 114,
		1, 115, 1, 115, 3, 115, 3037, 8, 115, 1, 115, 1, 115, 1, 115, 1, 115, 3,
		115, 3043, 8, 115, 1, 115, 3, 115, 3046, 8, 115, 1, 116, 1, 116, 1, 116,
		1, 117, 1, 117, 3, 117, 3053, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1,
		118, 1, 118, 1, 118, 1, 118, 5, 118, 3063, 8, 118, 10, 118, 12, 118, 3066,
		9, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 5, 119, 3074, 8,
		119, 10, 119, 12, 119, 3077, 9, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 5, 119, 3087, 8, 119, 10, 119, 12, 119, 3090,
		9, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 3098, 8,
		120, 10, 120, 12, 120, 3101, 9, 120, 1, 120, 1, 120, 3, 120, 3105, 8, 120,
		1, 121, 1, 121, 1, 122, 1, 122, 1, 123, 1, 123, 3, 123, 3113, 8, 123, 1,
		124, 1, 124, 1, 125, 3, 125, 3118, 8, 125, 1, 125, 1, 125, 1, 126, 1, 126,
		1, 126, 3, 126, 3125, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 5,
		126, 3132, 8, 126, 10, 126, 12, 126, 3135, 9, 126, 3, 126, 3137, 8, 126,
		1, 126, 1, 126, 1, 126, 3, 126, 3142, 8, 126, 1, 126, 1, 126, 1, 126, 5,
		126, 3147, 8, 126, 10, 126, 12, 126, 3150, 9, 126, 3, 126, 3152, 8, 126,
		1, 127, 1, 127, 1, 128, 3, 128, 3157, 8, 128, 1, 128, 1, 128, 5, 128, 3161,
		8, 128, 10, 128, 12, 128, 3164, 9, 128, 1, 129, 1, 129, 1, 129, 3, 129,
		3169, 8, 129, 1, 130, 1, 130, 1, 130, 3, 130, 3174, 8, 130, 1, 130, 1,
		130, 3, 130, 3178, 8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 3184,
		8, 130, 1, 130, 1, 130, 3, 130, 3188, 8, 130, 1, 131, 3, 131, 3191, 8,
		131, 1, 131, 1, 131, 1, 131, 3, 131, 3196, 8, 131, 1, 131, 3, 131, 3199,
		8, 131, 1, 131, 1, 131, 1, 131, 3, 131, 3204, 8, 131, 1, 131, 1, 131, 3,
		131, 3208, 8, 131, 1, 131, 3, 131, 3211, 8, 131, 1, 131, 3, 131, 3214,
		8, 131, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132, 3220, 8, 132, 1, 133, 1,
		133, 1, 133, 3, 133, 3225, 8, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133,
		3, 133, 3232, 8, 133, 1, 134, 3, 134, 3235, 8, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 3253, 8, 134, 3, 134, 3255,
		8, 134, 1, 134, 3, 134, 3258, 8, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1,
		136, 1, 136, 1, 136, 5, 136, 3267, 8, 136, 10, 136, 12, 136, 3270, 9, 136,
		1, 137, 1, 137, 1, 137, 1, 137, 5, 137, 3276, 8, 137, 10, 137, 12, 137,
		3279, 9, 137, 1, 137, 1, 137, 1, 138, 1, 138, 3, 138, 3285, 8, 138, 1,
		139, 1, 139, 1, 139, 1, 139, 5, 139, 3291, 8, 139, 10, 139, 12, 139, 3294,
		9, 139, 1, 139, 1, 139, 1, 140, 1, 140, 3, 140, 3300, 8, 140, 1, 141, 1,
		141, 1, 141, 3, 141, 3305, 8, 141, 1, 141, 3, 141, 3308, 8, 141, 1, 141,
		3, 141, 3311, 8, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3,
		141, 3319, 8, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3, 141,
		3327, 8, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3, 141, 3333, 8, 141, 1,
		142, 1, 142, 1, 142, 1, 143, 1, 143, 1, 143, 1, 143, 5, 143, 3342, 8, 143,
		10, 143, 12, 143, 3345, 9, 143, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144,
		3, 144, 3352, 8, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 3359,
		8, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 3366, 8, 144, 3,
		144, 3368, 8, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145,
		1, 145, 1, 145, 5, 145, 3379, 8, 145, 10, 145, 12, 145, 3382, 9, 145, 1,
		145, 1, 145, 1, 145, 1, 145, 1, 145, 4, 145, 3389, 8, 145, 11, 145, 12,
		145, 3390, 1, 145, 3, 145, 3394, 8, 145, 3, 145, 3396, 8, 145, 1, 145,
		1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 5, 145, 3404, 8, 145, 10, 145,
		12, 145, 3407, 9, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 4, 145,
		3414, 8, 145, 11, 145, 12, 145, 3415, 1, 145, 3, 145, 3419, 8, 145, 3,
		145, 3421, 8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 3, 147,
		3429, 8, 147, 1, 148, 1, 148, 3, 148, 3433, 8, 148, 1, 149, 1, 149, 1,
		149, 1, 149, 1, 149, 5, 149, 3440, 8, 149, 10, 149, 12, 149, 3443, 9, 149,
		3, 149, 3445, 8, 149, 1, 149, 1, 149, 1, 149, 1, 150, 3, 150, 3451, 8,
		150, 1, 150, 1, 150, 3, 150, 3455, 8, 150, 3, 150, 3457, 8, 150, 1, 151,
		1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 3466, 8, 151, 1,
		151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1,
		151, 3, 151, 3478, 8, 151, 3, 151, 3480, 8, 151, 1, 151, 1, 151, 1, 151,
		1, 151, 1, 151, 3, 151, 3487, 8, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1,
		151, 3, 151, 3494, 8, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 3500,
		8, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 3506, 8, 151, 3, 151, 3508,
		8, 151, 1, 152, 1, 152, 1, 152, 5, 152, 3513, 8, 152, 10, 152, 12, 152,
		3516, 9, 152, 1, 153, 1, 153, 1, 153, 5, 153, 3521, 8, 153, 10, 153, 12,
		153, 3524, 9, 153, 1, 154, 1, 154, 1, 154, 5, 154, 3529, 8, 154, 10, 154,
		12, 154, 3532, 9, 154, 1, 155, 1, 155, 1, 155, 3, 155, 3537, 8, 155, 1,
		156, 1, 156, 1, 156, 3, 156, 3542, 8, 156, 1, 156, 1, 156, 1, 157, 1, 157,
		1, 157, 3, 157, 3549, 8, 157, 1, 157, 1, 157, 1, 158, 1, 158, 3, 158, 3555,
		8, 158, 1, 158, 1, 158, 3, 158, 3559, 8, 158, 3, 158, 3561, 8, 158, 1,
		159, 1, 159, 1, 159, 5, 159, 3566, 8, 159, 10, 159, 12, 159, 3569, 9, 159,
		1, 160, 1, 160, 1, 160, 1, 160, 5, 160, 3575, 8, 160, 10, 160, 12, 160,
		3578, 9, 160, 1, 160, 1, 160, 1, 161, 1, 161, 3, 161, 3584, 8, 161, 1,
		162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 5, 162, 3592, 8, 162, 10,
		162, 12, 162, 3595, 9, 162, 1, 162, 1, 162, 3, 162, 3599, 8, 162, 1, 163,
		1, 163, 3, 163, 3603, 8, 163, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1,
		165, 1, 166, 1, 166, 3, 166, 3613, 8, 166, 1, 167, 1, 167, 1, 167, 5, 167,
		3618, 8, 167, 10, 167, 12, 167, 3621, 9, 167, 1, 168, 1, 168, 1, 168, 1,
		168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 3, 168, 3633, 8, 168,
		3, 168, 3635, 8, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 5,
		168, 3643, 8, 168, 10, 168, 12, 168, 3646, 9, 168, 1, 169, 3, 169, 3649,
		8, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 3, 169, 3657, 8,
		169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 3664, 8, 169, 10,
		169, 12, 169, 3667, 9, 169, 1, 169, 1, 169, 1, 169, 3, 169, 3672, 8, 169,
		1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 3, 169, 3680, 8, 169, 1,
		169, 1, 169, 1, 169, 3, 169, 3685, 8, 169, 1, 169, 1, 169, 1, 169, 1, 169,
		1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 3695, 8, 169, 10, 169, 12, 169,
		3698, 9, 169, 1, 169, 1, 169, 3, 169, 3702, 8, 169, 1, 169, 3, 169, 3705,
		8, 169, 1, 169, 1, 169, 1, 169, 1, 169, 3, 169, 3711, 8, 169, 1, 169, 1,
		169, 3, 169, 3715, 8, 169, 1, 169, 1, 169, 1, 169, 3, 169, 3720, 8, 169,
		1, 169, 1, 169, 1, 169, 3, 169, 3725, 8, 169, 1, 169, 1, 169, 1, 169, 3,
		169, 3730, 8, 169, 1, 170, 1, 170, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171,
		3738, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1,
		171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1,
		171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 5, 171, 3763, 8, 171,
		10, 171, 12, 171, 3766, 9, 171, 1, 172, 1, 172, 1, 173, 1, 173, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 3778, 8, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3,
		174, 3790, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 4, 174, 3800, 8, 174, 11, 174, 12, 174, 3801, 1, 174, 1, 174, 3,
		174, 3806, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 4, 174, 3813,
		8, 174, 11, 174, 12, 174, 3814, 1, 174, 1, 174, 3, 174, 3819, 8, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 5, 174, 3835, 8, 174, 10, 174, 12,
		174, 3838, 9, 174, 3, 174, 3840, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 3, 174, 3848, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 3, 174, 3857, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 3, 174, 3866, 8, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3,
		174, 3880, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 3886, 8, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 4, 174, 3892, 8, 174, 11, 174, 12, 174,
		3893, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 3, 174, 3905, 8, 174, 1, 174, 1, 174, 1, 174, 5, 174, 3910, 8, 174,
		10, 174, 12, 174, 3913, 9, 174, 3, 174, 3915, 8, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 5, 174, 3926, 8, 174,
		10, 174, 12, 174, 3929, 9, 174, 1, 174, 1, 174, 3, 174, 3933, 8, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 3941, 8, 174, 1, 174,
		1, 174, 3, 174, 3945, 8, 174, 1, 174, 1, 174, 3, 174, 3949, 8, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 4, 174, 3959,
		8, 174, 11, 174, 12, 174, 3960, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		3, 174, 3986, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 3993,
		8, 174, 1, 174, 3, 174, 3996, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3,
		174, 4011, 8, 174, 1, 174, 1, 174, 3, 174, 4015, 8, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 5, 174, 4033, 8, 174, 10, 174,
		12, 174, 4036, 9, 174, 1, 175, 1, 175, 5, 175, 4040, 8, 175, 10, 175, 12,
		175, 4043, 9, 175, 1, 176, 1, 176, 3, 176, 4047, 8, 176, 1, 177, 1, 177,
		1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 4058, 8,
		178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1,
		179, 1, 179, 3, 179, 4070, 8, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 3, 180, 4080, 8, 180, 1, 181, 1, 181, 1, 181, 1,
		181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 4, 181, 4093,
		8, 181, 11, 181, 12, 181, 4094, 3, 181, 4097, 8, 181, 1, 182, 1, 182, 1,
		183, 1, 183, 1, 184, 1, 184, 1, 185, 1, 185, 1, 186, 1, 186, 1, 186, 3,
		186, 4110, 8, 186, 1, 187, 1, 187, 3, 187, 4114, 8, 187, 1, 188, 1, 188,
		1, 188, 4, 188, 4119, 8, 188, 11, 188, 12, 188, 4120, 1, 189, 1, 189, 1,
		189, 3, 189, 4126, 8, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 191,
		3, 191, 4134, 8, 191, 1, 191, 1, 191, 1, 191, 3, 191, 4139, 8, 191, 1,
		192, 1, 192, 1, 193, 1, 193, 1, 194, 1, 194, 1, 194, 3, 194, 4148, 8, 194,
		1, 195, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1, 196, 1, 197, 1, 197,
		3, 197, 4159, 8, 197, 1, 197, 1, 197, 1, 197, 1, 197, 3, 197, 4165, 8,
		197, 1, 197, 1, 197, 1, 197, 1, 197, 3, 197, 4171, 8, 197, 1, 197, 1, 197,
		1, 197, 1, 197, 1, 197, 3, 197, 4178, 8, 197, 1, 197, 3, 197, 4181, 8,
		197, 1, 197, 1, 197, 1, 197, 1, 197, 3, 197, 4187, 8, 197, 1, 197, 1, 197,
		1, 197, 3, 197, 4192, 8, 197, 3, 197, 4194, 8, 197, 1, 197, 1, 197, 1,
		197, 1, 197, 3, 197, 4200, 8, 197, 1, 197, 1, 197, 1, 197, 1, 197, 3, 197,
		4206, 8, 197, 1, 197, 1, 197, 1, 197, 3, 197, 4211, 8, 197, 3, 197, 4213,
		8, 197, 1, 198, 1, 198, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199,
		1, 199, 5, 199, 4224, 8, 199, 10, 199, 12, 199, 4227, 9, 199, 1, 199, 3,
		199, 4230, 8, 199, 3, 199, 4232, 8, 199, 1, 200, 1, 200, 1, 200, 1, 200,
		1, 200, 3, 200, 4239, 8, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1,
		200, 1, 200, 3, 200, 4248, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 4253,
		8, 200, 1, 200, 1, 200, 3, 200, 4257, 8, 200, 1, 200, 3, 200, 4260, 8,
		200, 1, 201, 1, 201, 1, 201, 5, 201, 4265, 8, 201, 10, 201, 12, 201, 4268,
		9, 201, 1, 202, 1, 202, 1, 202, 5, 202, 4273, 8, 202, 10, 202, 12, 202,
		4276, 9, 202, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 3, 203, 4284,
		8, 203, 1, 204, 1, 204, 1, 204, 1, 205, 1, 205, 1, 205, 1, 206, 1, 206,
		1, 206, 5, 206, 4295, 8, 206, 10, 206, 12, 206, 4298, 9, 206, 1, 207, 1,
		207, 1, 207, 1, 207, 1, 207, 3, 207, 4305, 8, 207, 1, 207, 3, 207, 4308,
		8, 207, 1, 208, 1, 208, 1, 208, 5, 208, 4313, 8, 208, 10, 208, 12, 208,
		4316, 9, 208, 1, 209, 1, 209, 3, 209, 4320, 8, 209, 1, 210, 1, 210, 1,
		210, 5, 210, 4325, 8, 210, 10, 210, 12, 210, 4328, 9, 210, 1, 211, 1, 211,
		1, 211, 5, 211, 4333, 8, 211, 10, 211, 12, 211, 4336, 9, 211, 1, 212, 1,
		212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 3, 212, 4345, 8, 212, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 3, 213, 4358, 8, 213, 1, 213, 1, 213, 1, 213, 3, 213, 4363, 8,
		213, 3, 213, 4365, 8, 213, 1, 214, 1, 214, 5, 214, 4369, 8, 214, 10, 214,
		12, 214, 4372, 9, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1, 215, 1, 215,
		1, 215, 1, 215, 3, 215, 4382, 8, 215, 1, 216, 3, 216, 4385, 8, 216, 1,
		216, 1, 216, 3, 216, 4389, 8, 216, 1, 216, 3, 216, 4392, 8, 216, 1, 217,
		1, 217, 1, 217, 5, 217, 4397, 8, 217, 10, 217, 12, 217, 4400, 9, 217, 1,
		218, 1, 218, 3, 218, 4404, 8, 218, 1, 218, 1, 218, 1, 218, 1, 218, 3, 218,
		4410, 8, 218, 1, 218, 3, 218, 4413, 8, 218, 1, 219, 1, 219, 1, 219, 1,
		219, 1, 219, 1, 219, 1, 219, 5, 219, 4422, 8, 219, 10, 219, 12, 219, 4425,
		9, 219, 1, 220, 1, 220, 1, 220, 1, 221, 1, 221, 1, 221, 1, 222, 1, 222,
		1, 222, 1, 222, 3, 222, 4437, 8, 222, 1, 223, 1, 223, 1, 223, 1, 223, 1,
		223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 3, 223, 4449, 8, 223, 1, 224,
		1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 3, 224,
		4460, 8, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 3, 225, 4468,
		8, 225, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 227, 1, 227, 1, 227,
		1, 227, 5, 227, 4479, 8, 227, 10, 227, 12, 227, 4482, 9, 227, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1,
		229, 1, 229, 1, 229, 1, 229, 1, 229, 5, 229, 4499, 8, 229, 10, 229, 12,
		229, 4502, 9, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 5, 229, 4509,
		8, 229, 10, 229, 12, 229, 4512, 9, 229, 3, 229, 4514, 8, 229, 1, 229, 1,
		229, 1, 229, 1, 229, 1, 229, 5, 229, 4521, 8, 229, 10, 229, 12, 229, 4524,
		9, 229, 3, 229, 4526, 8, 229, 3, 229, 4528, 8, 229, 1, 229, 3, 229, 4531,
		8, 229, 1, 229, 3, 229, 4534, 8, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1,
		230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1,
		230, 1, 230, 1, 230, 3, 230, 4552, 8, 230, 1, 231, 1, 231, 1, 231, 1, 231,
		1, 231, 1, 231, 1, 231, 3, 231, 4561, 8, 231, 1, 232, 1, 232, 1, 232, 5,
		232, 4566, 8, 232, 10, 232, 12, 232, 4569, 9, 232, 1, 233, 1, 233, 1, 233,
		1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4581, 8,
		233, 1, 234, 1, 234, 1, 234, 5, 234, 4586, 8, 234, 10, 234, 12, 234, 4589,
		9, 234, 1, 235, 1, 235, 1, 235, 1, 236, 1, 236, 4, 236, 4596, 8, 236, 11,
		236, 12, 236, 4597, 1, 236, 3, 236, 4601, 8, 236, 1, 237, 1, 237, 1, 237,
		3, 237, 4606, 8, 237, 1, 238, 1, 238, 1, 238, 1, 238, 1, 238, 1, 238, 3,
		238, 4614, 8, 238, 1, 239, 1, 239, 1, 239, 3, 239, 4619, 8, 239, 1, 240,
		1, 240, 1, 241, 1, 241, 3, 241, 4625, 8, 241, 1, 241, 1, 241, 1, 241, 3,
		241, 4630, 8, 241, 1, 241, 1, 241, 1, 241, 3, 241, 4635, 8, 241, 1, 241,
		1, 241, 3, 241, 4639, 8, 241, 1, 241, 1, 241, 3, 241, 4643, 8, 241, 1,
		241, 1, 241, 3, 241, 4647, 8, 241, 1, 241, 1, 241, 3, 241, 4651, 8, 241,
		1, 241, 1, 241, 3, 241, 4655, 8, 241, 1, 241, 1, 241, 3, 241, 4659, 8,
		241, 1, 241, 1, 241, 3, 241, 4663, 8, 241, 1, 241, 3, 241, 4666, 8, 241,
		1, 242, 1, 242, 3, 242, 4670, 8, 242, 1, 242, 1, 242, 5, 242, 4674, 8,
		242, 10, 242, 12, 242, 4677, 9, 242, 1, 243, 1, 243, 1, 243, 3, 243, 4682,
		8, 243, 1, 244, 1, 244, 3, 244, 4686, 8, 244, 1, 244, 1, 244, 5, 244, 4690,
		8, 244, 10, 244, 12, 244, 4693, 9, 244, 1, 245, 1, 245, 1, 245, 3, 245,
		4698, 8, 245, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 247, 1, 247, 1,
		247, 3, 247, 4708, 8, 247, 1, 248, 1, 248, 1, 248, 1, 249, 1, 249, 1, 249,
		3, 249, 4716, 8, 249, 1, 250, 1, 250, 1, 250, 1, 250, 1, 250, 1, 251, 1,
		251, 3, 251, 4725, 8, 251, 1, 252, 1, 252, 1, 252, 3, 252, 4730, 8, 252,
		1, 253, 1, 253, 1, 254, 1, 254, 1, 254, 5, 254, 4737, 8, 254, 10, 254,
		12, 254, 4740, 9, 254, 1, 255, 1, 255, 3, 255, 4744, 8, 255, 1, 256, 1,
		256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1,
		256, 1, 256, 3, 256, 4758, 8, 256, 1, 257, 1, 257, 1, 257, 3, 257, 4763,
		8, 257, 1, 258, 1, 258, 3, 258, 4767, 8, 258, 1, 259, 1, 259, 3, 259, 4771,
		8, 259, 1, 260, 1, 260, 3, 260, 4775, 8, 260, 1, 260, 1, 260, 1, 260, 1,
		260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 3, 260, 4787, 8, 260,
		1, 260, 1, 260, 3, 260, 4791, 8, 260, 1, 260, 1, 260, 3, 260, 4795, 8,
		260, 1, 260, 1, 260, 1, 260, 1, 260, 3, 260, 4801, 8, 260, 1, 260, 1, 260,
		1, 260, 1, 260, 3, 260, 4807, 8, 260, 1, 260, 3, 260, 4810, 8, 260, 3,
		260, 4812, 8, 260, 1, 261, 1, 261, 1, 261, 5, 261, 4817, 8, 261, 10, 261,
		12, 261, 4820, 9, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261,
		5, 261, 4828, 8, 261, 10, 261, 12, 261, 4831, 9, 261, 1, 261, 1, 261, 1,
		261, 5, 261, 4836, 8, 261, 10, 261, 12, 261, 4839, 9, 261, 1, 262, 1, 262,
		1, 263, 1, 263, 1, 264, 1, 264, 1, 264, 9, 1558, 1625, 1685, 1752, 1769,
		1797, 1806, 1815, 1824, 4, 166, 336, 342, 348, 265, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234,
		236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264,
		266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294,
		296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324,
		326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354,
		356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384,
		386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414,
		416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444,
		446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474,
		476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504,
		506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 0, 67, 2, 0,
		69, 69, 122, 122, 2, 0, 90, 90, 263, 263, 2, 0, 41, 41, 286, 286, 2, 0,
		143, 143, 163, 163, 1, 0, 57, 58, 2, 0, 338, 338, 387, 387, 2, 0, 13, 13,
		46, 46, 5, 0, 53, 53, 70, 70, 126, 126, 141, 141, 204, 204, 1, 0, 99, 100,
		2, 0, 126, 126, 141, 141, 3, 0, 9, 9, 110, 110, 335, 335, 2, 0, 9, 9, 198,
		198, 3, 0, 84, 84, 224, 224, 300, 300, 3, 0, 85, 85, 225, 225, 301, 301,
		1, 0, 383, 384, 4, 0, 118, 118, 173, 173, 310, 310, 369, 369, 3, 0, 118,
		118, 310, 310, 369, 369, 2, 0, 23, 23, 99, 99, 2, 0, 134, 134, 187, 187,
		2, 0, 337, 337, 386, 386, 2, 0, 336, 336, 348, 348, 2, 0, 73, 73, 295,
		295, 2, 0, 120, 120, 164, 164, 2, 0, 12, 12, 105, 105, 2, 0, 436, 436,
		438, 438, 2, 0, 106, 106, 251, 251, 2, 0, 243, 243, 318, 318, 2, 0, 8,
		8, 231, 231, 1, 0, 194, 195, 3, 0, 12, 12, 18, 18, 317, 317, 3, 0, 129,
		129, 362, 362, 371, 371, 2, 0, 413, 414, 418, 418, 2, 0, 107, 107, 415,
		417, 2, 0, 413, 414, 421, 421, 1, 0, 410, 412, 11, 0, 79, 79, 81, 81, 155,
		155, 213, 213, 215, 215, 217, 217, 220, 220, 265, 265, 298, 298, 390, 390,
		399, 399, 3, 0, 75, 78, 308, 308, 378, 378, 2, 0, 86, 87, 351, 351, 3,
		0, 88, 89, 347, 347, 352, 352, 2, 0, 43, 43, 364, 364, 2, 0, 160, 160,
		285, 285, 1, 0, 333, 334, 2, 0, 4, 4, 143, 143, 2, 0, 4, 4, 138, 138, 3,
		0, 33, 33, 190, 190, 357, 357, 1, 0, 402, 409, 3, 0, 107, 107, 413, 421,
		423, 423, 4, 0, 16, 16, 163, 163, 231, 231, 242, 242, 2, 0, 129, 129, 362,
		362, 1, 0, 413, 414, 8, 0, 79, 80, 155, 156, 213, 218, 220, 221, 226, 227,
		298, 299, 390, 391, 399, 400, 6, 0, 79, 79, 155, 155, 217, 217, 220, 220,
		298, 298, 399, 399, 1, 0, 47, 48, 2, 0, 91, 92, 234, 234, 2, 0, 220, 220,
		399, 399, 4, 0, 79, 79, 155, 155, 217, 217, 298, 298, 3, 0, 155, 155, 217,
		217, 298, 298, 15, 0, 29, 30, 32, 32, 37, 37, 83, 83, 109, 109, 135, 135,
		175, 176, 205, 205, 269, 269, 312, 312, 316, 316, 349, 350, 353, 353, 385,
		385, 389, 389, 2, 0, 94, 94, 402, 402, 2, 0, 322, 322, 442, 442, 2, 0,
		137, 137, 258, 258, 1, 0, 437, 438, 2, 0, 235, 235, 278, 278, 2, 0, 110,
		110, 309, 309, 57, 0, 9, 11, 13, 15, 17, 17, 19, 21, 23, 25, 27, 32, 34,
		38, 40, 41, 44, 48, 50, 53, 56, 56, 58, 66, 68, 70, 73, 74, 79, 104, 106,
		110, 112, 112, 114, 114, 116, 117, 119, 128, 131, 131, 133, 137, 140, 142,
		145, 148, 151, 152, 154, 162, 164, 167, 169, 172, 174, 176, 178, 178, 180,
		181, 183, 187, 189, 189, 191, 191, 193, 227, 229, 230, 233, 236, 240, 241,
		244, 244, 246, 247, 249, 258, 260, 273, 275, 275, 277, 289, 291, 302, 304,
		307, 309, 316, 318, 321, 323, 337, 339, 344, 347, 353, 356, 356, 358, 368,
		372, 377, 380, 391, 394, 395, 398, 401, 16, 0, 17, 17, 72, 72, 118, 118,
		144, 144, 168, 168, 173, 173, 182, 182, 188, 188, 192, 192, 228, 228, 238,
		238, 290, 290, 304, 304, 310, 310, 369, 369, 379, 379, 17, 0, 9, 16, 18,
		71, 73, 117, 119, 143, 145, 167, 169, 172, 174, 181, 183, 187, 189, 191,
		193, 227, 229, 237, 239, 289, 291, 303, 305, 309, 311, 368, 370, 378, 380,
		401, 5529, 0, 531, 1, 0, 0, 0, 2, 539, 1, 0, 0, 0, 4, 541, 1, 0, 0, 0,
		6, 554, 1, 0, 0, 0, 8, 571, 1, 0, 0, 0, 10, 588, 1, 0, 0, 0, 12, 601, 1,
		0, 0, 0, 14, 603, 1, 0, 0, 0, 16, 605, 1, 0, 0, 0, 18, 625, 1, 0, 0, 0,
		20, 627, 1, 0, 0, 0, 22, 635, 1, 0, 0, 0, 24, 646, 1, 0, 0, 0, 26, 657,
		1, 0, 0, 0, 28, 679, 1, 0, 0, 0, 30, 690, 1, 0, 0, 0, 32, 693, 1, 0, 0,
		0, 34, 731, 1, 0, 0, 0, 36, 734, 1, 0, 0, 0, 38, 744, 1, 0, 0, 0, 40, 768,
		1, 0, 0, 0, 42, 770, 1, 0, 0, 0, 44, 773, 1, 0, 0, 0, 46, 775, 1, 0, 0,
		0, 48, 778, 1, 0, 0, 0, 50, 781, 1, 0, 0, 0, 52, 784, 1, 0, 0, 0, 54, 787,
		1, 0, 0, 0, 56, 790, 1, 0, 0, 0, 58, 793, 1, 0, 0, 0, 60, 1708, 1, 0, 0,
		0, 62, 1710, 1, 0, 0, 0, 64, 1713, 1, 0, 0, 0, 66, 1716, 1, 0, 0, 0, 68,
		1745, 1, 0, 0, 0, 70, 1827, 1, 0, 0, 0, 72, 1829, 1, 0, 0, 0, 74, 1846,
		1, 0, 0, 0, 76, 1850, 1, 0, 0, 0, 78, 1852, 1, 0, 0, 0, 80, 1854, 1, 0,
		0, 0, 82, 2024, 1, 0, 0, 0, 84, 2026, 1, 0, 0, 0, 86, 2044, 1, 0, 0, 0,
		88, 2050, 1, 0, 0, 0, 90, 2056, 1, 0, 0, 0, 92, 2068, 1, 0, 0, 0, 94, 2081,
		1, 0, 0, 0, 96, 2084, 1, 0, 0, 0, 98, 2093, 1, 0, 0, 0, 100, 2096, 1, 0,
		0, 0, 102, 2100, 1, 0, 0, 0, 104, 2190, 1, 0, 0, 0, 106, 2192, 1, 0, 0,
		0, 108, 2196, 1, 0, 0, 0, 110, 2217, 1, 0, 0, 0, 112, 2219, 1, 0, 0, 0,
		114, 2227, 1, 0, 0, 0, 116, 2229, 1, 0, 0, 0, 118, 2231, 1, 0, 0, 0, 120,
		2240, 1, 0, 0, 0, 122, 2242, 1, 0, 0, 0, 124, 2250, 1, 0, 0, 0, 126, 2262,
		1, 0, 0, 0, 128, 2279, 1, 0, 0, 0, 130, 2299, 1, 0, 0, 0, 132, 2302, 1,
		0, 0, 0, 134, 2313, 1, 0, 0, 0, 136, 2329, 1, 0, 0, 0, 138, 2335, 1, 0,
		0, 0, 140, 2337, 1, 0, 0, 0, 142, 2348, 1, 0, 0, 0, 144, 2355, 1, 0, 0,
		0, 146, 2366, 1, 0, 0, 0, 148, 2383, 1, 0, 0, 0, 150, 2391, 1, 0, 0, 0,
		152, 2393, 1, 0, 0, 0, 154, 2399, 1, 0, 0, 0, 156, 2463, 1, 0, 0, 0, 158,
		2471, 1, 0, 0, 0, 160, 2480, 1, 0, 0, 0, 162, 2492, 1, 0, 0, 0, 164, 2544,
		1, 0, 0, 0, 166, 2547, 1, 0, 0, 0, 168, 2588, 1, 0, 0, 0, 170, 2590, 1,
		0, 0, 0, 172, 2598, 1, 0, 0, 0, 174, 2632, 1, 0, 0, 0, 176, 2678, 1, 0,
		0, 0, 178, 2699, 1, 0, 0, 0, 180, 2731, 1, 0, 0, 0, 182, 2743, 1, 0, 0,
		0, 184, 2746, 1, 0, 0, 0, 186, 2755, 1, 0, 0, 0, 188, 2769, 1, 0, 0, 0,
		190, 2788, 1, 0, 0, 0, 192, 2808, 1, 0, 0, 0, 194, 2814, 1, 0, 0, 0, 196,
		2816, 1, 0, 0, 0, 198, 2821, 1, 0, 0, 0, 200, 2829, 1, 0, 0, 0, 202, 2833,
		1, 0, 0, 0, 204, 2836, 1, 0, 0, 0, 206, 2839, 1, 0, 0, 0, 208, 2865, 1,
		0, 0, 0, 210, 2867, 1, 0, 0, 0, 212, 2902, 1, 0, 0, 0, 214, 2943, 1, 0,
		0, 0, 216, 2947, 1, 0, 0, 0, 218, 2974, 1, 0, 0, 0, 220, 2978, 1, 0, 0,
		0, 222, 2993, 1, 0, 0, 0, 224, 2995, 1, 0, 0, 0, 226, 3025, 1, 0, 0, 0,
		228, 3027, 1, 0, 0, 0, 230, 3034, 1, 0, 0, 0, 232, 3047, 1, 0, 0, 0, 234,
		3052, 1, 0, 0, 0, 236, 3054, 1, 0, 0, 0, 238, 3069, 1, 0, 0, 0, 240, 3093,
		1, 0, 0, 0, 242, 3106, 1, 0, 0, 0, 244, 3108, 1, 0, 0, 0, 246, 3110, 1,
		0, 0, 0, 248, 3114, 1, 0, 0, 0, 250, 3117, 1, 0, 0, 0, 252, 3121, 1, 0,
		0, 0, 254, 3153, 1, 0, 0, 0, 256, 3156, 1, 0, 0, 0, 258, 3168, 1, 0, 0,
		0, 260, 3187, 1, 0, 0, 0, 262, 3213, 1, 0, 0, 0, 264, 3219, 1, 0, 0, 0,
		266, 3221, 1, 0, 0, 0, 268, 3257, 1, 0, 0, 0, 270, 3259, 1, 0, 0, 0, 272,
		3263, 1, 0, 0, 0, 274, 3271, 1, 0, 0, 0, 276, 3282, 1, 0, 0, 0, 278, 3286,
		1, 0, 0, 0, 280, 3297, 1, 0, 0, 0, 282, 3332, 1, 0, 0, 0, 284, 3334, 1,
		0, 0, 0, 286, 3337, 1, 0, 0, 0, 288, 3367, 1, 0, 0, 0, 290, 3395, 1, 0,
		0, 0, 292, 3422, 1, 0, 0, 0, 294, 3428, 1, 0, 0, 0, 296, 3432, 1, 0, 0,
		0, 298, 3434, 1, 0, 0, 0, 300, 3456, 1, 0, 0, 0, 302, 3507, 1, 0, 0, 0,
		304, 3509, 1, 0, 0, 0, 306, 3517, 1, 0, 0, 0, 308, 3525, 1, 0, 0, 0, 310,
		3533, 1, 0, 0, 0, 312, 3541, 1, 0, 0, 0, 314, 3548, 1, 0, 0, 0, 316, 3552,
		1, 0, 0, 0, 318, 3562, 1, 0, 0, 0, 320, 3570, 1, 0, 0, 0, 322, 3583, 1,
		0, 0, 0, 324, 3598, 1, 0, 0, 0, 326, 3602, 1, 0, 0, 0, 328, 3604, 1, 0,
		0, 0, 330, 3606, 1, 0, 0, 0, 332, 3612, 1, 0, 0, 0, 334, 3614, 1, 0, 0,
		0, 336, 3634, 1, 0, 0, 0, 338, 3729, 1, 0, 0, 0, 340, 3731, 1, 0, 0, 0,
		342, 3737, 1, 0, 0, 0, 344, 3767, 1, 0, 0, 0, 346, 3769, 1, 0, 0, 0, 348,
		4014, 1, 0, 0, 0, 350, 4037, 1, 0, 0, 0, 352, 4046, 1, 0, 0, 0, 354, 4048,
		1, 0, 0, 0, 356, 4057, 1, 0, 0, 0, 358, 4069, 1, 0, 0, 0, 360, 4079, 1,
		0, 0, 0, 362, 4096, 1, 0, 0, 0, 364, 4098, 1, 0, 0, 0, 366, 4100, 1, 0,
		0, 0, 368, 4102, 1, 0, 0, 0, 370, 4104, 1, 0, 0, 0, 372, 4106, 1, 0, 0,
		0, 374, 4111, 1, 0, 0, 0, 376, 4118, 1, 0, 0, 0, 378, 4122, 1, 0, 0, 0,
		380, 4127, 1, 0, 0, 0, 382, 4133, 1, 0, 0, 0, 384, 4140, 1, 0, 0, 0, 386,
		4142, 1, 0, 0, 0, 388, 4147, 1, 0, 0, 0, 390, 4149, 1, 0, 0, 0, 392, 4153,
		1, 0, 0, 0, 394, 4212, 1, 0, 0, 0, 396, 4214, 1, 0, 0, 0, 398, 4231, 1,
		0, 0, 0, 400, 4259, 1, 0, 0, 0, 402, 4261, 1, 0, 0, 0, 404, 4269, 1, 0,
		0, 0, 406, 4283, 1, 0, 0, 0, 408, 4285, 1, 0, 0, 0, 410, 4288, 1, 0, 0,
		0, 412, 4291, 1, 0, 0, 0, 414, 4299, 1, 0, 0, 0, 416, 4309, 1, 0, 0, 0,
		418, 4319, 1, 0, 0, 0, 420, 4321, 1, 0, 0, 0, 422, 4329, 1, 0, 0, 0, 424,
		4344, 1, 0, 0, 0, 426, 4364, 1, 0, 0, 0, 428, 4366, 1, 0, 0, 0, 430, 4381,
		1, 0, 0, 0, 432, 4391, 1, 0, 0, 0, 434, 4393, 1, 0, 0, 0, 436, 4401, 1,
		0, 0, 0, 438, 4423, 1, 0, 0, 0, 440, 4426, 1, 0, 0, 0, 442, 4429, 1, 0,
		0, 0, 444, 4436, 1, 0, 0, 0, 446, 4448, 1, 0, 0, 0, 448, 4459, 1, 0, 0,
		0, 450, 4467, 1, 0, 0, 0, 452, 4469, 1, 0, 0, 0, 454, 4474, 1, 0, 0, 0,
		456, 4483, 1, 0, 0, 0, 458, 4533, 1, 0, 0, 0, 460, 4551, 1, 0, 0, 0, 462,
		4560, 1, 0, 0, 0, 464, 4562, 1, 0, 0, 0, 466, 4580, 1, 0, 0, 0, 468, 4582,
		1, 0, 0, 0, 470, 4590, 1, 0, 0, 0, 472, 4600, 1, 0, 0, 0, 474, 4605, 1,
		0, 0, 0, 476, 4613, 1, 0, 0, 0, 478, 4618, 1, 0, 0, 0, 480, 4620, 1, 0,
		0, 0, 482, 4665, 1, 0, 0, 0, 484, 4669, 1, 0, 0, 0, 486, 4681, 1, 0, 0,
		0, 488, 4685, 1, 0, 0, 0, 490, 4697, 1, 0, 0, 0, 492, 4699, 1, 0, 0, 0,
		494, 4707, 1, 0, 0, 0, 496, 4709, 1, 0, 0, 0, 498, 4712, 1, 0, 0, 0, 500,
		4717, 1, 0, 0, 0, 502, 4724, 1, 0, 0, 0, 504, 4729, 1, 0, 0, 0, 506, 4731,
		1, 0, 0, 0, 508, 4733, 1, 0, 0, 0, 510, 4741, 1, 0, 0, 0, 512, 4757, 1,
		0, 0, 0, 514, 4762, 1, 0, 0, 0, 516, 4766, 1, 0, 0, 0, 518, 4770, 1, 0,
		0, 0, 520, 4811, 1, 0, 0, 0, 522, 4813, 1, 0, 0, 0, 524, 4840, 1, 0, 0,
		0, 526, 4842, 1, 0, 0, 0, 528, 4844, 1, 0, 0, 0, 530, 532, 3, 2, 1, 0,
		531, 530, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 531, 1, 0, 0, 0, 533,
		534, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535, 536, 5, 0, 0, 1, 536, 1, 1,
		0, 0, 0, 537, 540, 3, 40, 20, 0, 538, 540, 3, 4, 2, 0, 539, 537, 1, 0,
		0, 0, 539, 538, 1, 0, 0, 0, 540, 3, 1, 0, 0, 0, 541, 544, 5, 27, 0, 0,
		542, 543, 5, 231, 0, 0, 543, 545, 5, 25, 0, 0, 544, 542, 1, 0, 0, 0, 544,
		545, 1, 0, 0, 0, 545, 547, 1, 0, 0, 0, 546, 548, 3, 8, 4, 0, 547, 546,
		1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 551, 5, 113,
		0, 0, 550, 552, 5, 1, 0, 0, 551, 550, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0,
		552, 5, 1, 0, 0, 0, 553, 555, 3, 42, 21, 0, 554, 553, 1, 0, 0, 0, 554,
		555, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 559, 5, 27, 0, 0, 557, 558,
		5, 231, 0, 0, 558, 560, 5, 25, 0, 0, 559, 557, 1, 0, 0, 0, 559, 560, 1,
		0, 0, 0, 560, 562, 1, 0, 0, 0, 561, 563, 3, 8, 4, 0, 562, 561, 1, 0, 0,
		0, 562, 563, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 566, 5, 113, 0, 0,
		565, 567, 3, 44, 22, 0, 566, 565, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567,
		7, 1, 0, 0, 0, 568, 569, 3, 10, 5, 0, 569, 570, 5, 1, 0, 0, 570, 572, 1,
		0, 0, 0, 571, 568, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 571, 1, 0, 0,
		0, 573, 574, 1, 0, 0, 0, 574, 9, 1, 0, 0, 0, 575, 589, 3, 16, 8, 0, 576,
		589, 3, 60, 30, 0, 577, 589, 3, 12, 6, 0, 578, 589, 3, 6, 3, 0, 579, 589,
		3, 22, 11, 0, 580, 589, 3, 26, 13, 0, 581, 589, 3, 34, 17, 0, 582, 589,
		3, 24, 12, 0, 583, 589, 3, 28, 14, 0, 584, 589, 3, 30, 15, 0, 585, 589,
		3, 32, 16, 0, 586, 589, 3, 36, 18, 0, 587, 589, 3, 38, 19, 0, 588, 575,
		1, 0, 0, 0, 588, 576, 1, 0, 0, 0, 588, 577, 1, 0, 0, 0, 588, 578, 1, 0,
		0, 0, 588, 579, 1, 0, 0, 0, 588, 580, 1, 0, 0, 0, 588, 581, 1, 0, 0, 0,
		588, 582, 1, 0, 0, 0, 588, 583, 1, 0, 0, 0, 588, 584, 1, 0, 0, 0, 588,
		585, 1, 0, 0, 0, 588, 586, 1, 0, 0, 0, 588, 587, 1, 0, 0, 0, 589, 11, 1,
		0, 0, 0, 590, 591, 5, 309, 0, 0, 591, 602, 3, 198, 99, 0, 592, 593, 5,
		309, 0, 0, 593, 594, 5, 2, 0, 0, 594, 595, 3, 304, 152, 0, 595, 596, 5,
		3, 0, 0, 596, 597, 5, 402, 0, 0, 597, 598, 5, 2, 0, 0, 598, 599, 3, 102,
		51, 0, 599, 600, 5, 3, 0, 0, 600, 602, 1, 0, 0, 0, 601, 590, 1, 0, 0, 0,
		601, 592, 1, 0, 0, 0, 602, 13, 1, 0, 0, 0, 603, 604, 3, 514, 257, 0, 604,
		15, 1, 0, 0, 0, 605, 606, 5, 93, 0, 0, 606, 607, 3, 306, 153, 0, 607, 614,
		5, 66, 0, 0, 608, 609, 5, 138, 0, 0, 609, 611, 5, 324, 0, 0, 610, 612,
		5, 380, 0, 0, 611, 610, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 613, 1,
		0, 0, 0, 613, 615, 3, 14, 7, 0, 614, 608, 1, 0, 0, 0, 614, 615, 1, 0, 0,
		0, 615, 17, 1, 0, 0, 0, 616, 618, 5, 324, 0, 0, 617, 619, 5, 380, 0, 0,
		618, 617, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620,
		626, 3, 14, 7, 0, 621, 626, 5, 323, 0, 0, 622, 623, 5, 231, 0, 0, 623,
		626, 5, 142, 0, 0, 624, 626, 3, 306, 153, 0, 625, 616, 1, 0, 0, 0, 625,
		621, 1, 0, 0, 0, 625, 622, 1, 0, 0, 0, 625, 624, 1, 0, 0, 0, 626, 19, 1,
		0, 0, 0, 627, 632, 3, 18, 9, 0, 628, 629, 5, 4, 0, 0, 629, 631, 3, 18,
		9, 0, 630, 628, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0,
		632, 633, 1, 0, 0, 0, 633, 21, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 635, 636,
		5, 93, 0, 0, 636, 637, 7, 0, 0, 0, 637, 638, 5, 152, 0, 0, 638, 639, 5,
		138, 0, 0, 639, 643, 3, 20, 10, 0, 640, 644, 3, 6, 3, 0, 641, 644, 3, 60,
		30, 0, 642, 644, 3, 12, 6, 0, 643, 640, 1, 0, 0, 0, 643, 641, 1, 0, 0,
		0, 643, 642, 1, 0, 0, 0, 644, 23, 1, 0, 0, 0, 645, 647, 3, 42, 21, 0, 646,
		645, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 648, 1, 0, 0, 0, 648, 649,
		5, 394, 0, 0, 649, 650, 3, 336, 168, 0, 650, 651, 5, 108, 0, 0, 651, 652,
		3, 8, 4, 0, 652, 653, 5, 113, 0, 0, 653, 655, 5, 394, 0, 0, 654, 656, 3,
		44, 22, 0, 655, 654, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0, 656, 25, 1, 0, 0,
		0, 657, 658, 5, 159, 0, 0, 658, 659, 3, 336, 168, 0, 659, 660, 5, 345,
		0, 0, 660, 668, 3, 8, 4, 0, 661, 662, 5, 112, 0, 0, 662, 663, 3, 336, 168,
		0, 663, 664, 5, 345, 0, 0, 664, 665, 3, 8, 4, 0, 665, 667, 1, 0, 0, 0,
		666, 661, 1, 0, 0, 0, 667, 670, 1, 0, 0, 0, 668, 666, 1, 0, 0, 0, 668,
		669, 1, 0, 0, 0, 669, 673, 1, 0, 0, 0, 670, 668, 1, 0, 0, 0, 671, 672,
		5, 111, 0, 0, 672, 674, 3, 8, 4, 0, 673, 671, 1, 0, 0, 0, 673, 674, 1,
		0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 676, 5, 113, 0, 0, 676, 677, 5, 159,
		0, 0, 677, 27, 1, 0, 0, 0, 678, 680, 3, 42, 21, 0, 679, 678, 1, 0, 0, 0,
		679, 680, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681, 682, 5, 281, 0, 0, 682,
		683, 3, 8, 4, 0, 683, 684, 5, 375, 0, 0, 684, 685, 3, 336, 168, 0, 685,
		686, 5, 113, 0, 0, 686, 688, 5, 281, 0, 0, 687, 689, 3, 44, 22, 0, 688,
		687, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 29, 1, 0, 0, 0, 690, 691, 5,
		191, 0, 0, 691, 692, 3, 306, 153, 0, 692, 31, 1, 0, 0, 0, 693, 694, 5,
		181, 0, 0, 694, 695, 3, 306, 153, 0, 695, 33, 1, 0, 0, 0, 696, 702, 5,
		42, 0, 0, 697, 698, 5, 392, 0, 0, 698, 699, 3, 336, 168, 0, 699, 700, 5,
		345, 0, 0, 700, 701, 3, 8, 4, 0, 701, 703, 1, 0, 0, 0, 702, 697, 1, 0,
		0, 0, 703, 704, 1, 0, 0, 0, 704, 702, 1, 0, 0, 0, 704, 705, 1, 0, 0, 0,
		705, 708, 1, 0, 0, 0, 706, 707, 5, 111, 0, 0, 707, 709, 3, 8, 4, 0, 708,
		706, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 711,
		5, 113, 0, 0, 711, 712, 5, 42, 0, 0, 712, 732, 1, 0, 0, 0, 713, 714, 5,
		42, 0, 0, 714, 720, 3, 328, 164, 0, 715, 716, 5, 392, 0, 0, 716, 717, 3,
		328, 164, 0, 717, 718, 5, 345, 0, 0, 718, 719, 3, 8, 4, 0, 719, 721, 1,
		0, 0, 0, 720, 715, 1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 720, 1, 0, 0,
		0, 722, 723, 1, 0, 0, 0, 723, 726, 1, 0, 0, 0, 724, 725, 5, 111, 0, 0,
		725, 727, 3, 8, 4, 0, 726, 724, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0, 727,
		728, 1, 0, 0, 0, 728, 729, 5, 113, 0, 0, 729, 730, 5, 42, 0, 0, 730, 732,
		1, 0, 0, 0, 731, 696, 1, 0, 0, 0, 731, 713, 1, 0, 0, 0, 732, 35, 1, 0,
		0, 0, 733, 735, 3, 42, 21, 0, 734, 733, 1, 0, 0, 0, 734, 735, 1, 0, 0,
		0, 735, 736, 1, 0, 0, 0, 736, 737, 5, 206, 0, 0, 737, 738, 3, 8, 4, 0,
		738, 739, 5, 113, 0, 0, 739, 741, 5, 206, 0, 0, 740, 742, 3, 44, 22, 0,
		741, 740, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 37, 1, 0, 0, 0, 743, 745,
		3, 42, 21, 0, 744, 743, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 746, 1,
		0, 0, 0, 746, 750, 5, 138, 0, 0, 747, 748, 3, 306, 153, 0, 748, 749, 5,
		22, 0, 0, 749, 751, 1, 0, 0, 0, 750, 747, 1, 0, 0, 0, 750, 751, 1, 0, 0,
		0, 751, 752, 1, 0, 0, 0, 752, 753, 3, 102, 51, 0, 753, 754, 5, 108, 0,
		0, 754, 755, 3, 8, 4, 0, 755, 756, 5, 113, 0, 0, 756, 758, 5, 138, 0, 0,
		757, 759, 3, 44, 22, 0, 758, 757, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759,
		39, 1, 0, 0, 0, 760, 763, 3, 60, 30, 0, 761, 763, 3, 70, 35, 0, 762, 760,
		1, 0, 0, 0, 762, 761, 1, 0, 0, 0, 763, 765, 1, 0, 0, 0, 764, 766, 5, 1,
		0, 0, 765, 764, 1, 0, 0, 0, 765, 766, 1, 0, 0, 0, 766, 769, 1, 0, 0, 0,
		767, 769, 5, 1, 0, 0, 768, 762, 1, 0, 0, 0, 768, 767, 1, 0, 0, 0, 769,
		41, 1, 0, 0, 0, 770, 771, 3, 306, 153, 0, 771, 772, 5, 424, 0, 0, 772,
		43, 1, 0, 0, 0, 773, 774, 3, 306, 153, 0, 774, 45, 1, 0, 0, 0, 775, 776,
		3, 316, 158, 0, 776, 777, 5, 0, 0, 1, 777, 47, 1, 0, 0, 0, 778, 779, 3,
		312, 156, 0, 779, 780, 5, 0, 0, 1, 780, 49, 1, 0, 0, 0, 781, 782, 3, 306,
		153, 0, 782, 783, 5, 0, 0, 1, 783, 51, 1, 0, 0, 0, 784, 785, 3, 314, 157,
		0, 785, 786, 5, 0, 0, 1, 786, 53, 1, 0, 0, 0, 787, 788, 3, 400, 200, 0,
		788, 789, 5, 0, 0, 1, 789, 55, 1, 0, 0, 0, 790, 791, 3, 412, 206, 0, 791,
		792, 5, 0, 0, 1, 792, 57, 1, 0, 0, 0, 793, 794, 3, 420, 210, 0, 794, 795,
		5, 0, 0, 1, 795, 59, 1, 0, 0, 0, 796, 1709, 3, 102, 51, 0, 797, 1709, 3,
		72, 36, 0, 798, 800, 3, 124, 62, 0, 799, 798, 1, 0, 0, 0, 799, 800, 1,
		0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 1709, 3, 156, 78, 0, 802, 803, 5, 377,
		0, 0, 803, 1709, 3, 158, 79, 0, 804, 805, 5, 377, 0, 0, 805, 806, 3, 114,
		57, 0, 806, 807, 3, 158, 79, 0, 807, 1709, 1, 0, 0, 0, 808, 809, 5, 309,
		0, 0, 809, 810, 5, 44, 0, 0, 810, 1709, 3, 160, 80, 0, 811, 812, 5, 71,
		0, 0, 812, 817, 3, 114, 57, 0, 813, 814, 5, 159, 0, 0, 814, 815, 3, 340,
		170, 0, 815, 816, 5, 121, 0, 0, 816, 818, 1, 0, 0, 0, 817, 813, 1, 0, 0,
		0, 817, 818, 1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819, 828, 3, 158, 79, 0,
		820, 827, 3, 98, 49, 0, 821, 827, 3, 94, 47, 0, 822, 827, 3, 390, 195,
		0, 823, 824, 5, 396, 0, 0, 824, 825, 7, 1, 0, 0, 825, 827, 3, 132, 66,
		0, 826, 820, 1, 0, 0, 0, 826, 821, 1, 0, 0, 0, 826, 822, 1, 0, 0, 0, 826,
		823, 1, 0, 0, 0, 827, 830, 1, 0, 0, 0, 828, 826, 1, 0, 0, 0, 828, 829,
		1, 0, 0, 0, 829, 1709, 1, 0, 0, 0, 830, 828, 1, 0, 0, 0, 831, 832, 5, 13,
		0, 0, 832, 833, 3, 114, 57, 0, 833, 834, 3, 158, 79, 0, 834, 835, 5, 309,
		0, 0, 835, 836, 7, 1, 0, 0, 836, 837, 3, 132, 66, 0, 837, 1709, 1, 0, 0,
		0, 838, 839, 5, 13, 0, 0, 839, 840, 3, 114, 57, 0, 840, 841, 3, 158, 79,
		0, 841, 842, 5, 374, 0, 0, 842, 843, 7, 1, 0, 0, 843, 844, 3, 132, 66,
		0, 844, 1709, 1, 0, 0, 0, 845, 846, 5, 13, 0, 0, 846, 847, 3, 114, 57,
		0, 847, 848, 3, 158, 79, 0, 848, 849, 3, 390, 195, 0, 849, 1709, 1, 0,
		0, 0, 850, 851, 5, 13, 0, 0, 851, 852, 3, 114, 57, 0, 852, 853, 3, 158,
		79, 0, 853, 854, 5, 309, 0, 0, 854, 855, 3, 94, 47, 0, 855, 1709, 1, 0,
		0, 0, 856, 857, 5, 110, 0, 0, 857, 860, 3, 114, 57, 0, 858, 859, 5, 159,
		0, 0, 859, 861, 5, 121, 0, 0, 860, 858, 1, 0, 0, 0, 860, 861, 1, 0, 0,
		0, 861, 862, 1, 0, 0, 0, 862, 864, 3, 158, 79, 0, 863, 865, 7, 2, 0, 0,
		864, 863, 1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 1709, 1, 0, 0, 0, 866,
		867, 5, 313, 0, 0, 867, 870, 3, 116, 58, 0, 868, 869, 7, 3, 0, 0, 869,
		871, 3, 306, 153, 0, 870, 868, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871, 876,
		1, 0, 0, 0, 872, 874, 5, 194, 0, 0, 873, 872, 1, 0, 0, 0, 873, 874, 1,
		0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 877, 3, 514, 257, 0, 876, 873, 1, 0,
		0, 0, 876, 877, 1, 0, 0, 0, 877, 1709, 1, 0, 0, 0, 878, 883, 3, 84, 42,
		0, 879, 880, 5, 2, 0, 0, 880, 881, 3, 416, 208, 0, 881, 882, 5, 3, 0, 0,
		882, 884, 1, 0, 0, 0, 883, 879, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884,
		886, 1, 0, 0, 0, 885, 887, 3, 128, 64, 0, 886, 885, 1, 0, 0, 0, 886, 887,
		1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888, 893, 3, 130, 65, 0, 889, 891, 5,
		22, 0, 0, 890, 889, 1, 0, 0, 0, 890, 891, 1, 0, 0, 0, 891, 892, 1, 0, 0,
		0, 892, 894, 3, 102, 51, 0, 893, 890, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0,
		894, 1709, 1, 0, 0, 0, 895, 896, 5, 71, 0, 0, 896, 901, 5, 338, 0, 0, 897,
		898, 5, 159, 0, 0, 898, 899, 3, 340, 170, 0, 899, 900, 5, 121, 0, 0, 900,
		902, 1, 0, 0, 0, 901, 897, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 903,
		1, 0, 0, 0, 903, 904, 3, 312, 156, 0, 904, 905, 5, 194, 0, 0, 905, 914,
		3, 312, 156, 0, 906, 913, 3, 128, 64, 0, 907, 913, 3, 302, 151, 0, 908,
		913, 3, 148, 74, 0, 909, 913, 3, 94, 47, 0, 910, 911, 5, 342, 0, 0, 911,
		913, 3, 132, 66, 0, 912, 906, 1, 0, 0, 0, 912, 907, 1, 0, 0, 0, 912, 908,
		1, 0, 0, 0, 912, 909, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0, 913, 916, 1, 0,
		0, 0, 914, 912, 1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915, 1709, 1, 0, 0, 0,
		916, 914, 1, 0, 0, 0, 917, 922, 3, 86, 43, 0, 918, 919, 5, 2, 0, 0, 919,
		920, 3, 416, 208, 0, 920, 921, 5, 3, 0, 0, 921, 923, 1, 0, 0, 0, 922, 918,
		1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 925, 1, 0, 0, 0, 924, 926, 3, 128,
		64, 0, 925, 924, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0,
		927, 932, 3, 130, 65, 0, 928, 930, 5, 22, 0, 0, 929, 928, 1, 0, 0, 0, 929,
		930, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 933, 3, 102, 51, 0, 932, 929,
		1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 1709, 1, 0, 0, 0, 934, 935, 5, 15,
		0, 0, 935, 936, 5, 338, 0, 0, 936, 938, 3, 158, 79, 0, 937, 939, 3, 108,
		54, 0, 938, 937, 1, 0, 0, 0, 938, 939, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0,
		940, 941, 5, 64, 0, 0, 941, 949, 5, 326, 0, 0, 942, 950, 3, 474, 237, 0,
		943, 944, 5, 138, 0, 0, 944, 945, 5, 58, 0, 0, 945, 950, 3, 272, 136, 0,
		946, 947, 5, 138, 0, 0, 947, 948, 5, 12, 0, 0, 948, 950, 5, 58, 0, 0, 949,
		942, 1, 0, 0, 0, 949, 943, 1, 0, 0, 0, 949, 946, 1, 0, 0, 0, 949, 950,
		1, 0, 0, 0, 950, 1709, 1, 0, 0, 0, 951, 952, 5, 15, 0, 0, 952, 955, 5,
		339, 0, 0, 953, 954, 7, 3, 0, 0, 954, 956, 3, 158, 79, 0, 955, 953, 1,
		0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 958, 5, 64, 0,
		0, 958, 960, 5, 326, 0, 0, 959, 961, 3, 474, 237, 0, 960, 959, 1, 0, 0,
		0, 960, 961, 1, 0, 0, 0, 961, 1709, 1, 0, 0, 0, 962, 963, 5, 13, 0, 0,
		963, 964, 5, 338, 0, 0, 964, 965, 3, 158, 79, 0, 965, 966, 5, 9, 0, 0,
		966, 967, 7, 4, 0, 0, 967, 968, 3, 402, 201, 0, 968, 1709, 1, 0, 0, 0,
		969, 970, 5, 13, 0, 0, 970, 971, 5, 338, 0, 0, 971, 972, 3, 158, 79, 0,
		972, 973, 5, 9, 0, 0, 973, 974, 7, 4, 0, 0, 974, 975, 5, 2, 0, 0, 975,
		976, 3, 402, 201, 0, 976, 977, 5, 3, 0, 0, 977, 1709, 1, 0, 0, 0, 978,
		979, 5, 13, 0, 0, 979, 980, 5, 338, 0, 0, 980, 981, 3, 158, 79, 0, 981,
		982, 5, 279, 0, 0, 982, 983, 5, 57, 0, 0, 983, 984, 3, 306, 153, 0, 984,
		985, 5, 354, 0, 0, 985, 986, 3, 470, 235, 0, 986, 1709, 1, 0, 0, 0, 987,
		988, 5, 13, 0, 0, 988, 989, 5, 338, 0, 0, 989, 990, 3, 158, 79, 0, 990,
		991, 5, 110, 0, 0, 991, 994, 7, 4, 0, 0, 992, 993, 5, 159, 0, 0, 993, 995,
		5, 121, 0, 0, 994, 992, 1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995, 996, 1,
		0, 0, 0, 996, 997, 5, 2, 0, 0, 997, 998, 3, 304, 152, 0, 998, 999, 5, 3,
		0, 0, 999, 1709, 1, 0, 0, 0, 1000, 1001, 5, 13, 0, 0, 1001, 1002, 5, 338,
		0, 0, 1002, 1003, 3, 158, 79, 0, 1003, 1004, 5, 110, 0, 0, 1004, 1007,
		7, 4, 0, 0, 1005, 1006, 5, 159, 0, 0, 1006, 1008, 5, 121, 0, 0, 1007, 1005,
		1, 0, 0, 0, 1007, 1008, 1, 0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1010,
		3, 304, 152, 0, 1010, 1709, 1, 0, 0, 0, 1011, 1012, 5, 13, 0, 0, 1012,
		1013, 7, 5, 0, 0, 1013, 1014, 3, 158, 79, 0, 1014, 1015, 5, 279, 0, 0,
		1015, 1016, 5, 354, 0, 0, 1016, 1017, 3, 306, 153, 0, 1017, 1709, 1, 0,
		0, 0, 1018, 1019, 5, 13, 0, 0, 1019, 1020, 7, 5, 0, 0, 1020, 1021, 3, 158,
		79, 0, 1021, 1022, 5, 309, 0, 0, 1022, 1023, 5, 342, 0, 0, 1023, 1024,
		3, 132, 66, 0, 1024, 1709, 1, 0, 0, 0, 1025, 1026, 5, 13, 0, 0, 1026, 1027,
		7, 5, 0, 0, 1027, 1028, 3, 158, 79, 0, 1028, 1029, 5, 374, 0, 0, 1029,
		1032, 5, 342, 0, 0, 1030, 1031, 5, 159, 0, 0, 1031, 1033, 5, 121, 0, 0,
		1032, 1030, 1, 0, 0, 0, 1032, 1033, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0,
		1034, 1035, 3, 132, 66, 0, 1035, 1709, 1, 0, 0, 0, 1036, 1037, 5, 13, 0,
		0, 1037, 1038, 5, 338, 0, 0, 1038, 1039, 3, 158, 79, 0, 1039, 1041, 7,
		6, 0, 0, 1040, 1042, 5, 57, 0, 0, 1041, 1040, 1, 0, 0, 0, 1041, 1042, 1,
		0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 1044, 3, 508, 254, 0, 1044, 1709,
		1, 0, 0, 0, 1045, 1046, 5, 13, 0, 0, 1046, 1047, 5, 338, 0, 0, 1047, 1049,
		3, 158, 79, 0, 1048, 1050, 3, 108, 54, 0, 1049, 1048, 1, 0, 0, 0, 1049,
		1050, 1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051, 1053, 5, 46, 0, 0, 1052,
		1054, 5, 57, 0, 0, 1053, 1052, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054,
		1055, 1, 0, 0, 0, 1055, 1056, 3, 306, 153, 0, 1056, 1058, 3, 414, 207,
		0, 1057, 1059, 3, 388, 194, 0, 1058, 1057, 1, 0, 0, 0, 1058, 1059, 1, 0,
		0, 0, 1059, 1709, 1, 0, 0, 0, 1060, 1061, 5, 13, 0, 0, 1061, 1062, 5, 338,
		0, 0, 1062, 1064, 3, 158, 79, 0, 1063, 1065, 3, 108, 54, 0, 1064, 1063,
		1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1066, 1, 0, 0, 0, 1066, 1067,
		5, 283, 0, 0, 1067, 1068, 5, 58, 0, 0, 1068, 1069, 5, 2, 0, 0, 1069, 1070,
		3, 402, 201, 0, 1070, 1071, 5, 3, 0, 0, 1071, 1709, 1, 0, 0, 0, 1072, 1073,
		5, 13, 0, 0, 1073, 1074, 5, 338, 0, 0, 1074, 1076, 3, 158, 79, 0, 1075,
		1077, 3, 108, 54, 0, 1076, 1075, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077,
		1078, 1, 0, 0, 0, 1078, 1079, 5, 309, 0, 0, 1079, 1080, 5, 306, 0, 0, 1080,
		1084, 3, 514, 257, 0, 1081, 1082, 5, 396, 0, 0, 1082, 1083, 5, 307, 0,
		0, 1083, 1085, 3, 132, 66, 0, 1084, 1081, 1, 0, 0, 0, 1084, 1085, 1, 0,
		0, 0, 1085, 1709, 1, 0, 0, 0, 1086, 1087, 5, 13, 0, 0, 1087, 1088, 5, 338,
		0, 0, 1088, 1090, 3, 158, 79, 0, 1089, 1091, 3, 108, 54, 0, 1090, 1089,
		1, 0, 0, 0, 1090, 1091, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1093,
		5, 309, 0, 0, 1093, 1094, 5, 307, 0, 0, 1094, 1095, 3, 132, 66, 0, 1095,
		1709, 1, 0, 0, 0, 1096, 1097, 5, 13, 0, 0, 1097, 1098, 7, 5, 0, 0, 1098,
		1099, 3, 158, 79, 0, 1099, 1104, 5, 9, 0, 0, 1100, 1101, 5, 159, 0, 0,
		1101, 1102, 3, 340, 170, 0, 1102, 1103, 5, 121, 0, 0, 1103, 1105, 1, 0,
		0, 0, 1104, 1100, 1, 0, 0, 0, 1104, 1105, 1, 0, 0, 0, 1105, 1107, 1, 0,
		0, 0, 1106, 1108, 3, 106, 53, 0, 1107, 1106, 1, 0, 0, 0, 1108, 1109, 1,
		0, 0, 0, 1109, 1107, 1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110, 1709, 1,
		0, 0, 0, 1111, 1112, 5, 13, 0, 0, 1112, 1113, 5, 338, 0, 0, 1113, 1114,
		3, 158, 79, 0, 1114, 1115, 3, 108, 54, 0, 1115, 1116, 5, 279, 0, 0, 1116,
		1117, 5, 354, 0, 0, 1117, 1118, 3, 108, 54, 0, 1118, 1709, 1, 0, 0, 0,
		1119, 1120, 5, 13, 0, 0, 1120, 1121, 7, 5, 0, 0, 1121, 1122, 3, 158, 79,
		0, 1122, 1125, 5, 110, 0, 0, 1123, 1124, 5, 159, 0, 0, 1124, 1126, 5, 121,
		0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126, 1127, 1, 0,
		0, 0, 1127, 1132, 3, 108, 54, 0, 1128, 1129, 5, 4, 0, 0, 1129, 1131, 3,
		108, 54, 0, 1130, 1128, 1, 0, 0, 0, 1131, 1134, 1, 0, 0, 0, 1132, 1130,
		1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1136, 1, 0, 0, 0, 1134, 1132,
		1, 0, 0, 0, 1135, 1137, 5, 264, 0, 0, 1136, 1135, 1, 0, 0, 0, 1136, 1137,
		1, 0, 0, 0, 1137, 1709, 1, 0, 0, 0, 1138, 1139, 5, 13, 0, 0, 1139, 1140,
		5, 338, 0, 0, 1140, 1142, 3, 158, 79, 0, 1141, 1143, 3, 108, 54, 0, 1142,
		1141, 1, 0, 0, 0, 1142, 1143, 1, 0, 0, 0, 1143, 1144, 1, 0, 0, 0, 1144,
		1145, 5, 309, 0, 0, 1145, 1146, 3, 94, 47, 0, 1146, 1709, 1, 0, 0, 0, 1147,
		1148, 5, 13, 0, 0, 1148, 1149, 5, 338, 0, 0, 1149, 1150, 3, 158, 79, 0,
		1150, 1151, 5, 272, 0, 0, 1151, 1152, 5, 253, 0, 0, 1152, 1709, 1, 0, 0,
		0, 1153, 1154, 5, 13, 0, 0, 1154, 1155, 5, 338, 0, 0, 1155, 1160, 3, 158,
		79, 0, 1156, 1161, 3, 88, 44, 0, 1157, 1158, 5, 51, 0, 0, 1158, 1159, 5,
		36, 0, 0, 1159, 1161, 5, 230, 0, 0, 1160, 1156, 1, 0, 0, 0, 1160, 1157,
		1, 0, 0, 0, 1161, 1709, 1, 0, 0, 0, 1162, 1163, 5, 13, 0, 0, 1163, 1164,
		5, 338, 0, 0, 1164, 1165, 3, 158, 79, 0, 1165, 1166, 3, 390, 195, 0, 1166,
		1709, 1, 0, 0, 0, 1167, 1168, 5, 13, 0, 0, 1168, 1169, 5, 338, 0, 0, 1169,
		1170, 3, 158, 79, 0, 1170, 1171, 5, 9, 0, 0, 1171, 1172, 3, 488, 244, 0,
		1172, 1709, 1, 0, 0, 0, 1173, 1174, 5, 13, 0, 0, 1174, 1175, 5, 338, 0,
		0, 1175, 1176, 3, 158, 79, 0, 1176, 1177, 5, 110, 0, 0, 1177, 1180, 5,
		67, 0, 0, 1178, 1179, 5, 159, 0, 0, 1179, 1181, 5, 121, 0, 0, 1180, 1178,
		1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182, 1184,
		3, 474, 237, 0, 1183, 1185, 7, 2, 0, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185,
		1, 0, 0, 0, 1185, 1709, 1, 0, 0, 0, 1186, 1187, 5, 110, 0, 0, 1187, 1190,
		5, 338, 0, 0, 1188, 1189, 5, 159, 0, 0, 1189, 1191, 5, 121, 0, 0, 1190,
		1188, 1, 0, 0, 0, 1190, 1191, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192,
		1194, 3, 158, 79, 0, 1193, 1195, 5, 264, 0, 0, 1194, 1193, 1, 0, 0, 0,
		1194, 1195, 1, 0, 0, 0, 1195, 1709, 1, 0, 0, 0, 1196, 1197, 5, 110, 0,
		0, 1197, 1200, 5, 387, 0, 0, 1198, 1199, 5, 159, 0, 0, 1199, 1201, 5, 121,
		0, 0, 1200, 1198, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1202, 1, 0,
		0, 0, 1202, 1709, 3, 158, 79, 0, 1203, 1206, 5, 71, 0, 0, 1204, 1205, 5,
		242, 0, 0, 1205, 1207, 5, 283, 0, 0, 1206, 1204, 1, 0, 0, 0, 1206, 1207,
		1, 0, 0, 0, 1207, 1212, 1, 0, 0, 0, 1208, 1210, 5, 148, 0, 0, 1209, 1208,
		1, 0, 0, 0, 1209, 1210, 1, 0, 0, 0, 1210, 1211, 1, 0, 0, 0, 1211, 1213,
		5, 343, 0, 0, 1212, 1209, 1, 0, 0, 0, 1212, 1213, 1, 0, 0, 0, 1213, 1214,
		1, 0, 0, 0, 1214, 1219, 5, 387, 0, 0, 1215, 1216, 5, 159, 0, 0, 1216, 1217,
		3, 340, 170, 0, 1217, 1218, 5, 121, 0, 0, 1218, 1220, 1, 0, 0, 0, 1219,
		1215, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221,
		1223, 3, 158, 79, 0, 1222, 1224, 3, 278, 139, 0, 1223, 1222, 1, 0, 0, 0,
		1223, 1224, 1, 0, 0, 0, 1224, 1235, 1, 0, 0, 0, 1225, 1234, 3, 98, 49,
		0, 1226, 1234, 3, 96, 48, 0, 1227, 1234, 3, 390, 195, 0, 1228, 1229, 5,
		252, 0, 0, 1229, 1230, 5, 238, 0, 0, 1230, 1234, 3, 270, 135, 0, 1231,
		1232, 5, 342, 0, 0, 1232, 1234, 3, 132, 66, 0, 1233, 1225, 1, 0, 0, 0,
		1233, 1226, 1, 0, 0, 0, 1233, 1227, 1, 0, 0, 0, 1233, 1228, 1, 0, 0, 0,
		1233, 1231, 1, 0, 0, 0, 1234, 1237, 1, 0, 0, 0, 1235, 1233, 1, 0, 0, 0,
		1235, 1236, 1, 0, 0, 0, 1236, 1238, 1, 0, 0, 0, 1237, 1235, 1, 0, 0, 0,
		1238, 1239, 5, 22, 0, 0, 1239, 1240, 3, 102, 51, 0, 1240, 1709, 1, 0, 0,
		0, 1241, 1244, 5, 71, 0, 0, 1242, 1243, 5, 242, 0, 0, 1243, 1245, 5, 283,
		0, 0, 1244, 1242, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 1247, 1, 0,
		0, 0, 1246, 1248, 5, 148, 0, 0, 1247, 1246, 1, 0, 0, 0, 1247, 1248, 1,
		0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249, 1250, 5, 343, 0, 0, 1250, 1251,
		5, 387, 0, 0, 1251, 1256, 3, 312, 156, 0, 1252, 1253, 5, 2, 0, 0, 1253,
		1254, 3, 412, 206, 0, 1254, 1255, 5, 3, 0, 0, 1255, 1257, 1, 0, 0, 0, 1256,
		1252, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1258, 1, 0, 0, 0, 1258,
		1261, 3, 128, 64, 0, 1259, 1260, 5, 241, 0, 0, 1260, 1262, 3, 132, 66,
		0, 1261, 1259, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1709, 1, 0, 0,
		0, 1263, 1264, 5, 13, 0, 0, 1264, 1265, 5, 387, 0, 0, 1265, 1267, 3, 158,
		79, 0, 1266, 1268, 5, 22, 0, 0, 1267, 1266, 1, 0, 0, 0, 1267, 1268, 1,
		0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 1270, 3, 102, 51, 0, 1270, 1709,
		1, 0, 0, 0, 1271, 1272, 5, 13, 0, 0, 1272, 1273, 5, 387, 0, 0, 1273, 1274,
		3, 158, 79, 0, 1274, 1275, 3, 96, 48, 0, 1275, 1709, 1, 0, 0, 0, 1276,
		1279, 5, 71, 0, 0, 1277, 1278, 5, 242, 0, 0, 1278, 1280, 5, 283, 0, 0,
		1279, 1277, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280, 1282, 1, 0, 0, 0,
		1281, 1283, 5, 343, 0, 0, 1282, 1281, 1, 0, 0, 0, 1282, 1283, 1, 0, 0,
		0, 1283, 1284, 1, 0, 0, 0, 1284, 1289, 5, 145, 0, 0, 1285, 1286, 5, 159,
		0, 0, 1286, 1287, 3, 340, 170, 0, 1287, 1288, 5, 121, 0, 0, 1288, 1290,
		1, 0, 0, 0, 1289, 1285, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1291,
		1, 0, 0, 0, 1291, 1292, 3, 158, 79, 0, 1292, 1293, 5, 22, 0, 0, 1293, 1303,
		3, 514, 257, 0, 1294, 1295, 5, 379, 0, 0, 1295, 1300, 3, 154, 77, 0, 1296,
		1297, 5, 4, 0, 0, 1297, 1299, 3, 154, 77, 0, 1298, 1296, 1, 0, 0, 0, 1299,
		1302, 1, 0, 0, 0, 1300, 1298, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301,
		1304, 1, 0, 0, 0, 1302, 1300, 1, 0, 0, 0, 1303, 1294, 1, 0, 0, 0, 1303,
		1304, 1, 0, 0, 0, 1304, 1709, 1, 0, 0, 0, 1305, 1308, 5, 71, 0, 0, 1306,
		1307, 5, 242, 0, 0, 1307, 1309, 5, 283, 0, 0, 1308, 1306, 1, 0, 0, 0, 1308,
		1309, 1, 0, 0, 0, 1309, 1311, 1, 0, 0, 0, 1310, 1312, 5, 343, 0, 0, 1311,
		1310, 1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313,
		1318, 5, 145, 0, 0, 1314, 1315, 5, 159, 0, 0, 1315, 1316, 3, 340, 170,
		0, 1316, 1317, 5, 121, 0, 0, 1317, 1319, 1, 0, 0, 0, 1318, 1314, 1, 0,
		0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1321, 3, 158,
		79, 0, 1321, 1323, 5, 2, 0, 0, 1322, 1324, 3, 420, 210, 0, 1323, 1322,
		1, 0, 0, 0, 1323, 1324, 1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 1335,
		5, 3, 0, 0, 1326, 1333, 5, 288, 0, 0, 1327, 1334, 3, 400, 200, 0, 1328,
		1329, 5, 338, 0, 0, 1329, 1330, 5, 2, 0, 0, 1330, 1331, 3, 412, 206, 0,
		1331, 1332, 5, 3, 0, 0, 1332, 1334, 1, 0, 0, 0, 1333, 1327, 1, 0, 0, 0,
		1333, 1328, 1, 0, 0, 0, 1334, 1336, 1, 0, 0, 0, 1335, 1326, 1, 0, 0, 0,
		1335, 1336, 1, 0, 0, 0, 1336, 1337, 1, 0, 0, 0, 1337, 1338, 3, 438, 219,
		0, 1338, 1341, 5, 287, 0, 0, 1339, 1342, 3, 102, 51, 0, 1340, 1342, 3,
		328, 164, 0, 1341, 1339, 1, 0, 0, 0, 1341, 1340, 1, 0, 0, 0, 1342, 1709,
		1, 0, 0, 0, 1343, 1345, 5, 110, 0, 0, 1344, 1346, 5, 343, 0, 0, 1345, 1344,
		1, 0, 0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 1350,
		5, 145, 0, 0, 1348, 1349, 5, 159, 0, 0, 1349, 1351, 5, 121, 0, 0, 1350,
		1348, 1, 0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351, 1352, 1, 0, 0, 0, 1352,
		1709, 3, 158, 79, 0, 1353, 1356, 5, 93, 0, 0, 1354, 1355, 5, 242, 0, 0,
		1355, 1357, 5, 283, 0, 0, 1356, 1354, 1, 0, 0, 0, 1356, 1357, 1, 0, 0,
		0, 1357, 1359, 1, 0, 0, 0, 1358, 1360, 3, 118, 59, 0, 1359, 1358, 1, 0,
		0, 0, 1359, 1360, 1, 0, 0, 0, 1360, 1361, 1, 0, 0, 0, 1361, 1366, 3, 158,
		79, 0, 1362, 1363, 5, 4, 0, 0, 1363, 1365, 3, 158, 79, 0, 1364, 1362, 1,
		0, 0, 0, 1365, 1368, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1366, 1367, 1,
		0, 0, 0, 1367, 1370, 1, 0, 0, 0, 1368, 1366, 1, 0, 0, 0, 1369, 1371, 3,
		400, 200, 0, 1370, 1369, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1373,
		1, 0, 0, 0, 1372, 1374, 3, 410, 205, 0, 1373, 1372, 1, 0, 0, 0, 1373, 1374,
		1, 0, 0, 0, 1374, 1709, 1, 0, 0, 0, 1375, 1376, 5, 110, 0, 0, 1376, 1377,
		5, 343, 0, 0, 1377, 1380, 3, 118, 59, 0, 1378, 1379, 5, 159, 0, 0, 1379,
		1381, 5, 121, 0, 0, 1380, 1378, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1381,
		1382, 1, 0, 0, 0, 1382, 1383, 3, 158, 79, 0, 1383, 1709, 1, 0, 0, 0, 1384,
		1386, 5, 123, 0, 0, 1385, 1387, 7, 7, 0, 0, 1386, 1385, 1, 0, 0, 0, 1386,
		1387, 1, 0, 0, 0, 1387, 1390, 1, 0, 0, 0, 1388, 1391, 3, 60, 30, 0, 1389,
		1391, 3, 70, 35, 0, 1390, 1388, 1, 0, 0, 0, 1390, 1389, 1, 0, 0, 0, 1391,
		1709, 1, 0, 0, 0, 1392, 1393, 5, 313, 0, 0, 1393, 1396, 5, 339, 0, 0, 1394,
		1395, 7, 3, 0, 0, 1395, 1397, 3, 158, 79, 0, 1396, 1394, 1, 0, 0, 0, 1396,
		1397, 1, 0, 0, 0, 1397, 1402, 1, 0, 0, 0, 1398, 1400, 5, 194, 0, 0, 1399,
		1398, 1, 0, 0, 0, 1399, 1400, 1, 0, 0, 0, 1400, 1401, 1, 0, 0, 0, 1401,
		1403, 3, 514, 257, 0, 1402, 1399, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403,
		1709, 1, 0, 0, 0, 1404, 1405, 5, 313, 0, 0, 1405, 1406, 5, 338, 0, 0, 1406,
		1409, 5, 126, 0, 0, 1407, 1408, 7, 3, 0, 0, 1408, 1410, 3, 158, 79, 0,
		1409, 1407, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0,
		1411, 1412, 5, 194, 0, 0, 1412, 1414, 3, 514, 257, 0, 1413, 1415, 3, 108,
		54, 0, 1414, 1413, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 1709, 1, 0,
		0, 0, 1416, 1417, 5, 313, 0, 0, 1417, 1418, 5, 342, 0, 0, 1418, 1423, 3,
		158, 79, 0, 1419, 1420, 5, 2, 0, 0, 1420, 1421, 3, 136, 68, 0, 1421, 1422,
		5, 3, 0, 0, 1422, 1424, 1, 0, 0, 0, 1423, 1419, 1, 0, 0, 0, 1423, 1424,
		1, 0, 0, 0, 1424, 1709, 1, 0, 0, 0, 1425, 1426, 5, 313, 0, 0, 1426, 1427,
		5, 58, 0, 0, 1427, 1428, 7, 3, 0, 0, 1428, 1431, 3, 158, 79, 0, 1429, 1430,
		7, 3, 0, 0, 1430, 1432, 3, 306, 153, 0, 1431, 1429, 1, 0, 0, 0, 1431, 1432,
		1, 0, 0, 0, 1432, 1709, 1, 0, 0, 0, 1433, 1434, 5, 313, 0, 0, 1434, 1437,
		5, 388, 0, 0, 1435, 1436, 7, 3, 0, 0, 1436, 1438, 3, 158, 79, 0, 1437,
		1435, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 1443, 1, 0, 0, 0, 1439,
		1441, 5, 194, 0, 0, 1440, 1439, 1, 0, 0, 0, 1440, 1441, 1, 0, 0, 0, 1441,
		1442, 1, 0, 0, 0, 1442, 1444, 3, 514, 257, 0, 1443, 1440, 1, 0, 0, 0, 1443,
		1444, 1, 0, 0, 0, 1444, 1709, 1, 0, 0, 0, 1445, 1446, 5, 313, 0, 0, 1446,
		1447, 5, 253, 0, 0, 1447, 1449, 3, 158, 79, 0, 1448, 1450, 3, 108, 54,
		0, 1449, 1448, 1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1709, 1, 0, 0,
		0, 1451, 1453, 5, 313, 0, 0, 1452, 1454, 3, 474, 237, 0, 1453, 1452, 1,
		0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 1455, 1, 0, 0, 0, 1455, 1458, 5,
		146, 0, 0, 1456, 1457, 7, 3, 0, 0, 1457, 1459, 3, 158, 79, 0, 1458, 1456,
		1, 0, 0, 0, 1458, 1459, 1, 0, 0, 0, 1459, 1467, 1, 0, 0, 0, 1460, 1462,
		5, 194, 0, 0, 1461, 1460, 1, 0, 0, 0, 1461, 1462, 1, 0, 0, 0, 1462, 1465,
		1, 0, 0, 0, 1463, 1466, 3, 306, 153, 0, 1464, 1466, 3, 514, 257, 0, 1465,
		1463, 1, 0, 0, 0, 1465, 1464, 1, 0, 0, 0, 1466, 1468, 1, 0, 0, 0, 1467,
		1461, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1709, 1, 0, 0, 0, 1469,
		1470, 5, 313, 0, 0, 1470, 1473, 5, 262, 0, 0, 1471, 1472, 7, 3, 0, 0, 1472,
		1474, 3, 158, 79, 0, 1473, 1471, 1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0, 1474,
		1709, 1, 0, 0, 0, 1475, 1476, 5, 313, 0, 0, 1476, 1477, 5, 71, 0, 0, 1477,
		1478, 5, 338, 0, 0, 1478, 1481, 3, 158, 79, 0, 1479, 1480, 5, 22, 0, 0,
		1480, 1482, 5, 306, 0, 0, 1481, 1479, 1, 0, 0, 0, 1481, 1482, 1, 0, 0,
		0, 1482, 1709, 1, 0, 0, 0, 1483, 1484, 5, 313, 0, 0, 1484, 1485, 5, 74,
		0, 0, 1485, 1709, 3, 114, 57, 0, 1486, 1487, 5, 313, 0, 0, 1487, 1492,
		5, 45, 0, 0, 1488, 1490, 5, 194, 0, 0, 1489, 1488, 1, 0, 0, 0, 1489, 1490,
		1, 0, 0, 0, 1490, 1491, 1, 0, 0, 0, 1491, 1493, 3, 514, 257, 0, 1492, 1489,
		1, 0, 0, 0, 1492, 1493, 1, 0, 0, 0, 1493, 1709, 1, 0, 0, 0, 1494, 1495,
		7, 8, 0, 0, 1495, 1497, 5, 145, 0, 0, 1496, 1498, 5, 126, 0, 0, 1497, 1496,
		1, 0, 0, 0, 1497, 1498, 1, 0, 0, 0, 1498, 1499, 1, 0, 0, 0, 1499, 1709,
		3, 120, 60, 0, 1500, 1501, 7, 8, 0, 0, 1501, 1502, 5, 261, 0, 0, 1502,
		1709, 3, 158, 79, 0, 1503, 1504, 7, 8, 0, 0, 1504, 1506, 3, 114, 57, 0,
		1505, 1507, 5, 126, 0, 0, 1506, 1505, 1, 0, 0, 0, 1506, 1507, 1, 0, 0,
		0, 1507, 1508, 1, 0, 0, 0, 1508, 1509, 3, 158, 79, 0, 1509, 1709, 1, 0,
		0, 0, 1510, 1512, 7, 8, 0, 0, 1511, 1513, 5, 338, 0, 0, 1512, 1511, 1,
		0, 0, 0, 1512, 1513, 1, 0, 0, 0, 1513, 1515, 1, 0, 0, 0, 1514, 1516, 7,
		9, 0, 0, 1515, 1514, 1, 0, 0, 0, 1515, 1516, 1, 0, 0, 0, 1516, 1517, 1,
		0, 0, 0, 1517, 1519, 3, 158, 79, 0, 1518, 1520, 3, 108, 54, 0, 1519, 1518,
		1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 1522, 1, 0, 0, 0, 1521, 1523,
		3, 122, 61, 0, 1522, 1521, 1, 0, 0, 0, 1522, 1523, 1, 0, 0, 0, 1523, 1526,
		1, 0, 0, 0, 1524, 1525, 5, 22, 0, 0, 1525, 1527, 5, 183, 0, 0, 1526, 1524,
		1, 0, 0, 0, 1526, 1527, 1, 0, 0, 0, 1527, 1709, 1, 0, 0, 0, 1528, 1530,
		7, 8, 0, 0, 1529, 1531, 5, 266, 0, 0, 1530, 1529, 1, 0, 0, 0, 1530, 1531,
		1, 0, 0, 0, 1531, 1532, 1, 0, 0, 0, 1532, 1709, 3, 102, 51, 0, 1533, 1534,
		5, 59, 0, 0, 1534, 1535, 5, 238, 0, 0, 1535, 1536, 3, 114, 57, 0, 1536,
		1537, 3, 158, 79, 0, 1537, 1538, 5, 179, 0, 0, 1538, 1539, 3, 516, 258,
		0, 1539, 1709, 1, 0, 0, 0, 1540, 1541, 5, 59, 0, 0, 1541, 1542, 5, 238,
		0, 0, 1542, 1543, 5, 338, 0, 0, 1543, 1544, 3, 158, 79, 0, 1544, 1545,
		5, 179, 0, 0, 1545, 1546, 3, 516, 258, 0, 1546, 1709, 1, 0, 0, 0, 1547,
		1548, 5, 277, 0, 0, 1548, 1549, 5, 338, 0, 0, 1549, 1709, 3, 158, 79, 0,
		1550, 1551, 5, 277, 0, 0, 1551, 1552, 5, 145, 0, 0, 1552, 1709, 3, 158,
		79, 0, 1553, 1561, 5, 277, 0, 0, 1554, 1562, 3, 514, 257, 0, 1555, 1557,
		9, 0, 0, 0, 1556, 1555, 1, 0, 0, 0, 1557, 1560, 1, 0, 0, 0, 1558, 1559,
		1, 0, 0, 0, 1558, 1556, 1, 0, 0, 0, 1559, 1562, 1, 0, 0, 0, 1560, 1558,
		1, 0, 0, 0, 1561, 1554, 1, 0, 0, 0, 1561, 1558, 1, 0, 0, 0, 1562, 1709,
		1, 0, 0, 0, 1563, 1565, 5, 38, 0, 0, 1564, 1566, 5, 189, 0, 0, 1565, 1564,
		1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 1567, 1, 0, 0, 0, 1567, 1568,
		5, 338, 0, 0, 1568, 1571, 3, 158, 79, 0, 1569, 1570, 5, 241, 0, 0, 1570,
		1572, 3, 132, 66, 0, 1571, 1569, 1, 0, 0, 0, 1571, 1572, 1, 0, 0, 0, 1572,
		1577, 1, 0, 0, 0, 1573, 1575, 5, 22, 0, 0, 1574, 1573, 1, 0, 0, 0, 1574,
		1575, 1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 1578, 3, 102, 51, 0, 1577,
		1574, 1, 0, 0, 0, 1577, 1578, 1, 0, 0, 0, 1578, 1709, 1, 0, 0, 0, 1579,
		1580, 5, 368, 0, 0, 1580, 1583, 5, 338, 0, 0, 1581, 1582, 5, 159, 0, 0,
		1582, 1584, 5, 121, 0, 0, 1583, 1581, 1, 0, 0, 0, 1583, 1584, 1, 0, 0,
		0, 1584, 1585, 1, 0, 0, 0, 1585, 1709, 3, 158, 79, 0, 1586, 1587, 5, 50,
		0, 0, 1587, 1709, 5, 38, 0, 0, 1588, 1589, 5, 199, 0, 0, 1589, 1591, 5,
		82, 0, 0, 1590, 1592, 5, 200, 0, 0, 1591, 1590, 1, 0, 0, 0, 1591, 1592,
		1, 0, 0, 0, 1592, 1593, 1, 0, 0, 0, 1593, 1594, 5, 169, 0, 0, 1594, 1596,
		3, 514, 257, 0, 1595, 1597, 5, 250, 0, 0, 1596, 1595, 1, 0, 0, 0, 1596,
		1597, 1, 0, 0, 0, 1597, 1598, 1, 0, 0, 0, 1598, 1599, 5, 177, 0, 0, 1599,
		1600, 5, 338, 0, 0, 1600, 1602, 3, 158, 79, 0, 1601, 1603, 3, 108, 54,
		0, 1602, 1601, 1, 0, 0, 0, 1602, 1603, 1, 0, 0, 0, 1603, 1709, 1, 0, 0,
		0, 1604, 1605, 5, 363, 0, 0, 1605, 1606, 5, 338, 0, 0, 1606, 1608, 3, 158,
		79, 0, 1607, 1609, 3, 108, 54, 0, 1608, 1607, 1, 0, 0, 0, 1608, 1609, 1,
		0, 0, 0, 1609, 1709, 1, 0, 0, 0, 1610, 1612, 5, 222, 0, 0, 1611, 1610,
		1, 0, 0, 0, 1611, 1612, 1, 0, 0, 0, 1612, 1613, 1, 0, 0, 0, 1613, 1614,
		5, 280, 0, 0, 1614, 1615, 5, 338, 0, 0, 1615, 1618, 3, 158, 79, 0, 1616,
		1617, 7, 10, 0, 0, 1617, 1619, 5, 253, 0, 0, 1618, 1616, 1, 0, 0, 0, 1618,
		1619, 1, 0, 0, 0, 1619, 1709, 1, 0, 0, 0, 1620, 1621, 7, 11, 0, 0, 1621,
		1625, 3, 474, 237, 0, 1622, 1624, 9, 0, 0, 0, 1623, 1622, 1, 0, 0, 0, 1624,
		1627, 1, 0, 0, 0, 1625, 1626, 1, 0, 0, 0, 1625, 1623, 1, 0, 0, 0, 1626,
		1709, 1, 0, 0, 0, 1627, 1625, 1, 0, 0, 0, 1628, 1629, 5, 71, 0, 0, 1629,
		1634, 5, 166, 0, 0, 1630, 1631, 5, 159, 0, 0, 1631, 1632, 3, 340, 170,
		0, 1632, 1633, 5, 121, 0, 0, 1633, 1635, 1, 0, 0, 0, 1634, 1630, 1, 0,
		0, 0, 1634, 1635, 1, 0, 0, 0, 1635, 1636, 1, 0, 0, 0, 1636, 1637, 3, 474,
		237, 0, 1637, 1639, 5, 238, 0, 0, 1638, 1640, 5, 338, 0, 0, 1639, 1638,
		1, 0, 0, 0, 1639, 1640, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 1644,
		3, 158, 79, 0, 1642, 1643, 5, 379, 0, 0, 1643, 1645, 3, 474, 237, 0, 1644,
		1642, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646,
		1647, 5, 2, 0, 0, 1647, 1648, 3, 308, 154, 0, 1648, 1651, 5, 3, 0, 0, 1649,
		1650, 5, 241, 0, 0, 1650, 1652, 3, 132, 66, 0, 1651, 1649, 1, 0, 0, 0,
		1651, 1652, 1, 0, 0, 0, 1652, 1709, 1, 0, 0, 0, 1653, 1654, 5, 110, 0,
		0, 1654, 1657, 5, 166, 0, 0, 1655, 1656, 5, 159, 0, 0, 1656, 1658, 5, 121,
		0, 0, 1657, 1655, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1659, 1, 0,
		0, 0, 1659, 1660, 3, 474, 237, 0, 1660, 1662, 5, 238, 0, 0, 1661, 1663,
		5, 338, 0, 0, 1662, 1661, 1, 0, 0, 0, 1662, 1663, 1, 0, 0, 0, 1663, 1664,
		1, 0, 0, 0, 1664, 1665, 3, 158, 79, 0, 1665, 1709, 1, 0, 0, 0, 1666, 1667,
		5, 39, 0, 0, 1667, 1668, 3, 158, 79, 0, 1668, 1677, 5, 2, 0, 0, 1669, 1674,
		3, 332, 166, 0, 1670, 1671, 5, 4, 0, 0, 1671, 1673, 3, 332, 166, 0, 1672,
		1670, 1, 0, 0, 0, 1673, 1676, 1, 0, 0, 0, 1674, 1672, 1, 0, 0, 0, 1674,
		1675, 1, 0, 0, 0, 1675, 1678, 1, 0, 0, 0, 1676, 1674, 1, 0, 0, 0, 1677,
		1669, 1, 0, 0, 0, 1677, 1678, 1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679,
		1680, 5, 3, 0, 0, 1680, 1709, 1, 0, 0, 0, 1681, 1685, 3, 82, 41, 0, 1682,
		1684, 9, 0, 0, 0, 1683, 1682, 1, 0, 0, 0, 1684, 1687, 1, 0, 0, 0, 1685,
		1686, 1, 0, 0, 0, 1685, 1683, 1, 0, 0, 0, 1686, 1709, 1, 0, 0, 0, 1687,
		1685, 1, 0, 0, 0, 1688, 1694, 3, 66, 33, 0, 1689, 1691, 5, 2, 0, 0, 1690,
		1692, 3, 416, 208, 0, 1691, 1690, 1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692,
		1693, 1, 0, 0, 0, 1693, 1695, 5, 3, 0, 0, 1694, 1689, 1, 0, 0, 0, 1694,
		1695, 1, 0, 0, 0, 1695, 1697, 1, 0, 0, 0, 1696, 1698, 3, 128, 64, 0, 1697,
		1696, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1699, 1, 0, 0, 0, 1699,
		1702, 3, 130, 65, 0, 1700, 1701, 5, 22, 0, 0, 1701, 1703, 3, 102, 51, 0,
		1702, 1700, 1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0, 1703, 1709, 1, 0, 0, 0,
		1704, 1705, 3, 112, 56, 0, 1705, 1706, 3, 104, 52, 0, 1706, 1707, 3, 102,
		51, 0, 1707, 1709, 1, 0, 0, 0, 1708, 796, 1, 0, 0, 0, 1708, 797, 1, 0,
		0, 0, 1708, 799, 1, 0, 0, 0, 1708, 802, 1, 0, 0, 0, 1708, 804, 1, 0, 0,
		0, 1708, 808, 1, 0, 0, 0, 1708, 811, 1, 0, 0, 0, 1708, 831, 1, 0, 0, 0,
		1708, 838, 1, 0, 0, 0, 1708, 845, 1, 0, 0, 0, 1708, 850, 1, 0, 0, 0, 1708,
		856, 1, 0, 0, 0, 1708, 866, 1, 0, 0, 0, 1708, 878, 1, 0, 0, 0, 1708, 895,
		1, 0, 0, 0, 1708, 917, 1, 0, 0, 0, 1708, 934, 1, 0, 0, 0, 1708, 951, 1,
		0, 0, 0, 1708, 962, 1, 0, 0, 0, 1708, 969, 1, 0, 0, 0, 1708, 978, 1, 0,
		0, 0, 1708, 987, 1, 0, 0, 0, 1708, 1000, 1, 0, 0, 0, 1708, 1011, 1, 0,
		0, 0, 1708, 1018, 1, 0, 0, 0, 1708, 1025, 1, 0, 0, 0, 1708, 1036, 1, 0,
		0, 0, 1708, 1045, 1, 0, 0, 0, 1708, 1060, 1, 0, 0, 0, 1708, 1072, 1, 0,
		0, 0, 1708, 1086, 1, 0, 0, 0, 1708, 1096, 1, 0, 0, 0, 1708, 1111, 1, 0,
		0, 0, 1708, 1119, 1, 0, 0, 0, 1708, 1138, 1, 0, 0, 0, 1708, 1147, 1, 0,
		0, 0, 1708, 1153, 1, 0, 0, 0, 1708, 1162, 1, 0, 0, 0, 1708, 1167, 1, 0,
		0, 0, 1708, 1173, 1, 0, 0, 0, 1708, 1186, 1, 0, 0, 0, 1708, 1196, 1, 0,
		0, 0, 1708, 1203, 1, 0, 0, 0, 1708, 1241, 1, 0, 0, 0, 1708, 1263, 1, 0,
		0, 0, 1708, 1271, 1, 0, 0, 0, 1708, 1276, 1, 0, 0, 0, 1708, 1305, 1, 0,
		0, 0, 1708, 1343, 1, 0, 0, 0, 1708, 1353, 1, 0, 0, 0, 1708, 1375, 1, 0,
		0, 0, 1708, 1384, 1, 0, 0, 0, 1708, 1392, 1, 0, 0, 0, 1708, 1404, 1, 0,
		0, 0, 1708, 1416, 1, 0, 0, 0, 1708, 1425, 1, 0, 0, 0, 1708, 1433, 1, 0,
		0, 0, 1708, 1445, 1, 0, 0, 0, 1708, 1451, 1, 0, 0, 0, 1708, 1469, 1, 0,
		0, 0, 1708, 1475, 1, 0, 0, 0, 1708, 1483, 1, 0, 0, 0, 1708, 1486, 1, 0,
		0, 0, 1708, 1494, 1, 0, 0, 0, 1708, 1500, 1, 0, 0, 0, 1708, 1503, 1, 0,
		0, 0, 1708, 1510, 1, 0, 0, 0, 1708, 1528, 1, 0, 0, 0, 1708, 1533, 1, 0,
		0, 0, 1708, 1540, 1, 0, 0, 0, 1708, 1547, 1, 0, 0, 0, 1708, 1550, 1, 0,
		0, 0, 1708, 1553, 1, 0, 0, 0, 1708, 1563, 1, 0, 0, 0, 1708, 1579, 1, 0,
		0, 0, 1708, 1586, 1, 0, 0, 0, 1708, 1588, 1, 0, 0, 0, 1708, 1604, 1, 0,
		0, 0, 1708, 1611, 1, 0, 0, 0, 1708, 1620, 1, 0, 0, 0, 1708, 1628, 1, 0,
		0, 0, 1708, 1653, 1, 0, 0, 0, 1708, 1666, 1, 0, 0, 0, 1708, 1681, 1, 0,
		0, 0, 1708, 1688, 1, 0, 0, 0, 1708, 1704, 1, 0, 0, 0, 1709, 61, 1, 0, 0,
		0, 1710, 1711, 5, 210, 0, 0, 1711, 1712, 5, 387, 0, 0, 1712, 63, 1, 0,
		0, 0, 1713, 1714, 5, 330, 0, 0, 1714, 1715, 5, 338, 0, 0, 1715, 65, 1,
		0, 0, 0, 1716, 1719, 5, 71, 0, 0, 1717, 1720, 3, 62, 31, 0, 1718, 1720,
		3, 64, 32, 0, 1719, 1717, 1, 0, 0, 0, 1719, 1718, 1, 0, 0, 0, 1720, 1725,
		1, 0, 0, 0, 1721, 1722, 5, 159, 0, 0, 1722, 1723, 3, 340, 170, 0, 1723,
		1724, 5, 121, 0, 0, 1724, 1726, 1, 0, 0, 0, 1725, 1721, 1, 0, 0, 0, 1725,
		1726, 1, 0, 0, 0, 1726, 1727, 1, 0, 0, 0, 1727, 1728, 3, 158, 79, 0, 1728,
		67, 1, 0, 0, 0, 1729, 1730, 5, 329, 0, 0, 1730, 1732, 3, 306, 153, 0, 1731,
		1733, 3, 284, 142, 0, 1732, 1731, 1, 0, 0, 0, 1732, 1733, 1, 0, 0, 0, 1733,
		1734, 1, 0, 0, 0, 1734, 1735, 3, 300, 150, 0, 1735, 1746, 1, 0, 0, 0, 1736,
		1737, 5, 329, 0, 0, 1737, 1738, 5, 2, 0, 0, 1738, 1739, 3, 306, 153, 0,
		1739, 1741, 5, 3, 0, 0, 1740, 1742, 3, 284, 142, 0, 1741, 1740, 1, 0, 0,
		0, 1741, 1742, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1744, 3, 300,
		150, 0, 1744, 1746, 1, 0, 0, 0, 1745, 1729, 1, 0, 0, 0, 1745, 1736, 1,
		0, 0, 0, 1746, 69, 1, 0, 0, 0, 1747, 1748, 5, 309, 0, 0, 1748, 1752, 5,
		292, 0, 0, 1749, 1751, 9, 0, 0, 0, 1750, 1749, 1, 0, 0, 0, 1751, 1754,
		1, 0, 0, 0, 1752, 1753, 1, 0, 0, 0, 1752, 1750, 1, 0, 0, 0, 1753, 1828,
		1, 0, 0, 0, 1754, 1752, 1, 0, 0, 0, 1755, 1756, 5, 309, 0, 0, 1756, 1757,
		5, 346, 0, 0, 1757, 1758, 5, 401, 0, 0, 1758, 1828, 3, 372, 186, 0, 1759,
		1760, 5, 309, 0, 0, 1760, 1761, 5, 346, 0, 0, 1761, 1762, 5, 401, 0, 0,
		1762, 1828, 3, 76, 38, 0, 1763, 1764, 5, 309, 0, 0, 1764, 1765, 5, 346,
		0, 0, 1765, 1769, 5, 401, 0, 0, 1766, 1768, 9, 0, 0, 0, 1767, 1766, 1,
		0, 0, 0, 1768, 1771, 1, 0, 0, 0, 1769, 1770, 1, 0, 0, 0, 1769, 1767, 1,
		0, 0, 0, 1770, 1828, 1, 0, 0, 0, 1771, 1769, 1, 0, 0, 0, 1772, 1773, 5,
		309, 0, 0, 1773, 1774, 3, 118, 59, 0, 1774, 1775, 3, 198, 99, 0, 1775,
		1828, 1, 0, 0, 0, 1776, 1777, 5, 309, 0, 0, 1777, 1778, 3, 118, 59, 0,
		1778, 1779, 5, 2, 0, 0, 1779, 1780, 3, 304, 152, 0, 1780, 1781, 5, 3, 0,
		0, 1781, 1782, 5, 402, 0, 0, 1782, 1783, 5, 2, 0, 0, 1783, 1784, 3, 102,
		51, 0, 1784, 1785, 5, 3, 0, 0, 1785, 1828, 1, 0, 0, 0, 1786, 1787, 5, 309,
		0, 0, 1787, 1788, 3, 78, 39, 0, 1788, 1789, 5, 402, 0, 0, 1789, 1790, 3,
		80, 40, 0, 1790, 1828, 1, 0, 0, 0, 1791, 1792, 5, 309, 0, 0, 1792, 1800,
		3, 78, 39, 0, 1793, 1797, 5, 402, 0, 0, 1794, 1796, 9, 0, 0, 0, 1795, 1794,
		1, 0, 0, 0, 1796, 1799, 1, 0, 0, 0, 1797, 1798, 1, 0, 0, 0, 1797, 1795,
		1, 0, 0, 0, 1798, 1801, 1, 0, 0, 0, 1799, 1797, 1, 0, 0, 0, 1800, 1793,
		1, 0, 0, 0, 1800, 1801, 1, 0, 0, 0, 1801, 1828, 1, 0, 0, 0, 1802, 1806,
		5, 309, 0, 0, 1803, 1805, 9, 0, 0, 0, 1804, 1803, 1, 0, 0, 0, 1805, 1808,
		1, 0, 0, 0, 1806, 1807, 1, 0, 0, 0, 1806, 1804, 1, 0, 0, 0, 1807, 1809,
		1, 0, 0, 0, 1808, 1806, 1, 0, 0, 0, 1809, 1810, 5, 402, 0, 0, 1810, 1828,
		3, 80, 40, 0, 1811, 1815, 5, 309, 0, 0, 1812, 1814, 9, 0, 0, 0, 1813, 1812,
		1, 0, 0, 0, 1814, 1817, 1, 0, 0, 0, 1815, 1816, 1, 0, 0, 0, 1815, 1813,
		1, 0, 0, 0, 1816, 1828, 1, 0, 0, 0, 1817, 1815, 1, 0, 0, 0, 1818, 1819,
		5, 284, 0, 0, 1819, 1828, 3, 78, 39, 0, 1820, 1824, 5, 284, 0, 0, 1821,
		1823, 9, 0, 0, 0, 1822, 1821, 1, 0, 0, 0, 1823, 1826, 1, 0, 0, 0, 1824,
		1825, 1, 0, 0, 0, 1824, 1822, 1, 0, 0, 0, 1825, 1828, 1, 0, 0, 0, 1826,
		1824, 1, 0, 0, 0, 1827, 1747, 1, 0, 0, 0, 1827, 1755, 1, 0, 0, 0, 1827,
		1759, 1, 0, 0, 0, 1827, 1763, 1, 0, 0, 0, 1827, 1772, 1, 0, 0, 0, 1827,
		1776, 1, 0, 0, 0, 1827, 1786, 1, 0, 0, 0, 1827, 1791, 1, 0, 0, 0, 1827,
		1802, 1, 0, 0, 0, 1827, 1811, 1, 0, 0, 0, 1827, 1818, 1, 0, 0, 0, 1827,
		1820, 1, 0, 0, 0, 1828, 71, 1, 0, 0, 0, 1829, 1830, 5, 355, 0, 0, 1830,
		1831, 5, 161, 0, 0, 1831, 1834, 3, 328, 164, 0, 1832, 1833, 5, 177, 0,
		0, 1833, 1835, 3, 304, 152, 0, 1834, 1832, 1, 0, 0, 0, 1834, 1835, 1, 0,
		0, 0, 1835, 1837, 1, 0, 0, 0, 1836, 1838, 3, 74, 37, 0, 1837, 1836, 1,
		0, 0, 0, 1837, 1838, 1, 0, 0, 0, 1838, 73, 1, 0, 0, 0, 1839, 1840, 5, 379,
		0, 0, 1840, 1841, 5, 2, 0, 0, 1841, 1842, 3, 318, 159, 0, 1842, 1843, 5,
		3, 0, 0, 1843, 1847, 1, 0, 0, 0, 1844, 1845, 5, 379, 0, 0, 1845, 1847,
		3, 318, 159, 0, 1846, 1839, 1, 0, 0, 0, 1846, 1844, 1, 0, 0, 0, 1847, 75,
		1, 0, 0, 0, 1848, 1851, 3, 514, 257, 0, 1849, 1851, 5, 200, 0, 0, 1850,
		1848, 1, 0, 0, 0, 1850, 1849, 1, 0, 0, 0, 1851, 77, 1, 0, 0, 0, 1852, 1853,
		3, 478, 239, 0, 1853, 79, 1, 0, 0, 0, 1854, 1855, 3, 480, 240, 0, 1855,
		81, 1, 0, 0, 0, 1856, 1857, 5, 71, 0, 0, 1857, 2025, 5, 292, 0, 0, 1858,
		1859, 5, 110, 0, 0, 1859, 2025, 5, 292, 0, 0, 1860, 1862, 5, 149, 0, 0,
		1861, 1863, 5, 292, 0, 0, 1862, 1861, 1, 0, 0, 0, 1862, 1863, 1, 0, 0,
		0, 1863, 2025, 1, 0, 0, 0, 1864, 1866, 5, 289, 0, 0, 1865, 1867, 5, 292,
		0, 0, 1866, 1865, 1, 0, 0, 0, 1866, 1867, 1, 0, 0, 0, 1867, 2025, 1, 0,
		0, 0, 1868, 1869, 5, 313, 0, 0, 1869, 2025, 5, 149, 0, 0, 1870, 1871, 5,
		313, 0, 0, 1871, 1873, 5, 292, 0, 0, 1872, 1874, 5, 149, 0, 0, 1873, 1872,
		1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 2025, 1, 0, 0, 0, 1875, 1876,
		5, 313, 0, 0, 1876, 2025, 5, 260, 0, 0, 1877, 1878, 5, 313, 0, 0, 1878,
		2025, 5, 293, 0, 0, 1879, 1880, 5, 313, 0, 0, 1880, 1881, 5, 74, 0, 0,
		1881, 2025, 5, 293, 0, 0, 1882, 1883, 5, 124, 0, 0, 1883, 2025, 5, 338,
		0, 0, 1884, 1885, 5, 162, 0, 0, 1885, 2025, 5, 338, 0, 0, 1886, 1887, 5,
		313, 0, 0, 1887, 2025, 5, 62, 0, 0, 1888, 1889, 5, 313, 0, 0, 1889, 1890,
		5, 71, 0, 0, 1890, 2025, 5, 338, 0, 0, 1891, 1892, 5, 313, 0, 0, 1892,
		2025, 5, 359, 0, 0, 1893, 1894, 5, 313, 0, 0, 1894, 2025, 5, 167, 0, 0,
		1895, 1896, 5, 313, 0, 0, 1896, 2025, 5, 203, 0, 0, 1897, 1898, 5, 71,
		0, 0, 1898, 2025, 5, 166, 0, 0, 1899, 1900, 5, 110, 0, 0, 1900, 2025, 5,
		166, 0, 0, 1901, 1902, 5, 13, 0, 0, 1902, 2025, 5, 166, 0, 0, 1903, 1904,
		5, 202, 0, 0, 1904, 2025, 5, 338, 0, 0, 1905, 1906, 5, 202, 0, 0, 1906,
		2025, 5, 84, 0, 0, 1907, 1908, 5, 372, 0, 0, 1908, 2025, 5, 338, 0, 0,
		1909, 1910, 5, 372, 0, 0, 1910, 2025, 5, 84, 0, 0, 1911, 1912, 5, 71, 0,
		0, 1912, 1913, 5, 343, 0, 0, 1913, 2025, 5, 207, 0, 0, 1914, 1915, 5, 110,
		0, 0, 1915, 1916, 5, 343, 0, 0, 1916, 2025, 5, 207, 0, 0, 1917, 1918, 5,
		13, 0, 0, 1918, 1919, 5, 338, 0, 0, 1919, 1920, 3, 312, 156, 0, 1920, 1921,
		5, 231, 0, 0, 1921, 1922, 5, 52, 0, 0, 1922, 2025, 1, 0, 0, 0, 1923, 1924,
		5, 13, 0, 0, 1924, 1925, 5, 338, 0, 0, 1925, 1926, 3, 312, 156, 0, 1926,
		1927, 5, 52, 0, 0, 1927, 1928, 5, 36, 0, 0, 1928, 2025, 1, 0, 0, 0, 1929,
		1930, 5, 13, 0, 0, 1930, 1931, 5, 338, 0, 0, 1931, 1932, 3, 312, 156, 0,
		1932, 1933, 5, 231, 0, 0, 1933, 1934, 5, 319, 0, 0, 1934, 2025, 1, 0, 0,
		0, 1935, 1936, 5, 13, 0, 0, 1936, 1937, 5, 338, 0, 0, 1937, 1938, 3, 312,
		156, 0, 1938, 1939, 5, 315, 0, 0, 1939, 1940, 5, 36, 0, 0, 1940, 2025,
		1, 0, 0, 0, 1941, 1942, 5, 13, 0, 0, 1942, 1943, 5, 338, 0, 0, 1943, 1944,
		3, 312, 156, 0, 1944, 1945, 5, 231, 0, 0, 1945, 1946, 5, 315, 0, 0, 1946,
		2025, 1, 0, 0, 0, 1947, 1948, 5, 13, 0, 0, 1948, 1949, 5, 338, 0, 0, 1949,
		1950, 3, 312, 156, 0, 1950, 1951, 5, 231, 0, 0, 1951, 1952, 5, 327, 0,
		0, 1952, 1953, 5, 22, 0, 0, 1953, 1954, 5, 103, 0, 0, 1954, 2025, 1, 0,
		0, 0, 1955, 1956, 5, 13, 0, 0, 1956, 1957, 5, 338, 0, 0, 1957, 1958, 3,
		312, 156, 0, 1958, 1959, 5, 309, 0, 0, 1959, 1960, 5, 315, 0, 0, 1960,
		1961, 5, 201, 0, 0, 1961, 2025, 1, 0, 0, 0, 1962, 1963, 5, 13, 0, 0, 1963,
		1964, 5, 338, 0, 0, 1964, 1965, 3, 312, 156, 0, 1965, 1966, 5, 119, 0,
		0, 1966, 1967, 5, 251, 0, 0, 1967, 2025, 1, 0, 0, 0, 1968, 1969, 5, 13,
		0, 0, 1969, 1970, 5, 338, 0, 0, 1970, 1971, 3, 312, 156, 0, 1971, 1972,
		5, 20, 0, 0, 1972, 1973, 5, 251, 0, 0, 1973, 2025, 1, 0, 0, 0, 1974, 1975,
		5, 13, 0, 0, 1975, 1976, 5, 338, 0, 0, 1976, 1977, 3, 312, 156, 0, 1977,
		1978, 5, 366, 0, 0, 1978, 1979, 5, 251, 0, 0, 1979, 2025, 1, 0, 0, 0, 1980,
		1981, 5, 13, 0, 0, 1981, 1982, 5, 338, 0, 0, 1982, 1983, 3, 312, 156, 0,
		1983, 1984, 5, 356, 0, 0, 1984, 2025, 1, 0, 0, 0, 1985, 1986, 5, 13, 0,
		0, 1986, 1987, 5, 338, 0, 0, 1987, 1989, 3, 312, 156, 0, 1988, 1990, 3,
		108, 54, 0, 1989, 1988, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0, 1990, 1991,
		1, 0, 0, 0, 1991, 1992, 5, 61, 0, 0, 1992, 2025, 1, 0, 0, 0, 1993, 1994,
		5, 13, 0, 0, 1994, 1995, 5, 338, 0, 0, 1995, 1997, 3, 312, 156, 0, 1996,
		1998, 3, 108, 54, 0, 1997, 1996, 1, 0, 0, 0, 1997, 1998, 1, 0, 0, 0, 1998,
		1999, 1, 0, 0, 0, 1999, 2000, 5, 65, 0, 0, 2000, 2025, 1, 0, 0, 0, 2001,
		2002, 5, 13, 0, 0, 2002, 2003, 5, 338, 0, 0, 2003, 2005, 3, 312, 156, 0,
		2004, 2006, 3, 108, 54, 0, 2005, 2004, 1, 0, 0, 0, 2005, 2006, 1, 0, 0,
		0, 2006, 2007, 1, 0, 0, 0, 2007, 2008, 5, 309, 0, 0, 2008, 2009, 5, 133,
		0, 0, 2009, 2025, 1, 0, 0, 0, 2010, 2011, 5, 13, 0, 0, 2011, 2012, 5, 338,
		0, 0, 2012, 2014, 3, 312, 156, 0, 2013, 2015, 3, 108, 54, 0, 2014, 2013,
		1, 0, 0, 0, 2014, 2015, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2017,
		5, 283, 0, 0, 2017, 2018, 5, 58, 0, 0, 2018, 2025, 1, 0, 0, 0, 2019, 2020,
		5, 325, 0, 0, 2020, 2025, 5, 358, 0, 0, 2021, 2025, 5, 60, 0, 0, 2022,
		2025, 5, 294, 0, 0, 2023, 2025, 5, 102, 0, 0, 2024, 1856, 1, 0, 0, 0, 2024,
		1858, 1, 0, 0, 0, 2024, 1860, 1, 0, 0, 0, 2024, 1864, 1, 0, 0, 0, 2024,
		1868, 1, 0, 0, 0, 2024, 1870, 1, 0, 0, 0, 2024, 1875, 1, 0, 0, 0, 2024,
		1877, 1, 0, 0, 0, 2024, 1879, 1, 0, 0, 0, 2024, 1882, 1, 0, 0, 0, 2024,
		1884, 1, 0, 0, 0, 2024, 1886, 1, 0, 0, 0, 2024, 1888, 1, 0, 0, 0, 2024,
		1891, 1, 0, 0, 0, 2024, 1893, 1, 0, 0, 0, 2024, 1895, 1, 0, 0, 0, 2024,
		1897, 1, 0, 0, 0, 2024, 1899, 1, 0, 0, 0, 2024, 1901, 1, 0, 0, 0, 2024,
		1903, 1, 0, 0, 0, 2024, 1905, 1, 0, 0, 0, 2024, 1907, 1, 0, 0, 0, 2024,
		1909, 1, 0, 0, 0, 2024, 1911, 1, 0, 0, 0, 2024, 1914, 1, 0, 0, 0, 2024,
		1917, 1, 0, 0, 0, 2024, 1923, 1, 0, 0, 0, 2024, 1929, 1, 0, 0, 0, 2024,
		1935, 1, 0, 0, 0, 2024, 1941, 1, 0, 0, 0, 2024, 1947, 1, 0, 0, 0, 2024,
		1955, 1, 0, 0, 0, 2024, 1962, 1, 0, 0, 0, 2024, 1968, 1, 0, 0, 0, 2024,
		1974, 1, 0, 0, 0, 2024, 1980, 1, 0, 0, 0, 2024, 1985, 1, 0, 0, 0, 2024,
		1993, 1, 0, 0, 0, 2024, 2001, 1, 0, 0, 0, 2024, 2010, 1, 0, 0, 0, 2024,
		2019, 1, 0, 0, 0, 2024, 2021, 1, 0, 0, 0, 2024, 2022, 1, 0, 0, 0, 2024,
		2023, 1, 0, 0, 0, 2025, 83, 1, 0, 0, 0, 2026, 2028, 5, 71, 0, 0, 2027,
		2029, 5, 343, 0, 0, 2028, 2027, 1, 0, 0, 0, 2028, 2029, 1, 0, 0, 0, 2029,
		2031, 1, 0, 0, 0, 2030, 2032, 5, 127, 0, 0, 2031, 2030, 1, 0, 0, 0, 2031,
		2032, 1, 0, 0, 0, 2032, 2033, 1, 0, 0, 0, 2033, 2038, 5, 338, 0, 0, 2034,
		2035, 5, 159, 0, 0, 2035, 2036, 3, 340, 170, 0, 2036, 2037, 5, 121, 0,
		0, 2037, 2039, 1, 0, 0, 0, 2038, 2034, 1, 0, 0, 0, 2038, 2039, 1, 0, 0,
		0, 2039, 2040, 1, 0, 0, 0, 2040, 2041, 3, 158, 79, 0, 2041, 85, 1, 0, 0,
		0, 2042, 2043, 5, 71, 0, 0, 2043, 2045, 5, 242, 0, 0, 2044, 2042, 1, 0,
		0, 0, 2044, 2045, 1, 0, 0, 0, 2045, 2046, 1, 0, 0, 0, 2046, 2047, 5, 283,
		0, 0, 2047, 2048, 5, 338, 0, 0, 2048, 2049, 3, 158, 79, 0, 2049, 87, 1,
		0, 0, 0, 2050, 2051, 5, 51, 0, 0, 2051, 2052, 5, 36, 0, 0, 2052, 2053,
		5, 2, 0, 0, 2053, 2054, 3, 304, 152, 0, 2054, 2055, 5, 3, 0, 0, 2055, 89,
		1, 0, 0, 0, 2056, 2057, 5, 52, 0, 0, 2057, 2058, 5, 36, 0, 0, 2058, 2062,
		3, 270, 135, 0, 2059, 2060, 5, 319, 0, 0, 2060, 2061, 5, 36, 0, 0, 2061,
		2063, 3, 274, 137, 0, 2062, 2059, 1, 0, 0, 0, 2062, 2063, 1, 0, 0, 0, 2063,
		2064, 1, 0, 0, 0, 2064, 2065, 5, 177, 0, 0, 2065, 2066, 5, 436, 0, 0, 2066,
		2067, 5, 35, 0, 0, 2067, 91, 1, 0, 0, 0, 2068, 2069, 5, 315, 0, 0, 2069,
		2070, 5, 36, 0, 0, 2070, 2071, 3, 270, 135, 0, 2071, 2074, 5, 238, 0, 0,
		2072, 2075, 3, 144, 72, 0, 2073, 2075, 3, 146, 73, 0, 2074, 2072, 1, 0,
		0, 0, 2074, 2073, 1, 0, 0, 0, 2075, 2079, 1, 0, 0, 0, 2076, 2077, 5, 327,
		0, 0, 2077, 2078, 5, 22, 0, 0, 2078, 2080, 5, 103, 0, 0, 2079, 2076, 1,
		0, 0, 0, 2079, 2080, 1, 0, 0, 0, 2080, 93, 1, 0, 0, 0, 2081, 2082, 5, 201,
		0, 0, 2082, 2083, 3, 514, 257, 0, 2083, 95, 1, 0, 0, 0, 2084, 2085, 5,
		396, 0, 0, 2085, 2091, 5, 300, 0, 0, 2086, 2092, 5, 31, 0, 0, 2087, 2092,
		5, 63, 0, 0, 2088, 2092, 5, 117, 0, 0, 2089, 2090, 5, 365, 0, 0, 2090,
		2092, 5, 117, 0, 0, 2091, 2086, 1, 0, 0, 0, 2091, 2087, 1, 0, 0, 0, 2091,
		2088, 1, 0, 0, 0, 2091, 2089, 1, 0, 0, 0, 2092, 97, 1, 0, 0, 0, 2093, 2094,
		5, 59, 0, 0, 2094, 2095, 3, 514, 257, 0, 2095, 99, 1, 0, 0, 0, 2096, 2097,
		3, 102, 51, 0, 2097, 2098, 5, 0, 0, 1, 2098, 101, 1, 0, 0, 0, 2099, 2101,
		3, 124, 62, 0, 2100, 2099, 1, 0, 0, 0, 2100, 2101, 1, 0, 0, 0, 2101, 2102,
		1, 0, 0, 0, 2102, 2103, 3, 166, 83, 0, 2103, 2104, 3, 162, 81, 0, 2104,
		103, 1, 0, 0, 0, 2105, 2106, 5, 172, 0, 0, 2106, 2108, 5, 250, 0, 0, 2107,
		2109, 5, 338, 0, 0, 2108, 2107, 1, 0, 0, 0, 2108, 2109, 1, 0, 0, 0, 2109,
		2110, 1, 0, 0, 0, 2110, 2112, 3, 158, 79, 0, 2111, 2113, 3, 284, 142, 0,
		2112, 2111, 1, 0, 0, 0, 2112, 2113, 1, 0, 0, 0, 2113, 2121, 1, 0, 0, 0,
		2114, 2119, 3, 108, 54, 0, 2115, 2116, 5, 159, 0, 0, 2116, 2117, 3, 340,
		170, 0, 2117, 2118, 5, 121, 0, 0, 2118, 2120, 1, 0, 0, 0, 2119, 2115, 1,
		0, 0, 0, 2119, 2120, 1, 0, 0, 0, 2120, 2122, 1, 0, 0, 0, 2121, 2114, 1,
		0, 0, 0, 2121, 2122, 1, 0, 0, 0, 2122, 2126, 1, 0, 0, 0, 2123, 2124, 5,
		36, 0, 0, 2124, 2127, 5, 223, 0, 0, 2125, 2127, 3, 270, 135, 0, 2126, 2123,
		1, 0, 0, 0, 2126, 2125, 1, 0, 0, 0, 2126, 2127, 1, 0, 0, 0, 2127, 2191,
		1, 0, 0, 0, 2128, 2129, 5, 172, 0, 0, 2129, 2131, 5, 177, 0, 0, 2130, 2132,
		5, 338, 0, 0, 2131, 2130, 1, 0, 0, 0, 2131, 2132, 1, 0, 0, 0, 2132, 2133,
		1, 0, 0, 0, 2133, 2135, 3, 158, 79, 0, 2134, 2136, 3, 284, 142, 0, 2135,
		2134, 1, 0, 0, 0, 2135, 2136, 1, 0, 0, 0, 2136, 2138, 1, 0, 0, 0, 2137,
		2139, 3, 108, 54, 0, 2138, 2137, 1, 0, 0, 0, 2138, 2139, 1, 0, 0, 0, 2139,
		2144, 1, 0, 0, 0, 2140, 2141, 5, 159, 0, 0, 2141, 2142, 3, 340, 170, 0,
		2142, 2143, 5, 121, 0, 0, 2143, 2145, 1, 0, 0, 0, 2144, 2140, 1, 0, 0,
		0, 2144, 2145, 1, 0, 0, 0, 2145, 2149, 1, 0, 0, 0, 2146, 2147, 5, 36, 0,
		0, 2147, 2150, 5, 223, 0, 0, 2148, 2150, 3, 270, 135, 0, 2149, 2146, 1,
		0, 0, 0, 2149, 2148, 1, 0, 0, 0, 2149, 2150, 1, 0, 0, 0, 2150, 2191, 1,
		0, 0, 0, 2151, 2152, 5, 172, 0, 0, 2152, 2154, 5, 177, 0, 0, 2153, 2155,
		5, 338, 0, 0, 2154, 2153, 1, 0, 0, 0, 2154, 2155, 1, 0, 0, 0, 2155, 2156,
		1, 0, 0, 0, 2156, 2158, 3, 158, 79, 0, 2157, 2159, 3, 284, 142, 0, 2158,
		2157, 1, 0, 0, 0, 2158, 2159, 1, 0, 0, 0, 2159, 2160, 1, 0, 0, 0, 2160,
		2161, 5, 283, 0, 0, 2161, 2162, 3, 202, 101, 0, 2162, 2191, 1, 0, 0, 0,
		2163, 2164, 5, 172, 0, 0, 2164, 2166, 5, 250, 0, 0, 2165, 2167, 5, 200,
		0, 0, 2166, 2165, 1, 0, 0, 0, 2166, 2167, 1, 0, 0, 0, 2167, 2168, 1, 0,
		0, 0, 2168, 2169, 5, 104, 0, 0, 2169, 2171, 3, 514, 257, 0, 2170, 2172,
		3, 302, 151, 0, 2171, 2170, 1, 0, 0, 0, 2171, 2172, 1, 0, 0, 0, 2172, 2174,
		1, 0, 0, 0, 2173, 2175, 3, 148, 74, 0, 2174, 2173, 1, 0, 0, 0, 2174, 2175,
		1, 0, 0, 0, 2175, 2191, 1, 0, 0, 0, 2176, 2177, 5, 172, 0, 0, 2177, 2179,
		5, 250, 0, 0, 2178, 2180, 5, 200, 0, 0, 2179, 2178, 1, 0, 0, 0, 2179, 2180,
		1, 0, 0, 0, 2180, 2181, 1, 0, 0, 0, 2181, 2183, 5, 104, 0, 0, 2182, 2184,
		3, 514, 257, 0, 2183, 2182, 1, 0, 0, 0, 2183, 2184, 1, 0, 0, 0, 2184, 2185,
		1, 0, 0, 0, 2185, 2188, 3, 128, 64, 0, 2186, 2187, 5, 241, 0, 0, 2187,
		2189, 3, 132, 66, 0, 2188, 2186, 1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189,
		2191, 1, 0, 0, 0, 2190, 2105, 1, 0, 0, 0, 2190, 2128, 1, 0, 0, 0, 2190,
		2151, 1, 0, 0, 0, 2190, 2163, 1, 0, 0, 0, 2190, 2176, 1, 0, 0, 0, 2191,
		105, 1, 0, 0, 0, 2192, 2194, 3, 108, 54, 0, 2193, 2195, 3, 94, 47, 0, 2194,
		2193, 1, 0, 0, 0, 2194, 2195, 1, 0, 0, 0, 2195, 107, 1, 0, 0, 0, 2196,
		2197, 5, 251, 0, 0, 2197, 2198, 5, 2, 0, 0, 2198, 2203, 3, 110, 55, 0,
		2199, 2200, 5, 4, 0, 0, 2200, 2202, 3, 110, 55, 0, 2201, 2199, 1, 0, 0,
		0, 2202, 2205, 1, 0, 0, 0, 2203, 2201, 1, 0, 0, 0, 2203, 2204, 1, 0, 0,
		0, 2204, 2206, 1, 0, 0, 0, 2205, 2203, 1, 0, 0, 0, 2206, 2207, 5, 3, 0,
		0, 2207, 109, 1, 0, 0, 0, 2208, 2211, 3, 474, 237, 0, 2209, 2210, 5, 402,
		0, 0, 2210, 2212, 3, 362, 181, 0, 2211, 2209, 1, 0, 0, 0, 2211, 2212, 1,
		0, 0, 0, 2212, 2218, 1, 0, 0, 0, 2213, 2214, 3, 474, 237, 0, 2214, 2215,
		5, 402, 0, 0, 2215, 2216, 5, 94, 0, 0, 2216, 2218, 1, 0, 0, 0, 2217, 2208,
		1, 0, 0, 0, 2217, 2213, 1, 0, 0, 0, 2218, 111, 1, 0, 0, 0, 2219, 2220,
		5, 71, 0, 0, 2220, 2221, 5, 136, 0, 0, 2221, 2223, 3, 158, 79, 0, 2222,
		2224, 3, 98, 49, 0, 2223, 2222, 1, 0, 0, 0, 2223, 2224, 1, 0, 0, 0, 2224,
		2225, 1, 0, 0, 0, 2225, 2226, 5, 22, 0, 0, 2226, 113, 1, 0, 0, 0, 2227,
		2228, 7, 12, 0, 0, 2228, 115, 1, 0, 0, 0, 2229, 2230, 7, 13, 0, 0, 2230,
		117, 1, 0, 0, 0, 2231, 2232, 7, 14, 0, 0, 2232, 119, 1, 0, 0, 0, 2233,
		2241, 3, 158, 79, 0, 2234, 2241, 3, 514, 257, 0, 2235, 2241, 3, 364, 182,
		0, 2236, 2241, 3, 366, 183, 0, 2237, 2241, 3, 368, 184, 0, 2238, 2241,
		3, 344, 172, 0, 2239, 2241, 5, 8, 0, 0, 2240, 2233, 1, 0, 0, 0, 2240, 2234,
		1, 0, 0, 0, 2240, 2235, 1, 0, 0, 0, 2240, 2236, 1, 0, 0, 0, 2240, 2237,
		1, 0, 0, 0, 2240, 2238, 1, 0, 0, 0, 2240, 2239, 1, 0, 0, 0, 2241, 121,
		1, 0, 0, 0, 2242, 2247, 3, 470, 235, 0, 2243, 2244, 5, 5, 0, 0, 2244, 2246,
		3, 470, 235, 0, 2245, 2243, 1, 0, 0, 0, 2246, 2249, 1, 0, 0, 0, 2247, 2245,
		1, 0, 0, 0, 2247, 2248, 1, 0, 0, 0, 2248, 123, 1, 0, 0, 0, 2249, 2247,
		1, 0, 0, 0, 2250, 2252, 5, 396, 0, 0, 2251, 2253, 5, 274, 0, 0, 2252, 2251,
		1, 0, 0, 0, 2252, 2253, 1, 0, 0, 0, 2253, 2254, 1, 0, 0, 0, 2254, 2259,
		3, 126, 63, 0, 2255, 2256, 5, 4, 0, 0, 2256, 2258, 3, 126, 63, 0, 2257,
		2255, 1, 0, 0, 0, 2258, 2261, 1, 0, 0, 0, 2259, 2257, 1, 0, 0, 0, 2259,
		2260, 1, 0, 0, 0, 2260, 125, 1, 0, 0, 0, 2261, 2259, 1, 0, 0, 0, 2262,
		2264, 3, 470, 235, 0, 2263, 2265, 3, 270, 135, 0, 2264, 2263, 1, 0, 0,
		0, 2264, 2265, 1, 0, 0, 0, 2265, 2270, 1, 0, 0, 0, 2266, 2267, 5, 211,
		0, 0, 2267, 2268, 5, 273, 0, 0, 2268, 2269, 5, 193, 0, 0, 2269, 2271, 5,
		436, 0, 0, 2270, 2266, 1, 0, 0, 0, 2270, 2271, 1, 0, 0, 0, 2271, 2273,
		1, 0, 0, 0, 2272, 2274, 5, 22, 0, 0, 2273, 2272, 1, 0, 0, 0, 2273, 2274,
		1, 0, 0, 0, 2274, 2275, 1, 0, 0, 0, 2275, 2276, 5, 2, 0, 0, 2276, 2277,
		3, 102, 51, 0, 2277, 2278, 5, 3, 0, 0, 2278, 127, 1, 0, 0, 0, 2279, 2280,
		5, 379, 0, 0, 2280, 2281, 3, 306, 153, 0, 2281, 129, 1, 0, 0, 0, 2282,
		2283, 5, 241, 0, 0, 2283, 2298, 3, 140, 70, 0, 2284, 2285, 5, 252, 0, 0,
		2285, 2286, 5, 36, 0, 0, 2286, 2298, 3, 320, 160, 0, 2287, 2298, 3, 92,
		46, 0, 2288, 2298, 3, 88, 44, 0, 2289, 2298, 3, 90, 45, 0, 2290, 2298,
		3, 302, 151, 0, 2291, 2298, 3, 148, 74, 0, 2292, 2298, 3, 94, 47, 0, 2293,
		2298, 3, 98, 49, 0, 2294, 2298, 3, 390, 195, 0, 2295, 2296, 5, 342, 0,
		0, 2296, 2298, 3, 132, 66, 0, 2297, 2282, 1, 0, 0, 0, 2297, 2284, 1, 0,
		0, 0, 2297, 2287, 1, 0, 0, 0, 2297, 2288, 1, 0, 0, 0, 2297, 2289, 1, 0,
		0, 0, 2297, 2290, 1, 0, 0, 0, 2297, 2291, 1, 0, 0, 0, 2297, 2292, 1, 0,
		0, 0, 2297, 2293, 1, 0, 0, 0, 2297, 2294, 1, 0, 0, 0, 2297, 2295, 1, 0,
		0, 0, 2298, 2301, 1, 0, 0, 0, 2299, 2297, 1, 0, 0, 0, 2299, 2300, 1, 0,
		0, 0, 2300, 131, 1, 0, 0, 0, 2301, 2299, 1, 0, 0, 0, 2302, 2303, 5, 2,
		0, 0, 2303, 2308, 3, 134, 67, 0, 2304, 2305, 5, 4, 0, 0, 2305, 2307, 3,
		134, 67, 0, 2306, 2304, 1, 0, 0, 0, 2307, 2310, 1, 0, 0, 0, 2308, 2306,
		1, 0, 0, 0, 2308, 2309, 1, 0, 0, 0, 2309, 2311, 1, 0, 0, 0, 2310, 2308,
		1, 0, 0, 0, 2311, 2312, 5, 3, 0, 0, 2312, 133, 1, 0, 0, 0, 2313, 2318,
		3, 136, 68, 0, 2314, 2316, 5, 402, 0, 0, 2315, 2314, 1, 0, 0, 0, 2315,
		2316, 1, 0, 0, 0, 2316, 2317, 1, 0, 0, 0, 2317, 2319, 3, 138, 69, 0, 2318,
		2315, 1, 0, 0, 0, 2318, 2319, 1, 0, 0, 0, 2319, 135, 1, 0, 0, 0, 2320,
		2325, 3, 470, 235, 0, 2321, 2322, 5, 5, 0, 0, 2322, 2324, 3, 470, 235,
		0, 2323, 2321, 1, 0, 0, 0, 2324, 2327, 1, 0, 0, 0, 2325, 2323, 1, 0, 0,
		0, 2325, 2326, 1, 0, 0, 0, 2326, 2330, 1, 0, 0, 0, 2327, 2325, 1, 0, 0,
		0, 2328, 2330, 3, 514, 257, 0, 2329, 2320, 1, 0, 0, 0, 2329, 2328, 1, 0,
		0, 0, 2330, 137, 1, 0, 0, 0, 2331, 2336, 5, 436, 0, 0, 2332, 2336, 5, 438,
		0, 0, 2333, 2336, 3, 370, 185, 0, 2334, 2336, 3, 514, 257, 0, 2335, 2331,
		1, 0, 0, 0, 2335, 2332, 1, 0, 0, 0, 2335, 2333, 1, 0, 0, 0, 2335, 2334,
		1, 0, 0, 0, 2336, 139, 1, 0, 0, 0, 2337, 2338, 5, 2, 0, 0, 2338, 2343,
		3, 142, 71, 0, 2339, 2340, 5, 4, 0, 0, 2340, 2342, 3, 142, 71, 0, 2341,
		2339, 1, 0, 0, 0, 2342, 2345, 1, 0, 0, 0, 2343, 2341, 1, 0, 0, 0, 2343,
		2344, 1, 0, 0, 0, 2344, 2346, 1, 0, 0, 0, 2345, 2343, 1, 0, 0, 0, 2346,
		2347, 5, 3, 0, 0, 2347, 141, 1, 0, 0, 0, 2348, 2353, 3, 136, 68, 0, 2349,
		2351, 5, 402, 0, 0, 2350, 2349, 1, 0, 0, 0, 2350, 2351, 1, 0, 0, 0, 2351,
		2352, 1, 0, 0, 0, 2352, 2354, 3, 328, 164, 0, 2353, 2350, 1, 0, 0, 0, 2353,
		2354, 1, 0, 0, 0, 2354, 143, 1, 0, 0, 0, 2355, 2356, 5, 2, 0, 0, 2356,
		2361, 3, 362, 181, 0, 2357, 2358, 5, 4, 0, 0, 2358, 2360, 3, 362, 181,
		0, 2359, 2357, 1, 0, 0, 0, 2360, 2363, 1, 0, 0, 0, 2361, 2359, 1, 0, 0,
		0, 2361, 2362, 1, 0, 0, 0, 2362, 2364, 1, 0, 0, 0, 2363, 2361, 1, 0, 0,
		0, 2364, 2365, 5, 3, 0, 0, 2365, 145, 1, 0, 0, 0, 2366, 2367, 5, 2, 0,
		0, 2367, 2372, 3, 144, 72, 0, 2368, 2369, 5, 4, 0, 0, 2369, 2371, 3, 144,
		72, 0, 2370, 2368, 1, 0, 0, 0, 2371, 2374, 1, 0, 0, 0, 2372, 2370, 1, 0,
		0, 0, 2372, 2373, 1, 0, 0, 0, 2373, 2375, 1, 0, 0, 0, 2374, 2372, 1, 0,
		0, 0, 2375, 2376, 5, 3, 0, 0, 2376, 147, 1, 0, 0, 0, 2377, 2378, 5, 327,
		0, 0, 2378, 2379, 5, 22, 0, 0, 2379, 2384, 3, 150, 75, 0, 2380, 2381, 5,
		327, 0, 0, 2381, 2382, 5, 36, 0, 0, 2382, 2384, 3, 152, 76, 0, 2383, 2377,
		1, 0, 0, 0, 2383, 2380, 1, 0, 0, 0, 2384, 149, 1, 0, 0, 0, 2385, 2386,
		5, 171, 0, 0, 2386, 2387, 3, 514, 257, 0, 2387, 2388, 5, 246, 0, 0, 2388,
		2389, 3, 514, 257, 0, 2389, 2392, 1, 0, 0, 0, 2390, 2392, 3, 474, 237,
		0, 2391, 2385, 1, 0, 0, 0, 2391, 2390, 1, 0, 0, 0, 2392, 151, 1, 0, 0,
		0, 2393, 2397, 3, 514, 257, 0, 2394, 2395, 5, 396, 0, 0, 2395, 2396, 5,
		307, 0, 0, 2396, 2398, 3, 132, 66, 0, 2397, 2394, 1, 0, 0, 0, 2397, 2398,
		1, 0, 0, 0, 2398, 153, 1, 0, 0, 0, 2399, 2400, 3, 474, 237, 0, 2400, 2401,
		3, 514, 257, 0, 2401, 155, 1, 0, 0, 0, 2402, 2403, 3, 104, 52, 0, 2403,
		2404, 3, 102, 51, 0, 2404, 2464, 1, 0, 0, 0, 2405, 2407, 3, 210, 105, 0,
		2406, 2408, 3, 164, 82, 0, 2407, 2406, 1, 0, 0, 0, 2408, 2409, 1, 0, 0,
		0, 2409, 2407, 1, 0, 0, 0, 2409, 2410, 1, 0, 0, 0, 2410, 2464, 1, 0, 0,
		0, 2411, 2412, 5, 97, 0, 0, 2412, 2413, 5, 143, 0, 0, 2413, 2414, 3, 158,
		79, 0, 2414, 2416, 3, 300, 150, 0, 2415, 2417, 3, 202, 101, 0, 2416, 2415,
		1, 0, 0, 0, 2416, 2417, 1, 0, 0, 0, 2417, 2464, 1, 0, 0, 0, 2418, 2419,
		5, 376, 0, 0, 2419, 2420, 3, 158, 79, 0, 2420, 2421, 3, 300, 150, 0, 2421,
		2423, 3, 182, 91, 0, 2422, 2424, 3, 202, 101, 0, 2423, 2422, 1, 0, 0, 0,
		2423, 2424, 1, 0, 0, 0, 2424, 2464, 1, 0, 0, 0, 2425, 2429, 5, 212, 0,
		0, 2426, 2427, 5, 396, 0, 0, 2427, 2428, 5, 300, 0, 0, 2428, 2430, 5, 117,
		0, 0, 2429, 2426, 1, 0, 0, 0, 2429, 2430, 1, 0, 0, 0, 2430, 2431, 1, 0,
		0, 0, 2431, 2432, 5, 177, 0, 0, 2432, 2433, 3, 158, 79, 0, 2433, 2434,
		3, 300, 150, 0, 2434, 2440, 5, 379, 0, 0, 2435, 2441, 3, 158, 79, 0, 2436,
		2437, 5, 2, 0, 0, 2437, 2438, 3, 102, 51, 0, 2438, 2439, 5, 3, 0, 0, 2439,
		2441, 1, 0, 0, 0, 2440, 2435, 1, 0, 0, 0, 2440, 2436, 1, 0, 0, 0, 2441,
		2442, 1, 0, 0, 0, 2442, 2443, 3, 300, 150, 0, 2443, 2444, 5, 238, 0, 0,
		2444, 2448, 3, 336, 168, 0, 2445, 2447, 3, 184, 92, 0, 2446, 2445, 1, 0,
		0, 0, 2447, 2450, 1, 0, 0, 0, 2448, 2446, 1, 0, 0, 0, 2448, 2449, 1, 0,
		0, 0, 2449, 2454, 1, 0, 0, 0, 2450, 2448, 1, 0, 0, 0, 2451, 2453, 3, 186,
		93, 0, 2452, 2451, 1, 0, 0, 0, 2453, 2456, 1, 0, 0, 0, 2454, 2452, 1, 0,
		0, 0, 2454, 2455, 1, 0, 0, 0, 2455, 2460, 1, 0, 0, 0, 2456, 2454, 1, 0,
		0, 0, 2457, 2459, 3, 188, 94, 0, 2458, 2457, 1, 0, 0, 0, 2459, 2462, 1,
		0, 0, 0, 2460, 2458, 1, 0, 0, 0, 2460, 2461, 1, 0, 0, 0, 2461, 2464, 1,
		0, 0, 0, 2462, 2460, 1, 0, 0, 0, 2463, 2402, 1, 0, 0, 0, 2463, 2405, 1,
		0, 0, 0, 2463, 2411, 1, 0, 0, 0, 2463, 2418, 1, 0, 0, 0, 2463, 2425, 1,
		0, 0, 0, 2464, 157, 1, 0, 0, 0, 2465, 2466, 5, 157, 0, 0, 2466, 2467, 5,
		2, 0, 0, 2467, 2468, 3, 328, 164, 0, 2468, 2469, 5, 3, 0, 0, 2469, 2472,
		1, 0, 0, 0, 2470, 2472, 3, 306, 153, 0, 2471, 2465, 1, 0, 0, 0, 2471, 2470,
		1, 0, 0, 0, 2472, 159, 1, 0, 0, 0, 2473, 2474, 5, 157, 0, 0, 2474, 2475,
		5, 2, 0, 0, 2475, 2476, 3, 328, 164, 0, 2476, 2477, 5, 3, 0, 0, 2477, 2481,
		1, 0, 0, 0, 2478, 2481, 3, 470, 235, 0, 2479, 2481, 3, 514, 257, 0, 2480,
		2473, 1, 0, 0, 0, 2480, 2478, 1, 0, 0, 0, 2480, 2479, 1, 0, 0, 0, 2481,
		161, 1, 0, 0, 0, 2482, 2483, 5, 243, 0, 0, 2483, 2484, 5, 36, 0, 0, 2484,
		2489, 3, 170, 85, 0, 2485, 2486, 5, 4, 0, 0, 2486, 2488, 3, 170, 85, 0,
		2487, 2485, 1, 0, 0, 0, 2488, 2491, 1, 0, 0, 0, 2489, 2487, 1, 0, 0, 0,
		2489, 2490, 1, 0, 0, 0, 2490, 2493, 1, 0, 0, 0, 2491, 2489, 1, 0, 0, 0,
		2492, 2482, 1, 0, 0, 0, 2492, 2493, 1, 0, 0, 0, 2493, 2504, 1, 0, 0, 0,
		2494, 2495, 5, 51, 0, 0, 2495, 2496, 5, 36, 0, 0, 2496, 2501, 3, 328, 164,
		0, 2497, 2498, 5, 4, 0, 0, 2498, 2500, 3, 328, 164, 0, 2499, 2497, 1, 0,
		0, 0, 2500, 2503, 1, 0, 0, 0, 2501, 2499, 1, 0, 0, 0, 2501, 2502, 1, 0,
		0, 0, 2502, 2505, 1, 0, 0, 0, 2503, 2501, 1, 0, 0, 0, 2504, 2494, 1, 0,
		0, 0, 2504, 2505, 1, 0, 0, 0, 2505, 2516, 1, 0, 0, 0, 2506, 2507, 5, 106,
		0, 0, 2507, 2508, 5, 36, 0, 0, 2508, 2513, 3, 328, 164, 0, 2509, 2510,
		5, 4, 0, 0, 2510, 2512, 3, 328, 164, 0, 2511, 2509, 1, 0, 0, 0, 2512, 2515,
		1, 0, 0, 0, 2513, 2511, 1, 0, 0, 0, 2513, 2514, 1, 0, 0, 0, 2514, 2517,
		1, 0, 0, 0, 2515, 2513, 1, 0, 0, 0, 2516, 2506, 1, 0, 0, 0, 2516, 2517,
		1, 0, 0, 0, 2517, 2528, 1, 0, 0, 0, 2518, 2519, 5, 318, 0, 0, 2519, 2520,
		5, 36, 0, 0, 2520, 2525, 3, 170, 85, 0, 2521, 2522, 5, 4, 0, 0, 2522, 2524,
		3, 170, 85, 0, 2523, 2521, 1, 0, 0, 0, 2524, 2527, 1, 0, 0, 0, 2525, 2523,
		1, 0, 0, 0, 2525, 2526, 1, 0, 0, 0, 2526, 2529, 1, 0, 0, 0, 2527, 2525,
		1, 0, 0, 0, 2528, 2518, 1, 0, 0, 0, 2528, 2529, 1, 0, 0, 0, 2529, 2531,
		1, 0, 0, 0, 2530, 2532, 3, 454, 227, 0, 2531, 2530, 1, 0, 0, 0, 2531, 2532,
		1, 0, 0, 0, 2532, 2538, 1, 0, 0, 0, 2533, 2536, 5, 196, 0, 0, 2534, 2537,
		5, 12, 0, 0, 2535, 2537, 3, 328, 164, 0, 2536, 2534, 1, 0, 0, 0, 2536,
		2535, 1, 0, 0, 0, 2537, 2539, 1, 0, 0, 0, 2538, 2533, 1, 0, 0, 0, 2538,
		2539, 1, 0, 0, 0, 2539, 2542, 1, 0, 0, 0, 2540, 2541, 5, 237, 0, 0, 2541,
		2543, 3, 328, 164, 0, 2542, 2540, 1, 0, 0, 0, 2542, 2543, 1, 0, 0, 0, 2543,
		163, 1, 0, 0, 0, 2544, 2545, 3, 104, 52, 0, 2545, 2546, 3, 174, 87, 0,
		2546, 165, 1, 0, 0, 0, 2547, 2548, 6, 83, -1, 0, 2548, 2549, 3, 168, 84,
		0, 2549, 2576, 1, 0, 0, 0, 2550, 2551, 10, 4, 0, 0, 2551, 2552, 4, 83,
		1, 0, 2552, 2554, 7, 15, 0, 0, 2553, 2555, 3, 254, 127, 0, 2554, 2553,
		1, 0, 0, 0, 2554, 2555, 1, 0, 0, 0, 2555, 2556, 1, 0, 0, 0, 2556, 2575,
		3, 166, 83, 5, 2557, 2558, 10, 3, 0, 0, 2558, 2559, 4, 83, 3, 0, 2559,
		2561, 5, 173, 0, 0, 2560, 2562, 3, 254, 127, 0, 2561, 2560, 1, 0, 0, 0,
		2561, 2562, 1, 0, 0, 0, 2562, 2563, 1, 0, 0, 0, 2563, 2575, 3, 166, 83,
		4, 2564, 2565, 10, 2, 0, 0, 2565, 2566, 4, 83, 5, 0, 2566, 2568, 7, 16,
		0, 0, 2567, 2569, 3, 254, 127, 0, 2568, 2567, 1, 0, 0, 0, 2568, 2569, 1,
		0, 0, 0, 2569, 2570, 1, 0, 0, 0, 2570, 2575, 3, 166, 83, 3, 2571, 2572,
		10, 1, 0, 0, 2572, 2573, 5, 422, 0, 0, 2573, 2575, 3, 520, 260, 0, 2574,
		2550, 1, 0, 0, 0, 2574, 2557, 1, 0, 0, 0, 2574, 2564, 1, 0, 0, 0, 2574,
		2571, 1, 0, 0, 0, 2575, 2578, 1, 0, 0, 0, 2576, 2574, 1, 0, 0, 0, 2576,
		2577, 1, 0, 0, 0, 2577, 167, 1, 0, 0, 0, 2578, 2576, 1, 0, 0, 0, 2579,
		2589, 3, 176, 88, 0, 2580, 2589, 3, 172, 86, 0, 2581, 2582, 5, 338, 0,
		0, 2582, 2589, 3, 158, 79, 0, 2583, 2589, 3, 286, 143, 0, 2584, 2585, 5,
		2, 0, 0, 2585, 2586, 3, 102, 51, 0, 2586, 2587, 5, 3, 0, 0, 2587, 2589,
		1, 0, 0, 0, 2588, 2579, 1, 0, 0, 0, 2588, 2580, 1, 0, 0, 0, 2588, 2581,
		1, 0, 0, 0, 2588, 2583, 1, 0, 0, 0, 2588, 2584, 1, 0, 0, 0, 2589, 169,
		1, 0, 0, 0, 2590, 2592, 3, 328, 164, 0, 2591, 2593, 7, 17, 0, 0, 2592,
		2591, 1, 0, 0, 0, 2592, 2593, 1, 0, 0, 0, 2593, 2596, 1, 0, 0, 0, 2594,
		2595, 5, 233, 0, 0, 2595, 2597, 7, 18, 0, 0, 2596, 2594, 1, 0, 0, 0, 2596,
		2597, 1, 0, 0, 0, 2597, 171, 1, 0, 0, 0, 2598, 2602, 3, 210, 105, 0, 2599,
		2601, 3, 174, 87, 0, 2600, 2599, 1, 0, 0, 0, 2601, 2604, 1, 0, 0, 0, 2602,
		2600, 1, 0, 0, 0, 2602, 2603, 1, 0, 0, 0, 2603, 173, 1, 0, 0, 0, 2604,
		2602, 1, 0, 0, 0, 2605, 2607, 3, 178, 89, 0, 2606, 2608, 3, 202, 101, 0,
		2607, 2606, 1, 0, 0, 0, 2607, 2608, 1, 0, 0, 0, 2608, 2609, 1, 0, 0, 0,
		2609, 2610, 3, 162, 81, 0, 2610, 2633, 1, 0, 0, 0, 2611, 2615, 3, 180,
		90, 0, 2612, 2614, 3, 252, 126, 0, 2613, 2612, 1, 0, 0, 0, 2614, 2617,
		1, 0, 0, 0, 2615, 2613, 1, 0, 0, 0, 2615, 2616, 1, 0, 0, 0, 2616, 2619,
		1, 0, 0, 0, 2617, 2615, 1, 0, 0, 0, 2618, 2620, 3, 202, 101, 0, 2619, 2618,
		1, 0, 0, 0, 2619, 2620, 1, 0, 0, 0, 2620, 2622, 1, 0, 0, 0, 2621, 2623,
		3, 214, 107, 0, 2622, 2621, 1, 0, 0, 0, 2622, 2623, 1, 0, 0, 0, 2623, 2625,
		1, 0, 0, 0, 2624, 2626, 3, 204, 102, 0, 2625, 2624, 1, 0, 0, 0, 2625, 2626,
		1, 0, 0, 0, 2626, 2628, 1, 0, 0, 0, 2627, 2629, 3, 454, 227, 0, 2628, 2627,
		1, 0, 0, 0, 2628, 2629, 1, 0, 0, 0, 2629, 2630, 1, 0, 0, 0, 2630, 2631,
		3, 162, 81, 0, 2631, 2633, 1, 0, 0, 0, 2632, 2605, 1, 0, 0, 0, 2632, 2611,
		1, 0, 0, 0, 2633, 175, 1, 0, 0, 0, 2634, 2636, 3, 178, 89, 0, 2635, 2637,
		3, 210, 105, 0, 2636, 2635, 1, 0, 0, 0, 2636, 2637, 1, 0, 0, 0, 2637, 2641,
		1, 0, 0, 0, 2638, 2640, 3, 252, 126, 0, 2639, 2638, 1, 0, 0, 0, 2640, 2643,
		1, 0, 0, 0, 2641, 2639, 1, 0, 0, 0, 2641, 2642, 1, 0, 0, 0, 2642, 2645,
		1, 0, 0, 0, 2643, 2641, 1, 0, 0, 0, 2644, 2646, 3, 202, 101, 0, 2645, 2644,
		1, 0, 0, 0, 2645, 2646, 1, 0, 0, 0, 2646, 2648, 1, 0, 0, 0, 2647, 2649,
		3, 214, 107, 0, 2648, 2647, 1, 0, 0, 0, 2648, 2649, 1, 0, 0, 0, 2649, 2651,
		1, 0, 0, 0, 2650, 2652, 3, 204, 102, 0, 2651, 2650, 1, 0, 0, 0, 2651, 2652,
		1, 0, 0, 0, 2652, 2654, 1, 0, 0, 0, 2653, 2655, 3, 454, 227, 0, 2654, 2653,
		1, 0, 0, 0, 2654, 2655, 1, 0, 0, 0, 2655, 2679, 1, 0, 0, 0, 2656, 2658,
		3, 180, 90, 0, 2657, 2659, 3, 210, 105, 0, 2658, 2657, 1, 0, 0, 0, 2658,
		2659, 1, 0, 0, 0, 2659, 2663, 1, 0, 0, 0, 2660, 2662, 3, 252, 126, 0, 2661,
		2660, 1, 0, 0, 0, 2662, 2665, 1, 0, 0, 0, 2663, 2661, 1, 0, 0, 0, 2663,
		2664, 1, 0, 0, 0, 2664, 2667, 1, 0, 0, 0, 2665, 2663, 1, 0, 0, 0, 2666,
		2668, 3, 202, 101, 0, 2667, 2666, 1, 0, 0, 0, 2667, 2668, 1, 0, 0, 0, 2668,
		2670, 1, 0, 0, 0, 2669, 2671, 3, 214, 107, 0, 2670, 2669, 1, 0, 0, 0, 2670,
		2671, 1, 0, 0, 0, 2671, 2673, 1, 0, 0, 0, 2672, 2674, 3, 204, 102, 0, 2673,
		2672, 1, 0, 0, 0, 2673, 2674, 1, 0, 0, 0, 2674, 2676, 1, 0, 0, 0, 2675,
		2677, 3, 454, 227, 0, 2676, 2675, 1, 0, 0, 0, 2676, 2677, 1, 0, 0, 0, 2677,
		2679, 1, 0, 0, 0, 2678, 2634, 1, 0, 0, 0, 2678, 2656, 1, 0, 0, 0, 2679,
		177, 1, 0, 0, 0, 2680, 2681, 5, 303, 0, 0, 2681, 2682, 5, 360, 0, 0, 2682,
		2684, 5, 2, 0, 0, 2683, 2685, 3, 254, 127, 0, 2684, 2683, 1, 0, 0, 0, 2684,
		2685, 1, 0, 0, 0, 2685, 2686, 1, 0, 0, 0, 2686, 2687, 3, 334, 167, 0, 2687,
		2688, 5, 3, 0, 0, 2688, 2700, 1, 0, 0, 0, 2689, 2691, 5, 208, 0, 0, 2690,
		2692, 3, 254, 127, 0, 2691, 2690, 1, 0, 0, 0, 2691, 2692, 1, 0, 0, 0, 2692,
		2693, 1, 0, 0, 0, 2693, 2700, 3, 334, 167, 0, 2694, 2696, 5, 275, 0, 0,
		2695, 2697, 3, 254, 127, 0, 2696, 2695, 1, 0, 0, 0, 2696, 2697, 1, 0, 0,
		0, 2697, 2698, 1, 0, 0, 0, 2698, 2700, 3, 334, 167, 0, 2699, 2680, 1, 0,
		0, 0, 2699, 2689, 1, 0, 0, 0, 2699, 2694, 1, 0, 0, 0, 2700, 2702, 1, 0,
		0, 0, 2701, 2703, 3, 302, 151, 0, 2702, 2701, 1, 0, 0, 0, 2702, 2703, 1,
		0, 0, 0, 2703, 2706, 1, 0, 0, 0, 2704, 2705, 5, 271, 0, 0, 2705, 2707,
		3, 514, 257, 0, 2706, 2704, 1, 0, 0, 0, 2706, 2707, 1, 0, 0, 0, 2707, 2708,
		1, 0, 0, 0, 2708, 2709, 5, 379, 0, 0, 2709, 2722, 3, 514, 257, 0, 2710,
		2720, 5, 22, 0, 0, 2711, 2721, 3, 272, 136, 0, 2712, 2721, 3, 412, 206,
		0, 2713, 2716, 5, 2, 0, 0, 2714, 2717, 3, 272, 136, 0, 2715, 2717, 3, 412,
		206, 0, 2716, 2714, 1, 0, 0, 0, 2716, 2715, 1, 0, 0, 0, 2717, 2718, 1,
		0, 0, 0, 2718, 2719, 5, 3, 0, 0, 2719, 2721, 1, 0, 0, 0, 2720, 2711, 1,
		0, 0, 0, 2720, 2712, 1, 0, 0, 0, 2720, 2713, 1, 0, 0, 0, 2721, 2723, 1,
		0, 0, 0, 2722, 2710, 1, 0, 0, 0, 2722, 2723, 1, 0, 0, 0, 2723, 2725, 1,
		0, 0, 0, 2724, 2726, 3, 302, 151, 0, 2725, 2724, 1, 0, 0, 0, 2725, 2726,
		1, 0, 0, 0, 2726, 2729, 1, 0, 0, 0, 2727, 2728, 5, 270, 0, 0, 2728, 2730,
		3, 514, 257, 0, 2729, 2727, 1, 0, 0, 0, 2729, 2730, 1, 0, 0, 0, 2730, 179,
		1, 0, 0, 0, 2731, 2735, 5, 303, 0, 0, 2732, 2734, 3, 206, 103, 0, 2733,
		2732, 1, 0, 0, 0, 2734, 2737, 1, 0, 0, 0, 2735, 2733, 1, 0, 0, 0, 2735,
		2736, 1, 0, 0, 0, 2736, 2739, 1, 0, 0, 0, 2737, 2735, 1, 0, 0, 0, 2738,
		2740, 3, 254, 127, 0, 2739, 2738, 1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740,
		2741, 1, 0, 0, 0, 2741, 2742, 3, 318, 159, 0, 2742, 181, 1, 0, 0, 0, 2743,
		2744, 5, 309, 0, 0, 2744, 2745, 3, 198, 99, 0, 2745, 183, 1, 0, 0, 0, 2746,
		2747, 5, 392, 0, 0, 2747, 2750, 5, 209, 0, 0, 2748, 2749, 5, 16, 0, 0,
		2749, 2751, 3, 336, 168, 0, 2750, 2748, 1, 0, 0, 0, 2750, 2751, 1, 0, 0,
		0, 2751, 2752, 1, 0, 0, 0, 2752, 2753, 5, 345, 0, 0, 2753, 2754, 3, 190,
		95, 0, 2754, 185, 1, 0, 0, 0, 2755, 2756, 5, 392, 0, 0, 2756, 2757, 3,
		340, 170, 0, 2757, 2760, 5, 209, 0, 0, 2758, 2759, 5, 36, 0, 0, 2759, 2761,
		5, 341, 0, 0, 2760, 2758, 1, 0, 0, 0, 2760, 2761, 1, 0, 0, 0, 2761, 2764,
		1, 0, 0, 0, 2762, 2763, 5, 16, 0, 0, 2763, 2765, 3, 336, 168, 0, 2764,
		2762, 1, 0, 0, 0, 2764, 2765, 1, 0, 0, 0, 2765, 2766, 1, 0, 0, 0, 2766,
		2767, 5, 345, 0, 0, 2767, 2768, 3, 192, 96, 0, 2768, 187, 1, 0, 0, 0, 2769,
		2770, 5, 392, 0, 0, 2770, 2771, 3, 340, 170, 0, 2771, 2772, 5, 209, 0,
		0, 2772, 2773, 5, 36, 0, 0, 2773, 2776, 5, 320, 0, 0, 2774, 2775, 5, 16,
		0, 0, 2775, 2777, 3, 336, 168, 0, 2776, 2774, 1, 0, 0, 0, 2776, 2777, 1,
		0, 0, 0, 2777, 2778, 1, 0, 0, 0, 2778, 2779, 5, 345, 0, 0, 2779, 2780,
		3, 194, 97, 0, 2780, 189, 1, 0, 0, 0, 2781, 2789, 5, 97, 0, 0, 2782, 2783,
		5, 376, 0, 0, 2783, 2784, 5, 309, 0, 0, 2784, 2789, 5, 415, 0, 0, 2785,
		2786, 5, 376, 0, 0, 2786, 2787, 5, 309, 0, 0, 2787, 2789, 3, 198, 99, 0,
		2788, 2781, 1, 0, 0, 0, 2788, 2782, 1, 0, 0, 0, 2788, 2785, 1, 0, 0, 0,
		2789, 191, 1, 0, 0, 0, 2790, 2791, 5, 172, 0, 0, 2791, 2809, 5, 415, 0,
		0, 2792, 2793, 5, 172, 0, 0, 2793, 2794, 5, 2, 0, 0, 2794, 2795, 3, 304,
		152, 0, 2795, 2796, 5, 3, 0, 0, 2796, 2797, 5, 381, 0, 0, 2797, 2798, 5,
		2, 0, 0, 2798, 2803, 3, 328, 164, 0, 2799, 2800, 5, 4, 0, 0, 2800, 2802,
		3, 328, 164, 0, 2801, 2799, 1, 0, 0, 0, 2802, 2805, 1, 0, 0, 0, 2803, 2801,
		1, 0, 0, 0, 2803, 2804, 1, 0, 0, 0, 2804, 2806, 1, 0, 0, 0, 2805, 2803,
		1, 0, 0, 0, 2806, 2807, 5, 3, 0, 0, 2807, 2809, 1, 0, 0, 0, 2808, 2790,
		1, 0, 0, 0, 2808, 2792, 1, 0, 0, 0, 2809, 193, 1, 0, 0, 0, 2810, 2815,
		5, 97, 0, 0, 2811, 2812, 5, 376, 0, 0, 2812, 2813, 5, 309, 0, 0, 2813,
		2815, 3, 198, 99, 0, 2814, 2810, 1, 0, 0, 0, 2814, 2811, 1, 0, 0, 0, 2815,
		195, 1, 0, 0, 0, 2816, 2817, 5, 118, 0, 0, 2817, 2818, 5, 2, 0, 0, 2818,
		2819, 3, 304, 152, 0, 2819, 2820, 5, 3, 0, 0, 2820, 197, 1, 0, 0, 0, 2821,
		2826, 3, 200, 100, 0, 2822, 2823, 5, 4, 0, 0, 2823, 2825, 3, 200, 100,
		0, 2824, 2822, 1, 0, 0, 0, 2825, 2828, 1, 0, 0, 0, 2826, 2824, 1, 0, 0,
		0, 2826, 2827, 1, 0, 0, 0, 2827, 199, 1, 0, 0, 0, 2828, 2826, 1, 0, 0,
		0, 2829, 2830, 3, 306, 153, 0, 2830, 2831, 5, 402, 0, 0, 2831, 2832, 3,
		328, 164, 0, 2832, 201, 1, 0, 0, 0, 2833, 2834, 5, 393, 0, 0, 2834, 2835,
		3, 336, 168, 0, 2835, 203, 1, 0, 0, 0, 2836, 2837, 5, 153, 0, 0, 2837,
		2838, 3, 336, 168, 0, 2838, 205, 1, 0, 0, 0, 2839, 2840, 5, 428, 0, 0,
		2840, 2847, 3, 208, 104, 0, 2841, 2843, 5, 4, 0, 0, 2842, 2841, 1, 0, 0,
		0, 2842, 2843, 1, 0, 0, 0, 2843, 2844, 1, 0, 0, 0, 2844, 2846, 3, 208,
		104, 0, 2845, 2842, 1, 0, 0, 0, 2846, 2849, 1, 0, 0, 0, 2847, 2845, 1,
		0, 0, 0, 2847, 2848, 1, 0, 0, 0, 2848, 2850, 1, 0, 0, 0, 2849, 2847, 1,
		0, 0, 0, 2850, 2851, 5, 429, 0, 0, 2851, 207, 1, 0, 0, 0, 2852, 2866, 3,
		474, 237, 0, 2853, 2854, 3, 474, 237, 0, 2854, 2855, 5, 2, 0, 0, 2855,
		2860, 3, 348, 174, 0, 2856, 2857, 5, 4, 0, 0, 2857, 2859, 3, 348, 174,
		0, 2858, 2856, 1, 0, 0, 0, 2859, 2862, 1, 0, 0, 0, 2860, 2858, 1, 0, 0,
		0, 2860, 2861, 1, 0, 0, 0, 2861, 2863, 1, 0, 0, 0, 2862, 2860, 1, 0, 0,
		0, 2863, 2864, 5, 3, 0, 0, 2864, 2866, 1, 0, 0, 0, 2865, 2852, 1, 0, 0,
		0, 2865, 2853, 1, 0, 0, 0, 2866, 209, 1, 0, 0, 0, 2867, 2868, 5, 143, 0,
		0, 2868, 2873, 3, 256, 128, 0, 2869, 2870, 5, 4, 0, 0, 2870, 2872, 3, 256,
		128, 0, 2871, 2869, 1, 0, 0, 0, 2872, 2875, 1, 0, 0, 0, 2873, 2871, 1,
		0, 0, 0, 2873, 2874, 1, 0, 0, 0, 2874, 2879, 1, 0, 0, 0, 2875, 2873, 1,
		0, 0, 0, 2876, 2878, 3, 252, 126, 0, 2877, 2876, 1, 0, 0, 0, 2878, 2881,
		1, 0, 0, 0, 2879, 2877, 1, 0, 0, 0, 2879, 2880, 1, 0, 0, 0, 2880, 2883,
		1, 0, 0, 0, 2881, 2879, 1, 0, 0, 0, 2882, 2884, 3, 224, 112, 0, 2883, 2882,
		1, 0, 0, 0, 2883, 2884, 1, 0, 0, 0, 2884, 2886, 1, 0, 0, 0, 2885, 2887,
		3, 230, 115, 0, 2886, 2885, 1, 0, 0, 0, 2886, 2887, 1, 0, 0, 0, 2887, 211,
		1, 0, 0, 0, 2888, 2890, 5, 138, 0, 0, 2889, 2888, 1, 0, 0, 0, 2889, 2890,
		1, 0, 0, 0, 2890, 2891, 1, 0, 0, 0, 2891, 2892, 7, 19, 0, 0, 2892, 2893,
		5, 22, 0, 0, 2893, 2894, 5, 236, 0, 0, 2894, 2903, 3, 518, 259, 0, 2895,
		2897, 5, 138, 0, 0, 2896, 2895, 1, 0, 0, 0, 2896, 2897, 1, 0, 0, 0, 2897,
		2898, 1, 0, 0, 0, 2898, 2899, 7, 20, 0, 0, 2899, 2900, 5, 22, 0, 0, 2900,
		2901, 5, 236, 0, 0, 2901, 2903, 3, 342, 171, 0, 2902, 2889, 1, 0, 0, 0,
		2902, 2896, 1, 0, 0, 0, 2903, 213, 1, 0, 0, 0, 2904, 2905, 5, 150, 0, 0,
		2905, 2906, 5, 36, 0, 0, 2906, 2911, 3, 216, 108, 0, 2907, 2908, 5, 4,
		0, 0, 2908, 2910, 3, 216, 108, 0, 2909, 2907, 1, 0, 0, 0, 2910, 2913, 1,
		0, 0, 0, 2911, 2909, 1, 0, 0, 0, 2911, 2912, 1, 0, 0, 0, 2912, 2944, 1,
		0, 0, 0, 2913, 2911, 1, 0, 0, 0, 2914, 2915, 5, 150, 0, 0, 2915, 2916,
		5, 36, 0, 0, 2916, 2921, 3, 316, 158, 0, 2917, 2918, 5, 4, 0, 0, 2918,
		2920, 3, 316, 158, 0, 2919, 2917, 1, 0, 0, 0, 2920, 2923, 1, 0, 0, 0, 2921,
		2919, 1, 0, 0, 0, 2921, 2922, 1, 0, 0, 0, 2922, 2941, 1, 0, 0, 0, 2923,
		2921, 1, 0, 0, 0, 2924, 2925, 5, 396, 0, 0, 2925, 2942, 5, 295, 0, 0, 2926,
		2927, 5, 396, 0, 0, 2927, 2942, 5, 73, 0, 0, 2928, 2929, 5, 151, 0, 0,
		2929, 2930, 5, 311, 0, 0, 2930, 2931, 5, 2, 0, 0, 2931, 2936, 3, 222, 111,
		0, 2932, 2933, 5, 4, 0, 0, 2933, 2935, 3, 222, 111, 0, 2934, 2932, 1, 0,
		0, 0, 2935, 2938, 1, 0, 0, 0, 2936, 2934, 1, 0, 0, 0, 2936, 2937, 1, 0,
		0, 0, 2937, 2939, 1, 0, 0, 0, 2938, 2936, 1, 0, 0, 0, 2939, 2940, 5, 3,
		0, 0, 2940, 2942, 1, 0, 0, 0, 2941, 2924, 1, 0, 0, 0, 2941, 2926, 1, 0,
		0, 0, 2941, 2928, 1, 0, 0, 0, 2941, 2942, 1, 0, 0, 0, 2942, 2944, 1, 0,
		0, 0, 2943, 2904, 1, 0, 0, 0, 2943, 2914, 1, 0, 0, 0, 2944, 215, 1, 0,
		0, 0, 2945, 2948, 3, 218, 109, 0, 2946, 2948, 3, 328, 164, 0, 2947, 2945,
		1, 0, 0, 0, 2947, 2946, 1, 0, 0, 0, 2948, 217, 1, 0, 0, 0, 2949, 2950,
		7, 21, 0, 0, 2950, 2951, 5, 2, 0, 0, 2951, 2956, 3, 222, 111, 0, 2952,
		2953, 5, 4, 0, 0, 2953, 2955, 3, 222, 111, 0, 2954, 2952, 1, 0, 0, 0, 2955,
		2958, 1, 0, 0, 0, 2956, 2954, 1, 0, 0, 0, 2956, 2957, 1, 0, 0, 0, 2957,
		2959, 1, 0, 0, 0, 2958, 2956, 1, 0, 0, 0, 2959, 2960, 5, 3, 0, 0, 2960,
		2975, 1, 0, 0, 0, 2961, 2962, 5, 151, 0, 0, 2962, 2963, 5, 311, 0, 0, 2963,
		2964, 5, 2, 0, 0, 2964, 2969, 3, 220, 110, 0, 2965, 2966, 5, 4, 0, 0, 2966,
		2968, 3, 220, 110, 0, 2967, 2965, 1, 0, 0, 0, 2968, 2971, 1, 0, 0, 0, 2969,
		2967, 1, 0, 0, 0, 2969, 2970, 1, 0, 0, 0, 2970, 2972, 1, 0, 0, 0, 2971,
		2969, 1, 0, 0, 0, 2972, 2973, 5, 3, 0, 0, 2973, 2975, 1, 0, 0, 0, 2974,
		2949, 1, 0, 0, 0, 2974, 2961, 1, 0, 0, 0, 2975, 219, 1, 0, 0, 0, 2976,
		2979, 3, 218, 109, 0, 2977, 2979, 3, 222, 111, 0, 2978, 2976, 1, 0, 0,
		0, 2978, 2977, 1, 0, 0, 0, 2979, 221, 1, 0, 0, 0, 2980, 2989, 5, 2, 0,
		0, 2981, 2986, 3, 328, 164, 0, 2982, 2983, 5, 4, 0, 0, 2983, 2985, 3, 328,
		164, 0, 2984, 2982, 1, 0, 0, 0, 2985, 2988, 1, 0, 0, 0, 2986, 2984, 1,
		0, 0, 0, 2986, 2987, 1, 0, 0, 0, 2987, 2990, 1, 0, 0, 0, 2988, 2986, 1,
		0, 0, 0, 2989, 2981, 1, 0, 0, 0, 2989, 2990, 1, 0, 0, 0, 2990, 2991, 1,
		0, 0, 0, 2991, 2994, 5, 3, 0, 0, 2992, 2994, 3, 328, 164, 0, 2993, 2980,
		1, 0, 0, 0, 2993, 2992, 1, 0, 0, 0, 2994, 223, 1, 0, 0, 0, 2995, 2996,
		5, 255, 0, 0, 2996, 2997, 5, 2, 0, 0, 2997, 2998, 3, 318, 159, 0, 2998,
		2999, 5, 138, 0, 0, 2999, 3000, 3, 226, 113, 0, 3000, 3001, 5, 163, 0,
		0, 3001, 3002, 5, 2, 0, 0, 3002, 3007, 3, 228, 114, 0, 3003, 3004, 5, 4,
		0, 0, 3004, 3006, 3, 228, 114, 0, 3005, 3003, 1, 0, 0, 0, 3006, 3009, 1,
		0, 0, 0, 3007, 3005, 1, 0, 0, 0, 3007, 3008, 1, 0, 0, 0, 3008, 3010, 1,
		0, 0, 0, 3009, 3007, 1, 0, 0, 0, 3010, 3011, 5, 3, 0, 0, 3011, 3012, 5,
		3, 0, 0, 3012, 225, 1, 0, 0, 0, 3013, 3026, 3, 470, 235, 0, 3014, 3015,
		5, 2, 0, 0, 3015, 3020, 3, 470, 235, 0, 3016, 3017, 5, 4, 0, 0, 3017, 3019,
		3, 470, 235, 0, 3018, 3016, 1, 0, 0, 0, 3019, 3022, 1, 0, 0, 0, 3020, 3018,
		1, 0, 0, 0, 3020, 3021, 1, 0, 0, 0, 3021, 3023, 1, 0, 0, 0, 3022, 3020,
		1, 0, 0, 0, 3023, 3024, 5, 3, 0, 0, 3024, 3026, 1, 0, 0, 0, 3025, 3013,
		1, 0, 0, 0, 3025, 3014, 1, 0, 0, 0, 3026, 227, 1, 0, 0, 0, 3027, 3032,
		3, 328, 164, 0, 3028, 3030, 5, 22, 0, 0, 3029, 3028, 1, 0, 0, 0, 3029,
		3030, 1, 0, 0, 0, 3030, 3031, 1, 0, 0, 0, 3031, 3033, 3, 470, 235, 0, 3032,
		3029, 1, 0, 0, 0, 3032, 3033, 1, 0, 0, 0, 3033, 229, 1, 0, 0, 0, 3034,
		3036, 5, 373, 0, 0, 3035, 3037, 3, 232, 116, 0, 3036, 3035, 1, 0, 0, 0,
		3036, 3037, 1, 0, 0, 0, 3037, 3038, 1, 0, 0, 0, 3038, 3039, 5, 2, 0, 0,
		3039, 3040, 3, 234, 117, 0, 3040, 3045, 5, 3, 0, 0, 3041, 3043, 5, 22,
		0, 0, 3042, 3041, 1, 0, 0, 0, 3042, 3043, 1, 0, 0, 0, 3043, 3044, 1, 0,
		0, 0, 3044, 3046, 3, 470, 235, 0, 3045, 3042, 1, 0, 0, 0, 3045, 3046, 1,
		0, 0, 0, 3046, 231, 1, 0, 0, 0, 3047, 3048, 7, 22, 0, 0, 3048, 3049, 5,
		233, 0, 0, 3049, 233, 1, 0, 0, 0, 3050, 3053, 3, 236, 118, 0, 3051, 3053,
		3, 238, 119, 0, 3052, 3050, 1, 0, 0, 0, 3052, 3051, 1, 0, 0, 0, 3053, 235,
		1, 0, 0, 0, 3054, 3055, 3, 242, 121, 0, 3055, 3056, 5, 138, 0, 0, 3056,
		3057, 3, 244, 122, 0, 3057, 3058, 5, 163, 0, 0, 3058, 3059, 5, 2, 0, 0,
		3059, 3064, 3, 246, 123, 0, 3060, 3061, 5, 4, 0, 0, 3061, 3063, 3, 246,
		123, 0, 3062, 3060, 1, 0, 0, 0, 3063, 3066, 1, 0, 0, 0, 3064, 3062, 1,
		0, 0, 0, 3064, 3065, 1, 0, 0, 0, 3065, 3067, 1, 0, 0, 0, 3066, 3064, 1,
		0, 0, 0, 3067, 3068, 5, 3, 0, 0, 3068, 237, 1, 0, 0, 0, 3069, 3070, 5,
		2, 0, 0, 3070, 3075, 3, 242, 121, 0, 3071, 3072, 5, 4, 0, 0, 3072, 3074,
		3, 242, 121, 0, 3073, 3071, 1, 0, 0, 0, 3074, 3077, 1, 0, 0, 0, 3075, 3073,
		1, 0, 0, 0, 3075, 3076, 1, 0, 0, 0, 3076, 3078, 1, 0, 0, 0, 3077, 3075,
		1, 0, 0, 0, 3078, 3079, 5, 3, 0, 0, 3079, 3080, 5, 138, 0, 0, 3080, 3081,
		3, 244, 122, 0, 3081, 3082, 5, 163, 0, 0, 3082, 3083, 5, 2, 0, 0, 3083,
		3088, 3, 240, 120, 0, 3084, 3085, 5, 4, 0, 0, 3085, 3087, 3, 240, 120,
		0, 3086, 3084, 1, 0, 0, 0, 3087, 3090, 1, 0, 0, 0, 3088, 3086, 1, 0, 0,
		0, 3088, 3089, 1, 0, 0, 0, 3089, 3091, 1, 0, 0, 0, 3090, 3088, 1, 0, 0,
		0, 3091, 3092, 5, 3, 0, 0, 3092, 239, 1, 0, 0, 0, 3093, 3094, 5, 2, 0,
		0, 3094, 3099, 3, 248, 124, 0, 3095, 3096, 5, 4, 0, 0, 3096, 3098, 3, 248,
		124, 0, 3097, 3095, 1, 0, 0, 0, 3098, 3101, 1, 0, 0, 0, 3099, 3097, 1,
		0, 0, 0, 3099, 3100, 1, 0, 0, 0, 3100, 3102, 1, 0, 0, 0, 3101, 3099, 1,
		0, 0, 0, 3102, 3104, 5, 3, 0, 0, 3103, 3105, 3, 250, 125, 0, 3104, 3103,
		1, 0, 0, 0, 3104, 3105, 1, 0, 0, 0, 3105, 241, 1, 0, 0, 0, 3106, 3107,
		3, 474, 237, 0, 3107, 243, 1, 0, 0, 0, 3108, 3109, 3, 474, 237, 0, 3109,
		245, 1, 0, 0, 0, 3110, 3112, 3, 248, 124, 0, 3111, 3113, 3, 250, 125, 0,
		3112, 3111, 1, 0, 0, 0, 3112, 3113, 1, 0, 0, 0, 3113, 247, 1, 0, 0, 0,
		3114, 3115, 3, 306, 153, 0, 3115, 249, 1, 0, 0, 0, 3116, 3118, 5, 22, 0,
		0, 3117, 3116, 1, 0, 0, 0, 3117, 3118, 1, 0, 0, 0, 3118, 3119, 1, 0, 0,
		0, 3119, 3120, 3, 470, 235, 0, 3120, 251, 1, 0, 0, 0, 3121, 3122, 5, 188,
		0, 0, 3122, 3124, 5, 387, 0, 0, 3123, 3125, 5, 245, 0, 0, 3124, 3123, 1,
		0, 0, 0, 3124, 3125, 1, 0, 0, 0, 3125, 3126, 1, 0, 0, 0, 3126, 3127, 3,
		468, 234, 0, 3127, 3136, 5, 2, 0, 0, 3128, 3133, 3, 328, 164, 0, 3129,
		3130, 5, 4, 0, 0, 3130, 3132, 3, 328, 164, 0, 3131, 3129, 1, 0, 0, 0, 3132,
		3135, 1, 0, 0, 0, 3133, 3131, 1, 0, 0, 0, 3133, 3134, 1, 0, 0, 0, 3134,
		3137, 1, 0, 0, 0, 3135, 3133, 1, 0, 0, 0, 3136, 3128, 1, 0, 0, 0, 3136,
		3137, 1, 0, 0, 0, 3137, 3138, 1, 0, 0, 0, 3138, 3139, 5, 3, 0, 0, 3139,
		3151, 3, 474, 237, 0, 3140, 3142, 5, 22, 0, 0, 3141, 3140, 1, 0, 0, 0,
		3141, 3142, 1, 0, 0, 0, 3142, 3143, 1, 0, 0, 0, 3143, 3148, 3, 474, 237,
		0, 3144, 3145, 5, 4, 0, 0, 3145, 3147, 3, 474, 237, 0, 3146, 3144, 1, 0,
		0, 0, 3147, 3150, 1, 0, 0, 0, 3148, 3146, 1, 0, 0, 0, 3148, 3149, 1, 0,
		0, 0, 3149, 3152, 1, 0, 0, 0, 3150, 3148, 1, 0, 0, 0, 3151, 3141, 1, 0,
		0, 0, 3151, 3152, 1, 0, 0, 0, 3152, 253, 1, 0, 0, 0, 3153, 3154, 7, 23,
		0, 0, 3154, 255, 1, 0, 0, 0, 3155, 3157, 5, 188, 0, 0, 3156, 3155, 1, 0,
		0, 0, 3156, 3157, 1, 0, 0, 0, 3157, 3158, 1, 0, 0, 0, 3158, 3162, 3, 282,
		141, 0, 3159, 3161, 3, 258, 129, 0, 3160, 3159, 1, 0, 0, 0, 3161, 3164,
		1, 0, 0, 0, 3162, 3160, 1, 0, 0, 0, 3162, 3163, 1, 0, 0, 0, 3163, 257,
		1, 0, 0, 0, 3164, 3162, 1, 0, 0, 0, 3165, 3169, 3, 260, 130, 0, 3166, 3169,
		3, 224, 112, 0, 3167, 3169, 3, 230, 115, 0, 3168, 3165, 1, 0, 0, 0, 3168,
		3166, 1, 0, 0, 0, 3168, 3167, 1, 0, 0, 0, 3169, 259, 1, 0, 0, 0, 3170,
		3171, 3, 262, 131, 0, 3171, 3173, 5, 182, 0, 0, 3172, 3174, 5, 188, 0,
		0, 3173, 3172, 1, 0, 0, 0, 3173, 3174, 1, 0, 0, 0, 3174, 3175, 1, 0, 0,
		0, 3175, 3177, 3, 282, 141, 0, 3176, 3178, 3, 264, 132, 0, 3177, 3176,
		1, 0, 0, 0, 3177, 3178, 1, 0, 0, 0, 3178, 3188, 1, 0, 0, 0, 3179, 3180,
		5, 228, 0, 0, 3180, 3181, 3, 262, 131, 0, 3181, 3183, 5, 182, 0, 0, 3182,
		3184, 5, 188, 0, 0, 3183, 3182, 1, 0, 0, 0, 3183, 3184, 1, 0, 0, 0, 3184,
		3185, 1, 0, 0, 0, 3185, 3186, 3, 282, 141, 0, 3186, 3188, 1, 0, 0, 0, 3187,
		3170, 1, 0, 0, 0, 3187, 3179, 1, 0, 0, 0, 3188, 261, 1, 0, 0, 0, 3189,
		3191, 5, 168, 0, 0, 3190, 3189, 1, 0, 0, 0, 3190, 3191, 1, 0, 0, 0, 3191,
		3214, 1, 0, 0, 0, 3192, 3214, 5, 72, 0, 0, 3193, 3195, 5, 192, 0, 0, 3194,
		3196, 5, 245, 0, 0, 3195, 3194, 1, 0, 0, 0, 3195, 3196, 1, 0, 0, 0, 3196,
		3214, 1, 0, 0, 0, 3197, 3199, 5, 192, 0, 0, 3198, 3197, 1, 0, 0, 0, 3198,
		3199, 1, 0, 0, 0, 3199, 3200, 1, 0, 0, 0, 3200, 3214, 5, 304, 0, 0, 3201,
		3203, 5, 290, 0, 0, 3202, 3204, 5, 245, 0, 0, 3203, 3202, 1, 0, 0, 0, 3203,
		3204, 1, 0, 0, 0, 3204, 3214, 1, 0, 0, 0, 3205, 3207, 5, 144, 0, 0, 3206,
		3208, 5, 245, 0, 0, 3207, 3206, 1, 0, 0, 0, 3207, 3208, 1, 0, 0, 0, 3208,
		3214, 1, 0, 0, 0, 3209, 3211, 5, 192, 0, 0, 3210, 3209, 1, 0, 0, 0, 3210,
		3211, 1, 0, 0, 0, 3211, 3212, 1, 0, 0, 0, 3212, 3214, 5, 17, 0, 0, 3213,
		3190, 1, 0, 0, 0, 3213, 3192, 1, 0, 0, 0, 3213, 3193, 1, 0, 0, 0, 3213,
		3198, 1, 0, 0, 0, 3213, 3201, 1, 0, 0, 0, 3213, 3205, 1, 0, 0, 0, 3213,
		3210, 1, 0, 0, 0, 3214, 263, 1, 0, 0, 0, 3215, 3216, 5, 238, 0, 0, 3216,
		3220, 3, 336, 168, 0, 3217, 3218, 5, 379, 0, 0, 3218, 3220, 3, 270, 135,
		0, 3219, 3215, 1, 0, 0, 0, 3219, 3217, 1, 0, 0, 0, 3220, 265, 1, 0, 0,
		0, 3221, 3222, 5, 340, 0, 0, 3222, 3224, 5, 2, 0, 0, 3223, 3225, 3, 268,
		134, 0, 3224, 3223, 1, 0, 0, 0, 3224, 3225, 1, 0, 0, 0, 3225, 3226, 1,
		0, 0, 0, 3226, 3231, 5, 3, 0, 0, 3227, 3228, 5, 282, 0, 0, 3228, 3229,
		5, 2, 0, 0, 3229, 3230, 5, 436, 0, 0, 3230, 3232, 5, 3, 0, 0, 3231, 3227,
		1, 0, 0, 0, 3231, 3232, 1, 0, 0, 0, 3232, 267, 1, 0, 0, 0, 3233, 3235,
		5, 414, 0, 0, 3234, 3233, 1, 0, 0, 0, 3234, 3235, 1, 0, 0, 0, 3235, 3236,
		1, 0, 0, 0, 3236, 3237, 7, 24, 0, 0, 3237, 3258, 5, 254, 0, 0, 3238, 3239,
		3, 328, 164, 0, 3239, 3240, 5, 297, 0, 0, 3240, 3258, 1, 0, 0, 0, 3241,
		3242, 5, 34, 0, 0, 3242, 3243, 5, 436, 0, 0, 3243, 3244, 5, 244, 0, 0,
		3244, 3245, 5, 236, 0, 0, 3245, 3254, 5, 436, 0, 0, 3246, 3252, 5, 238,
		0, 0, 3247, 3253, 3, 474, 237, 0, 3248, 3249, 3, 468, 234, 0, 3249, 3250,
		5, 2, 0, 0, 3250, 3251, 5, 3, 0, 0, 3251, 3253, 1, 0, 0, 0, 3252, 3247,
		1, 0, 0, 0, 3252, 3248, 1, 0, 0, 0, 3253, 3255, 1, 0, 0, 0, 3254, 3246,
		1, 0, 0, 0, 3254, 3255, 1, 0, 0, 0, 3255, 3258, 1, 0, 0, 0, 3256, 3258,
		3, 328, 164, 0, 3257, 3234, 1, 0, 0, 0, 3257, 3238, 1, 0, 0, 0, 3257, 3241,
		1, 0, 0, 0, 3257, 3256, 1, 0, 0, 0, 3258, 269, 1, 0, 0, 0, 3259, 3260,
		5, 2, 0, 0, 3260, 3261, 3, 272, 136, 0, 3261, 3262, 5, 3, 0, 0, 3262, 271,
		1, 0, 0, 0, 3263, 3268, 3, 470, 235, 0, 3264, 3265, 5, 4, 0, 0, 3265, 3267,
		3, 470, 235, 0, 3266, 3264, 1, 0, 0, 0, 3267, 3270, 1, 0, 0, 0, 3268, 3266,
		1, 0, 0, 0, 3268, 3269, 1, 0, 0, 0, 3269, 273, 1, 0, 0, 0, 3270, 3268,
		1, 0, 0, 0, 3271, 3272, 5, 2, 0, 0, 3272, 3277, 3, 276, 138, 0, 3273, 3274,
		5, 4, 0, 0, 3274, 3276, 3, 276, 138, 0, 3275, 3273, 1, 0, 0, 0, 3276, 3279,
		1, 0, 0, 0, 3277, 3275, 1, 0, 0, 0, 3277, 3278, 1, 0, 0, 0, 3278, 3280,
		1, 0, 0, 0, 3279, 3277, 1, 0, 0, 0, 3280, 3281, 5, 3, 0, 0, 3281, 275,
		1, 0, 0, 0, 3282, 3284, 3, 470, 235, 0, 3283, 3285, 7, 17, 0, 0, 3284,
		3283, 1, 0, 0, 0, 3284, 3285, 1, 0, 0, 0, 3285, 277, 1, 0, 0, 0, 3286,
		3287, 5, 2, 0, 0, 3287, 3292, 3, 280, 140, 0, 3288, 3289, 5, 4, 0, 0, 3289,
		3291, 3, 280, 140, 0, 3290, 3288, 1, 0, 0, 0, 3291, 3294, 1, 0, 0, 0, 3292,
		3290, 1, 0, 0, 0, 3292, 3293, 1, 0, 0, 0, 3293, 3295, 1, 0, 0, 0, 3294,
		3292, 1, 0, 0, 0, 3295, 3296, 5, 3, 0, 0, 3296, 279, 1, 0, 0, 0, 3297,
		3299, 3, 474, 237, 0, 3298, 3300, 3, 98, 49, 0, 3299, 3298, 1, 0, 0, 0,
		3299, 3300, 1, 0, 0, 0, 3300, 281, 1, 0, 0, 0, 3301, 3333, 3, 68, 34, 0,
		3302, 3304, 3, 158, 79, 0, 3303, 3305, 3, 212, 106, 0, 3304, 3303, 1, 0,
		0, 0, 3304, 3305, 1, 0, 0, 0, 3305, 3307, 1, 0, 0, 0, 3306, 3308, 3, 284,
		142, 0, 3307, 3306, 1, 0, 0, 0, 3307, 3308, 1, 0, 0, 0, 3308, 3310, 1,
		0, 0, 0, 3309, 3311, 3, 266, 133, 0, 3310, 3309, 1, 0, 0, 0, 3310, 3311,
		1, 0, 0, 0, 3311, 3312, 1, 0, 0, 0, 3312, 3313, 3, 300, 150, 0, 3313, 3333,
		1, 0, 0, 0, 3314, 3315, 5, 2, 0, 0, 3315, 3316, 3, 102, 51, 0, 3316, 3318,
		5, 3, 0, 0, 3317, 3319, 3, 266, 133, 0, 3318, 3317, 1, 0, 0, 0, 3318, 3319,
		1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320, 3321, 3, 300, 150, 0, 3321, 3333,
		1, 0, 0, 0, 3322, 3323, 5, 2, 0, 0, 3323, 3324, 3, 256, 128, 0, 3324, 3326,
		5, 3, 0, 0, 3325, 3327, 3, 266, 133, 0, 3326, 3325, 1, 0, 0, 0, 3326, 3327,
		1, 0, 0, 0, 3327, 3328, 1, 0, 0, 0, 3328, 3329, 3, 300, 150, 0, 3329, 3333,
		1, 0, 0, 0, 3330, 3333, 3, 286, 143, 0, 3331, 3333, 3, 298, 149, 0, 3332,
		3301, 1, 0, 0, 0, 3332, 3302, 1, 0, 0, 0, 3332, 3314, 1, 0, 0, 0, 3332,
		3322, 1, 0, 0, 0, 3332, 3330, 1, 0, 0, 0, 3332, 3331, 1, 0, 0, 0, 3333,
		283, 1, 0, 0, 0, 3334, 3335, 5, 396, 0, 0, 3335, 3336, 3, 132, 66, 0, 3336,
		285, 1, 0, 0, 0, 3337, 3338, 5, 381, 0, 0, 3338, 3343, 3, 328, 164, 0,
		3339, 3340, 5, 4, 0, 0, 3340, 3342, 3, 328, 164, 0, 3341, 3339, 1, 0, 0,
		0, 3342, 3345, 1, 0, 0, 0, 3343, 3341, 1, 0, 0, 0, 3343, 3344, 1, 0, 0,
		0, 3344, 3346, 1, 0, 0, 0, 3345, 3343, 1, 0, 0, 0, 3346, 3347, 3, 300,
		150, 0, 3347, 287, 1, 0, 0, 0, 3348, 3349, 5, 338, 0, 0, 3349, 3351, 3,
		158, 79, 0, 3350, 3352, 3, 290, 145, 0, 3351, 3350, 1, 0, 0, 0, 3351, 3352,
		1, 0, 0, 0, 3352, 3368, 1, 0, 0, 0, 3353, 3354, 5, 338, 0, 0, 3354, 3355,
		5, 2, 0, 0, 3355, 3356, 3, 158, 79, 0, 3356, 3358, 5, 3, 0, 0, 3357, 3359,
		3, 290, 145, 0, 3358, 3357, 1, 0, 0, 0, 3358, 3359, 1, 0, 0, 0, 3359, 3368,
		1, 0, 0, 0, 3360, 3361, 5, 338, 0, 0, 3361, 3362, 5, 2, 0, 0, 3362, 3363,
		3, 102, 51, 0, 3363, 3365, 5, 3, 0, 0, 3364, 3366, 3, 290, 145, 0, 3365,
		3364, 1, 0, 0, 0, 3365, 3366, 1, 0, 0, 0, 3366, 3368, 1, 0, 0, 0, 3367,
		3348, 1, 0, 0, 0, 3367, 3353, 1, 0, 0, 0, 3367, 3360, 1, 0, 0, 0, 3368,
		289, 1, 0, 0, 0, 3369, 3370, 5, 396, 0, 0, 3370, 3371, 5, 314, 0, 0, 3371,
		3396, 5, 251, 0, 0, 3372, 3373, 7, 25, 0, 0, 3373, 3393, 5, 36, 0, 0, 3374,
		3375, 5, 2, 0, 0, 3375, 3380, 3, 328, 164, 0, 3376, 3377, 5, 4, 0, 0, 3377,
		3379, 3, 328, 164, 0, 3378, 3376, 1, 0, 0, 0, 3379, 3382, 1, 0, 0, 0, 3380,
		3378, 1, 0, 0, 0, 3380, 3381, 1, 0, 0, 0, 3381, 3383, 1, 0, 0, 0, 3382,
		3380, 1, 0, 0, 0, 3383, 3384, 5, 3, 0, 0, 3384, 3394, 1, 0, 0, 0, 3385,
		3388, 3, 328, 164, 0, 3386, 3387, 5, 4, 0, 0, 3387, 3389, 3, 328, 164,
		0, 3388, 3386, 1, 0, 0, 0, 3389, 3390, 1, 0, 0, 0, 3390, 3388, 1, 0, 0,
		0, 3390, 3391, 1, 0, 0, 0, 3391, 3394, 1, 0, 0, 0, 3392, 3394, 3, 328,
		164, 0, 3393, 3374, 1, 0, 0, 0, 3393, 3385, 1, 0, 0, 0, 3393, 3392, 1,
		0, 0, 0, 3394, 3396, 1, 0, 0, 0, 3395, 3369, 1, 0, 0, 0, 3395, 3372, 1,
		0, 0, 0, 3396, 3420, 1, 0, 0, 0, 3397, 3398, 7, 26, 0, 0, 3398, 3418, 5,
		36, 0, 0, 3399, 3400, 5, 2, 0, 0, 3400, 3405, 3, 170, 85, 0, 3401, 3402,
		5, 4, 0, 0, 3402, 3404, 3, 170, 85, 0, 3403, 3401, 1, 0, 0, 0, 3404, 3407,
		1, 0, 0, 0, 3405, 3403, 1, 0, 0, 0, 3405, 3406, 1, 0, 0, 0, 3406, 3408,
		1, 0, 0, 0, 3407, 3405, 1, 0, 0, 0, 3408, 3409, 5, 3, 0, 0, 3409, 3419,
		1, 0, 0, 0, 3410, 3413, 3, 170, 85, 0, 3411, 3412, 5, 4, 0, 0, 3412, 3414,
		3, 170, 85, 0, 3413, 3411, 1, 0, 0, 0, 3414, 3415, 1, 0, 0, 0, 3415, 3413,
		1, 0, 0, 0, 3415, 3416, 1, 0, 0, 0, 3416, 3419, 1, 0, 0, 0, 3417, 3419,
		3, 170, 85, 0, 3418, 3399, 1, 0, 0, 0, 3418, 3410, 1, 0, 0, 0, 3418, 3417,
		1, 0, 0, 0, 3419, 3421, 1, 0, 0, 0, 3420, 3397, 1, 0, 0, 0, 3420, 3421,
		1, 0, 0, 0, 3421, 291, 1, 0, 0, 0, 3422, 3423, 3, 474, 237, 0, 3423, 3424,
		5, 427, 0, 0, 3424, 3425, 3, 288, 144, 0, 3425, 293, 1, 0, 0, 0, 3426,
		3429, 3, 288, 144, 0, 3427, 3429, 3, 292, 146, 0, 3428, 3426, 1, 0, 0,
		0, 3428, 3427, 1, 0, 0, 0, 3429, 295, 1, 0, 0, 0, 3430, 3433, 3, 294, 147,
		0, 3431, 3433, 3, 332, 166, 0, 3432, 3430, 1, 0, 0, 0, 3432, 3431, 1, 0,
		0, 0, 3433, 297, 1, 0, 0, 0, 3434, 3435, 3, 466, 233, 0, 3435, 3444, 5,
		2, 0, 0, 3436, 3441, 3, 296, 148, 0, 3437, 3438, 5, 4, 0, 0, 3438, 3440,
		3, 296, 148, 0, 3439, 3437, 1, 0, 0, 0, 3440, 3443, 1, 0, 0, 0, 3441, 3439,
		1, 0, 0, 0, 3441, 3442, 1, 0, 0, 0, 3442, 3445, 1, 0, 0, 0, 3443, 3441,
		1, 0, 0, 0, 3444, 3436, 1, 0, 0, 0, 3444, 3445, 1, 0, 0, 0, 3445, 3446,
		1, 0, 0, 0, 3446, 3447, 5, 3, 0, 0, 3447, 3448, 3, 300, 150, 0, 3448, 299,
		1, 0, 0, 0, 3449, 3451, 5, 22, 0, 0, 3450, 3449, 1, 0, 0, 0, 3450, 3451,
		1, 0, 0, 0, 3451, 3452, 1, 0, 0, 0, 3452, 3454, 3, 476, 238, 0, 3453, 3455,
		3, 270, 135, 0, 3454, 3453, 1, 0, 0, 0, 3454, 3455, 1, 0, 0, 0, 3455, 3457,
		1, 0, 0, 0, 3456, 3450, 1, 0, 0, 0, 3456, 3457, 1, 0, 0, 0, 3457, 301,
		1, 0, 0, 0, 3458, 3459, 5, 296, 0, 0, 3459, 3460, 5, 140, 0, 0, 3460, 3461,
		5, 306, 0, 0, 3461, 3465, 3, 514, 257, 0, 3462, 3463, 5, 396, 0, 0, 3463,
		3464, 5, 307, 0, 0, 3464, 3466, 3, 132, 66, 0, 3465, 3462, 1, 0, 0, 0,
		3465, 3466, 1, 0, 0, 0, 3466, 3508, 1, 0, 0, 0, 3467, 3468, 5, 296, 0,
		0, 3468, 3469, 5, 140, 0, 0, 3469, 3479, 5, 98, 0, 0, 3470, 3471, 5, 131,
		0, 0, 3471, 3472, 5, 344, 0, 0, 3472, 3473, 5, 36, 0, 0, 3473, 3477, 3,
		514, 257, 0, 3474, 3475, 5, 116, 0, 0, 3475, 3476, 5, 36, 0, 0, 3476, 3478,
		3, 514, 257, 0, 3477, 3474, 1, 0, 0, 0, 3477, 3478, 1, 0, 0, 0, 3478, 3480,
		1, 0, 0, 0, 3479, 3470, 1, 0, 0, 0, 3479, 3480, 1, 0, 0, 0, 3480, 3486,
		1, 0, 0, 0, 3481, 3482, 5, 56, 0, 0, 3482, 3483, 5, 180, 0, 0, 3483, 3484,
		5, 344, 0, 0, 3484, 3485, 5, 36, 0, 0, 3485, 3487, 3, 514, 257, 0, 3486,
		3481, 1, 0, 0, 0, 3486, 3487, 1, 0, 0, 0, 3487, 3493, 1, 0, 0, 0, 3488,
		3489, 5, 208, 0, 0, 3489, 3490, 5, 185, 0, 0, 3490, 3491, 5, 344, 0, 0,
		3491, 3492, 5, 36, 0, 0, 3492, 3494, 3, 514, 257, 0, 3493, 3488, 1, 0,
		0, 0, 3493, 3494, 1, 0, 0, 0, 3494, 3499, 1, 0, 0, 0, 3495, 3496, 5, 197,
		0, 0, 3496, 3497, 5, 344, 0, 0, 3497, 3498, 5, 36, 0, 0, 3498, 3500, 3,
		514, 257, 0, 3499, 3495, 1, 0, 0, 0, 3499, 3500, 1, 0, 0, 0, 3500, 3505,
		1, 0, 0, 0, 3501, 3502, 5, 232, 0, 0, 3502, 3503, 5, 95, 0, 0, 3503, 3504,
		5, 22, 0, 0, 3504, 3506, 3, 514, 257, 0, 3505, 3501, 1, 0, 0, 0, 3505,
		3506, 1, 0, 0, 0, 3506, 3508, 1, 0, 0, 0, 3507, 3458, 1, 0, 0, 0, 3507,
		3467, 1, 0, 0, 0, 3508, 303, 1, 0, 0, 0, 3509, 3514, 3, 306, 153, 0, 3510,
		3511, 5, 4, 0, 0, 3511, 3513, 3, 306, 153, 0, 3512, 3510, 1, 0, 0, 0, 3513,
		3516, 1, 0, 0, 0, 3514, 3512, 1, 0, 0, 0, 3514, 3515, 1, 0, 0, 0, 3515,
		305, 1, 0, 0, 0, 3516, 3514, 1, 0, 0, 0, 3517, 3522, 3, 470, 235, 0, 3518,
		3519, 5, 5, 0, 0, 3519, 3521, 3, 470, 235, 0, 3520, 3518, 1, 0, 0, 0, 3521,
		3524, 1, 0, 0, 0, 3522, 3520, 1, 0, 0, 0, 3522, 3523, 1, 0, 0, 0, 3523,
		307, 1, 0, 0, 0, 3524, 3522, 1, 0, 0, 0, 3525, 3530, 3, 310, 155, 0, 3526,
		3527, 5, 4, 0, 0, 3527, 3529, 3, 310, 155, 0, 3528, 3526, 1, 0, 0, 0, 3529,
		3532, 1, 0, 0, 0, 3530, 3528, 1, 0, 0, 0, 3530, 3531, 1, 0, 0, 0, 3531,
		309, 1, 0, 0, 0, 3532, 3530, 1, 0, 0, 0, 3533, 3536, 3, 306, 153, 0, 3534,
		3535, 5, 241, 0, 0, 3535, 3537, 3, 132, 66, 0, 3536, 3534, 1, 0, 0, 0,
		3536, 3537, 1, 0, 0, 0, 3537, 311, 1, 0, 0, 0, 3538, 3539, 3, 470, 235,
		0, 3539, 3540, 5, 5, 0, 0, 3540, 3542, 1, 0, 0, 0, 3541, 3538, 1, 0, 0,
		0, 3541, 3542, 1, 0, 0, 0, 3542, 3543, 1, 0, 0, 0, 3543, 3544, 3, 470,
		235, 0, 3544, 313, 1, 0, 0, 0, 3545, 3546, 3, 470, 235, 0, 3546, 3547,
		5, 5, 0, 0, 3547, 3549, 1, 0, 0, 0, 3548, 3545, 1, 0, 0, 0, 3548, 3549,
		1, 0, 0, 0, 3549, 3550, 1, 0, 0, 0, 3550, 3551, 3, 470, 235, 0, 3551, 315,
		1, 0, 0, 0, 3552, 3560, 3, 328, 164, 0, 3553, 3555, 5, 22, 0, 0, 3554,
		3553, 1, 0, 0, 0, 3554, 3555, 1, 0, 0, 0, 3555, 3558, 1, 0, 0, 0, 3556,
		3559, 3, 470, 235, 0, 3557, 3559, 3, 270, 135, 0, 3558, 3556, 1, 0, 0,
		0, 3558, 3557, 1, 0, 0, 0, 3559, 3561, 1, 0, 0, 0, 3560, 3554, 1, 0, 0,
		0, 3560, 3561, 1, 0, 0, 0, 3561, 317, 1, 0, 0, 0, 3562, 3567, 3, 316, 158,
		0, 3563, 3564, 5, 4, 0, 0, 3564, 3566, 3, 316, 158, 0, 3565, 3563, 1, 0,
		0, 0, 3566, 3569, 1, 0, 0, 0, 3567, 3565, 1, 0, 0, 0, 3567, 3568, 1, 0,
		0, 0, 3568, 319, 1, 0, 0, 0, 3569, 3567, 1, 0, 0, 0, 3570, 3571, 5, 2,
		0, 0, 3571, 3576, 3, 322, 161, 0, 3572, 3573, 5, 4, 0, 0, 3573, 3575, 3,
		322, 161, 0, 3574, 3572, 1, 0, 0, 0, 3575, 3578, 1, 0, 0, 0, 3576, 3574,
		1, 0, 0, 0, 3576, 3577, 1, 0, 0, 0, 3577, 3579, 1, 0, 0, 0, 3578, 3576,
		1, 0, 0, 0, 3579, 3580, 5, 3, 0, 0, 3580, 321, 1, 0, 0, 0, 3581, 3584,
		3, 324, 162, 0, 3582, 3584, 3, 414, 207, 0, 3583, 3581, 1, 0, 0, 0, 3583,
		3582, 1, 0, 0, 0, 3584, 323, 1, 0, 0, 0, 3585, 3599, 3, 468, 234, 0, 3586,
		3587, 3, 474, 237, 0, 3587, 3588, 5, 2, 0, 0, 3588, 3593, 3, 326, 163,
		0, 3589, 3590, 5, 4, 0, 0, 3590, 3592, 3, 326, 163, 0, 3591, 3589, 1, 0,
		0, 0, 3592, 3595, 1, 0, 0, 0, 3593, 3591, 1, 0, 0, 0, 3593, 3594, 1, 0,
		0, 0, 3594, 3596, 1, 0, 0, 0, 3595, 3593, 1, 0, 0, 0, 3596, 3597, 5, 3,
		0, 0, 3597, 3599, 1, 0, 0, 0, 3598, 3585, 1, 0, 0, 0, 3598, 3586, 1, 0,
		0, 0, 3599, 325, 1, 0, 0, 0, 3600, 3603, 3, 468, 234, 0, 3601, 3603, 3,
		362, 181, 0, 3602, 3600, 1, 0, 0, 0, 3602, 3601, 1, 0, 0, 0, 3603, 327,
		1, 0, 0, 0, 3604, 3605, 3, 336, 168, 0, 3605, 329, 1, 0, 0, 0, 3606, 3607,
		3, 474, 237, 0, 3607, 3608, 5, 427, 0, 0, 3608, 3609, 3, 328, 164, 0, 3609,
		331, 1, 0, 0, 0, 3610, 3613, 3, 328, 164, 0, 3611, 3613, 3, 330, 165, 0,
		3612, 3610, 1, 0, 0, 0, 3612, 3611, 1, 0, 0, 0, 3613, 333, 1, 0, 0, 0,
		3614, 3619, 3, 328, 164, 0, 3615, 3616, 5, 4, 0, 0, 3616, 3618, 3, 328,
		164, 0, 3617, 3615, 1, 0, 0, 0, 3618, 3621, 1, 0, 0, 0, 3619, 3617, 1,
		0, 0, 0, 3619, 3620, 1, 0, 0, 0, 3620, 335, 1, 0, 0, 0, 3621, 3619, 1,
		0, 0, 0, 3622, 3623, 6, 168, -1, 0, 3623, 3624, 7, 27, 0, 0, 3624, 3635,
		3, 336, 168, 5, 3625, 3626, 5, 121, 0, 0, 3626, 3627, 5, 2, 0, 0, 3627,
		3628, 3, 102, 51, 0, 3628, 3629, 5, 3, 0, 0, 3629, 3635, 1, 0, 0, 0, 3630,
		3632, 3, 342, 171, 0, 3631, 3633, 3, 338, 169, 0, 3632, 3631, 1, 0, 0,
		0, 3632, 3633, 1, 0, 0, 0, 3633, 3635, 1, 0, 0, 0, 3634, 3622, 1, 0, 0,
		0, 3634, 3625, 1, 0, 0, 0, 3634, 3630, 1, 0, 0, 0, 3635, 3644, 1, 0, 0,
		0, 3636, 3637, 10, 2, 0, 0, 3637, 3638, 5, 16, 0, 0, 3638, 3643, 3, 336,
		168, 3, 3639, 3640, 10, 1, 0, 0, 3640, 3641, 5, 242, 0, 0, 3641, 3643,
		3, 336, 168, 2, 3642, 3636, 1, 0, 0, 0, 3642, 3639, 1, 0, 0, 0, 3643, 3646,
		1, 0, 0, 0, 3644, 3642, 1, 0, 0, 0, 3644, 3645, 1, 0, 0, 0, 3645, 337,
		1, 0, 0, 0, 3646, 3644, 1, 0, 0, 0, 3647, 3649, 3, 340, 170, 0, 3648, 3647,
		1, 0, 0, 0, 3648, 3649, 1, 0, 0, 0, 3649, 3650, 1, 0, 0, 0, 3650, 3651,
		5, 28, 0, 0, 3651, 3652, 3, 342, 171, 0, 3652, 3653, 5, 16, 0, 0, 3653,
		3654, 3, 342, 171, 0, 3654, 3730, 1, 0, 0, 0, 3655, 3657, 3, 340, 170,
		0, 3656, 3655, 1, 0, 0, 0, 3656, 3657, 1, 0, 0, 0, 3657, 3658, 1, 0, 0,
		0, 3658, 3659, 5, 163, 0, 0, 3659, 3660, 5, 2, 0, 0, 3660, 3665, 3, 328,
		164, 0, 3661, 3662, 5, 4, 0, 0, 3662, 3664, 3, 328, 164, 0, 3663, 3661,
		1, 0, 0, 0, 3664, 3667, 1, 0, 0, 0, 3665, 3663, 1, 0, 0, 0, 3665, 3666,
		1, 0, 0, 0, 3666, 3668, 1, 0, 0, 0, 3667, 3665, 1, 0, 0, 0, 3668, 3669,
		5, 3, 0, 0, 3669, 3730, 1, 0, 0, 0, 3670, 3672, 3, 340, 170, 0, 3671, 3670,
		1, 0, 0, 0, 3671, 3672, 1, 0, 0, 0, 3672, 3673, 1, 0, 0, 0, 3673, 3674,
		5, 163, 0, 0, 3674, 3675, 5, 2, 0, 0, 3675, 3676, 3, 102, 51, 0, 3676,
		3677, 5, 3, 0, 0, 3677, 3730, 1, 0, 0, 0, 3678, 3680, 3, 340, 170, 0, 3679,
		3678, 1, 0, 0, 0, 3679, 3680, 1, 0, 0, 0, 3680, 3681, 1, 0, 0, 0, 3681,
		3682, 5, 291, 0, 0, 3682, 3730, 3, 342, 171, 0, 3683, 3685, 3, 340, 170,
		0, 3684, 3683, 1, 0, 0, 0, 3684, 3685, 1, 0, 0, 0, 3685, 3686, 1, 0, 0,
		0, 3686, 3687, 7, 28, 0, 0, 3687, 3701, 7, 29, 0, 0, 3688, 3689, 5, 2,
		0, 0, 3689, 3702, 5, 3, 0, 0, 3690, 3691, 5, 2, 0, 0, 3691, 3696, 3, 328,
		164, 0, 3692, 3693, 5, 4, 0, 0, 3693, 3695, 3, 328, 164, 0, 3694, 3692,
		1, 0, 0, 0, 3695, 3698, 1, 0, 0, 0, 3696, 3694, 1, 0, 0, 0, 3696, 3697,
		1, 0, 0, 0, 3697, 3699, 1, 0, 0, 0, 3698, 3696, 1, 0, 0, 0, 3699, 3700,
		5, 3, 0, 0, 3700, 3702, 1, 0, 0, 0, 3701, 3688, 1, 0, 0, 0, 3701, 3690,
		1, 0, 0, 0, 3702, 3730, 1, 0, 0, 0, 3703, 3705, 3, 340, 170, 0, 3704, 3703,
		1, 0, 0, 0, 3704, 3705, 1, 0, 0, 0, 3705, 3706, 1, 0, 0, 0, 3706, 3707,
		7, 28, 0, 0, 3707, 3710, 3, 342, 171, 0, 3708, 3709, 5, 115, 0, 0, 3709,
		3711, 3, 514, 257, 0, 3710, 3708, 1, 0, 0, 0, 3710, 3711, 1, 0, 0, 0, 3711,
		3730, 1, 0, 0, 0, 3712, 3714, 5, 179, 0, 0, 3713, 3715, 3, 340, 170, 0,
		3714, 3713, 1, 0, 0, 0, 3714, 3715, 1, 0, 0, 0, 3715, 3716, 1, 0, 0, 0,
		3716, 3730, 5, 232, 0, 0, 3717, 3719, 5, 179, 0, 0, 3718, 3720, 3, 340,
		170, 0, 3719, 3718, 1, 0, 0, 0, 3719, 3720, 1, 0, 0, 0, 3720, 3721, 1,
		0, 0, 0, 3721, 3730, 7, 30, 0, 0, 3722, 3724, 5, 179, 0, 0, 3723, 3725,
		3, 340, 170, 0, 3724, 3723, 1, 0, 0, 0, 3724, 3725, 1, 0, 0, 0, 3725, 3726,
		1, 0, 0, 0, 3726, 3727, 5, 105, 0, 0, 3727, 3728, 5, 143, 0, 0, 3728, 3730,
		3, 342, 171, 0, 3729, 3648, 1, 0, 0, 0, 3729, 3656, 1, 0, 0, 0, 3729, 3671,
		1, 0, 0, 0, 3729, 3679, 1, 0, 0, 0, 3729, 3684, 1, 0, 0, 0, 3729, 3704,
		1, 0, 0, 0, 3729, 3712, 1, 0, 0, 0, 3729, 3717, 1, 0, 0, 0, 3729, 3722,
		1, 0, 0, 0, 3730, 339, 1, 0, 0, 0, 3731, 3732, 7, 27, 0, 0, 3732, 341,
		1, 0, 0, 0, 3733, 3734, 6, 171, -1, 0, 3734, 3738, 3, 348, 174, 0, 3735,
		3736, 7, 31, 0, 0, 3736, 3738, 3, 342, 171, 8, 3737, 3733, 1, 0, 0, 0,
		3737, 3735, 1, 0, 0, 0, 3738, 3764, 1, 0, 0, 0, 3739, 3740, 10, 7, 0, 0,
		3740, 3741, 7, 32, 0, 0, 3741, 3763, 3, 342, 171, 8, 3742, 3743, 10, 6,
		0, 0, 3743, 3744, 7, 33, 0, 0, 3744, 3763, 3, 342, 171, 7, 3745, 3746,
		10, 5, 0, 0, 3746, 3747, 3, 344, 172, 0, 3747, 3748, 3, 342, 171, 6, 3748,
		3763, 1, 0, 0, 0, 3749, 3750, 10, 4, 0, 0, 3750, 3751, 5, 419, 0, 0, 3751,
		3763, 3, 342, 171, 5, 3752, 3753, 10, 3, 0, 0, 3753, 3754, 5, 423, 0, 0,
		3754, 3763, 3, 342, 171, 4, 3755, 3756, 10, 2, 0, 0, 3756, 3757, 5, 420,
		0, 0, 3757, 3763, 3, 342, 171, 3, 3758, 3759, 10, 1, 0, 0, 3759, 3760,
		3, 364, 182, 0, 3760, 3761, 3, 342, 171, 2, 3761, 3763, 1, 0, 0, 0, 3762,
		3739, 1, 0, 0, 0, 3762, 3742, 1, 0, 0, 0, 3762, 3745, 1, 0, 0, 0, 3762,
		3749, 1, 0, 0, 0, 3762, 3752, 1, 0, 0, 0, 3762, 3755, 1, 0, 0, 0, 3762,
		3758, 1, 0, 0, 0, 3763, 3766, 1, 0, 0, 0, 3764, 3762, 1, 0, 0, 0, 3764,
		3765, 1, 0, 0, 0, 3765, 343, 1, 0, 0, 0, 3766, 3764, 1, 0, 0, 0, 3767,
		3768, 7, 34, 0, 0, 3768, 345, 1, 0, 0, 0, 3769, 3770, 7, 35, 0, 0, 3770,
		347, 1, 0, 0, 0, 3771, 3772, 6, 174, -1, 0, 3772, 4015, 7, 36, 0, 0, 3773,
		3774, 7, 37, 0, 0, 3774, 3777, 5, 2, 0, 0, 3775, 3778, 3, 346, 173, 0,
		3776, 3778, 3, 514, 257, 0, 3777, 3775, 1, 0, 0, 0, 3777, 3776, 1, 0, 0,
		0, 3778, 3779, 1, 0, 0, 0, 3779, 3780, 5, 4, 0, 0, 3780, 3781, 3, 342,
		171, 0, 3781, 3782, 5, 4, 0, 0, 3782, 3783, 3, 342, 171, 0, 3783, 3784,
		5, 3, 0, 0, 3784, 4015, 1, 0, 0, 0, 3785, 3786, 7, 38, 0, 0, 3786, 3789,
		5, 2, 0, 0, 3787, 3790, 3, 346, 173, 0, 3788, 3790, 3, 514, 257, 0, 3789,
		3787, 1, 0, 0, 0, 3789, 3788, 1, 0, 0, 0, 3790, 3791, 1, 0, 0, 0, 3791,
		3792, 5, 4, 0, 0, 3792, 3793, 3, 342, 171, 0, 3793, 3794, 5, 4, 0, 0, 3794,
		3795, 3, 342, 171, 0, 3795, 3796, 5, 3, 0, 0, 3796, 4015, 1, 0, 0, 0, 3797,
		3799, 5, 42, 0, 0, 3798, 3800, 3, 452, 226, 0, 3799, 3798, 1, 0, 0, 0,
		3800, 3801, 1, 0, 0, 0, 3801, 3799, 1, 0, 0, 0, 3801, 3802, 1, 0, 0, 0,
		3802, 3805, 1, 0, 0, 0, 3803, 3804, 5, 111, 0, 0, 3804, 3806, 3, 328, 164,
		0, 3805, 3803, 1, 0, 0, 0, 3805, 3806, 1, 0, 0, 0, 3806, 3807, 1, 0, 0,
		0, 3807, 3808, 5, 113, 0, 0, 3808, 4015, 1, 0, 0, 0, 3809, 3810, 5, 42,
		0, 0, 3810, 3812, 3, 328, 164, 0, 3811, 3813, 3, 452, 226, 0, 3812, 3811,
		1, 0, 0, 0, 3813, 3814, 1, 0, 0, 0, 3814, 3812, 1, 0, 0, 0, 3814, 3815,
		1, 0, 0, 0, 3815, 3818, 1, 0, 0, 0, 3816, 3817, 5, 111, 0, 0, 3817, 3819,
		3, 328, 164, 0, 3818, 3816, 1, 0, 0, 0, 3818, 3819, 1, 0, 0, 0, 3819, 3820,
		1, 0, 0, 0, 3820, 3821, 5, 113, 0, 0, 3821, 4015, 1, 0, 0, 0, 3822, 3823,
		7, 39, 0, 0, 3823, 3824, 5, 2, 0, 0, 3824, 3825, 3, 328, 164, 0, 3825,
		3826, 5, 22, 0, 0, 3826, 3827, 3, 400, 200, 0, 3827, 3828, 5, 3, 0, 0,
		3828, 4015, 1, 0, 0, 0, 3829, 3830, 5, 332, 0, 0, 3830, 3839, 5, 2, 0,
		0, 3831, 3836, 3, 316, 158, 0, 3832, 3833, 5, 4, 0, 0, 3833, 3835, 3, 316,
		158, 0, 3834, 3832, 1, 0, 0, 0, 3835, 3838, 1, 0, 0, 0, 3836, 3834, 1,
		0, 0, 0, 3836, 3837, 1, 0, 0, 0, 3837, 3840, 1, 0, 0, 0, 3838, 3836, 1,
		0, 0, 0, 3839, 3831, 1, 0, 0, 0, 3839, 3840, 1, 0, 0, 0, 3840, 3841, 1,
		0, 0, 0, 3841, 4015, 5, 3, 0, 0, 3842, 3843, 5, 134, 0, 0, 3843, 3844,
		5, 2, 0, 0, 3844, 3847, 3, 328, 164, 0, 3845, 3846, 5, 160, 0, 0, 3846,
		3848, 5, 233, 0, 0, 3847, 3845, 1, 0, 0, 0, 3847, 3848, 1, 0, 0, 0, 3848,
		3849, 1, 0, 0, 0, 3849, 3850, 5, 3, 0, 0, 3850, 4015, 1, 0, 0, 0, 3851,
		3852, 5, 19, 0, 0, 3852, 3853, 5, 2, 0, 0, 3853, 3856, 3, 328, 164, 0,
		3854, 3855, 5, 160, 0, 0, 3855, 3857, 5, 233, 0, 0, 3856, 3854, 1, 0, 0,
		0, 3856, 3857, 1, 0, 0, 0, 3857, 3858, 1, 0, 0, 0, 3858, 3859, 5, 3, 0,
		0, 3859, 4015, 1, 0, 0, 0, 3860, 3861, 5, 187, 0, 0, 3861, 3862, 5, 2,
		0, 0, 3862, 3865, 3, 328, 164, 0, 3863, 3864, 5, 160, 0, 0, 3864, 3866,
		5, 233, 0, 0, 3865, 3863, 1, 0, 0, 0, 3865, 3866, 1, 0, 0, 0, 3866, 3867,
		1, 0, 0, 0, 3867, 3868, 5, 3, 0, 0, 3868, 4015, 1, 0, 0, 0, 3869, 3870,
		5, 257, 0, 0, 3870, 3871, 5, 2, 0, 0, 3871, 3872, 3, 342, 171, 0, 3872,
		3873, 5, 163, 0, 0, 3873, 3874, 3, 342, 171, 0, 3874, 3875, 5, 3, 0, 0,
		3875, 4015, 1, 0, 0, 0, 3876, 4015, 3, 362, 181, 0, 3877, 3879, 5, 415,
		0, 0, 3878, 3880, 3, 196, 98, 0, 3879, 3878, 1, 0, 0, 0, 3879, 3880, 1,
		0, 0, 0, 3880, 4015, 1, 0, 0, 0, 3881, 3882, 3, 468, 234, 0, 3882, 3883,
		5, 5, 0, 0, 3883, 3885, 5, 415, 0, 0, 3884, 3886, 3, 196, 98, 0, 3885,
		3884, 1, 0, 0, 0, 3885, 3886, 1, 0, 0, 0, 3886, 4015, 1, 0, 0, 0, 3887,
		3888, 5, 2, 0, 0, 3888, 3891, 3, 316, 158, 0, 3889, 3890, 5, 4, 0, 0, 3890,
		3892, 3, 316, 158, 0, 3891, 3889, 1, 0, 0, 0, 3892, 3893, 1, 0, 0, 0, 3893,
		3891, 1, 0, 0, 0, 3893, 3894, 1, 0, 0, 0, 3894, 3895, 1, 0, 0, 0, 3895,
		3896, 5, 3, 0, 0, 3896, 4015, 1, 0, 0, 0, 3897, 3898, 5, 2, 0, 0, 3898,
		3899, 3, 102, 51, 0, 3899, 3900, 5, 3, 0, 0, 3900, 4015, 1, 0, 0, 0, 3901,
		3902, 3, 466, 233, 0, 3902, 3914, 5, 2, 0, 0, 3903, 3905, 3, 254, 127,
		0, 3904, 3903, 1, 0, 0, 0, 3904, 3905, 1, 0, 0, 0, 3905, 3906, 1, 0, 0,
		0, 3906, 3911, 3, 332, 166, 0, 3907, 3908, 5, 4, 0, 0, 3908, 3910, 3, 332,
		166, 0, 3909, 3907, 1, 0, 0, 0, 3910, 3913, 1, 0, 0, 0, 3911, 3909, 1,
		0, 0, 0, 3911, 3912, 1, 0, 0, 0, 3912, 3915, 1, 0, 0, 0, 3913, 3911, 1,
		0, 0, 0, 3914, 3904, 1, 0, 0, 0, 3914, 3915, 1, 0, 0, 0, 3915, 3916, 1,
		0, 0, 0, 3916, 3932, 5, 3, 0, 0, 3917, 3918, 5, 397, 0, 0, 3918, 3919,
		5, 150, 0, 0, 3919, 3920, 5, 2, 0, 0, 3920, 3921, 5, 243, 0, 0, 3921, 3922,
		5, 36, 0, 0, 3922, 3927, 3, 170, 85, 0, 3923, 3924, 5, 4, 0, 0, 3924, 3926,
		3, 170, 85, 0, 3925, 3923, 1, 0, 0, 0, 3926, 3929, 1, 0, 0, 0, 3927, 3925,
		1, 0, 0, 0, 3927, 3928, 1, 0, 0, 0, 3928, 3930, 1, 0, 0, 0, 3929, 3927,
		1, 0, 0, 0, 3930, 3931, 5, 3, 0, 0, 3931, 3933, 1, 0, 0, 0, 3932, 3917,
		1, 0, 0, 0, 3932, 3933, 1, 0, 0, 0, 3933, 3940, 1, 0, 0, 0, 3934, 3935,
		5, 132, 0, 0, 3935, 3936, 5, 2, 0, 0, 3936, 3937, 5, 393, 0, 0, 3937, 3938,
		3, 336, 168, 0, 3938, 3939, 5, 3, 0, 0, 3939, 3941, 1, 0, 0, 0, 3940, 3934,
		1, 0, 0, 0, 3940, 3941, 1, 0, 0, 0, 3941, 3944, 1, 0, 0, 0, 3942, 3943,
		7, 40, 0, 0, 3943, 3945, 5, 233, 0, 0, 3944, 3942, 1, 0, 0, 0, 3944, 3945,
		1, 0, 0, 0, 3945, 3948, 1, 0, 0, 0, 3946, 3947, 5, 247, 0, 0, 3947, 3949,
		3, 458, 229, 0, 3948, 3946, 1, 0, 0, 0, 3948, 3949, 1, 0, 0, 0, 3949, 4015,
		1, 0, 0, 0, 3950, 3951, 3, 474, 237, 0, 3951, 3952, 5, 426, 0, 0, 3952,
		3953, 3, 328, 164, 0, 3953, 4015, 1, 0, 0, 0, 3954, 3955, 5, 2, 0, 0, 3955,
		3958, 3, 474, 237, 0, 3956, 3957, 5, 4, 0, 0, 3957, 3959, 3, 474, 237,
		0, 3958, 3956, 1, 0, 0, 0, 3959, 3960, 1, 0, 0, 0, 3960, 3958, 1, 0, 0,
		0, 3960, 3961, 1, 0, 0, 0, 3961, 3962, 1, 0, 0, 0, 3962, 3963, 5, 3, 0,
		0, 3963, 3964, 5, 426, 0, 0, 3964, 3965, 3, 328, 164, 0, 3965, 4015, 1,
		0, 0, 0, 3966, 4015, 3, 474, 237, 0, 3967, 3968, 5, 2, 0, 0, 3968, 3969,
		3, 328, 164, 0, 3969, 3970, 5, 3, 0, 0, 3970, 4015, 1, 0, 0, 0, 3971, 3972,
		5, 128, 0, 0, 3972, 3973, 5, 2, 0, 0, 3973, 3974, 3, 474, 237, 0, 3974,
		3975, 5, 143, 0, 0, 3975, 3976, 3, 342, 171, 0, 3976, 3977, 5, 3, 0, 0,
		3977, 4015, 1, 0, 0, 0, 3978, 3979, 7, 41, 0, 0, 3979, 3980, 5, 2, 0, 0,
		3980, 3981, 3, 342, 171, 0, 3981, 3982, 7, 42, 0, 0, 3982, 3985, 3, 342,
		171, 0, 3983, 3984, 7, 43, 0, 0, 3984, 3986, 3, 342, 171, 0, 3985, 3983,
		1, 0, 0, 0, 3985, 3986, 1, 0, 0, 0, 3986, 3987, 1, 0, 0, 0, 3987, 3988,
		5, 3, 0, 0, 3988, 4015, 1, 0, 0, 0, 3989, 3990, 5, 361, 0, 0, 3990, 3992,
		5, 2, 0, 0, 3991, 3993, 7, 44, 0, 0, 3992, 3991, 1, 0, 0, 0, 3992, 3993,
		1, 0, 0, 0, 3993, 3995, 1, 0, 0, 0, 3994, 3996, 3, 342, 171, 0, 3995, 3994,
		1, 0, 0, 0, 3995, 3996, 1, 0, 0, 0, 3996, 3997, 1, 0, 0, 0, 3997, 3998,
		5, 143, 0, 0, 3998, 3999, 3, 342, 171, 0, 3999, 4000, 5, 3, 0, 0, 4000,
		4015, 1, 0, 0, 0, 4001, 4002, 5, 249, 0, 0, 4002, 4003, 5, 2, 0, 0, 4003,
		4004, 3, 342, 171, 0, 4004, 4005, 5, 256, 0, 0, 4005, 4006, 3, 342, 171,
		0, 4006, 4007, 5, 143, 0, 0, 4007, 4010, 3, 342, 171, 0, 4008, 4009, 5,
		138, 0, 0, 4009, 4011, 3, 342, 171, 0, 4010, 4008, 1, 0, 0, 0, 4010, 4011,
		1, 0, 0, 0, 4011, 4012, 1, 0, 0, 0, 4012, 4013, 5, 3, 0, 0, 4013, 4015,
		1, 0, 0, 0, 4014, 3771, 1, 0, 0, 0, 4014, 3773, 1, 0, 0, 0, 4014, 3785,
		1, 0, 0, 0, 4014, 3797, 1, 0, 0, 0, 4014, 3809, 1, 0, 0, 0, 4014, 3822,
		1, 0, 0, 0, 4014, 3829, 1, 0, 0, 0, 4014, 3842, 1, 0, 0, 0, 4014, 3851,
		1, 0, 0, 0, 4014, 3860, 1, 0, 0, 0, 4014, 3869, 1, 0, 0, 0, 4014, 3876,
		1, 0, 0, 0, 4014, 3877, 1, 0, 0, 0, 4014, 3881, 1, 0, 0, 0, 4014, 3887,
		1, 0, 0, 0, 4014, 3897, 1, 0, 0, 0, 4014, 3901, 1, 0, 0, 0, 4014, 3950,
		1, 0, 0, 0, 4014, 3954, 1, 0, 0, 0, 4014, 3966, 1, 0, 0, 0, 4014, 3967,
		1, 0, 0, 0, 4014, 3971, 1, 0, 0, 0, 4014, 3978, 1, 0, 0, 0, 4014, 3989,
		1, 0, 0, 0, 4014, 4001, 1, 0, 0, 0, 4015, 4034, 1, 0, 0, 0, 4016, 4017,
		10, 24, 0, 0, 4017, 4033, 3, 392, 196, 0, 4018, 4019, 10, 23, 0, 0, 4019,
		4020, 5, 425, 0, 0, 4020, 4033, 3, 400, 200, 0, 4021, 4022, 10, 14, 0,
		0, 4022, 4023, 5, 424, 0, 0, 4023, 4033, 3, 350, 175, 0, 4024, 4025, 10,
		8, 0, 0, 4025, 4026, 5, 6, 0, 0, 4026, 4027, 3, 342, 171, 0, 4027, 4028,
		5, 7, 0, 0, 4028, 4033, 1, 0, 0, 0, 4029, 4030, 10, 6, 0, 0, 4030, 4031,
		5, 5, 0, 0, 4031, 4033, 3, 474, 237, 0, 4032, 4016, 1, 0, 0, 0, 4032, 4018,
		1, 0, 0, 0, 4032, 4021, 1, 0, 0, 0, 4032, 4024, 1, 0, 0, 0, 4032, 4029,
		1, 0, 0, 0, 4033, 4036, 1, 0, 0, 0, 4034, 4032, 1, 0, 0, 0, 4034, 4035,
		1, 0, 0, 0, 4035, 349, 1, 0, 0, 0, 4036, 4034, 1, 0, 0, 0, 4037, 4041,
		3, 356, 178, 0, 4038, 4040, 3, 358, 179, 0, 4039, 4038, 1, 0, 0, 0, 4040,
		4043, 1, 0, 0, 0, 4041, 4039, 1, 0, 0, 0, 4041, 4042, 1, 0, 0, 0, 4042,
		351, 1, 0, 0, 0, 4043, 4041, 1, 0, 0, 0, 4044, 4047, 3, 474, 237, 0, 4045,
		4047, 5, 443, 0, 0, 4046, 4044, 1, 0, 0, 0, 4046, 4045, 1, 0, 0, 0, 4047,
		353, 1, 0, 0, 0, 4048, 4049, 5, 6, 0, 0, 4049, 4050, 3, 514, 257, 0, 4050,
		4051, 5, 7, 0, 0, 4051, 355, 1, 0, 0, 0, 4052, 4058, 3, 352, 176, 0, 4053,
		4058, 3, 354, 177, 0, 4054, 4055, 5, 6, 0, 0, 4055, 4056, 5, 436, 0, 0,
		4056, 4058, 5, 7, 0, 0, 4057, 4052, 1, 0, 0, 0, 4057, 4053, 1, 0, 0, 0,
		4057, 4054, 1, 0, 0, 0, 4058, 357, 1, 0, 0, 0, 4059, 4060, 5, 5, 0, 0,
		4060, 4070, 3, 352, 176, 0, 4061, 4070, 3, 354, 177, 0, 4062, 4063, 5,
		6, 0, 0, 4063, 4064, 5, 436, 0, 0, 4064, 4070, 5, 7, 0, 0, 4065, 4066,
		5, 6, 0, 0, 4066, 4067, 3, 474, 237, 0, 4067, 4068, 5, 7, 0, 0, 4068, 4070,
		1, 0, 0, 0, 4069, 4059, 1, 0, 0, 0, 4069, 4061, 1, 0, 0, 0, 4069, 4062,
		1, 0, 0, 0, 4069, 4065, 1, 0, 0, 0, 4070, 359, 1, 0, 0, 0, 4071, 4080,
		5, 83, 0, 0, 4072, 4080, 5, 346, 0, 0, 4073, 4080, 5, 348, 0, 0, 4074,
		4080, 5, 349, 0, 0, 4075, 4080, 5, 350, 0, 0, 4076, 4080, 5, 174, 0, 0,
		4077, 4080, 5, 154, 0, 0, 4078, 4080, 3, 474, 237, 0, 4079, 4071, 1, 0,
		0, 0, 4079, 4072, 1, 0, 0, 0, 4079, 4073, 1, 0, 0, 0, 4079, 4074, 1, 0,
		0, 0, 4079, 4075, 1, 0, 0, 0, 4079, 4076, 1, 0, 0, 0, 4079, 4077, 1, 0,
		0, 0, 4079, 4078, 1, 0, 0, 0, 4080, 361, 1, 0, 0, 0, 4081, 4097, 5, 232,
		0, 0, 4082, 4097, 5, 430, 0, 0, 4083, 4084, 5, 424, 0, 0, 4084, 4097, 3,
		474, 237, 0, 4085, 4097, 3, 372, 186, 0, 4086, 4087, 3, 360, 180, 0, 4087,
		4088, 3, 514, 257, 0, 4088, 4097, 1, 0, 0, 0, 4089, 4097, 3, 482, 241,
		0, 4090, 4097, 3, 370, 185, 0, 4091, 4093, 3, 514, 257, 0, 4092, 4091,
		1, 0, 0, 0, 4093, 4094, 1, 0, 0, 0, 4094, 4092, 1, 0, 0, 0, 4094, 4095,
		1, 0, 0, 0, 4095, 4097, 1, 0, 0, 0, 4096, 4081, 1, 0, 0, 0, 4096, 4082,
		1, 0, 0, 0, 4096, 4083, 1, 0, 0, 0, 4096, 4085, 1, 0, 0, 0, 4096, 4086,
		1, 0, 0, 0, 4096, 4089, 1, 0, 0, 0, 4096, 4090, 1, 0, 0, 0, 4096, 4092,
		1, 0, 0, 0, 4097, 363, 1, 0, 0, 0, 4098, 4099, 7, 45, 0, 0, 4099, 365,
		1, 0, 0, 0, 4100, 4101, 7, 46, 0, 0, 4101, 367, 1, 0, 0, 0, 4102, 4103,
		7, 47, 0, 0, 4103, 369, 1, 0, 0, 0, 4104, 4105, 7, 48, 0, 0, 4105, 371,
		1, 0, 0, 0, 4106, 4109, 5, 174, 0, 0, 4107, 4110, 3, 374, 187, 0, 4108,
		4110, 3, 378, 189, 0, 4109, 4107, 1, 0, 0, 0, 4109, 4108, 1, 0, 0, 0, 4110,
		373, 1, 0, 0, 0, 4111, 4113, 3, 376, 188, 0, 4112, 4114, 3, 380, 190, 0,
		4113, 4112, 1, 0, 0, 0, 4113, 4114, 1, 0, 0, 0, 4114, 375, 1, 0, 0, 0,
		4115, 4116, 3, 382, 191, 0, 4116, 4117, 3, 384, 192, 0, 4117, 4119, 1,
		0, 0, 0, 4118, 4115, 1, 0, 0, 0, 4119, 4120, 1, 0, 0, 0, 4120, 4118, 1,
		0, 0, 0, 4120, 4121, 1, 0, 0, 0, 4121, 377, 1, 0, 0, 0, 4122, 4125, 3,
		380, 190, 0, 4123, 4126, 3, 376, 188, 0, 4124, 4126, 3, 380, 190, 0, 4125,
		4123, 1, 0, 0, 0, 4125, 4124, 1, 0, 0, 0, 4125, 4126, 1, 0, 0, 0, 4126,
		379, 1, 0, 0, 0, 4127, 4128, 3, 382, 191, 0, 4128, 4129, 3, 386, 193, 0,
		4129, 4130, 5, 354, 0, 0, 4130, 4131, 3, 386, 193, 0, 4131, 381, 1, 0,
		0, 0, 4132, 4134, 7, 49, 0, 0, 4133, 4132, 1, 0, 0, 0, 4133, 4134, 1, 0,
		0, 0, 4134, 4138, 1, 0, 0, 0, 4135, 4139, 5, 436, 0, 0, 4136, 4139, 5,
		438, 0, 0, 4137, 4139, 3, 514, 257, 0, 4138, 4135, 1, 0, 0, 0, 4138, 4136,
		1, 0, 0, 0, 4138, 4137, 1, 0, 0, 0, 4139, 383, 1, 0, 0, 0, 4140, 4141,
		7, 50, 0, 0, 4141, 385, 1, 0, 0, 0, 4142, 4143, 7, 51, 0, 0, 4143, 387,
		1, 0, 0, 0, 4144, 4148, 5, 134, 0, 0, 4145, 4146, 5, 10, 0, 0, 4146, 4148,
		3, 470, 235, 0, 4147, 4144, 1, 0, 0, 0, 4147, 4145, 1, 0, 0, 0, 4148, 389,
		1, 0, 0, 0, 4149, 4150, 5, 94, 0, 0, 4150, 4151, 5, 55, 0, 0, 4151, 4152,
		3, 474, 237, 0, 4152, 391, 1, 0, 0, 0, 4153, 4154, 5, 54, 0, 0, 4154, 4155,
		3, 306, 153, 0, 4155, 393, 1, 0, 0, 0, 4156, 4158, 5, 331, 0, 0, 4157,
		4159, 3, 392, 196, 0, 4158, 4157, 1, 0, 0, 0, 4158, 4159, 1, 0, 0, 0, 4159,
		4213, 1, 0, 0, 0, 4160, 4164, 7, 52, 0, 0, 4161, 4162, 5, 2, 0, 0, 4162,
		4163, 5, 436, 0, 0, 4163, 4165, 5, 3, 0, 0, 4164, 4161, 1, 0, 0, 0, 4164,
		4165, 1, 0, 0, 0, 4165, 4213, 1, 0, 0, 0, 4166, 4170, 5, 382, 0, 0, 4167,
		4168, 5, 2, 0, 0, 4168, 4169, 5, 436, 0, 0, 4169, 4171, 5, 3, 0, 0, 4170,
		4167, 1, 0, 0, 0, 4170, 4171, 1, 0, 0, 0, 4171, 4213, 1, 0, 0, 0, 4172,
		4180, 7, 53, 0, 0, 4173, 4174, 5, 2, 0, 0, 4174, 4177, 5, 436, 0, 0, 4175,
		4176, 5, 4, 0, 0, 4176, 4178, 5, 436, 0, 0, 4177, 4175, 1, 0, 0, 0, 4177,
		4178, 1, 0, 0, 0, 4178, 4179, 1, 0, 0, 0, 4179, 4181, 5, 3, 0, 0, 4180,
		4173, 1, 0, 0, 0, 4180, 4181, 1, 0, 0, 0, 4181, 4213, 1, 0, 0, 0, 4182,
		4193, 5, 174, 0, 0, 4183, 4186, 7, 54, 0, 0, 4184, 4185, 5, 354, 0, 0,
		4185, 4187, 5, 220, 0, 0, 4186, 4184, 1, 0, 0, 0, 4186, 4187, 1, 0, 0,
		0, 4187, 4194, 1, 0, 0, 0, 4188, 4191, 7, 55, 0, 0, 4189, 4190, 5, 354,
		0, 0, 4190, 4192, 7, 56, 0, 0, 4191, 4189, 1, 0, 0, 0, 4191, 4192, 1, 0,
		0, 0, 4192, 4194, 1, 0, 0, 0, 4193, 4183, 1, 0, 0, 0, 4193, 4188, 1, 0,
		0, 0, 4193, 4194, 1, 0, 0, 0, 4194, 4213, 1, 0, 0, 0, 4195, 4199, 5, 348,
		0, 0, 4196, 4197, 5, 398, 0, 0, 4197, 4198, 5, 346, 0, 0, 4198, 4200, 5,
		401, 0, 0, 4199, 4196, 1, 0, 0, 0, 4199, 4200, 1, 0, 0, 0, 4200, 4213,
		1, 0, 0, 0, 4201, 4205, 5, 346, 0, 0, 4202, 4203, 5, 2, 0, 0, 4203, 4204,
		5, 436, 0, 0, 4204, 4206, 5, 3, 0, 0, 4205, 4202, 1, 0, 0, 0, 4205, 4206,
		1, 0, 0, 0, 4206, 4210, 1, 0, 0, 0, 4207, 4208, 5, 398, 0, 0, 4208, 4209,
		5, 346, 0, 0, 4209, 4211, 5, 401, 0, 0, 4210, 4207, 1, 0, 0, 0, 4210, 4211,
		1, 0, 0, 0, 4211, 4213, 1, 0, 0, 0, 4212, 4156, 1, 0, 0, 0, 4212, 4160,
		1, 0, 0, 0, 4212, 4166, 1, 0, 0, 0, 4212, 4172, 1, 0, 0, 0, 4212, 4182,
		1, 0, 0, 0, 4212, 4195, 1, 0, 0, 0, 4212, 4201, 1, 0, 0, 0, 4213, 395,
		1, 0, 0, 0, 4214, 4215, 7, 57, 0, 0, 4215, 397, 1, 0, 0, 0, 4216, 4232,
		3, 394, 197, 0, 4217, 4232, 3, 396, 198, 0, 4218, 4229, 3, 474, 237, 0,
		4219, 4220, 5, 2, 0, 0, 4220, 4225, 5, 436, 0, 0, 4221, 4222, 5, 4, 0,
		0, 4222, 4224, 5, 436, 0, 0, 4223, 4221, 1, 0, 0, 0, 4224, 4227, 1, 0,
		0, 0, 4225, 4223, 1, 0, 0, 0, 4225, 4226, 1, 0, 0, 0, 4226, 4228, 1, 0,
		0, 0, 4227, 4225, 1, 0, 0, 0, 4228, 4230, 5, 3, 0, 0, 4229, 4219, 1, 0,
		0, 0, 4229, 4230, 1, 0, 0, 0, 4230, 4232, 1, 0, 0, 0, 4231, 4216, 1, 0,
		0, 0, 4231, 4217, 1, 0, 0, 0, 4231, 4218, 1, 0, 0, 0, 4232, 399, 1, 0,
		0, 0, 4233, 4238, 5, 21, 0, 0, 4234, 4235, 5, 406, 0, 0, 4235, 4236, 3,
		400, 200, 0, 4236, 4237, 5, 408, 0, 0, 4237, 4239, 1, 0, 0, 0, 4238, 4234,
		1, 0, 0, 0, 4238, 4239, 1, 0, 0, 0, 4239, 4260, 1, 0, 0, 0, 4240, 4247,
		5, 208, 0, 0, 4241, 4242, 5, 406, 0, 0, 4242, 4243, 3, 400, 200, 0, 4243,
		4244, 5, 4, 0, 0, 4244, 4245, 3, 400, 200, 0, 4245, 4246, 5, 408, 0, 0,
		4246, 4248, 1, 0, 0, 0, 4247, 4241, 1, 0, 0, 0, 4247, 4248, 1, 0, 0, 0,
		4248, 4260, 1, 0, 0, 0, 4249, 4256, 5, 332, 0, 0, 4250, 4252, 5, 406, 0,
		0, 4251, 4253, 3, 434, 217, 0, 4252, 4251, 1, 0, 0, 0, 4252, 4253, 1, 0,
		0, 0, 4253, 4254, 1, 0, 0, 0, 4254, 4257, 5, 408, 0, 0, 4255, 4257, 5,
		404, 0, 0, 4256, 4250, 1, 0, 0, 0, 4256, 4255, 1, 0, 0, 0, 4256, 4257,
		1, 0, 0, 0, 4257, 4260, 1, 0, 0, 0, 4258, 4260, 3, 398, 199, 0, 4259, 4233,
		1, 0, 0, 0, 4259, 4240, 1, 0, 0, 0, 4259, 4249, 1, 0, 0, 0, 4259, 4258,
		1, 0, 0, 0, 4260, 401, 1, 0, 0, 0, 4261, 4266, 3, 404, 202, 0, 4262, 4263,
		5, 4, 0, 0, 4263, 4265, 3, 404, 202, 0, 4264, 4262, 1, 0, 0, 0, 4265, 4268,
		1, 0, 0, 0, 4266, 4264, 1, 0, 0, 0, 4266, 4267, 1, 0, 0, 0, 4267, 403,
		1, 0, 0, 0, 4268, 4266, 1, 0, 0, 0, 4269, 4270, 3, 306, 153, 0, 4270, 4274,
		3, 400, 200, 0, 4271, 4273, 3, 406, 203, 0, 4272, 4271, 1, 0, 0, 0, 4273,
		4276, 1, 0, 0, 0, 4274, 4272, 1, 0, 0, 0, 4274, 4275, 1, 0, 0, 0, 4275,
		405, 1, 0, 0, 0, 4276, 4274, 1, 0, 0, 0, 4277, 4278, 3, 340, 170, 0, 4278,
		4279, 5, 232, 0, 0, 4279, 4284, 1, 0, 0, 0, 4280, 4284, 3, 408, 204, 0,
		4281, 4284, 3, 98, 49, 0, 4282, 4284, 3, 388, 194, 0, 4283, 4277, 1, 0,
		0, 0, 4283, 4280, 1, 0, 0, 0, 4283, 4281, 1, 0, 0, 0, 4283, 4282, 1, 0,
		0, 0, 4284, 407, 1, 0, 0, 0, 4285, 4286, 5, 94, 0, 0, 4286, 4287, 3, 328,
		164, 0, 4287, 409, 1, 0, 0, 0, 4288, 4289, 7, 58, 0, 0, 4289, 4290, 3,
		328, 164, 0, 4290, 411, 1, 0, 0, 0, 4291, 4296, 3, 414, 207, 0, 4292, 4293,
		5, 4, 0, 0, 4293, 4295, 3, 414, 207, 0, 4294, 4292, 1, 0, 0, 0, 4295, 4298,
		1, 0, 0, 0, 4296, 4294, 1, 0, 0, 0, 4296, 4297, 1, 0, 0, 0, 4297, 413,
		1, 0, 0, 0, 4298, 4296, 1, 0, 0, 0, 4299, 4300, 3, 470, 235, 0, 4300, 4304,
		3, 400, 200, 0, 4301, 4302, 3, 340, 170, 0, 4302, 4303, 5, 232, 0, 0, 4303,
		4305, 1, 0, 0, 0, 4304, 4301, 1, 0, 0, 0, 4304, 4305, 1, 0, 0, 0, 4305,
		4307, 1, 0, 0, 0, 4306, 4308, 3, 98, 49, 0, 4307, 4306, 1, 0, 0, 0, 4307,
		4308, 1, 0, 0, 0, 4308, 415, 1, 0, 0, 0, 4309, 4314, 3, 418, 209, 0, 4310,
		4311, 5, 4, 0, 0, 4311, 4313, 3, 418, 209, 0, 4312, 4310, 1, 0, 0, 0, 4313,
		4316, 1, 0, 0, 0, 4314, 4312, 1, 0, 0, 0, 4314, 4315, 1, 0, 0, 0, 4315,
		417, 1, 0, 0, 0, 4316, 4314, 1, 0, 0, 0, 4317, 4320, 3, 488, 244, 0, 4318,
		4320, 3, 422, 211, 0, 4319, 4317, 1, 0, 0, 0, 4319, 4318, 1, 0, 0, 0, 4320,
		419, 1, 0, 0, 0, 4321, 4326, 3, 422, 211, 0, 4322, 4323, 5, 4, 0, 0, 4323,
		4325, 3, 422, 211, 0, 4324, 4322, 1, 0, 0, 0, 4325, 4328, 1, 0, 0, 0, 4326,
		4324, 1, 0, 0, 0, 4326, 4327, 1, 0, 0, 0, 4327, 421, 1, 0, 0, 0, 4328,
		4326, 1, 0, 0, 0, 4329, 4330, 3, 470, 235, 0, 4330, 4334, 3, 400, 200,
		0, 4331, 4333, 3, 424, 212, 0, 4332, 4331, 1, 0, 0, 0, 4333, 4336, 1, 0,
		0, 0, 4334, 4332, 1, 0, 0, 0, 4334, 4335, 1, 0, 0, 0, 4335, 423, 1, 0,
		0, 0, 4336, 4334, 1, 0, 0, 0, 4337, 4338, 3, 340, 170, 0, 4338, 4339, 5,
		232, 0, 0, 4339, 4345, 1, 0, 0, 0, 4340, 4345, 3, 408, 204, 0, 4341, 4345,
		3, 426, 213, 0, 4342, 4345, 3, 98, 49, 0, 4343, 4345, 3, 484, 242, 0, 4344,
		4337, 1, 0, 0, 0, 4344, 4340, 1, 0, 0, 0, 4344, 4341, 1, 0, 0, 0, 4344,
		4342, 1, 0, 0, 0, 4344, 4343, 1, 0, 0, 0, 4345, 425, 1, 0, 0, 0, 4346,
		4347, 5, 147, 0, 0, 4347, 4348, 5, 14, 0, 0, 4348, 4349, 5, 22, 0, 0, 4349,
		4350, 5, 2, 0, 0, 4350, 4351, 3, 328, 164, 0, 4351, 4352, 5, 3, 0, 0, 4352,
		4365, 1, 0, 0, 0, 4353, 4357, 5, 147, 0, 0, 4354, 4358, 5, 14, 0, 0, 4355,
		4356, 5, 36, 0, 0, 4356, 4358, 5, 94, 0, 0, 4357, 4354, 1, 0, 0, 0, 4357,
		4355, 1, 0, 0, 0, 4358, 4359, 1, 0, 0, 0, 4359, 4360, 5, 22, 0, 0, 4360,
		4362, 5, 158, 0, 0, 4361, 4363, 3, 428, 214, 0, 4362, 4361, 1, 0, 0, 0,
		4362, 4363, 1, 0, 0, 0, 4363, 4365, 1, 0, 0, 0, 4364, 4346, 1, 0, 0, 0,
		4364, 4353, 1, 0, 0, 0, 4365, 427, 1, 0, 0, 0, 4366, 4370, 5, 2, 0, 0,
		4367, 4369, 3, 430, 215, 0, 4368, 4367, 1, 0, 0, 0, 4369, 4372, 1, 0, 0,
		0, 4370, 4368, 1, 0, 0, 0, 4370, 4371, 1, 0, 0, 0, 4371, 4373, 1, 0, 0,
		0, 4372, 4370, 1, 0, 0, 0, 4373, 4374, 5, 3, 0, 0, 4374, 429, 1, 0, 0,
		0, 4375, 4376, 5, 325, 0, 0, 4376, 4377, 5, 396, 0, 0, 4377, 4382, 3, 432,
		216, 0, 4378, 4379, 5, 165, 0, 0, 4379, 4380, 5, 36, 0, 0, 4380, 4382,
		3, 432, 216, 0, 4381, 4375, 1, 0, 0, 0, 4381, 4378, 1, 0, 0, 0, 4382, 431,
		1, 0, 0, 0, 4383, 4385, 5, 414, 0, 0, 4384, 4383, 1, 0, 0, 0, 4384, 4385,
		1, 0, 0, 0, 4385, 4386, 1, 0, 0, 0, 4386, 4392, 5, 436, 0, 0, 4387, 4389,
		5, 414, 0, 0, 4388, 4387, 1, 0, 0, 0, 4388, 4389, 1, 0, 0, 0, 4389, 4390,
		1, 0, 0, 0, 4390, 4392, 5, 433, 0, 0, 4391, 4384, 1, 0, 0, 0, 4391, 4388,
		1, 0, 0, 0, 4392, 433, 1, 0, 0, 0, 4393, 4398, 3, 436, 218, 0, 4394, 4395,
		5, 4, 0, 0, 4395, 4397, 3, 436, 218, 0, 4396, 4394, 1, 0, 0, 0, 4397, 4400,
		1, 0, 0, 0, 4398, 4396, 1, 0, 0, 0, 4398, 4399, 1, 0, 0, 0, 4399, 435,
		1, 0, 0, 0, 4400, 4398, 1, 0, 0, 0, 4401, 4403, 3, 470, 235, 0, 4402, 4404,
		5, 424, 0, 0, 4403, 4402, 1, 0, 0, 0, 4403, 4404, 1, 0, 0, 0, 4404, 4405,
		1, 0, 0, 0, 4405, 4409, 3, 400, 200, 0, 4406, 4407, 3, 340, 170, 0, 4407,
		4408, 5, 232, 0, 0, 4408, 4410, 1, 0, 0, 0, 4409, 4406, 1, 0, 0, 0, 4409,
		4410, 1, 0, 0, 0, 4410, 4412, 1, 0, 0, 0, 4411, 4413, 3, 98, 49, 0, 4412,
		4411, 1, 0, 0, 0, 4412, 4413, 1, 0, 0, 0, 4413, 437, 1, 0, 0, 0, 4414,
		4422, 3, 440, 220, 0, 4415, 4422, 3, 442, 221, 0, 4416, 4422, 3, 444, 222,
		0, 4417, 4422, 3, 446, 223, 0, 4418, 4422, 3, 448, 224, 0, 4419, 4422,
		3, 98, 49, 0, 4420, 4422, 3, 450, 225, 0, 4421, 4414, 1, 0, 0, 0, 4421,
		4415, 1, 0, 0, 0, 4421, 4416, 1, 0, 0, 0, 4421, 4417, 1, 0, 0, 0, 4421,
		4418, 1, 0, 0, 0, 4421, 4419, 1, 0, 0, 0, 4421, 4420, 1, 0, 0, 0, 4422,
		4425, 1, 0, 0, 0, 4423, 4421, 1, 0, 0, 0, 4423, 4424, 1, 0, 0, 0, 4424,
		439, 1, 0, 0, 0, 4425, 4423, 1, 0, 0, 0, 4426, 4427, 5, 186, 0, 0, 4427,
		4428, 7, 59, 0, 0, 4428, 441, 1, 0, 0, 0, 4429, 4430, 5, 321, 0, 0, 4430,
		4431, 3, 470, 235, 0, 4431, 443, 1, 0, 0, 0, 4432, 4437, 5, 101, 0, 0,
		4433, 4434, 3, 340, 170, 0, 4434, 4435, 5, 101, 0, 0, 4435, 4437, 1, 0,
		0, 0, 4436, 4432, 1, 0, 0, 0, 4436, 4433, 1, 0, 0, 0, 4437, 445, 1, 0,
		0, 0, 4438, 4439, 5, 229, 0, 0, 4439, 4449, 5, 322, 0, 0, 4440, 4441, 5,
		68, 0, 0, 4441, 4449, 5, 322, 0, 0, 4442, 4443, 5, 268, 0, 0, 4443, 4444,
		5, 322, 0, 0, 4444, 4449, 5, 82, 0, 0, 4445, 4446, 5, 219, 0, 0, 4446,
		4447, 5, 322, 0, 0, 4447, 4449, 5, 82, 0, 0, 4448, 4438, 1, 0, 0, 0, 4448,
		4440, 1, 0, 0, 0, 4448, 4442, 1, 0, 0, 0, 4448, 4445, 1, 0, 0, 0, 4449,
		447, 1, 0, 0, 0, 4450, 4451, 5, 288, 0, 0, 4451, 4452, 5, 232, 0, 0, 4452,
		4453, 5, 238, 0, 0, 4453, 4454, 5, 232, 0, 0, 4454, 4460, 5, 170, 0, 0,
		4455, 4456, 5, 40, 0, 0, 4456, 4457, 5, 238, 0, 0, 4457, 4458, 5, 232,
		0, 0, 4458, 4460, 5, 170, 0, 0, 4459, 4450, 1, 0, 0, 0, 4459, 4455, 1,
		0, 0, 0, 4460, 449, 1, 0, 0, 0, 4461, 4462, 5, 322, 0, 0, 4462, 4463, 5,
		302, 0, 0, 4463, 4468, 5, 178, 0, 0, 4464, 4465, 5, 322, 0, 0, 4465, 4466,
		5, 302, 0, 0, 4466, 4468, 5, 96, 0, 0, 4467, 4461, 1, 0, 0, 0, 4467, 4464,
		1, 0, 0, 0, 4468, 451, 1, 0, 0, 0, 4469, 4470, 5, 392, 0, 0, 4470, 4471,
		3, 328, 164, 0, 4471, 4472, 5, 345, 0, 0, 4472, 4473, 3, 328, 164, 0, 4473,
		453, 1, 0, 0, 0, 4474, 4475, 5, 395, 0, 0, 4475, 4480, 3, 456, 228, 0,
		4476, 4477, 5, 4, 0, 0, 4477, 4479, 3, 456, 228, 0, 4478, 4476, 1, 0, 0,
		0, 4479, 4482, 1, 0, 0, 0, 4480, 4478, 1, 0, 0, 0, 4480, 4481, 1, 0, 0,
		0, 4481, 455, 1, 0, 0, 0, 4482, 4480, 1, 0, 0, 0, 4483, 4484, 3, 470, 235,
		0, 4484, 4485, 5, 22, 0, 0, 4485, 4486, 3, 458, 229, 0, 4486, 457, 1, 0,
		0, 0, 4487, 4534, 3, 470, 235, 0, 4488, 4489, 5, 2, 0, 0, 4489, 4490, 3,
		470, 235, 0, 4490, 4491, 5, 3, 0, 0, 4491, 4534, 1, 0, 0, 0, 4492, 4527,
		5, 2, 0, 0, 4493, 4494, 5, 51, 0, 0, 4494, 4495, 5, 36, 0, 0, 4495, 4500,
		3, 328, 164, 0, 4496, 4497, 5, 4, 0, 0, 4497, 4499, 3, 328, 164, 0, 4498,
		4496, 1, 0, 0, 0, 4499, 4502, 1, 0, 0, 0, 4500, 4498, 1, 0, 0, 0, 4500,
		4501, 1, 0, 0, 0, 4501, 4528, 1, 0, 0, 0, 4502, 4500, 1, 0, 0, 0, 4503,
		4504, 7, 25, 0, 0, 4504, 4505, 5, 36, 0, 0, 4505, 4510, 3, 328, 164, 0,
		4506, 4507, 5, 4, 0, 0, 4507, 4509, 3, 328, 164, 0, 4508, 4506, 1, 0, 0,
		0, 4509, 4512, 1, 0, 0, 0, 4510, 4508, 1, 0, 0, 0, 4510, 4511, 1, 0, 0,
		0, 4511, 4514, 1, 0, 0, 0, 4512, 4510, 1, 0, 0, 0, 4513, 4503, 1, 0, 0,
		0, 4513, 4514, 1, 0, 0, 0, 4514, 4525, 1, 0, 0, 0, 4515, 4516, 7, 26, 0,
		0, 4516, 4517, 5, 36, 0, 0, 4517, 4522, 3, 170, 85, 0, 4518, 4519, 5, 4,
		0, 0, 4519, 4521, 3, 170, 85, 0, 4520, 4518, 1, 0, 0, 0, 4521, 4524, 1,
		0, 0, 0, 4522, 4520, 1, 0, 0, 0, 4522, 4523, 1, 0, 0, 0, 4523, 4526, 1,
		0, 0, 0, 4524, 4522, 1, 0, 0, 0, 4525, 4515, 1, 0, 0, 0, 4525, 4526, 1,
		0, 0, 0, 4526, 4528, 1, 0, 0, 0, 4527, 4493, 1, 0, 0, 0, 4527, 4513, 1,
		0, 0, 0, 4528, 4530, 1, 0, 0, 0, 4529, 4531, 3, 460, 230, 0, 4530, 4529,
		1, 0, 0, 0, 4530, 4531, 1, 0, 0, 0, 4531, 4532, 1, 0, 0, 0, 4532, 4534,
		5, 3, 0, 0, 4533, 4487, 1, 0, 0, 0, 4533, 4488, 1, 0, 0, 0, 4533, 4492,
		1, 0, 0, 0, 4534, 459, 1, 0, 0, 0, 4535, 4536, 5, 267, 0, 0, 4536, 4552,
		3, 462, 231, 0, 4537, 4538, 5, 297, 0, 0, 4538, 4552, 3, 462, 231, 0, 4539,
		4540, 5, 267, 0, 0, 4540, 4541, 5, 28, 0, 0, 4541, 4542, 3, 462, 231, 0,
		4542, 4543, 5, 16, 0, 0, 4543, 4544, 3, 462, 231, 0, 4544, 4552, 1, 0,
		0, 0, 4545, 4546, 5, 297, 0, 0, 4546, 4547, 5, 28, 0, 0, 4547, 4548, 3,
		462, 231, 0, 4548, 4549, 5, 16, 0, 0, 4549, 4550, 3, 462, 231, 0, 4550,
		4552, 1, 0, 0, 0, 4551, 4535, 1, 0, 0, 0, 4551, 4537, 1, 0, 0, 0, 4551,
		4539, 1, 0, 0, 0, 4551, 4545, 1, 0, 0, 0, 4552, 461, 1, 0, 0, 0, 4553,
		4554, 5, 367, 0, 0, 4554, 4561, 7, 60, 0, 0, 4555, 4556, 5, 74, 0, 0, 4556,
		4561, 5, 296, 0, 0, 4557, 4558, 3, 328, 164, 0, 4558, 4559, 7, 60, 0, 0,
		4559, 4561, 1, 0, 0, 0, 4560, 4553, 1, 0, 0, 0, 4560, 4555, 1, 0, 0, 0,
		4560, 4557, 1, 0, 0, 0, 4561, 463, 1, 0, 0, 0, 4562, 4567, 3, 468, 234,
		0, 4563, 4564, 5, 4, 0, 0, 4564, 4566, 3, 468, 234, 0, 4565, 4563, 1, 0,
		0, 0, 4566, 4569, 1, 0, 0, 0, 4567, 4565, 1, 0, 0, 0, 4567, 4568, 1, 0,
		0, 0, 4568, 465, 1, 0, 0, 0, 4569, 4567, 1, 0, 0, 0, 4570, 4571, 5, 157,
		0, 0, 4571, 4572, 5, 2, 0, 0, 4572, 4573, 3, 328, 164, 0, 4573, 4574, 5,
		3, 0, 0, 4574, 4581, 1, 0, 0, 0, 4575, 4581, 5, 157, 0, 0, 4576, 4581,
		3, 468, 234, 0, 4577, 4581, 5, 132, 0, 0, 4578, 4581, 5, 192, 0, 0, 4579,
		4581, 5, 290, 0, 0, 4580, 4570, 1, 0, 0, 0, 4580, 4575, 1, 0, 0, 0, 4580,
		4576, 1, 0, 0, 0, 4580, 4577, 1, 0, 0, 0, 4580, 4578, 1, 0, 0, 0, 4580,
		4579, 1, 0, 0, 0, 4581, 467, 1, 0, 0, 0, 4582, 4587, 3, 474, 237, 0, 4583,
		4584, 5, 5, 0, 0, 4584, 4586, 3, 474, 237, 0, 4585, 4583, 1, 0, 0, 0, 4586,
		4589, 1, 0, 0, 0, 4587, 4585, 1, 0, 0, 0, 4587, 4588, 1, 0, 0, 0, 4588,
		469, 1, 0, 0, 0, 4589, 4587, 1, 0, 0, 0, 4590, 4591, 3, 474, 237, 0, 4591,
		4592, 3, 472, 236, 0, 4592, 471, 1, 0, 0, 0, 4593, 4594, 5, 414, 0, 0,
		4594, 4596, 3, 474, 237, 0, 4595, 4593, 1, 0, 0, 0, 4596, 4597, 1, 0, 0,
		0, 4597, 4595, 1, 0, 0, 0, 4597, 4598, 1, 0, 0, 0, 4598, 4601, 1, 0, 0,
		0, 4599, 4601, 1, 0, 0, 0, 4600, 4595, 1, 0, 0, 0, 4600, 4599, 1, 0, 0,
		0, 4601, 473, 1, 0, 0, 0, 4602, 4606, 3, 476, 238, 0, 4603, 4604, 4, 237,
		21, 0, 4604, 4606, 3, 526, 263, 0, 4605, 4602, 1, 0, 0, 0, 4605, 4603,
		1, 0, 0, 0, 4606, 475, 1, 0, 0, 0, 4607, 4614, 5, 442, 0, 0, 4608, 4614,
		3, 478, 239, 0, 4609, 4610, 4, 238, 22, 0, 4610, 4614, 3, 524, 262, 0,
		4611, 4612, 4, 238, 23, 0, 4612, 4614, 3, 528, 264, 0, 4613, 4607, 1, 0,
		0, 0, 4613, 4608, 1, 0, 0, 0, 4613, 4609, 1, 0, 0, 0, 4613, 4611, 1, 0,
		0, 0, 4614, 477, 1, 0, 0, 0, 4615, 4619, 5, 443, 0, 0, 4616, 4617, 4, 239,
		24, 0, 4617, 4619, 5, 432, 0, 0, 4618, 4615, 1, 0, 0, 0, 4618, 4616, 1,
		0, 0, 0, 4619, 479, 1, 0, 0, 0, 4620, 4621, 5, 443, 0, 0, 4621, 481, 1,
		0, 0, 0, 4622, 4624, 4, 241, 25, 0, 4623, 4625, 5, 414, 0, 0, 4624, 4623,
		1, 0, 0, 0, 4624, 4625, 1, 0, 0, 0, 4625, 4626, 1, 0, 0, 0, 4626, 4666,
		5, 437, 0, 0, 4627, 4629, 4, 241, 26, 0, 4628, 4630, 5, 414, 0, 0, 4629,
		4628, 1, 0, 0, 0, 4629, 4630, 1, 0, 0, 0, 4630, 4631, 1, 0, 0, 0, 4631,
		4666, 5, 438, 0, 0, 4632, 4634, 4, 241, 27, 0, 4633, 4635, 5, 414, 0, 0,
		4634, 4633, 1, 0, 0, 0, 4634, 4635, 1, 0, 0, 0, 4635, 4636, 1, 0, 0, 0,
		4636, 4666, 7, 61, 0, 0, 4637, 4639, 5, 414, 0, 0, 4638, 4637, 1, 0, 0,
		0, 4638, 4639, 1, 0, 0, 0, 4639, 4640, 1, 0, 0, 0, 4640, 4666, 5, 436,
		0, 0, 4641, 4643, 5, 414, 0, 0, 4642, 4641, 1, 0, 0, 0, 4642, 4643, 1,
		0, 0, 0, 4643, 4644, 1, 0, 0, 0, 4644, 4666, 5, 433, 0, 0, 4645, 4647,
		5, 414, 0, 0, 4646, 4645, 1, 0, 0, 0, 4646, 4647, 1, 0, 0, 0, 4647, 4648,
		1, 0, 0, 0, 4648, 4666, 5, 434, 0, 0, 4649, 4651, 5, 414, 0, 0, 4650, 4649,
		1, 0, 0, 0, 4650, 4651, 1, 0, 0, 0, 4651, 4652, 1, 0, 0, 0, 4652, 4666,
		5, 435, 0, 0, 4653, 4655, 5, 414, 0, 0, 4654, 4653, 1, 0, 0, 0, 4654, 4655,
		1, 0, 0, 0, 4655, 4656, 1, 0, 0, 0, 4656, 4666, 5, 440, 0, 0, 4657, 4659,
		5, 414, 0, 0, 4658, 4657, 1, 0, 0, 0, 4658, 4659, 1, 0, 0, 0, 4659, 4660,
		1, 0, 0, 0, 4660, 4666, 5, 439, 0, 0, 4661, 4663, 5, 414, 0, 0, 4662, 4661,
		1, 0, 0, 0, 4662, 4663, 1, 0, 0, 0, 4663, 4664, 1, 0, 0, 0, 4664, 4666,
		5, 441, 0, 0, 4665, 4622, 1, 0, 0, 0, 4665, 4627, 1, 0, 0, 0, 4665, 4632,
		1, 0, 0, 0, 4665, 4638, 1, 0, 0, 0, 4665, 4642, 1, 0, 0, 0, 4665, 4646,
		1, 0, 0, 0, 4665, 4650, 1, 0, 0, 0, 4665, 4654, 1, 0, 0, 0, 4665, 4658,
		1, 0, 0, 0, 4665, 4662, 1, 0, 0, 0, 4666, 483, 1, 0, 0, 0, 4667, 4668,
		5, 67, 0, 0, 4668, 4670, 3, 470, 235, 0, 4669, 4667, 1, 0, 0, 0, 4669,
		4670, 1, 0, 0, 0, 4670, 4671, 1, 0, 0, 0, 4671, 4675, 3, 486, 243, 0, 4672,
		4674, 3, 502, 251, 0, 4673, 4672, 1, 0, 0, 0, 4674, 4677, 1, 0, 0, 0, 4675,
		4673, 1, 0, 0, 0, 4675, 4676, 1, 0, 0, 0, 4676, 485, 1, 0, 0, 0, 4677,
		4675, 1, 0, 0, 0, 4678, 4682, 3, 492, 246, 0, 4679, 4682, 3, 494, 247,
		0, 4680, 4682, 3, 498, 249, 0, 4681, 4678, 1, 0, 0, 0, 4681, 4679, 1, 0,
		0, 0, 4681, 4680, 1, 0, 0, 0, 4682, 487, 1, 0, 0, 0, 4683, 4684, 5, 67,
		0, 0, 4684, 4686, 3, 470, 235, 0, 4685, 4683, 1, 0, 0, 0, 4685, 4686, 1,
		0, 0, 0, 4686, 4687, 1, 0, 0, 0, 4687, 4691, 3, 490, 245, 0, 4688, 4690,
		3, 502, 251, 0, 4689, 4688, 1, 0, 0, 0, 4690, 4693, 1, 0, 0, 0, 4691, 4689,
		1, 0, 0, 0, 4691, 4692, 1, 0, 0, 0, 4692, 489, 1, 0, 0, 0, 4693, 4691,
		1, 0, 0, 0, 4694, 4698, 3, 492, 246, 0, 4695, 4698, 3, 496, 248, 0, 4696,
		4698, 3, 500, 250, 0, 4697, 4694, 1, 0, 0, 0, 4697, 4695, 1, 0, 0, 0, 4697,
		4696, 1, 0, 0, 0, 4698, 491, 1, 0, 0, 0, 4699, 4700, 5, 49, 0, 0, 4700,
		4701, 5, 2, 0, 0, 4701, 4702, 3, 336, 168, 0, 4702, 4703, 5, 3, 0, 0, 4703,
		493, 1, 0, 0, 0, 4704, 4708, 5, 370, 0, 0, 4705, 4706, 5, 259, 0, 0, 4706,
		4708, 5, 184, 0, 0, 4707, 4704, 1, 0, 0, 0, 4707, 4705, 1, 0, 0, 0, 4708,
		495, 1, 0, 0, 0, 4709, 4710, 3, 494, 247, 0, 4710, 4711, 3, 270, 135, 0,
		4711, 497, 1, 0, 0, 0, 4712, 4713, 5, 276, 0, 0, 4713, 4715, 3, 306, 153,
		0, 4714, 4716, 3, 270, 135, 0, 4715, 4714, 1, 0, 0, 0, 4715, 4716, 1, 0,
		0, 0, 4716, 499, 1, 0, 0, 0, 4717, 4718, 5, 139, 0, 0, 4718, 4719, 5, 184,
		0, 0, 4719, 4720, 3, 270, 135, 0, 4720, 4721, 3, 498, 249, 0, 4721, 501,
		1, 0, 0, 0, 4722, 4725, 3, 504, 252, 0, 4723, 4725, 3, 506, 253, 0, 4724,
		4722, 1, 0, 0, 0, 4724, 4723, 1, 0, 0, 0, 4725, 503, 1, 0, 0, 0, 4726,
		4730, 5, 114, 0, 0, 4727, 4728, 5, 231, 0, 0, 4728, 4730, 5, 114, 0, 0,
		4729, 4726, 1, 0, 0, 0, 4729, 4727, 1, 0, 0, 0, 4730, 505, 1, 0, 0, 0,
		4731, 4732, 7, 62, 0, 0, 4732, 507, 1, 0, 0, 0, 4733, 4738, 3, 510, 255,
		0, 4734, 4735, 5, 4, 0, 0, 4735, 4737, 3, 510, 255, 0, 4736, 4734, 1, 0,
		0, 0, 4737, 4740, 1, 0, 0, 0, 4738, 4736, 1, 0, 0, 0, 4738, 4739, 1, 0,
		0, 0, 4739, 509, 1, 0, 0, 0, 4740, 4738, 1, 0, 0, 0, 4741, 4743, 3, 306,
		153, 0, 4742, 4744, 3, 512, 256, 0, 4743, 4742, 1, 0, 0, 0, 4743, 4744,
		1, 0, 0, 0, 4744, 511, 1, 0, 0, 0, 4745, 4746, 5, 365, 0, 0, 4746, 4758,
		3, 400, 200, 0, 4747, 4758, 3, 98, 49, 0, 4748, 4758, 3, 388, 194, 0, 4749,
		4750, 7, 63, 0, 0, 4750, 4751, 3, 340, 170, 0, 4751, 4752, 5, 232, 0, 0,
		4752, 4758, 1, 0, 0, 0, 4753, 4754, 5, 309, 0, 0, 4754, 4758, 3, 408, 204,
		0, 4755, 4756, 5, 110, 0, 0, 4756, 4758, 5, 94, 0, 0, 4757, 4745, 1, 0,
		0, 0, 4757, 4747, 1, 0, 0, 0, 4757, 4748, 1, 0, 0, 0, 4757, 4749, 1, 0,
		0, 0, 4757, 4753, 1, 0, 0, 0, 4757, 4755, 1, 0, 0, 0, 4758, 513, 1, 0,
		0, 0, 4759, 4763, 5, 431, 0, 0, 4760, 4761, 4, 257, 28, 0, 4761, 4763,
		5, 432, 0, 0, 4762, 4759, 1, 0, 0, 0, 4762, 4760, 1, 0, 0, 0, 4763, 515,
		1, 0, 0, 0, 4764, 4767, 3, 514, 257, 0, 4765, 4767, 5, 232, 0, 0, 4766,
		4764, 1, 0, 0, 0, 4766, 4765, 1, 0, 0, 0, 4767, 517, 1, 0, 0, 0, 4768,
		4771, 5, 436, 0, 0, 4769, 4771, 3, 514, 257, 0, 4770, 4768, 1, 0, 0, 0,
		4770, 4769, 1, 0, 0, 0, 4771, 519, 1, 0, 0, 0, 4772, 4774, 3, 180, 90,
		0, 4773, 4775, 3, 454, 227, 0, 4774, 4773, 1, 0, 0, 0, 4774, 4775, 1, 0,
		0, 0, 4775, 4812, 1, 0, 0, 0, 4776, 4777, 5, 125, 0, 0, 4777, 4812, 3,
		318, 159, 0, 4778, 4779, 5, 309, 0, 0, 4779, 4812, 3, 522, 261, 0, 4780,
		4781, 5, 110, 0, 0, 4781, 4812, 3, 272, 136, 0, 4782, 4783, 5, 22, 0, 0,
		4783, 4812, 3, 470, 235, 0, 4784, 4786, 3, 202, 101, 0, 4785, 4787, 3,
		454, 227, 0, 4786, 4785, 1, 0, 0, 0, 4786, 4787, 1, 0, 0, 0, 4787, 4812,
		1, 0, 0, 0, 4788, 4790, 3, 224, 112, 0, 4789, 4791, 3, 230, 115, 0, 4790,
		4789, 1, 0, 0, 0, 4790, 4791, 1, 0, 0, 0, 4791, 4812, 1, 0, 0, 0, 4792,
		4794, 3, 230, 115, 0, 4793, 4795, 3, 224, 112, 0, 4794, 4793, 1, 0, 0,
		0, 4794, 4795, 1, 0, 0, 0, 4795, 4812, 1, 0, 0, 0, 4796, 4812, 3, 266,
		133, 0, 4797, 4812, 3, 260, 130, 0, 4798, 4800, 7, 15, 0, 0, 4799, 4801,
		3, 254, 127, 0, 4800, 4799, 1, 0, 0, 0, 4800, 4801, 1, 0, 0, 0, 4801, 4802,
		1, 0, 0, 0, 4802, 4812, 3, 168, 84, 0, 4803, 4812, 3, 162, 81, 0, 4804,
		4806, 5, 11, 0, 0, 4805, 4807, 3, 318, 159, 0, 4806, 4805, 1, 0, 0, 0,
		4806, 4807, 1, 0, 0, 0, 4807, 4809, 1, 0, 0, 0, 4808, 4810, 3, 214, 107,
		0, 4809, 4808, 1, 0, 0, 0, 4809, 4810, 1, 0, 0, 0, 4810, 4812, 1, 0, 0,
		0, 4811, 4772, 1, 0, 0, 0, 4811, 4776, 1, 0, 0, 0, 4811, 4778, 1, 0, 0,
		0, 4811, 4780, 1, 0, 0, 0, 4811, 4782, 1, 0, 0, 0, 4811, 4784, 1, 0, 0,
		0, 4811, 4788, 1, 0, 0, 0, 4811, 4792, 1, 0, 0, 0, 4811, 4796, 1, 0, 0,
		0, 4811, 4797, 1, 0, 0, 0, 4811, 4798, 1, 0, 0, 0, 4811, 4803, 1, 0, 0,
		0, 4811, 4804, 1, 0, 0, 0, 4812, 521, 1, 0, 0, 0, 4813, 4818, 3, 470, 235,
		0, 4814, 4815, 5, 5, 0, 0, 4815, 4817, 3, 470, 235, 0, 4816, 4814, 1, 0,
		0, 0, 4817, 4820, 1, 0, 0, 0, 4818, 4816, 1, 0, 0, 0, 4818, 4819, 1, 0,
		0, 0, 4819, 4821, 1, 0, 0, 0, 4820, 4818, 1, 0, 0, 0, 4821, 4822, 5, 402,
		0, 0, 4822, 4837, 3, 328, 164, 0, 4823, 4824, 5, 4, 0, 0, 4824, 4829, 3,
		470, 235, 0, 4825, 4826, 5, 5, 0, 0, 4826, 4828, 3, 470, 235, 0, 4827,
		4825, 1, 0, 0, 0, 4828, 4831, 1, 0, 0, 0, 4829, 4827, 1, 0, 0, 0, 4829,
		4830, 1, 0, 0, 0, 4830, 4832, 1, 0, 0, 0, 4831, 4829, 1, 0, 0, 0, 4832,
		4833, 5, 402, 0, 0, 4833, 4834, 3, 328, 164, 0, 4834, 4836, 1, 0, 0, 0,
		4835, 4823, 1, 0, 0, 0, 4836, 4839, 1, 0, 0, 0, 4837, 4835, 1, 0, 0, 0,
		4837, 4838, 1, 0, 0, 0, 4838, 523, 1, 0, 0, 0, 4839, 4837, 1, 0, 0, 0,
		4840, 4841, 7, 64, 0, 0, 4841, 525, 1, 0, 0, 0, 4842, 4843, 7, 65, 0, 0,
		4843, 527, 1, 0, 0, 0, 4844, 4845, 7, 66, 0, 0, 4845, 529, 1, 0, 0, 0,
		623, 533, 539, 544, 547, 551, 554, 559, 562, 566, 573, 588, 601, 611, 614,
		618, 625, 632, 643, 646, 655, 668, 673, 679, 688, 704, 708, 722, 726, 731,
		734, 741, 744, 750, 758, 762, 765, 768, 799, 817, 826, 828, 860, 864, 870,
		873, 876, 883, 886, 890, 893, 901, 912, 914, 922, 925, 929, 932, 938, 949,
		955, 960, 994, 1007, 1032, 1041, 1049, 1053, 1058, 1064, 1076, 1084, 1090,
		1104, 1109, 1125, 1132, 1136, 1142, 1160, 1180, 1184, 1190, 1194, 1200,
		1206, 1209, 1212, 1219, 1223, 1233, 1235, 1244, 1247, 1256, 1261, 1267,
		1279, 1282, 1289, 1300, 1303, 1308, 1311, 1318, 1323, 1333, 1335, 1341,
		1345, 1350, 1356, 1359, 1366, 1370, 1373, 1380, 1386, 1390, 1396, 1399,
		1402, 1409, 1414, 1423, 1431, 1437, 1440, 1443, 1449, 1453, 1458, 1461,
		1465, 1467, 1473, 1481, 1489, 1492, 1497, 1506, 1512, 1515, 1519, 1522,
		1526, 1530, 1558, 1561, 1565, 1571, 1574, 1577, 1583, 1591, 1596, 1602,
		1608, 1611, 1618, 1625, 1634, 1639, 1644, 1651, 1657, 1662, 1674, 1677,
		1685, 1691, 1694, 1697, 1702, 1708, 1719, 1725, 1732, 1741, 1745, 1752,
		1769, 1797, 1800, 1806, 1815, 1824, 1827, 1834, 1837, 1846, 1850, 1862,
		1866, 1873, 1989, 1997, 2005, 2014, 2024, 2028, 2031, 2038, 2044, 2062,
		2074, 2079, 2091, 2100, 2108, 2112, 2119, 2121, 2126, 2131, 2135, 2138,
		2144, 2149, 2154, 2158, 2166, 2171, 2174, 2179, 2183, 2188, 2190, 2194,
		2203, 2211, 2217, 2223, 2240, 2247, 2252, 2259, 2264, 2270, 2273, 2297,
		2299, 2308, 2315, 2318, 2325, 2329, 2335, 2343, 2350, 2353, 2361, 2372,
		2383, 2391, 2397, 2409, 2416, 2423, 2429, 2440, 2448, 2454, 2460, 2463,
		2471, 2480, 2489, 2492, 2501, 2504, 2513, 2516, 2525, 2528, 2531, 2536,
		2538, 2542, 2554, 2561, 2568, 2574, 2576, 2588, 2592, 2596, 2602, 2607,
		2615, 2619, 2622, 2625, 2628, 2632, 2636, 2641, 2645, 2648, 2651, 2654,
		2658, 2663, 2667, 2670, 2673, 2676, 2678, 2684, 2691, 2696, 2699, 2702,
		2706, 2716, 2720, 2722, 2725, 2729, 2735, 2739, 2750, 2760, 2764, 2776,
		2788, 2803, 2808, 2814, 2826, 2842, 2847, 2860, 2865, 2873, 2879, 2883,
		2886, 2889, 2896, 2902, 2911, 2921, 2936, 2941, 2943, 2947, 2956, 2969,
		2974, 2978, 2986, 2989, 2993, 3007, 3020, 3025, 3029, 3032, 3036, 3042,
		3045, 3052, 3064, 3075, 3088, 3099, 3104, 3112, 3117, 3124, 3133, 3136,
		3141, 3148, 3151, 3156, 3162, 3168, 3173, 3177, 3183, 3187, 3190, 3195,
		3198, 3203, 3207, 3210, 3213, 3219, 3224, 3231, 3234, 3252, 3254, 3257,
		3268, 3277, 3284, 3292, 3299, 3304, 3307, 3310, 3318, 3326, 3332, 3343,
		3351, 3358, 3365, 3367, 3380, 3390, 3393, 3395, 3405, 3415, 3418, 3420,
		3428, 3432, 3441, 3444, 3450, 3454, 3456, 3465, 3477, 3479, 3486, 3493,
		3499, 3505, 3507, 3514, 3522, 3530, 3536, 3541, 3548, 3554, 3558, 3560,
		3567, 3576, 3583, 3593, 3598, 3602, 3612, 3619, 3632, 3634, 3642, 3644,
		3648, 3656, 3665, 3671, 3679, 3684, 3696, 3701, 3704, 3710, 3714, 3719,
		3724, 3729, 3737, 3762, 3764, 3777, 3789, 3801, 3805, 3814, 3818, 3836,
		3839, 3847, 3856, 3865, 3879, 3885, 3893, 3904, 3911, 3914, 3927, 3932,
		3940, 3944, 3948, 3960, 3985, 3992, 3995, 4010, 4014, 4032, 4034, 4041,
		4046, 4057, 4069, 4079, 4094, 4096, 4109, 4113, 4120, 4125, 4133, 4138,
		4147, 4158, 4164, 4170, 4177, 4180, 4186, 4191, 4193, 4199, 4205, 4210,
		4212, 4225, 4229, 4231, 4238, 4247, 4252, 4256, 4259, 4266, 4274, 4283,
		4296, 4304, 4307, 4314, 4319, 4326, 4334, 4344, 4357, 4362, 4364, 4370,
		4381, 4384, 4388, 4391, 4398, 4403, 4409, 4412, 4421, 4423, 4436, 4448,
		4459, 4467, 4480, 4500, 4510, 4513, 4522, 4525, 4527, 4530, 4533, 4551,
		4560, 4567, 4580, 4587, 4597, 4600, 4605, 4613, 4618, 4624, 4629, 4634,
		4638, 4642, 4646, 4650, 4654, 4658, 4662, 4665, 4669, 4675, 4681, 4685,
		4691, 4697, 4707, 4715, 4724, 4729, 4738, 4743, 4757, 4762, 4766, 4770,
		4774, 4786, 4790, 4794, 4800, 4806, 4809, 4811, 4818, 4829, 4837,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SqlBaseParserInit initializes any static state used to implement SqlBaseParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSqlBaseParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SqlBaseParserInit() {
	staticData := &SqlBaseParserParserStaticData
	staticData.once.Do(sqlbaseparserParserInit)
}

// NewSqlBaseParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSqlBaseParser(input antlr.TokenStream) *SqlBaseParser {
	SqlBaseParserInit()
	this := new(SqlBaseParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SqlBaseParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SqlBaseParser.g4"

	return this
}

var (
	// Note that '@members' cannot be changed now, but this should have been 'globals'
	// If you are looking to have variables for each instance, use '@structmembers'

	/**
	 * When false, INTERSECT is given the greater precedence over the other set
	 * operations (UNION, EXCEPT and MINUS) as per the SQL standard.
	 */
	legacy_setops_precedence_enabled = false

	/**
	 * When false, a literal with an exponent would be converted into
	 * double type rather than decimal type.
	 */
	legacy_exponent_literal_as_decimal_enabled = false

	/**
	 * When true, the behavior of keywords follows ANSI SQL standard.
	 */
	SQL_standard_keyword_behavior = false

	/**
	 * When true, double quoted literals are identifiers rather than STRINGs.
	 */
	double_quoted_identifiers = false
)

// SqlBaseParser tokens.
const (
	SqlBaseParserEOF                   = antlr.TokenEOF
	SqlBaseParserSEMICOLON             = 1
	SqlBaseParserLEFT_PAREN            = 2
	SqlBaseParserRIGHT_PAREN           = 3
	SqlBaseParserCOMMA                 = 4
	SqlBaseParserDOT                   = 5
	SqlBaseParserLEFT_BRACKET          = 6
	SqlBaseParserRIGHT_BRACKET         = 7
	SqlBaseParserBANG                  = 8
	SqlBaseParserADD                   = 9
	SqlBaseParserAFTER                 = 10
	SqlBaseParserAGGREGATE             = 11
	SqlBaseParserALL                   = 12
	SqlBaseParserALTER                 = 13
	SqlBaseParserALWAYS                = 14
	SqlBaseParserANALYZE               = 15
	SqlBaseParserAND                   = 16
	SqlBaseParserANTI                  = 17
	SqlBaseParserANY                   = 18
	SqlBaseParserANY_VALUE             = 19
	SqlBaseParserARCHIVE               = 20
	SqlBaseParserARRAY                 = 21
	SqlBaseParserAS                    = 22
	SqlBaseParserASC                   = 23
	SqlBaseParserAT                    = 24
	SqlBaseParserATOMIC                = 25
	SqlBaseParserAUTHORIZATION         = 26
	SqlBaseParserBEGIN                 = 27
	SqlBaseParserBETWEEN               = 28
	SqlBaseParserBIGINT                = 29
	SqlBaseParserBINARY                = 30
	SqlBaseParserBINDING               = 31
	SqlBaseParserBOOLEAN               = 32
	SqlBaseParserBOTH                  = 33
	SqlBaseParserBUCKET                = 34
	SqlBaseParserBUCKETS               = 35
	SqlBaseParserBY                    = 36
	SqlBaseParserBYTE                  = 37
	SqlBaseParserCACHE                 = 38
	SqlBaseParserCALL                  = 39
	SqlBaseParserCALLED                = 40
	SqlBaseParserCASCADE               = 41
	SqlBaseParserCASE                  = 42
	SqlBaseParserCAST                  = 43
	SqlBaseParserCATALOG               = 44
	SqlBaseParserCATALOGS              = 45
	SqlBaseParserCHANGE                = 46
	SqlBaseParserCHAR                  = 47
	SqlBaseParserCHARACTER             = 48
	SqlBaseParserCHECK                 = 49
	SqlBaseParserCLEAR                 = 50
	SqlBaseParserCLUSTER               = 51
	SqlBaseParserCLUSTERED             = 52
	SqlBaseParserCODEGEN               = 53
	SqlBaseParserCOLLATE               = 54
	SqlBaseParserCOLLATION             = 55
	SqlBaseParserCOLLECTION            = 56
	SqlBaseParserCOLUMN                = 57
	SqlBaseParserCOLUMNS               = 58
	SqlBaseParserCOMMENT               = 59
	SqlBaseParserCOMMIT                = 60
	SqlBaseParserCOMPACT               = 61
	SqlBaseParserCOMPACTIONS           = 62
	SqlBaseParserCOMPENSATION          = 63
	SqlBaseParserCOMPUTE               = 64
	SqlBaseParserCONCATENATE           = 65
	SqlBaseParserCONDITION             = 66
	SqlBaseParserCONSTRAINT            = 67
	SqlBaseParserCONTAINS              = 68
	SqlBaseParserCONTINUE              = 69
	SqlBaseParserCOST                  = 70
	SqlBaseParserCREATE                = 71
	SqlBaseParserCROSS                 = 72
	SqlBaseParserCUBE                  = 73
	SqlBaseParserCURRENT               = 74
	SqlBaseParserCURRENT_DATE          = 75
	SqlBaseParserCURRENT_TIME          = 76
	SqlBaseParserCURRENT_TIMESTAMP     = 77
	SqlBaseParserCURRENT_USER          = 78
	SqlBaseParserDAY                   = 79
	SqlBaseParserDAYS                  = 80
	SqlBaseParserDAYOFYEAR             = 81
	SqlBaseParserDATA                  = 82
	SqlBaseParserDATE                  = 83
	SqlBaseParserDATABASE              = 84
	SqlBaseParserDATABASES             = 85
	SqlBaseParserDATEADD               = 86
	SqlBaseParserDATE_ADD              = 87
	SqlBaseParserDATEDIFF              = 88
	SqlBaseParserDATE_DIFF             = 89
	SqlBaseParserDBPROPERTIES          = 90
	SqlBaseParserDEC                   = 91
	SqlBaseParserDECIMAL               = 92
	SqlBaseParserDECLARE               = 93
	SqlBaseParserDEFAULT               = 94
	SqlBaseParserDEFINED               = 95
	SqlBaseParserDEFINER               = 96
	SqlBaseParserDELETE                = 97
	SqlBaseParserDELIMITED             = 98
	SqlBaseParserDESC                  = 99
	SqlBaseParserDESCRIBE              = 100
	SqlBaseParserDETERMINISTIC         = 101
	SqlBaseParserDFS                   = 102
	SqlBaseParserDIRECTORIES           = 103
	SqlBaseParserDIRECTORY             = 104
	SqlBaseParserDISTINCT              = 105
	SqlBaseParserDISTRIBUTE            = 106
	SqlBaseParserDIV                   = 107
	SqlBaseParserDO                    = 108
	SqlBaseParserDOUBLE                = 109
	SqlBaseParserDROP                  = 110
	SqlBaseParserELSE                  = 111
	SqlBaseParserELSEIF                = 112
	SqlBaseParserEND                   = 113
	SqlBaseParserENFORCED              = 114
	SqlBaseParserESCAPE                = 115
	SqlBaseParserESCAPED               = 116
	SqlBaseParserEVOLUTION             = 117
	SqlBaseParserEXCEPT                = 118
	SqlBaseParserEXCHANGE              = 119
	SqlBaseParserEXCLUDE               = 120
	SqlBaseParserEXISTS                = 121
	SqlBaseParserEXIT                  = 122
	SqlBaseParserEXPLAIN               = 123
	SqlBaseParserEXPORT                = 124
	SqlBaseParserEXTEND                = 125
	SqlBaseParserEXTENDED              = 126
	SqlBaseParserEXTERNAL              = 127
	SqlBaseParserEXTRACT               = 128
	SqlBaseParserFALSE                 = 129
	SqlBaseParserFETCH                 = 130
	SqlBaseParserFIELDS                = 131
	SqlBaseParserFILTER                = 132
	SqlBaseParserFILEFORMAT            = 133
	SqlBaseParserFIRST                 = 134
	SqlBaseParserFLOAT                 = 135
	SqlBaseParserFLOW                  = 136
	SqlBaseParserFOLLOWING             = 137
	SqlBaseParserFOR                   = 138
	SqlBaseParserFOREIGN               = 139
	SqlBaseParserFORMAT                = 140
	SqlBaseParserFORMATTED             = 141
	SqlBaseParserFOUND                 = 142
	SqlBaseParserFROM                  = 143
	SqlBaseParserFULL                  = 144
	SqlBaseParserFUNCTION              = 145
	SqlBaseParserFUNCTIONS             = 146
	SqlBaseParserGENERATED             = 147
	SqlBaseParserGLOBAL                = 148
	SqlBaseParserGRANT                 = 149
	SqlBaseParserGROUP                 = 150
	SqlBaseParserGROUPING              = 151
	SqlBaseParserHANDLER               = 152
	SqlBaseParserHAVING                = 153
	SqlBaseParserBINARY_HEX            = 154
	SqlBaseParserHOUR                  = 155
	SqlBaseParserHOURS                 = 156
	SqlBaseParserIDENTIFIER_KW         = 157
	SqlBaseParserIDENTITY              = 158
	SqlBaseParserIF                    = 159
	SqlBaseParserIGNORE                = 160
	SqlBaseParserIMMEDIATE             = 161
	SqlBaseParserIMPORT                = 162
	SqlBaseParserIN                    = 163
	SqlBaseParserINCLUDE               = 164
	SqlBaseParserINCREMENT             = 165
	SqlBaseParserINDEX                 = 166
	SqlBaseParserINDEXES               = 167
	SqlBaseParserINNER                 = 168
	SqlBaseParserINPATH                = 169
	SqlBaseParserINPUT                 = 170
	SqlBaseParserINPUTFORMAT           = 171
	SqlBaseParserINSERT                = 172
	SqlBaseParserINTERSECT             = 173
	SqlBaseParserINTERVAL              = 174
	SqlBaseParserINT                   = 175
	SqlBaseParserINTEGER               = 176
	SqlBaseParserINTO                  = 177
	SqlBaseParserINVOKER               = 178
	SqlBaseParserIS                    = 179
	SqlBaseParserITEMS                 = 180
	SqlBaseParserITERATE               = 181
	SqlBaseParserJOIN                  = 182
	SqlBaseParserJSON                  = 183
	SqlBaseParserKEY                   = 184
	SqlBaseParserKEYS                  = 185
	SqlBaseParserLANGUAGE              = 186
	SqlBaseParserLAST                  = 187
	SqlBaseParserLATERAL               = 188
	SqlBaseParserLAZY                  = 189
	SqlBaseParserLEADING               = 190
	SqlBaseParserLEAVE                 = 191
	SqlBaseParserLEFT                  = 192
	SqlBaseParserLEVEL                 = 193
	SqlBaseParserLIKE                  = 194
	SqlBaseParserILIKE                 = 195
	SqlBaseParserLIMIT                 = 196
	SqlBaseParserLINES                 = 197
	SqlBaseParserLIST                  = 198
	SqlBaseParserLOAD                  = 199
	SqlBaseParserLOCAL                 = 200
	SqlBaseParserLOCATION              = 201
	SqlBaseParserLOCK                  = 202
	SqlBaseParserLOCKS                 = 203
	SqlBaseParserLOGICAL               = 204
	SqlBaseParserLONG                  = 205
	SqlBaseParserLOOP                  = 206
	SqlBaseParserMACRO                 = 207
	SqlBaseParserMAP                   = 208
	SqlBaseParserMATCHED               = 209
	SqlBaseParserMATERIALIZED          = 210
	SqlBaseParserMAX                   = 211
	SqlBaseParserMERGE                 = 212
	SqlBaseParserMICROSECOND           = 213
	SqlBaseParserMICROSECONDS          = 214
	SqlBaseParserMILLISECOND           = 215
	SqlBaseParserMILLISECONDS          = 216
	SqlBaseParserMINUTE                = 217
	SqlBaseParserMINUTES               = 218
	SqlBaseParserMODIFIES              = 219
	SqlBaseParserMONTH                 = 220
	SqlBaseParserMONTHS                = 221
	SqlBaseParserMSCK                  = 222
	SqlBaseParserNAME                  = 223
	SqlBaseParserNAMESPACE             = 224
	SqlBaseParserNAMESPACES            = 225
	SqlBaseParserNANOSECOND            = 226
	SqlBaseParserNANOSECONDS           = 227
	SqlBaseParserNATURAL               = 228
	SqlBaseParserNO                    = 229
	SqlBaseParserNONE                  = 230
	SqlBaseParserNOT                   = 231
	SqlBaseParserNULL                  = 232
	SqlBaseParserNULLS                 = 233
	SqlBaseParserNUMERIC               = 234
	SqlBaseParserNORELY                = 235
	SqlBaseParserOF                    = 236
	SqlBaseParserOFFSET                = 237
	SqlBaseParserON                    = 238
	SqlBaseParserONLY                  = 239
	SqlBaseParserOPTION                = 240
	SqlBaseParserOPTIONS               = 241
	SqlBaseParserOR                    = 242
	SqlBaseParserORDER                 = 243
	SqlBaseParserOUT                   = 244
	SqlBaseParserOUTER                 = 245
	SqlBaseParserOUTPUTFORMAT          = 246
	SqlBaseParserOVER                  = 247
	SqlBaseParserOVERLAPS              = 248
	SqlBaseParserOVERLAY               = 249
	SqlBaseParserOVERWRITE             = 250
	SqlBaseParserPARTITION             = 251
	SqlBaseParserPARTITIONED           = 252
	SqlBaseParserPARTITIONS            = 253
	SqlBaseParserPERCENTLIT            = 254
	SqlBaseParserPIVOT                 = 255
	SqlBaseParserPLACING               = 256
	SqlBaseParserPOSITION              = 257
	SqlBaseParserPRECEDING             = 258
	SqlBaseParserPRIMARY               = 259
	SqlBaseParserPRINCIPALS            = 260
	SqlBaseParserPROCEDURE             = 261
	SqlBaseParserPROCEDURES            = 262
	SqlBaseParserPROPERTIES            = 263
	SqlBaseParserPURGE                 = 264
	SqlBaseParserQUARTER               = 265
	SqlBaseParserQUERY                 = 266
	SqlBaseParserRANGE                 = 267
	SqlBaseParserREADS                 = 268
	SqlBaseParserREAL                  = 269
	SqlBaseParserRECORDREADER          = 270
	SqlBaseParserRECORDWRITER          = 271
	SqlBaseParserRECOVER               = 272
	SqlBaseParserRECURSION             = 273
	SqlBaseParserRECURSIVE             = 274
	SqlBaseParserREDUCE                = 275
	SqlBaseParserREFERENCES            = 276
	SqlBaseParserREFRESH               = 277
	SqlBaseParserRELY                  = 278
	SqlBaseParserRENAME                = 279
	SqlBaseParserREPAIR                = 280
	SqlBaseParserREPEAT                = 281
	SqlBaseParserREPEATABLE            = 282
	SqlBaseParserREPLACE               = 283
	SqlBaseParserRESET                 = 284
	SqlBaseParserRESPECT               = 285
	SqlBaseParserRESTRICT              = 286
	SqlBaseParserRETURN                = 287
	SqlBaseParserRETURNS               = 288
	SqlBaseParserREVOKE                = 289
	SqlBaseParserRIGHT                 = 290
	SqlBaseParserRLIKE                 = 291
	SqlBaseParserROLE                  = 292
	SqlBaseParserROLES                 = 293
	SqlBaseParserROLLBACK              = 294
	SqlBaseParserROLLUP                = 295
	SqlBaseParserROW                   = 296
	SqlBaseParserROWS                  = 297
	SqlBaseParserSECOND                = 298
	SqlBaseParserSECONDS               = 299
	SqlBaseParserSCHEMA                = 300
	SqlBaseParserSCHEMAS               = 301
	SqlBaseParserSECURITY              = 302
	SqlBaseParserSELECT                = 303
	SqlBaseParserSEMI                  = 304
	SqlBaseParserSEPARATED             = 305
	SqlBaseParserSERDE                 = 306
	SqlBaseParserSERDEPROPERTIES       = 307
	SqlBaseParserSESSION_USER          = 308
	SqlBaseParserSET                   = 309
	SqlBaseParserSETMINUS              = 310
	SqlBaseParserSETS                  = 311
	SqlBaseParserSHORT                 = 312
	SqlBaseParserSHOW                  = 313
	SqlBaseParserSINGLE                = 314
	SqlBaseParserSKEWED                = 315
	SqlBaseParserSMALLINT              = 316
	SqlBaseParserSOME                  = 317
	SqlBaseParserSORT                  = 318
	SqlBaseParserSORTED                = 319
	SqlBaseParserSOURCE                = 320
	SqlBaseParserSPECIFIC              = 321
	SqlBaseParserSQL                   = 322
	SqlBaseParserSQLEXCEPTION          = 323
	SqlBaseParserSQLSTATE              = 324
	SqlBaseParserSTART                 = 325
	SqlBaseParserSTATISTICS            = 326
	SqlBaseParserSTORED                = 327
	SqlBaseParserSTRATIFY              = 328
	SqlBaseParserSTREAM                = 329
	SqlBaseParserSTREAMING             = 330
	SqlBaseParserSTRING                = 331
	SqlBaseParserSTRUCT                = 332
	SqlBaseParserSUBSTR                = 333
	SqlBaseParserSUBSTRING             = 334
	SqlBaseParserSYNC                  = 335
	SqlBaseParserSYSTEM_TIME           = 336
	SqlBaseParserSYSTEM_VERSION        = 337
	SqlBaseParserTABLE                 = 338
	SqlBaseParserTABLES                = 339
	SqlBaseParserTABLESAMPLE           = 340
	SqlBaseParserTARGET                = 341
	SqlBaseParserTBLPROPERTIES         = 342
	SqlBaseParserTEMPORARY             = 343
	SqlBaseParserTERMINATED            = 344
	SqlBaseParserTHEN                  = 345
	SqlBaseParserTIME                  = 346
	SqlBaseParserTIMEDIFF              = 347
	SqlBaseParserTIMESTAMP             = 348
	SqlBaseParserTIMESTAMP_LTZ         = 349
	SqlBaseParserTIMESTAMP_NTZ         = 350
	SqlBaseParserTIMESTAMPADD          = 351
	SqlBaseParserTIMESTAMPDIFF         = 352
	SqlBaseParserTINYINT               = 353
	SqlBaseParserTO                    = 354
	SqlBaseParserEXECUTE               = 355
	SqlBaseParserTOUCH                 = 356
	SqlBaseParserTRAILING              = 357
	SqlBaseParserTRANSACTION           = 358
	SqlBaseParserTRANSACTIONS          = 359
	SqlBaseParserTRANSFORM             = 360
	SqlBaseParserTRIM                  = 361
	SqlBaseParserTRUE                  = 362
	SqlBaseParserTRUNCATE              = 363
	SqlBaseParserTRY_CAST              = 364
	SqlBaseParserTYPE                  = 365
	SqlBaseParserUNARCHIVE             = 366
	SqlBaseParserUNBOUNDED             = 367
	SqlBaseParserUNCACHE               = 368
	SqlBaseParserUNION                 = 369
	SqlBaseParserUNIQUE                = 370
	SqlBaseParserUNKNOWN               = 371
	SqlBaseParserUNLOCK                = 372
	SqlBaseParserUNPIVOT               = 373
	SqlBaseParserUNSET                 = 374
	SqlBaseParserUNTIL                 = 375
	SqlBaseParserUPDATE                = 376
	SqlBaseParserUSE                   = 377
	SqlBaseParserUSER                  = 378
	SqlBaseParserUSING                 = 379
	SqlBaseParserVALUE                 = 380
	SqlBaseParserVALUES                = 381
	SqlBaseParserVARCHAR               = 382
	SqlBaseParserVAR                   = 383
	SqlBaseParserVARIABLE              = 384
	SqlBaseParserVARIANT               = 385
	SqlBaseParserVERSION               = 386
	SqlBaseParserVIEW                  = 387
	SqlBaseParserVIEWS                 = 388
	SqlBaseParserVOID                  = 389
	SqlBaseParserWEEK                  = 390
	SqlBaseParserWEEKS                 = 391
	SqlBaseParserWHEN                  = 392
	SqlBaseParserWHERE                 = 393
	SqlBaseParserWHILE                 = 394
	SqlBaseParserWINDOW                = 395
	SqlBaseParserWITH                  = 396
	SqlBaseParserWITHIN                = 397
	SqlBaseParserWITHOUT               = 398
	SqlBaseParserYEAR                  = 399
	SqlBaseParserYEARS                 = 400
	SqlBaseParserZONE                  = 401
	SqlBaseParserEQ                    = 402
	SqlBaseParserNSEQ                  = 403
	SqlBaseParserNEQ                   = 404
	SqlBaseParserNEQJ                  = 405
	SqlBaseParserLT                    = 406
	SqlBaseParserLTE                   = 407
	SqlBaseParserGT                    = 408
	SqlBaseParserGTE                   = 409
	SqlBaseParserSHIFT_LEFT            = 410
	SqlBaseParserSHIFT_RIGHT           = 411
	SqlBaseParserSHIFT_RIGHT_UNSIGNED  = 412
	SqlBaseParserPLUS                  = 413
	SqlBaseParserMINUS                 = 414
	SqlBaseParserASTERISK              = 415
	SqlBaseParserSLASH                 = 416
	SqlBaseParserPERCENT               = 417
	SqlBaseParserTILDE                 = 418
	SqlBaseParserAMPERSAND             = 419
	SqlBaseParserPIPE                  = 420
	SqlBaseParserCONCAT_PIPE           = 421
	SqlBaseParserOPERATOR_PIPE         = 422
	SqlBaseParserHAT                   = 423
	SqlBaseParserCOLON                 = 424
	SqlBaseParserDOUBLE_COLON          = 425
	SqlBaseParserARROW                 = 426
	SqlBaseParserFAT_ARROW             = 427
	SqlBaseParserHENT_START            = 428
	SqlBaseParserHENT_END              = 429
	SqlBaseParserQUESTION              = 430
	SqlBaseParserSTRING_LITERAL        = 431
	SqlBaseParserDOUBLEQUOTED_STRING   = 432
	SqlBaseParserBIGINT_LITERAL        = 433
	SqlBaseParserSMALLINT_LITERAL      = 434
	SqlBaseParserTINYINT_LITERAL       = 435
	SqlBaseParserINTEGER_VALUE         = 436
	SqlBaseParserEXPONENT_VALUE        = 437
	SqlBaseParserDECIMAL_VALUE         = 438
	SqlBaseParserFLOAT_LITERAL         = 439
	SqlBaseParserDOUBLE_LITERAL        = 440
	SqlBaseParserBIGDECIMAL_LITERAL    = 441
	SqlBaseParserIDENTIFIER            = 442
	SqlBaseParserBACKQUOTED_IDENTIFIER = 443
	SqlBaseParserSIMPLE_COMMENT        = 444
	SqlBaseParserBRACKETED_COMMENT     = 445
	SqlBaseParserWS                    = 446
	SqlBaseParserUNRECOGNIZED          = 447
)

// SqlBaseParser rules.
const (
	SqlBaseParserRULE_program                              = 0
	SqlBaseParserRULE_compoundOrSingleStatement            = 1
	SqlBaseParserRULE_singleCompoundStatement              = 2
	SqlBaseParserRULE_beginEndCompoundBlock                = 3
	SqlBaseParserRULE_compoundBody                         = 4
	SqlBaseParserRULE_compoundStatement                    = 5
	SqlBaseParserRULE_setStatementInsideSqlScript          = 6
	SqlBaseParserRULE_sqlStateValue                        = 7
	SqlBaseParserRULE_declareConditionStatement            = 8
	SqlBaseParserRULE_conditionValue                       = 9
	SqlBaseParserRULE_conditionValues                      = 10
	SqlBaseParserRULE_declareHandlerStatement              = 11
	SqlBaseParserRULE_whileStatement                       = 12
	SqlBaseParserRULE_ifElseStatement                      = 13
	SqlBaseParserRULE_repeatStatement                      = 14
	SqlBaseParserRULE_leaveStatement                       = 15
	SqlBaseParserRULE_iterateStatement                     = 16
	SqlBaseParserRULE_caseStatement                        = 17
	SqlBaseParserRULE_loopStatement                        = 18
	SqlBaseParserRULE_forStatement                         = 19
	SqlBaseParserRULE_singleStatement                      = 20
	SqlBaseParserRULE_beginLabel                           = 21
	SqlBaseParserRULE_endLabel                             = 22
	SqlBaseParserRULE_singleExpression                     = 23
	SqlBaseParserRULE_singleTableIdentifier                = 24
	SqlBaseParserRULE_singleMultipartIdentifier            = 25
	SqlBaseParserRULE_singleFunctionIdentifier             = 26
	SqlBaseParserRULE_singleDataType                       = 27
	SqlBaseParserRULE_singleTableSchema                    = 28
	SqlBaseParserRULE_singleRoutineParamList               = 29
	SqlBaseParserRULE_statement                            = 30
	SqlBaseParserRULE_materializedView                     = 31
	SqlBaseParserRULE_streamingTable                       = 32
	SqlBaseParserRULE_createPipelineDatasetHeader          = 33
	SqlBaseParserRULE_streamRelationPrimary                = 34
	SqlBaseParserRULE_setResetStatement                    = 35
	SqlBaseParserRULE_executeImmediate                     = 36
	SqlBaseParserRULE_executeImmediateUsing                = 37
	SqlBaseParserRULE_timezone                             = 38
	SqlBaseParserRULE_configKey                            = 39
	SqlBaseParserRULE_configValue                          = 40
	SqlBaseParserRULE_unsupportedHiveNativeCommands        = 41
	SqlBaseParserRULE_createTableHeader                    = 42
	SqlBaseParserRULE_replaceTableHeader                   = 43
	SqlBaseParserRULE_clusterBySpec                        = 44
	SqlBaseParserRULE_bucketSpec                           = 45
	SqlBaseParserRULE_skewSpec                             = 46
	SqlBaseParserRULE_locationSpec                         = 47
	SqlBaseParserRULE_schemaBinding                        = 48
	SqlBaseParserRULE_commentSpec                          = 49
	SqlBaseParserRULE_singleQuery                          = 50
	SqlBaseParserRULE_query                                = 51
	SqlBaseParserRULE_insertInto                           = 52
	SqlBaseParserRULE_partitionSpecLocation                = 53
	SqlBaseParserRULE_partitionSpec                        = 54
	SqlBaseParserRULE_partitionVal                         = 55
	SqlBaseParserRULE_createPipelineFlowHeader             = 56
	SqlBaseParserRULE_namespace                            = 57
	SqlBaseParserRULE_namespaces                           = 58
	SqlBaseParserRULE_variable                             = 59
	SqlBaseParserRULE_describeFuncName                     = 60
	SqlBaseParserRULE_describeColName                      = 61
	SqlBaseParserRULE_ctes                                 = 62
	SqlBaseParserRULE_namedQuery                           = 63
	SqlBaseParserRULE_tableProvider                        = 64
	SqlBaseParserRULE_createTableClauses                   = 65
	SqlBaseParserRULE_propertyList                         = 66
	SqlBaseParserRULE_property                             = 67
	SqlBaseParserRULE_propertyKey                          = 68
	SqlBaseParserRULE_propertyValue                        = 69
	SqlBaseParserRULE_expressionPropertyList               = 70
	SqlBaseParserRULE_expressionProperty                   = 71
	SqlBaseParserRULE_constantList                         = 72
	SqlBaseParserRULE_nestedConstantList                   = 73
	SqlBaseParserRULE_createFileFormat                     = 74
	SqlBaseParserRULE_fileFormat                           = 75
	SqlBaseParserRULE_storageHandler                       = 76
	SqlBaseParserRULE_resource                             = 77
	SqlBaseParserRULE_dmlStatementNoWith                   = 78
	SqlBaseParserRULE_identifierReference                  = 79
	SqlBaseParserRULE_catalogIdentifierReference           = 80
	SqlBaseParserRULE_queryOrganization                    = 81
	SqlBaseParserRULE_multiInsertQueryBody                 = 82
	SqlBaseParserRULE_queryTerm                            = 83
	SqlBaseParserRULE_queryPrimary                         = 84
	SqlBaseParserRULE_sortItem                             = 85
	SqlBaseParserRULE_fromStatement                        = 86
	SqlBaseParserRULE_fromStatementBody                    = 87
	SqlBaseParserRULE_querySpecification                   = 88
	SqlBaseParserRULE_transformClause                      = 89
	SqlBaseParserRULE_selectClause                         = 90
	SqlBaseParserRULE_setClause                            = 91
	SqlBaseParserRULE_matchedClause                        = 92
	SqlBaseParserRULE_notMatchedClause                     = 93
	SqlBaseParserRULE_notMatchedBySourceClause             = 94
	SqlBaseParserRULE_matchedAction                        = 95
	SqlBaseParserRULE_notMatchedAction                     = 96
	SqlBaseParserRULE_notMatchedBySourceAction             = 97
	SqlBaseParserRULE_exceptClause                         = 98
	SqlBaseParserRULE_assignmentList                       = 99
	SqlBaseParserRULE_assignment                           = 100
	SqlBaseParserRULE_whereClause                          = 101
	SqlBaseParserRULE_havingClause                         = 102
	SqlBaseParserRULE_hint                                 = 103
	SqlBaseParserRULE_hintStatement                        = 104
	SqlBaseParserRULE_fromClause                           = 105
	SqlBaseParserRULE_temporalClause                       = 106
	SqlBaseParserRULE_aggregationClause                    = 107
	SqlBaseParserRULE_groupByClause                        = 108
	SqlBaseParserRULE_groupingAnalytics                    = 109
	SqlBaseParserRULE_groupingElement                      = 110
	SqlBaseParserRULE_groupingSet                          = 111
	SqlBaseParserRULE_pivotClause                          = 112
	SqlBaseParserRULE_pivotColumn                          = 113
	SqlBaseParserRULE_pivotValue                           = 114
	SqlBaseParserRULE_unpivotClause                        = 115
	SqlBaseParserRULE_unpivotNullClause                    = 116
	SqlBaseParserRULE_unpivotOperator                      = 117
	SqlBaseParserRULE_unpivotSingleValueColumnClause       = 118
	SqlBaseParserRULE_unpivotMultiValueColumnClause        = 119
	SqlBaseParserRULE_unpivotColumnSet                     = 120
	SqlBaseParserRULE_unpivotValueColumn                   = 121
	SqlBaseParserRULE_unpivotNameColumn                    = 122
	SqlBaseParserRULE_unpivotColumnAndAlias                = 123
	SqlBaseParserRULE_unpivotColumn                        = 124
	SqlBaseParserRULE_unpivotAlias                         = 125
	SqlBaseParserRULE_lateralView                          = 126
	SqlBaseParserRULE_setQuantifier                        = 127
	SqlBaseParserRULE_relation                             = 128
	SqlBaseParserRULE_relationExtension                    = 129
	SqlBaseParserRULE_joinRelation                         = 130
	SqlBaseParserRULE_joinType                             = 131
	SqlBaseParserRULE_joinCriteria                         = 132
	SqlBaseParserRULE_sample                               = 133
	SqlBaseParserRULE_sampleMethod                         = 134
	SqlBaseParserRULE_identifierList                       = 135
	SqlBaseParserRULE_identifierSeq                        = 136
	SqlBaseParserRULE_orderedIdentifierList                = 137
	SqlBaseParserRULE_orderedIdentifier                    = 138
	SqlBaseParserRULE_identifierCommentList                = 139
	SqlBaseParserRULE_identifierComment                    = 140
	SqlBaseParserRULE_relationPrimary                      = 141
	SqlBaseParserRULE_optionsClause                        = 142
	SqlBaseParserRULE_inlineTable                          = 143
	SqlBaseParserRULE_functionTableSubqueryArgument        = 144
	SqlBaseParserRULE_tableArgumentPartitioning            = 145
	SqlBaseParserRULE_functionTableNamedArgumentExpression = 146
	SqlBaseParserRULE_functionTableReferenceArgument       = 147
	SqlBaseParserRULE_functionTableArgument                = 148
	SqlBaseParserRULE_functionTable                        = 149
	SqlBaseParserRULE_tableAlias                           = 150
	SqlBaseParserRULE_rowFormat                            = 151
	SqlBaseParserRULE_multipartIdentifierList              = 152
	SqlBaseParserRULE_multipartIdentifier                  = 153
	SqlBaseParserRULE_multipartIdentifierPropertyList      = 154
	SqlBaseParserRULE_multipartIdentifierProperty          = 155
	SqlBaseParserRULE_tableIdentifier                      = 156
	SqlBaseParserRULE_functionIdentifier                   = 157
	SqlBaseParserRULE_namedExpression                      = 158
	SqlBaseParserRULE_namedExpressionSeq                   = 159
	SqlBaseParserRULE_partitionFieldList                   = 160
	SqlBaseParserRULE_partitionField                       = 161
	SqlBaseParserRULE_transform                            = 162
	SqlBaseParserRULE_transformArgument                    = 163
	SqlBaseParserRULE_expression                           = 164
	SqlBaseParserRULE_namedArgumentExpression              = 165
	SqlBaseParserRULE_functionArgument                     = 166
	SqlBaseParserRULE_expressionSeq                        = 167
	SqlBaseParserRULE_booleanExpression                    = 168
	SqlBaseParserRULE_predicate                            = 169
	SqlBaseParserRULE_errorCapturingNot                    = 170
	SqlBaseParserRULE_valueExpression                      = 171
	SqlBaseParserRULE_shiftOperator                        = 172
	SqlBaseParserRULE_datetimeUnit                         = 173
	SqlBaseParserRULE_primaryExpression                    = 174
	SqlBaseParserRULE_semiStructuredExtractionPath         = 175
	SqlBaseParserRULE_jsonPathIdentifier                   = 176
	SqlBaseParserRULE_jsonPathBracketedIdentifier          = 177
	SqlBaseParserRULE_jsonPathFirstPart                    = 178
	SqlBaseParserRULE_jsonPathParts                        = 179
	SqlBaseParserRULE_literalType                          = 180
	SqlBaseParserRULE_constant                             = 181
	SqlBaseParserRULE_comparisonOperator                   = 182
	SqlBaseParserRULE_arithmeticOperator                   = 183
	SqlBaseParserRULE_predicateOperator                    = 184
	SqlBaseParserRULE_booleanValue                         = 185
	SqlBaseParserRULE_interval                             = 186
	SqlBaseParserRULE_errorCapturingMultiUnitsInterval     = 187
	SqlBaseParserRULE_multiUnitsInterval                   = 188
	SqlBaseParserRULE_errorCapturingUnitToUnitInterval     = 189
	SqlBaseParserRULE_unitToUnitInterval                   = 190
	SqlBaseParserRULE_intervalValue                        = 191
	SqlBaseParserRULE_unitInMultiUnits                     = 192
	SqlBaseParserRULE_unitInUnitToUnit                     = 193
	SqlBaseParserRULE_colPosition                          = 194
	SqlBaseParserRULE_collationSpec                        = 195
	SqlBaseParserRULE_collateClause                        = 196
	SqlBaseParserRULE_nonTrivialPrimitiveType              = 197
	SqlBaseParserRULE_trivialPrimitiveType                 = 198
	SqlBaseParserRULE_primitiveType                        = 199
	SqlBaseParserRULE_dataType                             = 200
	SqlBaseParserRULE_qualifiedColTypeWithPositionList     = 201
	SqlBaseParserRULE_qualifiedColTypeWithPosition         = 202
	SqlBaseParserRULE_colDefinitionDescriptorWithPosition  = 203
	SqlBaseParserRULE_defaultExpression                    = 204
	SqlBaseParserRULE_variableDefaultExpression            = 205
	SqlBaseParserRULE_colTypeList                          = 206
	SqlBaseParserRULE_colType                              = 207
	SqlBaseParserRULE_tableElementList                     = 208
	SqlBaseParserRULE_tableElement                         = 209
	SqlBaseParserRULE_colDefinitionList                    = 210
	SqlBaseParserRULE_colDefinition                        = 211
	SqlBaseParserRULE_colDefinitionOption                  = 212
	SqlBaseParserRULE_generationExpression                 = 213
	SqlBaseParserRULE_identityColSpec                      = 214
	SqlBaseParserRULE_sequenceGeneratorOption              = 215
	SqlBaseParserRULE_sequenceGeneratorStartOrStep         = 216
	SqlBaseParserRULE_complexColTypeList                   = 217
	SqlBaseParserRULE_complexColType                       = 218
	SqlBaseParserRULE_routineCharacteristics               = 219
	SqlBaseParserRULE_routineLanguage                      = 220
	SqlBaseParserRULE_specificName                         = 221
	SqlBaseParserRULE_deterministic                        = 222
	SqlBaseParserRULE_sqlDataAccess                        = 223
	SqlBaseParserRULE_nullCall                             = 224
	SqlBaseParserRULE_rightsClause                         = 225
	SqlBaseParserRULE_whenClause                           = 226
	SqlBaseParserRULE_windowClause                         = 227
	SqlBaseParserRULE_namedWindow                          = 228
	SqlBaseParserRULE_windowSpec                           = 229
	SqlBaseParserRULE_windowFrame                          = 230
	SqlBaseParserRULE_frameBound                           = 231
	SqlBaseParserRULE_qualifiedNameList                    = 232
	SqlBaseParserRULE_functionName                         = 233
	SqlBaseParserRULE_qualifiedName                        = 234
	SqlBaseParserRULE_errorCapturingIdentifier             = 235
	SqlBaseParserRULE_errorCapturingIdentifierExtra        = 236
	SqlBaseParserRULE_identifier                           = 237
	SqlBaseParserRULE_strictIdentifier                     = 238
	SqlBaseParserRULE_quotedIdentifier                     = 239
	SqlBaseParserRULE_backQuotedIdentifier                 = 240
	SqlBaseParserRULE_number                               = 241
	SqlBaseParserRULE_columnConstraintDefinition           = 242
	SqlBaseParserRULE_columnConstraint                     = 243
	SqlBaseParserRULE_tableConstraintDefinition            = 244
	SqlBaseParserRULE_tableConstraint                      = 245
	SqlBaseParserRULE_checkConstraint                      = 246
	SqlBaseParserRULE_uniqueSpec                           = 247
	SqlBaseParserRULE_uniqueConstraint                     = 248
	SqlBaseParserRULE_referenceSpec                        = 249
	SqlBaseParserRULE_foreignKeyConstraint                 = 250
	SqlBaseParserRULE_constraintCharacteristic             = 251
	SqlBaseParserRULE_enforcedCharacteristic               = 252
	SqlBaseParserRULE_relyCharacteristic                   = 253
	SqlBaseParserRULE_alterColumnSpecList                  = 254
	SqlBaseParserRULE_alterColumnSpec                      = 255
	SqlBaseParserRULE_alterColumnAction                    = 256
	SqlBaseParserRULE_stringLit                            = 257
	SqlBaseParserRULE_comment                              = 258
	SqlBaseParserRULE_version                              = 259
	SqlBaseParserRULE_operatorPipeRightSide                = 260
	SqlBaseParserRULE_operatorPipeSetAssignmentSeq         = 261
	SqlBaseParserRULE_ansiNonReserved                      = 262
	SqlBaseParserRULE_strictNonReserved                    = 263
	SqlBaseParserRULE_nonReserved                          = 264
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllCompoundOrSingleStatement() []ICompoundOrSingleStatementContext
	CompoundOrSingleStatement(i int) ICompoundOrSingleStatementContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *ProgramContext) AllCompoundOrSingleStatement() []ICompoundOrSingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompoundOrSingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ICompoundOrSingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompoundOrSingleStatementContext); ok {
			tst[i] = t.(ICompoundOrSingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) CompoundOrSingleStatement(i int) ICompoundOrSingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundOrSingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundOrSingleStatementContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *SqlBaseParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SqlBaseParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1730508981585093126) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&13511351662018561) != 0) || ((int64((_la-143)) & ^0x3f) == 0 && ((int64(1)<<(_la-143))&684547143897710657) != 0) || ((int64((_la-208)) & ^0x3f) == 0 && ((int64(1)<<(_la-208))&16401) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-9222245844621180123) != 0) || ((int64((_la-355)) & ^0x3f) == 0 && ((int64(1)<<(_la-355))&2199096795393) != 0) {
		{
			p.SetState(530)
			p.CompoundOrSingleStatement()
		}

		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(535)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundOrSingleStatementContext is an interface to support dynamic dispatch.
type ICompoundOrSingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleStatement() ISingleStatementContext
	SingleCompoundStatement() ISingleCompoundStatementContext

	// IsCompoundOrSingleStatementContext differentiates from other interfaces.
	IsCompoundOrSingleStatementContext()
}

type CompoundOrSingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundOrSingleStatementContext() *CompoundOrSingleStatementContext {
	var p = new(CompoundOrSingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_compoundOrSingleStatement
	return p
}

func InitEmptyCompoundOrSingleStatementContext(p *CompoundOrSingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_compoundOrSingleStatement
}

func (*CompoundOrSingleStatementContext) IsCompoundOrSingleStatementContext() {}

func NewCompoundOrSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundOrSingleStatementContext {
	var p = new(CompoundOrSingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_compoundOrSingleStatement

	return p
}

func (s *CompoundOrSingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundOrSingleStatementContext) SingleStatement() ISingleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *CompoundOrSingleStatementContext) SingleCompoundStatement() ISingleCompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleCompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleCompoundStatementContext)
}

func (s *CompoundOrSingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundOrSingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundOrSingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCompoundOrSingleStatement(s)
	}
}

func (s *CompoundOrSingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCompoundOrSingleStatement(s)
	}
}

func (p *SqlBaseParser) CompoundOrSingleStatement() (localctx ICompoundOrSingleStatementContext) {
	localctx = NewCompoundOrSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SqlBaseParserRULE_compoundOrSingleStatement)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSEMICOLON, SqlBaseParserLEFT_PAREN, SqlBaseParserADD, SqlBaseParserALTER, SqlBaseParserANALYZE, SqlBaseParserCACHE, SqlBaseParserCALL, SqlBaseParserCLEAR, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCREATE, SqlBaseParserDECLARE, SqlBaseParserDELETE, SqlBaseParserDESC, SqlBaseParserDESCRIBE, SqlBaseParserDFS, SqlBaseParserDROP, SqlBaseParserEXPLAIN, SqlBaseParserEXPORT, SqlBaseParserFROM, SqlBaseParserGRANT, SqlBaseParserIMPORT, SqlBaseParserINSERT, SqlBaseParserLIST, SqlBaseParserLOAD, SqlBaseParserLOCK, SqlBaseParserMAP, SqlBaseParserMERGE, SqlBaseParserMSCK, SqlBaseParserREDUCE, SqlBaseParserREFRESH, SqlBaseParserREPAIR, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserREVOKE, SqlBaseParserROLLBACK, SqlBaseParserSELECT, SqlBaseParserSET, SqlBaseParserSHOW, SqlBaseParserSTART, SqlBaseParserTABLE, SqlBaseParserEXECUTE, SqlBaseParserTRUNCATE, SqlBaseParserUNCACHE, SqlBaseParserUNLOCK, SqlBaseParserUPDATE, SqlBaseParserUSE, SqlBaseParserVALUES, SqlBaseParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.SingleStatement()
		}

	case SqlBaseParserBEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.SingleCompoundStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleCompoundStatementContext is an interface to support dynamic dispatch.
type ISingleCompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	END() antlr.TerminalNode
	NOT() antlr.TerminalNode
	ATOMIC() antlr.TerminalNode
	CompoundBody() ICompoundBodyContext
	SEMICOLON() antlr.TerminalNode

	// IsSingleCompoundStatementContext differentiates from other interfaces.
	IsSingleCompoundStatementContext()
}

type SingleCompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleCompoundStatementContext() *SingleCompoundStatementContext {
	var p = new(SingleCompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleCompoundStatement
	return p
}

func InitEmptySingleCompoundStatementContext(p *SingleCompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleCompoundStatement
}

func (*SingleCompoundStatementContext) IsSingleCompoundStatementContext() {}

func NewSingleCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleCompoundStatementContext {
	var p = new(SingleCompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleCompoundStatement

	return p
}

func (s *SingleCompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleCompoundStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBEGIN, 0)
}

func (s *SingleCompoundStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SingleCompoundStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *SingleCompoundStatementContext) ATOMIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserATOMIC, 0)
}

func (s *SingleCompoundStatementContext) CompoundBody() ICompoundBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *SingleCompoundStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEMICOLON, 0)
}

func (s *SingleCompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleCompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleCompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleCompoundStatement(s)
	}
}

func (s *SingleCompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleCompoundStatement(s)
	}
}

func (p *SqlBaseParser) SingleCompoundStatement() (localctx ISingleCompoundStatementContext) {
	localctx = NewSingleCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SqlBaseParserRULE_singleCompoundStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(SqlBaseParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(544)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(542)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(543)
			p.Match(SqlBaseParserATOMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(546)
			p.CompoundBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(549)
		p.Match(SqlBaseParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(550)
			p.Match(SqlBaseParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginEndCompoundBlockContext is an interface to support dynamic dispatch.
type IBeginEndCompoundBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	END() antlr.TerminalNode
	BeginLabel() IBeginLabelContext
	NOT() antlr.TerminalNode
	ATOMIC() antlr.TerminalNode
	CompoundBody() ICompoundBodyContext
	EndLabel() IEndLabelContext

	// IsBeginEndCompoundBlockContext differentiates from other interfaces.
	IsBeginEndCompoundBlockContext()
}

type BeginEndCompoundBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginEndCompoundBlockContext() *BeginEndCompoundBlockContext {
	var p = new(BeginEndCompoundBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_beginEndCompoundBlock
	return p
}

func InitEmptyBeginEndCompoundBlockContext(p *BeginEndCompoundBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_beginEndCompoundBlock
}

func (*BeginEndCompoundBlockContext) IsBeginEndCompoundBlockContext() {}

func NewBeginEndCompoundBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginEndCompoundBlockContext {
	var p = new(BeginEndCompoundBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_beginEndCompoundBlock

	return p
}

func (s *BeginEndCompoundBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginEndCompoundBlockContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBEGIN, 0)
}

func (s *BeginEndCompoundBlockContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *BeginEndCompoundBlockContext) BeginLabel() IBeginLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginLabelContext)
}

func (s *BeginEndCompoundBlockContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *BeginEndCompoundBlockContext) ATOMIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserATOMIC, 0)
}

func (s *BeginEndCompoundBlockContext) CompoundBody() ICompoundBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *BeginEndCompoundBlockContext) EndLabel() IEndLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndLabelContext)
}

func (s *BeginEndCompoundBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginEndCompoundBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginEndCompoundBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBeginEndCompoundBlock(s)
	}
}

func (s *BeginEndCompoundBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBeginEndCompoundBlock(s)
	}
}

func (p *SqlBaseParser) BeginEndCompoundBlock() (localctx IBeginEndCompoundBlockContext) {
	localctx = NewBeginEndCompoundBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SqlBaseParserRULE_beginEndCompoundBlock)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(554)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(553)
			p.BeginLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(556)
		p.Match(SqlBaseParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(557)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)
			p.Match(SqlBaseParserATOMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(561)
			p.CompoundBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(564)
		p.Match(SqlBaseParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(565)
			p.EndLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundBodyContext is an interface to support dynamic dispatch.
type ICompoundBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_compoundStatement returns the _compoundStatement rule contexts.
	Get_compoundStatement() ICompoundStatementContext

	// Set_compoundStatement sets the _compoundStatement rule contexts.
	Set_compoundStatement(ICompoundStatementContext)

	// GetCompoundStatements returns the compoundStatements rule context list.
	GetCompoundStatements() []ICompoundStatementContext

	// SetCompoundStatements sets the compoundStatements rule context list.
	SetCompoundStatements([]ICompoundStatementContext)

	// Getter signatures
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllCompoundStatement() []ICompoundStatementContext
	CompoundStatement(i int) ICompoundStatementContext

	// IsCompoundBodyContext differentiates from other interfaces.
	IsCompoundBodyContext()
}

type CompoundBodyContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	_compoundStatement ICompoundStatementContext
	compoundStatements []ICompoundStatementContext
}

func NewEmptyCompoundBodyContext() *CompoundBodyContext {
	var p = new(CompoundBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_compoundBody
	return p
}

func InitEmptyCompoundBodyContext(p *CompoundBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_compoundBody
}

func (*CompoundBodyContext) IsCompoundBodyContext() {}

func NewCompoundBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundBodyContext {
	var p = new(CompoundBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_compoundBody

	return p
}

func (s *CompoundBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundBodyContext) Get_compoundStatement() ICompoundStatementContext {
	return s._compoundStatement
}

func (s *CompoundBodyContext) Set_compoundStatement(v ICompoundStatementContext) {
	s._compoundStatement = v
}

func (s *CompoundBodyContext) GetCompoundStatements() []ICompoundStatementContext {
	return s.compoundStatements
}

func (s *CompoundBodyContext) SetCompoundStatements(v []ICompoundStatementContext) {
	s.compoundStatements = v
}

func (s *CompoundBodyContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserSEMICOLON)
}

func (s *CompoundBodyContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEMICOLON, i)
}

func (s *CompoundBodyContext) AllCompoundStatement() []ICompoundStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			len++
		}
	}

	tst := make([]ICompoundStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompoundStatementContext); ok {
			tst[i] = t.(ICompoundStatementContext)
			i++
		}
	}

	return tst
}

func (s *CompoundBodyContext) CompoundStatement(i int) ICompoundStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CompoundBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCompoundBody(s)
	}
}

func (s *CompoundBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCompoundBody(s)
	}
}

func (p *SqlBaseParser) CompoundBody() (localctx ICompoundBodyContext) {
	localctx = NewCompoundBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SqlBaseParserRULE_compoundBody)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(568)

				var _x = p.CompoundStatement()

				localctx.(*CompoundBodyContext)._compoundStatement = _x
			}
			localctx.(*CompoundBodyContext).compoundStatements = append(localctx.(*CompoundBodyContext).compoundStatements, localctx.(*CompoundBodyContext)._compoundStatement)
			{
				p.SetState(569)
				p.Match(SqlBaseParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclareConditionStatement() IDeclareConditionStatementContext
	Statement() IStatementContext
	SetStatementInsideSqlScript() ISetStatementInsideSqlScriptContext
	BeginEndCompoundBlock() IBeginEndCompoundBlockContext
	DeclareHandlerStatement() IDeclareHandlerStatementContext
	IfElseStatement() IIfElseStatementContext
	CaseStatement() ICaseStatementContext
	WhileStatement() IWhileStatementContext
	RepeatStatement() IRepeatStatementContext
	LeaveStatement() ILeaveStatementContext
	IterateStatement() IIterateStatementContext
	LoopStatement() ILoopStatementContext
	ForStatement() IForStatementContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) DeclareConditionStatement() IDeclareConditionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareConditionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareConditionStatementContext)
}

func (s *CompoundStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CompoundStatementContext) SetStatementInsideSqlScript() ISetStatementInsideSqlScriptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementInsideSqlScriptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementInsideSqlScriptContext)
}

func (s *CompoundStatementContext) BeginEndCompoundBlock() IBeginEndCompoundBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginEndCompoundBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginEndCompoundBlockContext)
}

func (s *CompoundStatementContext) DeclareHandlerStatement() IDeclareHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareHandlerStatementContext)
}

func (s *CompoundStatementContext) IfElseStatement() IIfElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfElseStatementContext)
}

func (s *CompoundStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *CompoundStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *CompoundStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *CompoundStatementContext) LeaveStatement() ILeaveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeaveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeaveStatementContext)
}

func (s *CompoundStatementContext) IterateStatement() IIterateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterateStatementContext)
}

func (s *CompoundStatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *CompoundStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (p *SqlBaseParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SqlBaseParserRULE_compoundStatement)
	p.SetState(588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(575)
			p.DeclareConditionStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(576)
			p.Statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(577)
			p.SetStatementInsideSqlScript()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(578)
			p.BeginEndCompoundBlock()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(579)
			p.DeclareHandlerStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(580)
			p.IfElseStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(581)
			p.CaseStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(582)
			p.WhileStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(583)
			p.RepeatStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(584)
			p.LeaveStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(585)
			p.IterateStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(586)
			p.LoopStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(587)
			p.ForStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementInsideSqlScriptContext is an interface to support dynamic dispatch.
type ISetStatementInsideSqlScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetStatementInsideSqlScriptContext differentiates from other interfaces.
	IsSetStatementInsideSqlScriptContext()
}

type SetStatementInsideSqlScriptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementInsideSqlScriptContext() *SetStatementInsideSqlScriptContext {
	var p = new(SetStatementInsideSqlScriptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setStatementInsideSqlScript
	return p
}

func InitEmptySetStatementInsideSqlScriptContext(p *SetStatementInsideSqlScriptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setStatementInsideSqlScript
}

func (*SetStatementInsideSqlScriptContext) IsSetStatementInsideSqlScriptContext() {}

func NewSetStatementInsideSqlScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementInsideSqlScriptContext {
	var p = new(SetStatementInsideSqlScriptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_setStatementInsideSqlScript

	return p
}

func (s *SetStatementInsideSqlScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementInsideSqlScriptContext) CopyAll(ctx *SetStatementInsideSqlScriptContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetStatementInsideSqlScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementInsideSqlScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetVariableInsideSqlScriptContext struct {
	SetStatementInsideSqlScriptContext
}

func NewSetVariableInsideSqlScriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableInsideSqlScriptContext {
	var p = new(SetVariableInsideSqlScriptContext)

	InitEmptySetStatementInsideSqlScriptContext(&p.SetStatementInsideSqlScriptContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementInsideSqlScriptContext))

	return p
}

func (s *SetVariableInsideSqlScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableInsideSqlScriptContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetVariableInsideSqlScriptContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *SetVariableInsideSqlScriptContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *SetVariableInsideSqlScriptContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *SetVariableInsideSqlScriptContext) MultipartIdentifierList() IMultipartIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierListContext)
}

func (s *SetVariableInsideSqlScriptContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *SetVariableInsideSqlScriptContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *SetVariableInsideSqlScriptContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetVariableInsideSqlScriptContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SetVariableInsideSqlScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetVariableInsideSqlScript(s)
	}
}

func (s *SetVariableInsideSqlScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetVariableInsideSqlScript(s)
	}
}

func (p *SqlBaseParser) SetStatementInsideSqlScript() (localctx ISetStatementInsideSqlScriptContext) {
	localctx = NewSetStatementInsideSqlScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SqlBaseParserRULE_setStatementInsideSqlScript)
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetVariableInsideSqlScriptContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(590)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(591)
			p.AssignmentList()
		}

	case 2:
		localctx = NewSetVariableInsideSqlScriptContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(592)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(593)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)
			p.MultipartIdentifierList()
		}
		{
			p.SetState(595)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(596)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(597)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(598)
			p.Query()
		}
		{
			p.SetState(599)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStateValueContext is an interface to support dynamic dispatch.
type ISqlStateValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLit() IStringLitContext

	// IsSqlStateValueContext differentiates from other interfaces.
	IsSqlStateValueContext()
}

type SqlStateValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStateValueContext() *SqlStateValueContext {
	var p = new(SqlStateValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sqlStateValue
	return p
}

func InitEmptySqlStateValueContext(p *SqlStateValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sqlStateValue
}

func (*SqlStateValueContext) IsSqlStateValueContext() {}

func NewSqlStateValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStateValueContext {
	var p = new(SqlStateValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sqlStateValue

	return p
}

func (s *SqlStateValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStateValueContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *SqlStateValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStateValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStateValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSqlStateValue(s)
	}
}

func (s *SqlStateValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSqlStateValue(s)
	}
}

func (p *SqlBaseParser) SqlStateValue() (localctx ISqlStateValueContext) {
	localctx = NewSqlStateValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SqlBaseParserRULE_sqlStateValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.StringLit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareConditionStatementContext is an interface to support dynamic dispatch.
type IDeclareConditionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	CONDITION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	SQLSTATE() antlr.TerminalNode
	SqlStateValue() ISqlStateValueContext
	VALUE() antlr.TerminalNode

	// IsDeclareConditionStatementContext differentiates from other interfaces.
	IsDeclareConditionStatementContext()
}

type DeclareConditionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareConditionStatementContext() *DeclareConditionStatementContext {
	var p = new(DeclareConditionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_declareConditionStatement
	return p
}

func InitEmptyDeclareConditionStatementContext(p *DeclareConditionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_declareConditionStatement
}

func (*DeclareConditionStatementContext) IsDeclareConditionStatementContext() {}

func NewDeclareConditionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareConditionStatementContext {
	var p = new(DeclareConditionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_declareConditionStatement

	return p
}

func (s *DeclareConditionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareConditionStatementContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECLARE, 0)
}

func (s *DeclareConditionStatementContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DeclareConditionStatementContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONDITION, 0)
}

func (s *DeclareConditionStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *DeclareConditionStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQLSTATE, 0)
}

func (s *DeclareConditionStatementContext) SqlStateValue() ISqlStateValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStateValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStateValueContext)
}

func (s *DeclareConditionStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUE, 0)
}

func (s *DeclareConditionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareConditionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareConditionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDeclareConditionStatement(s)
	}
}

func (s *DeclareConditionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDeclareConditionStatement(s)
	}
}

func (p *SqlBaseParser) DeclareConditionStatement() (localctx IDeclareConditionStatementContext) {
	localctx = NewDeclareConditionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SqlBaseParserRULE_declareConditionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Match(SqlBaseParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(606)
		p.MultipartIdentifier()
	}
	{
		p.SetState(607)
		p.Match(SqlBaseParserCONDITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserFOR {
		{
			p.SetState(608)
			p.Match(SqlBaseParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(609)
			p.Match(SqlBaseParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(611)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(610)
				p.Match(SqlBaseParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(613)
			p.SqlStateValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionValueContext is an interface to support dynamic dispatch.
type IConditionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SQLSTATE() antlr.TerminalNode
	SqlStateValue() ISqlStateValueContext
	VALUE() antlr.TerminalNode
	SQLEXCEPTION() antlr.TerminalNode
	NOT() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsConditionValueContext differentiates from other interfaces.
	IsConditionValueContext()
}

type ConditionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionValueContext() *ConditionValueContext {
	var p = new(ConditionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_conditionValue
	return p
}

func InitEmptyConditionValueContext(p *ConditionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_conditionValue
}

func (*ConditionValueContext) IsConditionValueContext() {}

func NewConditionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionValueContext {
	var p = new(ConditionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_conditionValue

	return p
}

func (s *ConditionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionValueContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQLSTATE, 0)
}

func (s *ConditionValueContext) SqlStateValue() ISqlStateValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStateValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStateValueContext)
}

func (s *ConditionValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUE, 0)
}

func (s *ConditionValueContext) SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQLEXCEPTION, 0)
}

func (s *ConditionValueContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *ConditionValueContext) FOUND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOUND, 0)
}

func (s *ConditionValueContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ConditionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterConditionValue(s)
	}
}

func (s *ConditionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitConditionValue(s)
	}
}

func (p *SqlBaseParser) ConditionValue() (localctx IConditionValueContext) {
	localctx = NewConditionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SqlBaseParserRULE_conditionValue)
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.Match(SqlBaseParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(617)
				p.Match(SqlBaseParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(620)
			p.SqlStateValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(621)
			p.Match(SqlBaseParserSQLEXCEPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(622)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(623)
			p.Match(SqlBaseParserFOUND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(624)
			p.MultipartIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionValuesContext is an interface to support dynamic dispatch.
type IConditionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_conditionValue returns the _conditionValue rule contexts.
	Get_conditionValue() IConditionValueContext

	// Set_conditionValue sets the _conditionValue rule contexts.
	Set_conditionValue(IConditionValueContext)

	// GetCvList returns the cvList rule context list.
	GetCvList() []IConditionValueContext

	// SetCvList sets the cvList rule context list.
	SetCvList([]IConditionValueContext)

	// Getter signatures
	AllConditionValue() []IConditionValueContext
	ConditionValue(i int) IConditionValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConditionValuesContext differentiates from other interfaces.
	IsConditionValuesContext()
}

type ConditionValuesContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_conditionValue IConditionValueContext
	cvList          []IConditionValueContext
}

func NewEmptyConditionValuesContext() *ConditionValuesContext {
	var p = new(ConditionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_conditionValues
	return p
}

func InitEmptyConditionValuesContext(p *ConditionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_conditionValues
}

func (*ConditionValuesContext) IsConditionValuesContext() {}

func NewConditionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionValuesContext {
	var p = new(ConditionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_conditionValues

	return p
}

func (s *ConditionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionValuesContext) Get_conditionValue() IConditionValueContext {
	return s._conditionValue
}

func (s *ConditionValuesContext) Set_conditionValue(v IConditionValueContext) { s._conditionValue = v }

func (s *ConditionValuesContext) GetCvList() []IConditionValueContext { return s.cvList }

func (s *ConditionValuesContext) SetCvList(v []IConditionValueContext) { s.cvList = v }

func (s *ConditionValuesContext) AllConditionValue() []IConditionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionValueContext); ok {
			len++
		}
	}

	tst := make([]IConditionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionValueContext); ok {
			tst[i] = t.(IConditionValueContext)
			i++
		}
	}

	return tst
}

func (s *ConditionValuesContext) ConditionValue(i int) IConditionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionValueContext)
}

func (s *ConditionValuesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ConditionValuesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ConditionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterConditionValues(s)
	}
}

func (s *ConditionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitConditionValues(s)
	}
}

func (p *SqlBaseParser) ConditionValues() (localctx IConditionValuesContext) {
	localctx = NewConditionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SqlBaseParserRULE_conditionValues)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)

		var _x = p.ConditionValue()

		localctx.(*ConditionValuesContext)._conditionValue = _x
	}
	localctx.(*ConditionValuesContext).cvList = append(localctx.(*ConditionValuesContext).cvList, localctx.(*ConditionValuesContext)._conditionValue)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(628)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(629)

				var _x = p.ConditionValue()

				localctx.(*ConditionValuesContext)._conditionValue = _x
			}
			localctx.(*ConditionValuesContext).cvList = append(localctx.(*ConditionValuesContext).cvList, localctx.(*ConditionValuesContext)._conditionValue)

		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareHandlerStatementContext is an interface to support dynamic dispatch.
type IDeclareHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	ConditionValues() IConditionValuesContext
	CONTINUE() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	BeginEndCompoundBlock() IBeginEndCompoundBlockContext
	Statement() IStatementContext
	SetStatementInsideSqlScript() ISetStatementInsideSqlScriptContext

	// IsDeclareHandlerStatementContext differentiates from other interfaces.
	IsDeclareHandlerStatementContext()
}

type DeclareHandlerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareHandlerStatementContext() *DeclareHandlerStatementContext {
	var p = new(DeclareHandlerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_declareHandlerStatement
	return p
}

func InitEmptyDeclareHandlerStatementContext(p *DeclareHandlerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_declareHandlerStatement
}

func (*DeclareHandlerStatementContext) IsDeclareHandlerStatementContext() {}

func NewDeclareHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareHandlerStatementContext {
	var p = new(DeclareHandlerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_declareHandlerStatement

	return p
}

func (s *DeclareHandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareHandlerStatementContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECLARE, 0)
}

func (s *DeclareHandlerStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHANDLER, 0)
}

func (s *DeclareHandlerStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *DeclareHandlerStatementContext) ConditionValues() IConditionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionValuesContext)
}

func (s *DeclareHandlerStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONTINUE, 0)
}

func (s *DeclareHandlerStatementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXIT, 0)
}

func (s *DeclareHandlerStatementContext) BeginEndCompoundBlock() IBeginEndCompoundBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginEndCompoundBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginEndCompoundBlockContext)
}

func (s *DeclareHandlerStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DeclareHandlerStatementContext) SetStatementInsideSqlScript() ISetStatementInsideSqlScriptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementInsideSqlScriptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementInsideSqlScriptContext)
}

func (s *DeclareHandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareHandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareHandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDeclareHandlerStatement(s)
	}
}

func (s *DeclareHandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDeclareHandlerStatement(s)
	}
}

func (p *SqlBaseParser) DeclareHandlerStatement() (localctx IDeclareHandlerStatementContext) {
	localctx = NewDeclareHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SqlBaseParserRULE_declareHandlerStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Match(SqlBaseParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(636)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserCONTINUE || _la == SqlBaseParserEXIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(637)
		p.Match(SqlBaseParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(638)
		p.Match(SqlBaseParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(639)
		p.ConditionValues()
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(640)
			p.BeginEndCompoundBlock()
		}

	case 2:
		{
			p.SetState(641)
			p.Statement()
		}

	case 3:
		{
			p.SetState(642)
			p.SetStatementInsideSqlScript()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWHILE() []antlr.TerminalNode
	WHILE(i int) antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	DO() antlr.TerminalNode
	CompoundBody() ICompoundBodyContext
	END() antlr.TerminalNode
	BeginLabel() IBeginLabelContext
	EndLabel() IEndLabelContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) AllWHILE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserWHILE)
}

func (s *WhileStatementContext) WHILE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHILE, i)
}

func (s *WhileStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDO, 0)
}

func (s *WhileStatementContext) CompoundBody() ICompoundBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *WhileStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *WhileStatementContext) BeginLabel() IBeginLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginLabelContext)
}

func (s *WhileStatementContext) EndLabel() IEndLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndLabelContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *SqlBaseParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SqlBaseParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(646)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(645)
			p.BeginLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(648)
		p.Match(SqlBaseParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(649)
		p.booleanExpression(0)
	}
	{
		p.SetState(650)
		p.Match(SqlBaseParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(651)
		p.CompoundBody()
	}
	{
		p.SetState(652)
		p.Match(SqlBaseParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.Match(SqlBaseParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(655)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(654)
			p.EndLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfElseStatementContext is an interface to support dynamic dispatch.
type IIfElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_compoundBody returns the _compoundBody rule contexts.
	Get_compoundBody() ICompoundBodyContext

	// GetElseBody returns the elseBody rule contexts.
	GetElseBody() ICompoundBodyContext

	// Set_compoundBody sets the _compoundBody rule contexts.
	Set_compoundBody(ICompoundBodyContext)

	// SetElseBody sets the elseBody rule contexts.
	SetElseBody(ICompoundBodyContext)

	// GetConditionalBodies returns the conditionalBodies rule context list.
	GetConditionalBodies() []ICompoundBodyContext

	// SetConditionalBodies sets the conditionalBodies rule context list.
	SetConditionalBodies([]ICompoundBodyContext)

	// Getter signatures
	AllIF() []antlr.TerminalNode
	IF(i int) antlr.TerminalNode
	AllBooleanExpression() []IBooleanExpressionContext
	BooleanExpression(i int) IBooleanExpressionContext
	AllTHEN() []antlr.TerminalNode
	THEN(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	AllCompoundBody() []ICompoundBodyContext
	CompoundBody(i int) ICompoundBodyContext
	AllELSEIF() []antlr.TerminalNode
	ELSEIF(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsIfElseStatementContext differentiates from other interfaces.
	IsIfElseStatementContext()
}

type IfElseStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	_compoundBody     ICompoundBodyContext
	conditionalBodies []ICompoundBodyContext
	elseBody          ICompoundBodyContext
}

func NewEmptyIfElseStatementContext() *IfElseStatementContext {
	var p = new(IfElseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_ifElseStatement
	return p
}

func InitEmptyIfElseStatementContext(p *IfElseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_ifElseStatement
}

func (*IfElseStatementContext) IsIfElseStatementContext() {}

func NewIfElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseStatementContext {
	var p = new(IfElseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_ifElseStatement

	return p
}

func (s *IfElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseStatementContext) Get_compoundBody() ICompoundBodyContext { return s._compoundBody }

func (s *IfElseStatementContext) GetElseBody() ICompoundBodyContext { return s.elseBody }

func (s *IfElseStatementContext) Set_compoundBody(v ICompoundBodyContext) { s._compoundBody = v }

func (s *IfElseStatementContext) SetElseBody(v ICompoundBodyContext) { s.elseBody = v }

func (s *IfElseStatementContext) GetConditionalBodies() []ICompoundBodyContext {
	return s.conditionalBodies
}

func (s *IfElseStatementContext) SetConditionalBodies(v []ICompoundBodyContext) {
	s.conditionalBodies = v
}

func (s *IfElseStatementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserIF)
}

func (s *IfElseStatementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, i)
}

func (s *IfElseStatementContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IfElseStatementContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *IfElseStatementContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTHEN)
}

func (s *IfElseStatementContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, i)
}

func (s *IfElseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *IfElseStatementContext) AllCompoundBody() []ICompoundBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			len++
		}
	}

	tst := make([]ICompoundBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompoundBodyContext); ok {
			tst[i] = t.(ICompoundBodyContext)
			i++
		}
	}

	return tst
}

func (s *IfElseStatementContext) CompoundBody(i int) ICompoundBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *IfElseStatementContext) AllELSEIF() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserELSEIF)
}

func (s *IfElseStatementContext) ELSEIF(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSEIF, i)
}

func (s *IfElseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *IfElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIfElseStatement(s)
	}
}

func (s *IfElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIfElseStatement(s)
	}
}

func (p *SqlBaseParser) IfElseStatement() (localctx IIfElseStatementContext) {
	localctx = NewIfElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SqlBaseParserRULE_ifElseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(SqlBaseParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.booleanExpression(0)
	}
	{
		p.SetState(659)
		p.Match(SqlBaseParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(660)

		var _x = p.CompoundBody()

		localctx.(*IfElseStatementContext)._compoundBody = _x
	}
	localctx.(*IfElseStatementContext).conditionalBodies = append(localctx.(*IfElseStatementContext).conditionalBodies, localctx.(*IfElseStatementContext)._compoundBody)
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserELSEIF {
		{
			p.SetState(661)
			p.Match(SqlBaseParserELSEIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(662)
			p.booleanExpression(0)
		}
		{
			p.SetState(663)
			p.Match(SqlBaseParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(664)

			var _x = p.CompoundBody()

			localctx.(*IfElseStatementContext)._compoundBody = _x
		}
		localctx.(*IfElseStatementContext).conditionalBodies = append(localctx.(*IfElseStatementContext).conditionalBodies, localctx.(*IfElseStatementContext)._compoundBody)

		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserELSE {
		{
			p.SetState(671)
			p.Match(SqlBaseParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(672)

			var _x = p.CompoundBody()

			localctx.(*IfElseStatementContext).elseBody = _x
		}

	}
	{
		p.SetState(675)
		p.Match(SqlBaseParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(676)
		p.Match(SqlBaseParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllREPEAT() []antlr.TerminalNode
	REPEAT(i int) antlr.TerminalNode
	CompoundBody() ICompoundBodyContext
	UNTIL() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	END() antlr.TerminalNode
	BeginLabel() IBeginLabelContext
	EndLabel() IEndLabelContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) AllREPEAT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserREPEAT)
}

func (s *RepeatStatementContext) REPEAT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEAT, i)
}

func (s *RepeatStatementContext) CompoundBody() ICompoundBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNTIL, 0)
}

func (s *RepeatStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *RepeatStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *RepeatStatementContext) BeginLabel() IBeginLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginLabelContext)
}

func (s *RepeatStatementContext) EndLabel() IEndLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndLabelContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (p *SqlBaseParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SqlBaseParserRULE_repeatStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(679)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(678)
			p.BeginLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(681)
		p.Match(SqlBaseParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(682)
		p.CompoundBody()
	}
	{
		p.SetState(683)
		p.Match(SqlBaseParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(684)
		p.booleanExpression(0)
	}
	{
		p.SetState(685)
		p.Match(SqlBaseParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(686)
		p.Match(SqlBaseParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(687)
			p.EndLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeaveStatementContext is an interface to support dynamic dispatch.
type ILeaveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEAVE() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsLeaveStatementContext differentiates from other interfaces.
	IsLeaveStatementContext()
}

type LeaveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeaveStatementContext() *LeaveStatementContext {
	var p = new(LeaveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_leaveStatement
	return p
}

func InitEmptyLeaveStatementContext(p *LeaveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_leaveStatement
}

func (*LeaveStatementContext) IsLeaveStatementContext() {}

func NewLeaveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeaveStatementContext {
	var p = new(LeaveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_leaveStatement

	return p
}

func (s *LeaveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LeaveStatementContext) LEAVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEAVE, 0)
}

func (s *LeaveStatementContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *LeaveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeaveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeaveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLeaveStatement(s)
	}
}

func (p *SqlBaseParser) LeaveStatement() (localctx ILeaveStatementContext) {
	localctx = NewLeaveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SqlBaseParserRULE_leaveStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(SqlBaseParserLEAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(691)
		p.MultipartIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterateStatementContext is an interface to support dynamic dispatch.
type IIterateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ITERATE() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsIterateStatementContext differentiates from other interfaces.
	IsIterateStatementContext()
}

type IterateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterateStatementContext() *IterateStatementContext {
	var p = new(IterateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_iterateStatement
	return p
}

func InitEmptyIterateStatementContext(p *IterateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_iterateStatement
}

func (*IterateStatementContext) IsIterateStatementContext() {}

func NewIterateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterateStatementContext {
	var p = new(IterateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_iterateStatement

	return p
}

func (s *IterateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterateStatementContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserITERATE, 0)
}

func (s *IterateStatementContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *IterateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIterateStatement(s)
	}
}

func (s *IterateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIterateStatement(s)
	}
}

func (p *SqlBaseParser) IterateStatement() (localctx IIterateStatementContext) {
	localctx = NewIterateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SqlBaseParserRULE_iterateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(SqlBaseParserITERATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(694)
		p.MultipartIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CopyAll(ctx *CaseStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleCaseStatementContext struct {
	CaseStatementContext
	caseVariable         IExpressionContext
	_expression          IExpressionContext
	conditionExpressions []IExpressionContext
	_compoundBody        ICompoundBodyContext
	conditionalBodies    []ICompoundBodyContext
	elseBody             ICompoundBodyContext
}

func NewSimpleCaseStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseStatementContext {
	var p = new(SimpleCaseStatementContext)

	InitEmptyCaseStatementContext(&p.CaseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CaseStatementContext))

	return p
}

func (s *SimpleCaseStatementContext) GetCaseVariable() IExpressionContext { return s.caseVariable }

func (s *SimpleCaseStatementContext) Get_expression() IExpressionContext { return s._expression }

func (s *SimpleCaseStatementContext) Get_compoundBody() ICompoundBodyContext { return s._compoundBody }

func (s *SimpleCaseStatementContext) GetElseBody() ICompoundBodyContext { return s.elseBody }

func (s *SimpleCaseStatementContext) SetCaseVariable(v IExpressionContext) { s.caseVariable = v }

func (s *SimpleCaseStatementContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *SimpleCaseStatementContext) Set_compoundBody(v ICompoundBodyContext) { s._compoundBody = v }

func (s *SimpleCaseStatementContext) SetElseBody(v ICompoundBodyContext) { s.elseBody = v }

func (s *SimpleCaseStatementContext) GetConditionExpressions() []IExpressionContext {
	return s.conditionExpressions
}

func (s *SimpleCaseStatementContext) GetConditionalBodies() []ICompoundBodyContext {
	return s.conditionalBodies
}

func (s *SimpleCaseStatementContext) SetConditionExpressions(v []IExpressionContext) {
	s.conditionExpressions = v
}

func (s *SimpleCaseStatementContext) SetConditionalBodies(v []ICompoundBodyContext) {
	s.conditionalBodies = v
}

func (s *SimpleCaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseStatementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCASE)
}

func (s *SimpleCaseStatementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, i)
}

func (s *SimpleCaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SimpleCaseStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseStatementContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserWHEN)
}

func (s *SimpleCaseStatementContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, i)
}

func (s *SimpleCaseStatementContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTHEN)
}

func (s *SimpleCaseStatementContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, i)
}

func (s *SimpleCaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SimpleCaseStatementContext) AllCompoundBody() []ICompoundBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			len++
		}
	}

	tst := make([]ICompoundBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompoundBodyContext); ok {
			tst[i] = t.(ICompoundBodyContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseStatementContext) CompoundBody(i int) ICompoundBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *SimpleCaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSimpleCaseStatement(s)
	}
}

func (s *SimpleCaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSimpleCaseStatement(s)
	}
}

type SearchedCaseStatementContext struct {
	CaseStatementContext
	_booleanExpression IBooleanExpressionContext
	conditions         []IBooleanExpressionContext
	_compoundBody      ICompoundBodyContext
	conditionalBodies  []ICompoundBodyContext
	elseBody           ICompoundBodyContext
}

func NewSearchedCaseStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseStatementContext {
	var p = new(SearchedCaseStatementContext)

	InitEmptyCaseStatementContext(&p.CaseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CaseStatementContext))

	return p
}

func (s *SearchedCaseStatementContext) Get_booleanExpression() IBooleanExpressionContext {
	return s._booleanExpression
}

func (s *SearchedCaseStatementContext) Get_compoundBody() ICompoundBodyContext {
	return s._compoundBody
}

func (s *SearchedCaseStatementContext) GetElseBody() ICompoundBodyContext { return s.elseBody }

func (s *SearchedCaseStatementContext) Set_booleanExpression(v IBooleanExpressionContext) {
	s._booleanExpression = v
}

func (s *SearchedCaseStatementContext) Set_compoundBody(v ICompoundBodyContext) { s._compoundBody = v }

func (s *SearchedCaseStatementContext) SetElseBody(v ICompoundBodyContext) { s.elseBody = v }

func (s *SearchedCaseStatementContext) GetConditions() []IBooleanExpressionContext {
	return s.conditions
}

func (s *SearchedCaseStatementContext) GetConditionalBodies() []ICompoundBodyContext {
	return s.conditionalBodies
}

func (s *SearchedCaseStatementContext) SetConditions(v []IBooleanExpressionContext) { s.conditions = v }

func (s *SearchedCaseStatementContext) SetConditionalBodies(v []ICompoundBodyContext) {
	s.conditionalBodies = v
}

func (s *SearchedCaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseStatementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCASE)
}

func (s *SearchedCaseStatementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, i)
}

func (s *SearchedCaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SearchedCaseStatementContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserWHEN)
}

func (s *SearchedCaseStatementContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, i)
}

func (s *SearchedCaseStatementContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTHEN)
}

func (s *SearchedCaseStatementContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, i)
}

func (s *SearchedCaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SearchedCaseStatementContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseStatementContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *SearchedCaseStatementContext) AllCompoundBody() []ICompoundBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			len++
		}
	}

	tst := make([]ICompoundBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompoundBodyContext); ok {
			tst[i] = t.(ICompoundBodyContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseStatementContext) CompoundBody(i int) ICompoundBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *SearchedCaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSearchedCaseStatement(s)
	}
}

func (s *SearchedCaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSearchedCaseStatement(s)
	}
}

func (p *SqlBaseParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SqlBaseParserRULE_caseStatement)
	var _la int

	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSearchedCaseStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(696)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(697)
				p.Match(SqlBaseParserWHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(698)

				var _x = p.booleanExpression(0)

				localctx.(*SearchedCaseStatementContext)._booleanExpression = _x
			}
			localctx.(*SearchedCaseStatementContext).conditions = append(localctx.(*SearchedCaseStatementContext).conditions, localctx.(*SearchedCaseStatementContext)._booleanExpression)
			{
				p.SetState(699)
				p.Match(SqlBaseParserTHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(700)

				var _x = p.CompoundBody()

				localctx.(*SearchedCaseStatementContext)._compoundBody = _x
			}
			localctx.(*SearchedCaseStatementContext).conditionalBodies = append(localctx.(*SearchedCaseStatementContext).conditionalBodies, localctx.(*SearchedCaseStatementContext)._compoundBody)

			p.SetState(704)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(706)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(707)

				var _x = p.CompoundBody()

				localctx.(*SearchedCaseStatementContext).elseBody = _x
			}

		}
		{
			p.SetState(710)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(711)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSimpleCaseStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(713)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(714)

			var _x = p.Expression()

			localctx.(*SimpleCaseStatementContext).caseVariable = _x
		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(715)
				p.Match(SqlBaseParserWHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(716)

				var _x = p.Expression()

				localctx.(*SimpleCaseStatementContext)._expression = _x
			}
			localctx.(*SimpleCaseStatementContext).conditionExpressions = append(localctx.(*SimpleCaseStatementContext).conditionExpressions, localctx.(*SimpleCaseStatementContext)._expression)
			{
				p.SetState(717)
				p.Match(SqlBaseParserTHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(718)

				var _x = p.CompoundBody()

				localctx.(*SimpleCaseStatementContext)._compoundBody = _x
			}
			localctx.(*SimpleCaseStatementContext).conditionalBodies = append(localctx.(*SimpleCaseStatementContext).conditionalBodies, localctx.(*SimpleCaseStatementContext)._compoundBody)

			p.SetState(722)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(724)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(725)

				var _x = p.CompoundBody()

				localctx.(*SimpleCaseStatementContext).elseBody = _x
			}

		}
		{
			p.SetState(728)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOOP() []antlr.TerminalNode
	LOOP(i int) antlr.TerminalNode
	CompoundBody() ICompoundBodyContext
	END() antlr.TerminalNode
	BeginLabel() IBeginLabelContext
	EndLabel() IEndLabelContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLOOP)
}

func (s *LoopStatementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOOP, i)
}

func (s *LoopStatementContext) CompoundBody() ICompoundBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *LoopStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *LoopStatementContext) BeginLabel() IBeginLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginLabelContext)
}

func (s *LoopStatementContext) EndLabel() IEndLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndLabelContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (p *SqlBaseParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SqlBaseParserRULE_loopStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(734)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(733)
			p.BeginLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(736)
		p.Match(SqlBaseParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(737)
		p.CompoundBody()
	}
	{
		p.SetState(738)
		p.Match(SqlBaseParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(739)
		p.Match(SqlBaseParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(740)
			p.EndLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFOR() []antlr.TerminalNode
	FOR(i int) antlr.TerminalNode
	Query() IQueryContext
	DO() antlr.TerminalNode
	CompoundBody() ICompoundBodyContext
	END() antlr.TerminalNode
	BeginLabel() IBeginLabelContext
	MultipartIdentifier() IMultipartIdentifierContext
	AS() antlr.TerminalNode
	EndLabel() IEndLabelContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserFOR)
}

func (s *ForStatementContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, i)
}

func (s *ForStatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ForStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDO, 0)
}

func (s *ForStatementContext) CompoundBody() ICompoundBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundBodyContext)
}

func (s *ForStatementContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *ForStatementContext) BeginLabel() IBeginLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginLabelContext)
}

func (s *ForStatementContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ForStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *ForStatementContext) EndLabel() IEndLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndLabelContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *SqlBaseParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SqlBaseParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(744)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(743)
			p.BeginLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(746)
		p.Match(SqlBaseParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(750)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(747)
			p.MultipartIdentifier()
		}
		{
			p.SetState(748)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(752)
		p.Query()
	}
	{
		p.SetState(753)
		p.Match(SqlBaseParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(754)
		p.CompoundBody()
	}
	{
		p.SetState(755)
		p.Match(SqlBaseParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(756)
		p.Match(SqlBaseParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(758)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(757)
			p.EndLabel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SetResetStatement() ISetResetStatementContext
	SEMICOLON() antlr.TerminalNode

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) SetResetStatement() ISetResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetResetStatementContext)
}

func (s *SingleStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEMICOLON, 0)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *SqlBaseParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SqlBaseParserRULE_singleStatement)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserLEFT_PAREN, SqlBaseParserADD, SqlBaseParserALTER, SqlBaseParserANALYZE, SqlBaseParserCACHE, SqlBaseParserCALL, SqlBaseParserCLEAR, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCREATE, SqlBaseParserDECLARE, SqlBaseParserDELETE, SqlBaseParserDESC, SqlBaseParserDESCRIBE, SqlBaseParserDFS, SqlBaseParserDROP, SqlBaseParserEXPLAIN, SqlBaseParserEXPORT, SqlBaseParserFROM, SqlBaseParserGRANT, SqlBaseParserIMPORT, SqlBaseParserINSERT, SqlBaseParserLIST, SqlBaseParserLOAD, SqlBaseParserLOCK, SqlBaseParserMAP, SqlBaseParserMERGE, SqlBaseParserMSCK, SqlBaseParserREDUCE, SqlBaseParserREFRESH, SqlBaseParserREPAIR, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserREVOKE, SqlBaseParserROLLBACK, SqlBaseParserSELECT, SqlBaseParserSET, SqlBaseParserSHOW, SqlBaseParserSTART, SqlBaseParserTABLE, SqlBaseParserEXECUTE, SqlBaseParserTRUNCATE, SqlBaseParserUNCACHE, SqlBaseParserUNLOCK, SqlBaseParserUPDATE, SqlBaseParserUSE, SqlBaseParserVALUES, SqlBaseParserWITH:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(760)
				p.Statement()
			}

		case 2:
			{
				p.SetState(761)
				p.SetResetStatement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(764)
				p.Match(SqlBaseParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(767)
			p.Match(SqlBaseParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginLabelContext is an interface to support dynamic dispatch.
type IBeginLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	COLON() antlr.TerminalNode

	// IsBeginLabelContext differentiates from other interfaces.
	IsBeginLabelContext()
}

type BeginLabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginLabelContext() *BeginLabelContext {
	var p = new(BeginLabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_beginLabel
	return p
}

func InitEmptyBeginLabelContext(p *BeginLabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_beginLabel
}

func (*BeginLabelContext) IsBeginLabelContext() {}

func NewBeginLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginLabelContext {
	var p = new(BeginLabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_beginLabel

	return p
}

func (s *BeginLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginLabelContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BeginLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLON, 0)
}

func (s *BeginLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBeginLabel(s)
	}
}

func (s *BeginLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBeginLabel(s)
	}
}

func (p *SqlBaseParser) BeginLabel() (localctx IBeginLabelContext) {
	localctx = NewBeginLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SqlBaseParserRULE_beginLabel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.MultipartIdentifier()
	}
	{
		p.SetState(771)
		p.Match(SqlBaseParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndLabelContext is an interface to support dynamic dispatch.
type IEndLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext

	// IsEndLabelContext differentiates from other interfaces.
	IsEndLabelContext()
}

type EndLabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndLabelContext() *EndLabelContext {
	var p = new(EndLabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_endLabel
	return p
}

func InitEmptyEndLabelContext(p *EndLabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_endLabel
}

func (*EndLabelContext) IsEndLabelContext() {}

func NewEndLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndLabelContext {
	var p = new(EndLabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_endLabel

	return p
}

func (s *EndLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *EndLabelContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *EndLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterEndLabel(s)
	}
}

func (s *EndLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitEndLabel(s)
	}
}

func (p *SqlBaseParser) EndLabel() (localctx IEndLabelContext) {
	localctx = NewEndLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SqlBaseParserRULE_endLabel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.MultipartIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedExpression() INamedExpressionContext
	EOF() antlr.TerminalNode

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleExpression
	return p
}

func InitEmptySingleExpressionContext(p *SingleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleExpression
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) NamedExpression() INamedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *SingleExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleExpression(s)
	}
}

func (s *SingleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleExpression(s)
	}
}

func (p *SqlBaseParser) SingleExpression() (localctx ISingleExpressionContext) {
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SqlBaseParserRULE_singleExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.NamedExpression()
	}
	{
		p.SetState(776)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTableIdentifierContext is an interface to support dynamic dispatch.
type ISingleTableIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableIdentifier() ITableIdentifierContext
	EOF() antlr.TerminalNode

	// IsSingleTableIdentifierContext differentiates from other interfaces.
	IsSingleTableIdentifierContext()
}

type SingleTableIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableIdentifierContext() *SingleTableIdentifierContext {
	var p = new(SingleTableIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleTableIdentifier
	return p
}

func InitEmptySingleTableIdentifierContext(p *SingleTableIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleTableIdentifier
}

func (*SingleTableIdentifierContext) IsSingleTableIdentifierContext() {}

func NewSingleTableIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableIdentifierContext {
	var p = new(SingleTableIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleTableIdentifier

	return p
}

func (s *SingleTableIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableIdentifierContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *SingleTableIdentifierContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleTableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleTableIdentifier(s)
	}
}

func (s *SingleTableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleTableIdentifier(s)
	}
}

func (p *SqlBaseParser) SingleTableIdentifier() (localctx ISingleTableIdentifierContext) {
	localctx = NewSingleTableIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SqlBaseParserRULE_singleTableIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.TableIdentifier()
	}
	{
		p.SetState(779)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleMultipartIdentifierContext is an interface to support dynamic dispatch.
type ISingleMultipartIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	EOF() antlr.TerminalNode

	// IsSingleMultipartIdentifierContext differentiates from other interfaces.
	IsSingleMultipartIdentifierContext()
}

type SingleMultipartIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleMultipartIdentifierContext() *SingleMultipartIdentifierContext {
	var p = new(SingleMultipartIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleMultipartIdentifier
	return p
}

func InitEmptySingleMultipartIdentifierContext(p *SingleMultipartIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleMultipartIdentifier
}

func (*SingleMultipartIdentifierContext) IsSingleMultipartIdentifierContext() {}

func NewSingleMultipartIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleMultipartIdentifierContext {
	var p = new(SingleMultipartIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleMultipartIdentifier

	return p
}

func (s *SingleMultipartIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleMultipartIdentifierContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *SingleMultipartIdentifierContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleMultipartIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleMultipartIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleMultipartIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleMultipartIdentifier(s)
	}
}

func (s *SingleMultipartIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleMultipartIdentifier(s)
	}
}

func (p *SqlBaseParser) SingleMultipartIdentifier() (localctx ISingleMultipartIdentifierContext) {
	localctx = NewSingleMultipartIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SqlBaseParserRULE_singleMultipartIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.MultipartIdentifier()
	}
	{
		p.SetState(782)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleFunctionIdentifierContext is an interface to support dynamic dispatch.
type ISingleFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionIdentifier() IFunctionIdentifierContext
	EOF() antlr.TerminalNode

	// IsSingleFunctionIdentifierContext differentiates from other interfaces.
	IsSingleFunctionIdentifierContext()
}

type SingleFunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleFunctionIdentifierContext() *SingleFunctionIdentifierContext {
	var p = new(SingleFunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleFunctionIdentifier
	return p
}

func InitEmptySingleFunctionIdentifierContext(p *SingleFunctionIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleFunctionIdentifier
}

func (*SingleFunctionIdentifierContext) IsSingleFunctionIdentifierContext() {}

func NewSingleFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleFunctionIdentifierContext {
	var p = new(SingleFunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleFunctionIdentifier

	return p
}

func (s *SingleFunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleFunctionIdentifierContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *SingleFunctionIdentifierContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleFunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleFunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleFunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleFunctionIdentifier(s)
	}
}

func (s *SingleFunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleFunctionIdentifier(s)
	}
}

func (p *SqlBaseParser) SingleFunctionIdentifier() (localctx ISingleFunctionIdentifierContext) {
	localctx = NewSingleFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SqlBaseParserRULE_singleFunctionIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.FunctionIdentifier()
	}
	{
		p.SetState(785)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleDataTypeContext is an interface to support dynamic dispatch.
type ISingleDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	EOF() antlr.TerminalNode

	// IsSingleDataTypeContext differentiates from other interfaces.
	IsSingleDataTypeContext()
}

type SingleDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleDataTypeContext() *SingleDataTypeContext {
	var p = new(SingleDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleDataType
	return p
}

func InitEmptySingleDataTypeContext(p *SingleDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleDataType
}

func (*SingleDataTypeContext) IsSingleDataTypeContext() {}

func NewSingleDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleDataTypeContext {
	var p = new(SingleDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleDataType

	return p
}

func (s *SingleDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleDataTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *SingleDataTypeContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleDataType(s)
	}
}

func (s *SingleDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleDataType(s)
	}
}

func (p *SqlBaseParser) SingleDataType() (localctx ISingleDataTypeContext) {
	localctx = NewSingleDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SqlBaseParserRULE_singleDataType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.DataType()
	}
	{
		p.SetState(788)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTableSchemaContext is an interface to support dynamic dispatch.
type ISingleTableSchemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColTypeList() IColTypeListContext
	EOF() antlr.TerminalNode

	// IsSingleTableSchemaContext differentiates from other interfaces.
	IsSingleTableSchemaContext()
}

type SingleTableSchemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableSchemaContext() *SingleTableSchemaContext {
	var p = new(SingleTableSchemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleTableSchema
	return p
}

func InitEmptySingleTableSchemaContext(p *SingleTableSchemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleTableSchema
}

func (*SingleTableSchemaContext) IsSingleTableSchemaContext() {}

func NewSingleTableSchemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableSchemaContext {
	var p = new(SingleTableSchemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleTableSchema

	return p
}

func (s *SingleTableSchemaContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableSchemaContext) ColTypeList() IColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeListContext)
}

func (s *SingleTableSchemaContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleTableSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableSchemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleTableSchema(s)
	}
}

func (s *SingleTableSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleTableSchema(s)
	}
}

func (p *SqlBaseParser) SingleTableSchema() (localctx ISingleTableSchemaContext) {
	localctx = NewSingleTableSchemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SqlBaseParserRULE_singleTableSchema)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.ColTypeList()
	}
	{
		p.SetState(791)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleRoutineParamListContext is an interface to support dynamic dispatch.
type ISingleRoutineParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColDefinitionList() IColDefinitionListContext
	EOF() antlr.TerminalNode

	// IsSingleRoutineParamListContext differentiates from other interfaces.
	IsSingleRoutineParamListContext()
}

type SingleRoutineParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleRoutineParamListContext() *SingleRoutineParamListContext {
	var p = new(SingleRoutineParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleRoutineParamList
	return p
}

func InitEmptySingleRoutineParamListContext(p *SingleRoutineParamListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleRoutineParamList
}

func (*SingleRoutineParamListContext) IsSingleRoutineParamListContext() {}

func NewSingleRoutineParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleRoutineParamListContext {
	var p = new(SingleRoutineParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleRoutineParamList

	return p
}

func (s *SingleRoutineParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleRoutineParamListContext) ColDefinitionList() IColDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColDefinitionListContext)
}

func (s *SingleRoutineParamListContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleRoutineParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleRoutineParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleRoutineParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleRoutineParamList(s)
	}
}

func (s *SingleRoutineParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleRoutineParamList(s)
	}
}

func (p *SqlBaseParser) SingleRoutineParamList() (localctx ISingleRoutineParamListContext) {
	localctx = NewSingleRoutineParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SqlBaseParserRULE_singleRoutineParamList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.ColDefinitionList()
	}
	{
		p.SetState(794)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainContext struct {
	StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) SetResetStatement() ISetResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetResetStatementContext)
}

func (s *ExplainContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *ExplainContext) FORMATTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMATTED, 0)
}

func (s *ExplainContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *ExplainContext) CODEGEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCODEGEN, 0)
}

func (s *ExplainContext) COST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOST, 0)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExplain(s)
	}
}

type SetNamespaceCollationContext struct {
	StatementContext
}

func NewSetNamespaceCollationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamespaceCollationContext {
	var p = new(SetNamespaceCollationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetNamespaceCollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamespaceCollationContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetNamespaceCollationContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *SetNamespaceCollationContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *SetNamespaceCollationContext) CollationSpec() ICollationSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationSpecContext)
}

func (s *SetNamespaceCollationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetNamespaceCollation(s)
	}
}

func (s *SetNamespaceCollationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetNamespaceCollation(s)
	}
}

type AlterViewQueryContext struct {
	StatementContext
}

func NewAlterViewQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterViewQueryContext {
	var p = new(AlterViewQueryContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AlterViewQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewQueryContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AlterViewQueryContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *AlterViewQueryContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AlterViewQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AlterViewQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *AlterViewQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterViewQuery(s)
	}
}

func (s *AlterViewQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterViewQuery(s)
	}
}

type CreatePipelineInsertIntoFlowContext struct {
	StatementContext
}

func NewCreatePipelineInsertIntoFlowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreatePipelineInsertIntoFlowContext {
	var p = new(CreatePipelineInsertIntoFlowContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreatePipelineInsertIntoFlowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipelineInsertIntoFlowContext) CreatePipelineFlowHeader() ICreatePipelineFlowHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatePipelineFlowHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatePipelineFlowHeaderContext)
}

func (s *CreatePipelineInsertIntoFlowContext) InsertInto() IInsertIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertIntoContext)
}

func (s *CreatePipelineInsertIntoFlowContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreatePipelineInsertIntoFlowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreatePipelineInsertIntoFlow(s)
	}
}

func (s *CreatePipelineInsertIntoFlowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreatePipelineInsertIntoFlow(s)
	}
}

type UseContext struct {
	StatementContext
}

func NewUseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseContext {
	var p = new(UseContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *UseContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *UseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUse(s)
	}
}

func (s *UseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUse(s)
	}
}

type DropNamespaceContext struct {
	StatementContext
}

func NewDropNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropNamespaceContext {
	var p = new(DropNamespaceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropNamespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropNamespaceContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *DropNamespaceContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropNamespaceContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropNamespaceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropNamespaceContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *DropNamespaceContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *DropNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropNamespace(s)
	}
}

func (s *DropNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropNamespace(s)
	}
}

type CreateTempViewUsingContext struct {
	StatementContext
}

func NewCreateTempViewUsingContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTempViewUsingContext {
	var p = new(CreateTempViewUsingContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTempViewUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTempViewUsingContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTempViewUsingContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *CreateTempViewUsingContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *CreateTempViewUsingContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateTempViewUsingContext) TableProvider() ITableProviderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProviderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProviderContext)
}

func (s *CreateTempViewUsingContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateTempViewUsingContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateTempViewUsingContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGLOBAL, 0)
}

func (s *CreateTempViewUsingContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CreateTempViewUsingContext) ColTypeList() IColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeListContext)
}

func (s *CreateTempViewUsingContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CreateTempViewUsingContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, 0)
}

func (s *CreateTempViewUsingContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateTempViewUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateTempViewUsing(s)
	}
}

func (s *CreateTempViewUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateTempViewUsing(s)
	}
}

type ShowProceduresContext struct {
	StatementContext
}

func NewShowProceduresContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProceduresContext {
	var p = new(ShowProceduresContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowProceduresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProceduresContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowProceduresContext) PROCEDURES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROCEDURES, 0)
}

func (s *ShowProceduresContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowProceduresContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowProceduresContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowProceduresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowProcedures(s)
	}
}

func (s *ShowProceduresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowProcedures(s)
	}
}

type RenameTableContext struct {
	StatementContext
	from IIdentifierReferenceContext
	to   IMultipartIdentifierContext
}

func NewRenameTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTableContext {
	var p = new(RenameTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameTableContext) GetFrom() IIdentifierReferenceContext { return s.from }

func (s *RenameTableContext) GetTo() IMultipartIdentifierContext { return s.to }

func (s *RenameTableContext) SetFrom(v IIdentifierReferenceContext) { s.from = v }

func (s *RenameTableContext) SetTo(v IMultipartIdentifierContext) { s.to = v }

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameTableContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RenameTableContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *RenameTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *RenameTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

type FailNativeCommandContext struct {
	StatementContext
}

func NewFailNativeCommandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FailNativeCommandContext {
	var p = new(FailNativeCommandContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *FailNativeCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FailNativeCommandContext) UnsupportedHiveNativeCommands() IUnsupportedHiveNativeCommandsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedHiveNativeCommandsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedHiveNativeCommandsContext)
}

func (s *FailNativeCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFailNativeCommand(s)
	}
}

func (s *FailNativeCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFailNativeCommand(s)
	}
}

type SetCatalogContext struct {
	StatementContext
}

func NewSetCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCatalogContext {
	var p = new(SetCatalogContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCatalogContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOG, 0)
}

func (s *SetCatalogContext) CatalogIdentifierReference() ICatalogIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogIdentifierReferenceContext)
}

func (s *SetCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetCatalog(s)
	}
}

func (s *SetCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetCatalog(s)
	}
}

type ClearCacheContext struct {
	StatementContext
}

func NewClearCacheContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClearCacheContext {
	var p = new(ClearCacheContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ClearCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClearCacheContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLEAR, 0)
}

func (s *ClearCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *ClearCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterClearCache(s)
	}
}

func (s *ClearCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitClearCache(s)
	}
}

type DropViewContext struct {
	StatementContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *DropViewContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

type ShowTablesContext struct {
	StatementContext
	pattern IStringLitContext
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowTablesContext) GetPattern() IStringLitContext { return s.pattern }

func (s *ShowTablesContext) SetPattern(v IStringLitContext) { s.pattern = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *ShowTablesContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowTablesContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *ShowTablesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowTables(s)
	}
}

type RecoverPartitionsContext struct {
	StatementContext
}

func NewRecoverPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverPartitionsContext {
	var p = new(RecoverPartitionsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RecoverPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RecoverPartitionsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RecoverPartitionsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *RecoverPartitionsContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECOVER, 0)
}

func (s *RecoverPartitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *RecoverPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRecoverPartitions(s)
	}
}

func (s *RecoverPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRecoverPartitions(s)
	}
}

type DropTableConstraintContext struct {
	StatementContext
	name IIdentifierContext
}

func NewDropTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableConstraintContext {
	var p = new(DropTableConstraintContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTableConstraintContext) GetName() IIdentifierContext { return s.name }

func (s *DropTableConstraintContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *DropTableConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropTableConstraintContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropTableConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONSTRAINT, 0)
}

func (s *DropTableConstraintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTableConstraintContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTableConstraintContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTableConstraintContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *DropTableConstraintContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *DropTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropTableConstraint(s)
	}
}

func (s *DropTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropTableConstraint(s)
	}
}

type DropIndexContext struct {
	StatementContext
}

func NewDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexContext {
	var p = new(DropIndexContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *DropIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *DropIndexContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropIndexContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

type ShowCatalogsContext struct {
	StatementContext
	pattern IStringLitContext
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCatalogsContext) GetPattern() IStringLitContext { return s.pattern }

func (s *ShowCatalogsContext) SetPattern(v IStringLitContext) { s.pattern = v }

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *ShowCatalogsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

type ShowCurrentNamespaceContext struct {
	StatementContext
}

func NewShowCurrentNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCurrentNamespaceContext {
	var p = new(ShowCurrentNamespaceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCurrentNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCurrentNamespaceContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCurrentNamespaceContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *ShowCurrentNamespaceContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *ShowCurrentNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowCurrentNamespace(s)
	}
}

func (s *ShowCurrentNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowCurrentNamespace(s)
	}
}

type RenameTablePartitionContext struct {
	StatementContext
	from IPartitionSpecContext
	to   IPartitionSpecContext
}

func NewRenameTablePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTablePartitionContext {
	var p = new(RenameTablePartitionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameTablePartitionContext) GetFrom() IPartitionSpecContext { return s.from }

func (s *RenameTablePartitionContext) GetTo() IPartitionSpecContext { return s.to }

func (s *RenameTablePartitionContext) SetFrom(v IPartitionSpecContext) { s.from = v }

func (s *RenameTablePartitionContext) SetTo(v IPartitionSpecContext) { s.to = v }

func (s *RenameTablePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTablePartitionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameTablePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RenameTablePartitionContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *RenameTablePartitionContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameTablePartitionContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameTablePartitionContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *RenameTablePartitionContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *RenameTablePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRenameTablePartition(s)
	}
}

func (s *RenameTablePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRenameTablePartition(s)
	}
}

type RepairTableContext struct {
	StatementContext
	option antlr.Token
}

func NewRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RepairTableContext {
	var p = new(RepairTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RepairTableContext) GetOption() antlr.Token { return s.option }

func (s *RepairTableContext) SetOption(v antlr.Token) { s.option = v }

func (s *RepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPAIR, 0)
}

func (s *RepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RepairTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *RepairTableContext) MSCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMSCK, 0)
}

func (s *RepairTableContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *RepairTableContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *RepairTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *RepairTableContext) SYNC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYNC, 0)
}

func (s *RepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRepairTable(s)
	}
}

func (s *RepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRepairTable(s)
	}
}

type AddTableConstraintContext struct {
	StatementContext
}

func NewAddTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddTableConstraintContext {
	var p = new(AddTableConstraintContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AddTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddTableConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AddTableConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AddTableConstraintContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AddTableConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *AddTableConstraintContext) TableConstraintDefinition() ITableConstraintDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintDefinitionContext)
}

func (s *AddTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAddTableConstraint(s)
	}
}

func (s *AddTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAddTableConstraint(s)
	}
}

type RefreshResourceContext struct {
	StatementContext
}

func NewRefreshResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshResourceContext {
	var p = new(RefreshResourceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RefreshResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshResourceContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *RefreshResourceContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *RefreshResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRefreshResource(s)
	}
}

func (s *RefreshResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRefreshResource(s)
	}
}

type AlterViewSchemaBindingContext struct {
	StatementContext
}

func NewAlterViewSchemaBindingContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterViewSchemaBindingContext {
	var p = new(AlterViewSchemaBindingContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AlterViewSchemaBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewSchemaBindingContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AlterViewSchemaBindingContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *AlterViewSchemaBindingContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AlterViewSchemaBindingContext) SchemaBinding() ISchemaBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaBindingContext)
}

func (s *AlterViewSchemaBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterViewSchemaBinding(s)
	}
}

func (s *AlterViewSchemaBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterViewSchemaBinding(s)
	}
}

type CreateVariableContext struct {
	StatementContext
	_identifierReference IIdentifierReferenceContext
	identifierReferences []IIdentifierReferenceContext
}

func NewCreateVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateVariableContext {
	var p = new(CreateVariableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateVariableContext) Get_identifierReference() IIdentifierReferenceContext {
	return s._identifierReference
}

func (s *CreateVariableContext) Set_identifierReference(v IIdentifierReferenceContext) {
	s._identifierReference = v
}

func (s *CreateVariableContext) GetIdentifierReferences() []IIdentifierReferenceContext {
	return s.identifierReferences
}

func (s *CreateVariableContext) SetIdentifierReferences(v []IIdentifierReferenceContext) {
	s.identifierReferences = v
}

func (s *CreateVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateVariableContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECLARE, 0)
}

func (s *CreateVariableContext) AllIdentifierReference() []IIdentifierReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierReferenceContext); ok {
			tst[i] = t.(IIdentifierReferenceContext)
			i++
		}
	}

	return tst
}

func (s *CreateVariableContext) IdentifierReference(i int) IIdentifierReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreateVariableContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateVariableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *CreateVariableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *CreateVariableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *CreateVariableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateVariableContext) VariableDefaultExpression() IVariableDefaultExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDefaultExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDefaultExpressionContext)
}

func (s *CreateVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateVariable(s)
	}
}

func (s *CreateVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateVariable(s)
	}
}

type CreatePipelineDatasetContext struct {
	StatementContext
}

func NewCreatePipelineDatasetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreatePipelineDatasetContext {
	var p = new(CreatePipelineDatasetContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreatePipelineDatasetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipelineDatasetContext) CreatePipelineDatasetHeader() ICreatePipelineDatasetHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatePipelineDatasetHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatePipelineDatasetHeaderContext)
}

func (s *CreatePipelineDatasetContext) CreateTableClauses() ICreateTableClausesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableClausesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableClausesContext)
}

func (s *CreatePipelineDatasetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CreatePipelineDatasetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CreatePipelineDatasetContext) TableProvider() ITableProviderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProviderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProviderContext)
}

func (s *CreatePipelineDatasetContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreatePipelineDatasetContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreatePipelineDatasetContext) TableElementList() ITableElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementListContext)
}

func (s *CreatePipelineDatasetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreatePipelineDataset(s)
	}
}

func (s *CreatePipelineDatasetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreatePipelineDataset(s)
	}
}

type ShowCreateTableContext struct {
	StatementContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *ShowCreateTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowCreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *ShowCreateTableContext) SERDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDE, 0)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

type ShowNamespacesContext struct {
	StatementContext
	pattern IStringLitContext
}

func NewShowNamespacesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowNamespacesContext {
	var p = new(ShowNamespacesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowNamespacesContext) GetPattern() IStringLitContext { return s.pattern }

func (s *ShowNamespacesContext) SetPattern(v IStringLitContext) { s.pattern = v }

func (s *ShowNamespacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowNamespacesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowNamespacesContext) Namespaces() INamespacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespacesContext)
}

func (s *ShowNamespacesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowNamespacesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowNamespacesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowNamespacesContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *ShowNamespacesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowNamespacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowNamespaces(s)
	}
}

func (s *ShowNamespacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowNamespaces(s)
	}
}

type ShowColumnsContext struct {
	StatementContext
	table IIdentifierReferenceContext
	ns    IMultipartIdentifierContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetTable() IIdentifierReferenceContext { return s.table }

func (s *ShowColumnsContext) GetNs() IMultipartIdentifierContext { return s.ns }

func (s *ShowColumnsContext) SetTable(v IIdentifierReferenceContext) { s.table = v }

func (s *ShowColumnsContext) SetNs(v IMultipartIdentifierContext) { s.ns = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, i)
}

func (s *ShowColumnsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowColumnsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type ReplaceTableContext struct {
	StatementContext
}

func NewReplaceTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceTableContext {
	var p = new(ReplaceTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ReplaceTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceTableContext) ReplaceTableHeader() IReplaceTableHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceTableHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceTableHeaderContext)
}

func (s *ReplaceTableContext) CreateTableClauses() ICreateTableClausesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableClausesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableClausesContext)
}

func (s *ReplaceTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ReplaceTableContext) TableElementList() ITableElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementListContext)
}

func (s *ReplaceTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ReplaceTableContext) TableProvider() ITableProviderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProviderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProviderContext)
}

func (s *ReplaceTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ReplaceTableContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *ReplaceTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterReplaceTable(s)
	}
}

func (s *ReplaceTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitReplaceTable(s)
	}
}

type AnalyzeTablesContext struct {
	StatementContext
}

func NewAnalyzeTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeTablesContext {
	var p = new(AnalyzeTablesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AnalyzeTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTablesContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *AnalyzeTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *AnalyzeTablesContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPUTE, 0)
}

func (s *AnalyzeTablesContext) STATISTICS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATISTICS, 0)
}

func (s *AnalyzeTablesContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AnalyzeTablesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnalyzeTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *AnalyzeTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *AnalyzeTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAnalyzeTables(s)
	}
}

func (s *AnalyzeTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAnalyzeTables(s)
	}
}

type UnsetNamespacePropertiesContext struct {
	StatementContext
}

func NewUnsetNamespacePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsetNamespacePropertiesContext {
	var p = new(UnsetNamespacePropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UnsetNamespacePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetNamespacePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *UnsetNamespacePropertiesContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *UnsetNamespacePropertiesContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *UnsetNamespacePropertiesContext) UNSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNSET, 0)
}

func (s *UnsetNamespacePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *UnsetNamespacePropertiesContext) DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDBPROPERTIES, 0)
}

func (s *UnsetNamespacePropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *UnsetNamespacePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnsetNamespaceProperties(s)
	}
}

func (s *UnsetNamespacePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnsetNamespaceProperties(s)
	}
}

type AddTablePartitionContext struct {
	StatementContext
}

func NewAddTablePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddTablePartitionContext {
	var p = new(AddTablePartitionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AddTablePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddTablePartitionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AddTablePartitionContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AddTablePartitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *AddTablePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AddTablePartitionContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *AddTablePartitionContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *AddTablePartitionContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *AddTablePartitionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *AddTablePartitionContext) AllPartitionSpecLocation() []IPartitionSpecLocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecLocationContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecLocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecLocationContext); ok {
			tst[i] = t.(IPartitionSpecLocationContext)
			i++
		}
	}

	return tst
}

func (s *AddTablePartitionContext) PartitionSpecLocation(i int) IPartitionSpecLocationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecLocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecLocationContext)
}

func (s *AddTablePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAddTablePartition(s)
	}
}

func (s *AddTablePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAddTablePartition(s)
	}
}

type SetNamespaceLocationContext struct {
	StatementContext
}

func NewSetNamespaceLocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamespaceLocationContext {
	var p = new(SetNamespaceLocationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetNamespaceLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamespaceLocationContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetNamespaceLocationContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *SetNamespaceLocationContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *SetNamespaceLocationContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetNamespaceLocationContext) LocationSpec() ILocationSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationSpecContext)
}

func (s *SetNamespaceLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetNamespaceLocation(s)
	}
}

func (s *SetNamespaceLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetNamespaceLocation(s)
	}
}

type RefreshTableContext struct {
	StatementContext
}

func NewRefreshTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshTableContext {
	var p = new(RefreshTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RefreshTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *RefreshTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RefreshTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *RefreshTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRefreshTable(s)
	}
}

func (s *RefreshTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRefreshTable(s)
	}
}

type AlterTableCollationContext struct {
	StatementContext
}

func NewAlterTableCollationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableCollationContext {
	var p = new(AlterTableCollationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AlterTableCollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableCollationContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AlterTableCollationContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AlterTableCollationContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AlterTableCollationContext) CollationSpec() ICollationSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationSpecContext)
}

func (s *AlterTableCollationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterTableCollation(s)
	}
}

func (s *AlterTableCollationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterTableCollation(s)
	}
}

type SetNamespacePropertiesContext struct {
	StatementContext
}

func NewSetNamespacePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamespacePropertiesContext {
	var p = new(SetNamespacePropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetNamespacePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamespacePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetNamespacePropertiesContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *SetNamespacePropertiesContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *SetNamespacePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetNamespacePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SetNamespacePropertiesContext) DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDBPROPERTIES, 0)
}

func (s *SetNamespacePropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *SetNamespacePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetNamespaceProperties(s)
	}
}

func (s *SetNamespacePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetNamespaceProperties(s)
	}
}

type ManageResourceContext struct {
	StatementContext
	op antlr.Token
}

func NewManageResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ManageResourceContext {
	var p = new(ManageResourceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ManageResourceContext) GetOp() antlr.Token { return s.op }

func (s *ManageResourceContext) SetOp(v antlr.Token) { s.op = v }

func (s *ManageResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ManageResourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ManageResourceContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *ManageResourceContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ManageResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterManageResource(s)
	}
}

func (s *ManageResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitManageResource(s)
	}
}

type AnalyzeContext struct {
	StatementContext
}

func NewAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeContext {
	var p = new(AnalyzeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *AnalyzeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AnalyzeContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AnalyzeContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPUTE, 0)
}

func (s *AnalyzeContext) STATISTICS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATISTICS, 0)
}

func (s *AnalyzeContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AnalyzeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnalyzeContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *AnalyzeContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *AnalyzeContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *AnalyzeContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *AnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAnalyze(s)
	}
}

func (s *AnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAnalyze(s)
	}
}

type CreateFunctionContext struct {
	StatementContext
	className IStringLitContext
}

func NewCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateFunctionContext) GetClassName() IStringLitContext { return s.className }

func (s *CreateFunctionContext) SetClassName(v IStringLitContext) { s.className = v }

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *CreateFunctionContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreateFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateFunctionContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *CreateFunctionContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateFunctionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateFunctionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *CreateFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateFunctionContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreateFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateFunctionContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *CreateFunctionContext) AllResource() []IResourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceContext); ok {
			len++
		}
	}

	tst := make([]IResourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceContext); ok {
			tst[i] = t.(IResourceContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) Resource(i int) IResourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *CreateFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *CreateFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

type HiveReplaceColumnsContext struct {
	StatementContext
	table   IIdentifierReferenceContext
	columns IQualifiedColTypeWithPositionListContext
}

func NewHiveReplaceColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HiveReplaceColumnsContext {
	var p = new(HiveReplaceColumnsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *HiveReplaceColumnsContext) GetTable() IIdentifierReferenceContext { return s.table }

func (s *HiveReplaceColumnsContext) GetColumns() IQualifiedColTypeWithPositionListContext {
	return s.columns
}

func (s *HiveReplaceColumnsContext) SetTable(v IIdentifierReferenceContext) { s.table = v }

func (s *HiveReplaceColumnsContext) SetColumns(v IQualifiedColTypeWithPositionListContext) {
	s.columns = v
}

func (s *HiveReplaceColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HiveReplaceColumnsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *HiveReplaceColumnsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *HiveReplaceColumnsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *HiveReplaceColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *HiveReplaceColumnsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *HiveReplaceColumnsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *HiveReplaceColumnsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *HiveReplaceColumnsContext) QualifiedColTypeWithPositionList() IQualifiedColTypeWithPositionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedColTypeWithPositionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedColTypeWithPositionListContext)
}

func (s *HiveReplaceColumnsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *HiveReplaceColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterHiveReplaceColumns(s)
	}
}

func (s *HiveReplaceColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitHiveReplaceColumns(s)
	}
}

type CommentNamespaceContext struct {
	StatementContext
}

func NewCommentNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentNamespaceContext {
	var p = new(CommentNamespaceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommentNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentNamespaceContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CommentNamespaceContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *CommentNamespaceContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *CommentNamespaceContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CommentNamespaceContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *CommentNamespaceContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CommentNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCommentNamespace(s)
	}
}

func (s *CommentNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCommentNamespace(s)
	}
}

type CreateTableContext struct {
	StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CreateTableHeader() ICreateTableHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableHeaderContext)
}

func (s *CreateTableContext) CreateTableClauses() ICreateTableClausesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableClausesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableClausesContext)
}

func (s *CreateTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CreateTableContext) TableElementList() ITableElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementListContext)
}

func (s *CreateTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CreateTableContext) TableProvider() ITableProviderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProviderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProviderContext)
}

func (s *CreateTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type DmlStatementContext struct {
	StatementContext
}

func NewDmlStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DmlStatementContext {
	var p = new(DmlStatementContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) DmlStatementNoWith() IDmlStatementNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementNoWithContext)
}

func (s *DmlStatementContext) Ctes() ICtesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICtesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICtesContext)
}

func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDmlStatement(s)
	}
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDmlStatement(s)
	}
}

type CreateTableLikeContext struct {
	StatementContext
	target     ITableIdentifierContext
	source     ITableIdentifierContext
	tableProps IPropertyListContext
}

func NewCreateTableLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableLikeContext {
	var p = new(CreateTableLikeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableLikeContext) GetTarget() ITableIdentifierContext { return s.target }

func (s *CreateTableLikeContext) GetSource() ITableIdentifierContext { return s.source }

func (s *CreateTableLikeContext) GetTableProps() IPropertyListContext { return s.tableProps }

func (s *CreateTableLikeContext) SetTarget(v ITableIdentifierContext) { s.target = v }

func (s *CreateTableLikeContext) SetSource(v ITableIdentifierContext) { s.source = v }

func (s *CreateTableLikeContext) SetTableProps(v IPropertyListContext) { s.tableProps = v }

func (s *CreateTableLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableLikeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableLikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *CreateTableLikeContext) AllTableIdentifier() []ITableIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITableIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableIdentifierContext); ok {
			tst[i] = t.(ITableIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) TableIdentifier(i int) ITableIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateTableLikeContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableLikeContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreateTableLikeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableLikeContext) AllTableProvider() []ITableProviderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableProviderContext); ok {
			len++
		}
	}

	tst := make([]ITableProviderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableProviderContext); ok {
			tst[i] = t.(ITableProviderContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) TableProvider(i int) ITableProviderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProviderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProviderContext)
}

func (s *CreateTableLikeContext) AllRowFormat() []IRowFormatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowFormatContext); ok {
			len++
		}
	}

	tst := make([]IRowFormatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowFormatContext); ok {
			tst[i] = t.(IRowFormatContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) RowFormat(i int) IRowFormatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatContext)
}

func (s *CreateTableLikeContext) AllCreateFileFormat() []ICreateFileFormatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateFileFormatContext); ok {
			len++
		}
	}

	tst := make([]ICreateFileFormatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateFileFormatContext); ok {
			tst[i] = t.(ICreateFileFormatContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) CreateFileFormat(i int) ICreateFileFormatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFileFormatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFileFormatContext)
}

func (s *CreateTableLikeContext) AllLocationSpec() []ILocationSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILocationSpecContext); ok {
			len++
		}
	}

	tst := make([]ILocationSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILocationSpecContext); ok {
			tst[i] = t.(ILocationSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) LocationSpec(i int) ILocationSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationSpecContext)
}

func (s *CreateTableLikeContext) AllTBLPROPERTIES() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTBLPROPERTIES)
}

func (s *CreateTableLikeContext) TBLPROPERTIES(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, i)
}

func (s *CreateTableLikeContext) AllPropertyList() []IPropertyListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyListContext); ok {
			len++
		}
	}

	tst := make([]IPropertyListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyListContext); ok {
			tst[i] = t.(IPropertyListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) PropertyList(i int) IPropertyListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateTableLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateTableLike(s)
	}
}

func (s *CreateTableLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateTableLike(s)
	}
}

type UncacheTableContext struct {
	StatementContext
}

func NewUncacheTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UncacheTableContext {
	var p = new(UncacheTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UncacheTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UncacheTableContext) UNCACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCACHE, 0)
}

func (s *UncacheTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *UncacheTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *UncacheTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *UncacheTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *UncacheTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUncacheTable(s)
	}
}

func (s *UncacheTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUncacheTable(s)
	}
}

type DropFunctionContext struct {
	StatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *DropFunctionContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropFunctionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *DropFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

type DescribeRelationContext struct {
	StatementContext
	option antlr.Token
}

func NewDescribeRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeRelationContext {
	var p = new(DescribeRelationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeRelationContext) GetOption() antlr.Token { return s.option }

func (s *DescribeRelationContext) SetOption(v antlr.Token) { s.option = v }

func (s *DescribeRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeRelationContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DescribeRelationContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *DescribeRelationContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeRelationContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DescribeRelationContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DescribeRelationContext) DescribeColName() IDescribeColNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeColNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeColNameContext)
}

func (s *DescribeRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *DescribeRelationContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *DescribeRelationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *DescribeRelationContext) FORMATTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMATTED, 0)
}

func (s *DescribeRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDescribeRelation(s)
	}
}

func (s *DescribeRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDescribeRelation(s)
	}
}

type LoadDataContext struct {
	StatementContext
	path IStringLitContext
}

func NewLoadDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoadDataContext {
	var p = new(LoadDataContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *LoadDataContext) GetPath() IStringLitContext { return s.path }

func (s *LoadDataContext) SetPath(v IStringLitContext) { s.path = v }

func (s *LoadDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadDataContext) LOAD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOAD, 0)
}

func (s *LoadDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *LoadDataContext) INPATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPATH, 0)
}

func (s *LoadDataContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *LoadDataContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *LoadDataContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *LoadDataContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *LoadDataContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCAL, 0)
}

func (s *LoadDataContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *LoadDataContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *LoadDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLoadData(s)
	}
}

func (s *LoadDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLoadData(s)
	}
}

type ShowPartitionsContext struct {
	StatementContext
}

func NewShowPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionsContext {
	var p = new(ShowPartitionsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowPartitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *ShowPartitionsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowPartitionsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowPartitions(s)
	}
}

func (s *ShowPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowPartitions(s)
	}
}

type DescribeFunctionContext struct {
	StatementContext
}

func NewDescribeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeFunctionContext {
	var p = new(DescribeFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *DescribeFunctionContext) DescribeFuncName() IDescribeFuncNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeFuncNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeFuncNameContext)
}

func (s *DescribeFunctionContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *DescribeFunctionContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeFunctionContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *DescribeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDescribeFunction(s)
	}
}

func (s *DescribeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDescribeFunction(s)
	}
}

type RenameTableColumnContext struct {
	StatementContext
	table IIdentifierReferenceContext
	from  IMultipartIdentifierContext
	to    IErrorCapturingIdentifierContext
}

func NewRenameTableColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTableColumnContext {
	var p = new(RenameTableColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameTableColumnContext) GetTable() IIdentifierReferenceContext { return s.table }

func (s *RenameTableColumnContext) GetFrom() IMultipartIdentifierContext { return s.from }

func (s *RenameTableColumnContext) GetTo() IErrorCapturingIdentifierContext { return s.to }

func (s *RenameTableColumnContext) SetTable(v IIdentifierReferenceContext) { s.table = v }

func (s *RenameTableColumnContext) SetFrom(v IMultipartIdentifierContext) { s.from = v }

func (s *RenameTableColumnContext) SetTo(v IErrorCapturingIdentifierContext) { s.to = v }

func (s *RenameTableColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameTableColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RenameTableColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameTableColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *RenameTableColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameTableColumnContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *RenameTableColumnContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RenameTableColumnContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *RenameTableColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRenameTableColumn(s)
	}
}

func (s *RenameTableColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRenameTableColumn(s)
	}
}

type CreateUserDefinedFunctionContext struct {
	StatementContext
	parameters   IColDefinitionListContext
	returnParams IColTypeListContext
}

func NewCreateUserDefinedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserDefinedFunctionContext {
	var p = new(CreateUserDefinedFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateUserDefinedFunctionContext) GetParameters() IColDefinitionListContext {
	return s.parameters
}

func (s *CreateUserDefinedFunctionContext) GetReturnParams() IColTypeListContext {
	return s.returnParams
}

func (s *CreateUserDefinedFunctionContext) SetParameters(v IColDefinitionListContext) {
	s.parameters = v
}

func (s *CreateUserDefinedFunctionContext) SetReturnParams(v IColTypeListContext) { s.returnParams = v }

func (s *CreateUserDefinedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserDefinedFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateUserDefinedFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *CreateUserDefinedFunctionContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreateUserDefinedFunctionContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *CreateUserDefinedFunctionContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *CreateUserDefinedFunctionContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *CreateUserDefinedFunctionContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *CreateUserDefinedFunctionContext) RoutineCharacteristics() IRoutineCharacteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineCharacteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineCharacteristicsContext)
}

func (s *CreateUserDefinedFunctionContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURN, 0)
}

func (s *CreateUserDefinedFunctionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateUserDefinedFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateUserDefinedFunctionContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateUserDefinedFunctionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateUserDefinedFunctionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *CreateUserDefinedFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateUserDefinedFunctionContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreateUserDefinedFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateUserDefinedFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *CreateUserDefinedFunctionContext) ColDefinitionList() IColDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColDefinitionListContext)
}

func (s *CreateUserDefinedFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateUserDefinedFunctionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateUserDefinedFunctionContext) ColTypeList() IColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeListContext)
}

func (s *CreateUserDefinedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateUserDefinedFunction(s)
	}
}

func (s *CreateUserDefinedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateUserDefinedFunction(s)
	}
}

type StatementDefaultContext struct {
	StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

type AlterClusterByContext struct {
	StatementContext
}

func NewAlterClusterByContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterClusterByContext {
	var p = new(AlterClusterByContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AlterClusterByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterClusterByContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AlterClusterByContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AlterClusterByContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AlterClusterByContext) ClusterBySpec() IClusterBySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterBySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterBySpecContext)
}

func (s *AlterClusterByContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTER, 0)
}

func (s *AlterClusterByContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *AlterClusterByContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *AlterClusterByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterClusterBy(s)
	}
}

func (s *AlterClusterByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterClusterBy(s)
	}
}

type HiveChangeColumnContext struct {
	StatementContext
	table   IIdentifierReferenceContext
	colName IMultipartIdentifierContext
}

func NewHiveChangeColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HiveChangeColumnContext {
	var p = new(HiveChangeColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *HiveChangeColumnContext) GetTable() IIdentifierReferenceContext { return s.table }

func (s *HiveChangeColumnContext) GetColName() IMultipartIdentifierContext { return s.colName }

func (s *HiveChangeColumnContext) SetTable(v IIdentifierReferenceContext) { s.table = v }

func (s *HiveChangeColumnContext) SetColName(v IMultipartIdentifierContext) { s.colName = v }

func (s *HiveChangeColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HiveChangeColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *HiveChangeColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *HiveChangeColumnContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHANGE, 0)
}

func (s *HiveChangeColumnContext) ColType() IColTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *HiveChangeColumnContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *HiveChangeColumnContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *HiveChangeColumnContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *HiveChangeColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *HiveChangeColumnContext) ColPosition() IColPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColPositionContext)
}

func (s *HiveChangeColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterHiveChangeColumn(s)
	}
}

func (s *HiveChangeColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitHiveChangeColumn(s)
	}
}

type DescribeQueryContext struct {
	StatementContext
}

func NewDescribeQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeQueryContext {
	var p = new(DescribeQueryContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *DescribeQueryContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *DescribeQueryContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeQueryContext) QUERY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUERY, 0)
}

func (s *DescribeQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDescribeQuery(s)
	}
}

func (s *DescribeQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDescribeQuery(s)
	}
}

type TruncateTableContext struct {
	StatementContext
}

func NewTruncateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TruncateTableContext {
	var p = new(TruncateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *TruncateTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *TruncateTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

type SetTableSerDeContext struct {
	StatementContext
}

func NewSetTableSerDeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTableSerDeContext {
	var p = new(SetTableSerDeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetTableSerDeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTableSerDeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetTableSerDeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *SetTableSerDeContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *SetTableSerDeContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetTableSerDeContext) SERDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDE, 0)
}

func (s *SetTableSerDeContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *SetTableSerDeContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *SetTableSerDeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *SetTableSerDeContext) SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDEPROPERTIES, 0)
}

func (s *SetTableSerDeContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SetTableSerDeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetTableSerDe(s)
	}
}

func (s *SetTableSerDeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetTableSerDe(s)
	}
}

type CreateViewContext struct {
	StatementContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *CreateViewContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateViewContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *CreateViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateViewContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreateViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateViewContext) IdentifierCommentList() IIdentifierCommentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierCommentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierCommentListContext)
}

func (s *CreateViewContext) AllCommentSpec() []ICommentSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentSpecContext); ok {
			len++
		}
	}

	tst := make([]ICommentSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentSpecContext); ok {
			tst[i] = t.(ICommentSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewContext) CommentSpec(i int) ICommentSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateViewContext) AllSchemaBinding() []ISchemaBindingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISchemaBindingContext); ok {
			len++
		}
	}

	tst := make([]ISchemaBindingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISchemaBindingContext); ok {
			tst[i] = t.(ISchemaBindingContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewContext) SchemaBinding(i int) ISchemaBindingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaBindingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaBindingContext)
}

func (s *CreateViewContext) AllCollationSpec() []ICollationSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICollationSpecContext); ok {
			len++
		}
	}

	tst := make([]ICollationSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICollationSpecContext); ok {
			tst[i] = t.(ICollationSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewContext) CollationSpec(i int) ICollationSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationSpecContext)
}

func (s *CreateViewContext) AllPARTITIONED() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserPARTITIONED)
}

func (s *CreateViewContext) PARTITIONED(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONED, i)
}

func (s *CreateViewContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserON)
}

func (s *CreateViewContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, i)
}

func (s *CreateViewContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateViewContext) AllTBLPROPERTIES() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTBLPROPERTIES)
}

func (s *CreateViewContext) TBLPROPERTIES(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, i)
}

func (s *CreateViewContext) AllPropertyList() []IPropertyListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyListContext); ok {
			len++
		}
	}

	tst := make([]IPropertyListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyListContext); ok {
			tst[i] = t.(IPropertyListContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewContext) PropertyList(i int) IPropertyListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateViewContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGLOBAL, 0)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

type DropTablePartitionsContext struct {
	StatementContext
}

func NewDropTablePartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTablePartitionsContext {
	var p = new(DropTablePartitionsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTablePartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTablePartitionsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *DropTablePartitionsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropTablePartitionsContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTablePartitionsContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *DropTablePartitionsContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DropTablePartitionsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropTablePartitionsContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *DropTablePartitionsContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTablePartitionsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTablePartitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *DropTablePartitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *DropTablePartitionsContext) PURGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPURGE, 0)
}

func (s *DropTablePartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropTablePartitions(s)
	}
}

func (s *DropTablePartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropTablePartitions(s)
	}
}

type DropTableContext struct {
	StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTableContext) PURGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPURGE, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type ShowTableExtendedContext struct {
	StatementContext
	ns      IIdentifierReferenceContext
	pattern IStringLitContext
}

func NewShowTableExtendedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableExtendedContext {
	var p = new(ShowTableExtendedContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowTableExtendedContext) GetNs() IIdentifierReferenceContext { return s.ns }

func (s *ShowTableExtendedContext) GetPattern() IStringLitContext { return s.pattern }

func (s *ShowTableExtendedContext) SetNs(v IIdentifierReferenceContext) { s.ns = v }

func (s *ShowTableExtendedContext) SetPattern(v IStringLitContext) { s.pattern = v }

func (s *ShowTableExtendedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableExtendedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowTableExtendedContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *ShowTableExtendedContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *ShowTableExtendedContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowTableExtendedContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *ShowTableExtendedContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowTableExtendedContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowTableExtendedContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowTableExtendedContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowTableExtendedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowTableExtended(s)
	}
}

func (s *ShowTableExtendedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowTableExtended(s)
	}
}

type DescribeNamespaceContext struct {
	StatementContext
}

func NewDescribeNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeNamespaceContext {
	var p = new(DescribeNamespaceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeNamespaceContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *DescribeNamespaceContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DescribeNamespaceContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *DescribeNamespaceContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeNamespaceContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *DescribeNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDescribeNamespace(s)
	}
}

func (s *DescribeNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDescribeNamespace(s)
	}
}

type AlterTableAlterColumnContext struct {
	StatementContext
	table   IIdentifierReferenceContext
	columns IAlterColumnSpecListContext
}

func NewAlterTableAlterColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableAlterColumnContext {
	var p = new(AlterTableAlterColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AlterTableAlterColumnContext) GetTable() IIdentifierReferenceContext { return s.table }

func (s *AlterTableAlterColumnContext) GetColumns() IAlterColumnSpecListContext { return s.columns }

func (s *AlterTableAlterColumnContext) SetTable(v IIdentifierReferenceContext) { s.table = v }

func (s *AlterTableAlterColumnContext) SetColumns(v IAlterColumnSpecListContext) { s.columns = v }

func (s *AlterTableAlterColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAlterColumnContext) AllALTER() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserALTER)
}

func (s *AlterTableAlterColumnContext) ALTER(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, i)
}

func (s *AlterTableAlterColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AlterTableAlterColumnContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AlterTableAlterColumnContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHANGE, 0)
}

func (s *AlterTableAlterColumnContext) AlterColumnSpecList() IAlterColumnSpecListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterColumnSpecListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterColumnSpecListContext)
}

func (s *AlterTableAlterColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *AlterTableAlterColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterTableAlterColumn(s)
	}
}

func (s *AlterTableAlterColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterTableAlterColumn(s)
	}
}

type RefreshFunctionContext struct {
	StatementContext
}

func NewRefreshFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshFunctionContext {
	var p = new(RefreshFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RefreshFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshFunctionContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *RefreshFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *RefreshFunctionContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *RefreshFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRefreshFunction(s)
	}
}

func (s *RefreshFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRefreshFunction(s)
	}
}

type CommentTableContext struct {
	StatementContext
}

func NewCommentTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentTableContext {
	var p = new(CommentTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommentTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CommentTableContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *CommentTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CommentTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CommentTableContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *CommentTableContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CommentTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCommentTable(s)
	}
}

func (s *CommentTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCommentTable(s)
	}
}

type DescribeProcedureContext struct {
	StatementContext
}

func NewDescribeProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeProcedureContext {
	var p = new(DescribeProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROCEDURE, 0)
}

func (s *DescribeProcedureContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DescribeProcedureContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *DescribeProcedureContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDescribeProcedure(s)
	}
}

func (s *DescribeProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDescribeProcedure(s)
	}
}

type CreateIndexContext struct {
	StatementContext
	indexType IIdentifierContext
	columns   IMultipartIdentifierPropertyListContext
	options   IPropertyListContext
}

func NewCreateIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexContext {
	var p = new(CreateIndexContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateIndexContext) GetIndexType() IIdentifierContext { return s.indexType }

func (s *CreateIndexContext) GetColumns() IMultipartIdentifierPropertyListContext { return s.columns }

func (s *CreateIndexContext) GetOptions() IPropertyListContext { return s.options }

func (s *CreateIndexContext) SetIndexType(v IIdentifierContext) { s.indexType = v }

func (s *CreateIndexContext) SetColumns(v IMultipartIdentifierPropertyListContext) { s.columns = v }

func (s *CreateIndexContext) SetOptions(v IPropertyListContext) { s.options = v }

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *CreateIndexContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *CreateIndexContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreateIndexContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CreateIndexContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CreateIndexContext) MultipartIdentifierPropertyList() IMultipartIdentifierPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierPropertyListContext)
}

func (s *CreateIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateIndexContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreateIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateIndexContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateIndexContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *CreateIndexContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, 0)
}

func (s *CreateIndexContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

type UseNamespaceContext struct {
	StatementContext
}

func NewUseNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseNamespaceContext {
	var p = new(UseNamespaceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UseNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseNamespaceContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *UseNamespaceContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *UseNamespaceContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *UseNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUseNamespace(s)
	}
}

func (s *UseNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUseNamespace(s)
	}
}

type DropVariableContext struct {
	StatementContext
}

func NewDropVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropVariableContext {
	var p = new(DropVariableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropVariableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropVariableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *DropVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *DropVariableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropVariableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropVariableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropVariable(s)
	}
}

func (s *DropVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropVariable(s)
	}
}

type CreateNamespaceContext struct {
	StatementContext
}

func NewCreateNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateNamespaceContext {
	var p = new(CreateNamespaceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateNamespaceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateNamespaceContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *CreateNamespaceContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreateNamespaceContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateNamespaceContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreateNamespaceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateNamespaceContext) AllCommentSpec() []ICommentSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentSpecContext); ok {
			len++
		}
	}

	tst := make([]ICommentSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentSpecContext); ok {
			tst[i] = t.(ICommentSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateNamespaceContext) CommentSpec(i int) ICommentSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateNamespaceContext) AllLocationSpec() []ILocationSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILocationSpecContext); ok {
			len++
		}
	}

	tst := make([]ILocationSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILocationSpecContext); ok {
			tst[i] = t.(ILocationSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateNamespaceContext) LocationSpec(i int) ILocationSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationSpecContext)
}

func (s *CreateNamespaceContext) AllCollationSpec() []ICollationSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICollationSpecContext); ok {
			len++
		}
	}

	tst := make([]ICollationSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICollationSpecContext); ok {
			tst[i] = t.(ICollationSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateNamespaceContext) CollationSpec(i int) ICollationSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationSpecContext)
}

func (s *CreateNamespaceContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserWITH)
}

func (s *CreateNamespaceContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, i)
}

func (s *CreateNamespaceContext) AllPropertyList() []IPropertyListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyListContext); ok {
			len++
		}
	}

	tst := make([]IPropertyListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyListContext); ok {
			tst[i] = t.(IPropertyListContext)
			i++
		}
	}

	return tst
}

func (s *CreateNamespaceContext) PropertyList(i int) IPropertyListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateNamespaceContext) AllDBPROPERTIES() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserDBPROPERTIES)
}

func (s *CreateNamespaceContext) DBPROPERTIES(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDBPROPERTIES, i)
}

func (s *CreateNamespaceContext) AllPROPERTIES() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserPROPERTIES)
}

func (s *CreateNamespaceContext) PROPERTIES(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, i)
}

func (s *CreateNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateNamespace(s)
	}
}

func (s *CreateNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateNamespace(s)
	}
}

type CallContext struct {
	StatementContext
}

func NewCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallContext {
	var p = new(CallContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALL, 0)
}

func (s *CallContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CallContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CallContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CallContext) AllFunctionArgument() []IFunctionArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgumentContext); ok {
			tst[i] = t.(IFunctionArgumentContext)
			i++
		}
	}

	return tst
}

func (s *CallContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *CallContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *CallContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCall(s)
	}
}

type ShowTblPropertiesContext struct {
	StatementContext
	table IIdentifierReferenceContext
	key   IPropertyKeyContext
}

func NewShowTblPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTblPropertiesContext {
	var p = new(ShowTblPropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowTblPropertiesContext) GetTable() IIdentifierReferenceContext { return s.table }

func (s *ShowTblPropertiesContext) GetKey() IPropertyKeyContext { return s.key }

func (s *ShowTblPropertiesContext) SetTable(v IIdentifierReferenceContext) { s.table = v }

func (s *ShowTblPropertiesContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *ShowTblPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTblPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowTblPropertiesContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, 0)
}

func (s *ShowTblPropertiesContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowTblPropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ShowTblPropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ShowTblPropertiesContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *ShowTblPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowTblProperties(s)
	}
}

func (s *ShowTblPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowTblProperties(s)
	}
}

type VisitExecuteImmediateContext struct {
	StatementContext
}

func NewVisitExecuteImmediateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VisitExecuteImmediateContext {
	var p = new(VisitExecuteImmediateContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *VisitExecuteImmediateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisitExecuteImmediateContext) ExecuteImmediate() IExecuteImmediateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteImmediateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteImmediateContext)
}

func (s *VisitExecuteImmediateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterVisitExecuteImmediate(s)
	}
}

func (s *VisitExecuteImmediateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitVisitExecuteImmediate(s)
	}
}

type UnsetTablePropertiesContext struct {
	StatementContext
}

func NewUnsetTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsetTablePropertiesContext {
	var p = new(UnsetTablePropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UnsetTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetTablePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *UnsetTablePropertiesContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *UnsetTablePropertiesContext) UNSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNSET, 0)
}

func (s *UnsetTablePropertiesContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, 0)
}

func (s *UnsetTablePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *UnsetTablePropertiesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *UnsetTablePropertiesContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *UnsetTablePropertiesContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *UnsetTablePropertiesContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *UnsetTablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnsetTableProperties(s)
	}
}

func (s *UnsetTablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnsetTableProperties(s)
	}
}

type SetTableLocationContext struct {
	StatementContext
}

func NewSetTableLocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTableLocationContext {
	var p = new(SetTableLocationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetTableLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTableLocationContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetTableLocationContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *SetTableLocationContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *SetTableLocationContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetTableLocationContext) LocationSpec() ILocationSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationSpecContext)
}

func (s *SetTableLocationContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *SetTableLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetTableLocation(s)
	}
}

func (s *SetTableLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetTableLocation(s)
	}
}

type DropTableColumnsContext struct {
	StatementContext
	columns IMultipartIdentifierListContext
}

func NewDropTableColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableColumnsContext {
	var p = new(DropTableColumnsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTableColumnsContext) GetColumns() IMultipartIdentifierListContext { return s.columns }

func (s *DropTableColumnsContext) SetColumns(v IMultipartIdentifierListContext) { s.columns = v }

func (s *DropTableColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableColumnsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *DropTableColumnsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropTableColumnsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DropTableColumnsContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTableColumnsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *DropTableColumnsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *DropTableColumnsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *DropTableColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *DropTableColumnsContext) MultipartIdentifierList() IMultipartIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierListContext)
}

func (s *DropTableColumnsContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTableColumnsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTableColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDropTableColumns(s)
	}
}

func (s *DropTableColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDropTableColumns(s)
	}
}

type ShowViewsContext struct {
	StatementContext
	pattern IStringLitContext
}

func NewShowViewsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewsContext {
	var p = new(ShowViewsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowViewsContext) GetPattern() IStringLitContext { return s.pattern }

func (s *ShowViewsContext) SetPattern(v IStringLitContext) { s.pattern = v }

func (s *ShowViewsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowViewsContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEWS, 0)
}

func (s *ShowViewsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowViewsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowViewsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowViewsContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *ShowViewsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowViewsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowViews(s)
	}
}

func (s *ShowViewsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowViews(s)
	}
}

type ShowFunctionsContext struct {
	StatementContext
	ns      IIdentifierReferenceContext
	legacy  IMultipartIdentifierContext
	pattern IStringLitContext
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowFunctionsContext) GetNs() IIdentifierReferenceContext { return s.ns }

func (s *ShowFunctionsContext) GetLegacy() IMultipartIdentifierContext { return s.legacy }

func (s *ShowFunctionsContext) GetPattern() IStringLitContext { return s.pattern }

func (s *ShowFunctionsContext) SetNs(v IIdentifierReferenceContext) { s.ns = v }

func (s *ShowFunctionsContext) SetLegacy(v IMultipartIdentifierContext) { s.legacy = v }

func (s *ShowFunctionsContext) SetPattern(v IStringLitContext) { s.pattern = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowFunctionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowFunctionsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowFunctionsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ShowFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowFunctionsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowFunctionsContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

type CacheTableContext struct {
	StatementContext
	options IPropertyListContext
}

func NewCacheTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CacheTableContext {
	var p = new(CacheTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CacheTableContext) GetOptions() IPropertyListContext { return s.options }

func (s *CacheTableContext) SetOptions(v IPropertyListContext) { s.options = v }

func (s *CacheTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CacheTableContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *CacheTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CacheTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CacheTableContext) LAZY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAZY, 0)
}

func (s *CacheTableContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, 0)
}

func (s *CacheTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CacheTableContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CacheTableContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CacheTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCacheTable(s)
	}
}

func (s *CacheTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCacheTable(s)
	}
}

type AddTableColumnsContext struct {
	StatementContext
	columns IQualifiedColTypeWithPositionListContext
}

func NewAddTableColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddTableColumnsContext {
	var p = new(AddTableColumnsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AddTableColumnsContext) GetColumns() IQualifiedColTypeWithPositionListContext {
	return s.columns
}

func (s *AddTableColumnsContext) SetColumns(v IQualifiedColTypeWithPositionListContext) {
	s.columns = v
}

func (s *AddTableColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddTableColumnsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AddTableColumnsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AddTableColumnsContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *AddTableColumnsContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *AddTableColumnsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *AddTableColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *AddTableColumnsContext) QualifiedColTypeWithPositionList() IQualifiedColTypeWithPositionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedColTypeWithPositionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedColTypeWithPositionListContext)
}

func (s *AddTableColumnsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *AddTableColumnsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *AddTableColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAddTableColumns(s)
	}
}

func (s *AddTableColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAddTableColumns(s)
	}
}

type SetTablePropertiesContext struct {
	StatementContext
}

func NewSetTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTablePropertiesContext {
	var p = new(SetTablePropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTablePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetTablePropertiesContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *SetTablePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetTablePropertiesContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, 0)
}

func (s *SetTablePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SetTablePropertiesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *SetTablePropertiesContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *SetTablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetTableProperties(s)
	}
}

func (s *SetTablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetTableProperties(s)
	}
}

func (p *SqlBaseParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SqlBaseParserRULE_statement)
	var _la int

	var _alt int

	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(796)
			p.Query()
		}

	case 2:
		localctx = NewVisitExecuteImmediateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(797)
			p.ExecuteImmediate()
		}

	case 3:
		localctx = NewDmlStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(798)
				p.Ctes()
			}

		}
		{
			p.SetState(801)
			p.DmlStatementNoWith()
		}

	case 4:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(802)
			p.Match(SqlBaseParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(803)
			p.IdentifierReference()
		}

	case 5:
		localctx = NewUseNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(804)
			p.Match(SqlBaseParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(805)
			p.Namespace()
		}
		{
			p.SetState(806)
			p.IdentifierReference()
		}

	case 6:
		localctx = NewSetCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(808)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(809)
			p.Match(SqlBaseParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(810)
			p.CatalogIdentifierReference()
		}

	case 7:
		localctx = NewCreateNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(811)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(812)
			p.Namespace()
		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(813)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(814)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(815)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(819)
			p.IdentifierReference()
		}
		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(826)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case SqlBaseParserCOMMENT:
					{
						p.SetState(820)
						p.CommentSpec()
					}

				case SqlBaseParserLOCATION:
					{
						p.SetState(821)
						p.LocationSpec()
					}

				case SqlBaseParserDEFAULT:
					{
						p.SetState(822)
						p.CollationSpec()
					}

				case SqlBaseParserWITH:
					{
						p.SetState(823)
						p.Match(SqlBaseParserWITH)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(824)
						_la = p.GetTokenStream().LA(1)

						if !(_la == SqlBaseParserDBPROPERTIES || _la == SqlBaseParserPROPERTIES) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}
					{
						p.SetState(825)
						p.PropertyList()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(830)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 8:
		localctx = NewSetNamespacePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(831)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(832)
			p.Namespace()
		}
		{
			p.SetState(833)
			p.IdentifierReference()
		}
		{
			p.SetState(834)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(835)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDBPROPERTIES || _la == SqlBaseParserPROPERTIES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(836)
			p.PropertyList()
		}

	case 9:
		localctx = NewUnsetNamespacePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(838)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(839)
			p.Namespace()
		}
		{
			p.SetState(840)
			p.IdentifierReference()
		}
		{
			p.SetState(841)
			p.Match(SqlBaseParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(842)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDBPROPERTIES || _la == SqlBaseParserPROPERTIES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(843)
			p.PropertyList()
		}

	case 10:
		localctx = NewSetNamespaceCollationContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(845)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(846)
			p.Namespace()
		}
		{
			p.SetState(847)
			p.IdentifierReference()
		}
		{
			p.SetState(848)
			p.CollationSpec()
		}

	case 11:
		localctx = NewSetNamespaceLocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(850)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(851)
			p.Namespace()
		}
		{
			p.SetState(852)
			p.IdentifierReference()
		}
		{
			p.SetState(853)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(854)
			p.LocationSpec()
		}

	case 12:
		localctx = NewDropNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(856)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(857)
			p.Namespace()
		}
		p.SetState(860)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(858)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(859)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(862)
			p.IdentifierReference()
		}
		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT {
			{
				p.SetState(863)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 13:
		localctx = NewShowNamespacesContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(866)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(867)
			p.Namespaces()
		}
		p.SetState(870)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(868)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(869)
				p.MultipartIdentifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			p.SetState(873)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(872)
					p.Match(SqlBaseParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(875)

				var _x = p.StringLit()

				localctx.(*ShowNamespacesContext).pattern = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(878)
			p.CreateTableHeader()
		}
		p.SetState(883)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(879)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(880)
				p.TableElementList()
			}
			{
				p.SetState(881)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(885)
				p.TableProvider()
			}

		}
		{
			p.SetState(888)
			p.CreateTableClauses()
		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			p.SetState(890)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserAS {
				{
					p.SetState(889)
					p.Match(SqlBaseParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(892)
				p.Query()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 15:
		localctx = NewCreateTableLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(895)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(896)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(897)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(898)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(899)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(903)

			var _x = p.TableIdentifier()

			localctx.(*CreateTableLikeContext).target = _x
		}
		{
			p.SetState(904)
			p.Match(SqlBaseParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(905)

			var _x = p.TableIdentifier()

			localctx.(*CreateTableLikeContext).source = _x
		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserLOCATION || ((int64((_la-296)) & ^0x3f) == 0 && ((int64(1)<<(_la-296))&70370891661313) != 0) || _la == SqlBaseParserUSING {
			p.SetState(912)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case SqlBaseParserUSING:
				{
					p.SetState(906)
					p.TableProvider()
				}

			case SqlBaseParserROW:
				{
					p.SetState(907)
					p.RowFormat()
				}

			case SqlBaseParserSTORED:
				{
					p.SetState(908)
					p.CreateFileFormat()
				}

			case SqlBaseParserLOCATION:
				{
					p.SetState(909)
					p.LocationSpec()
				}

			case SqlBaseParserTBLPROPERTIES:
				{
					p.SetState(910)
					p.Match(SqlBaseParserTBLPROPERTIES)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(911)

					var _x = p.PropertyList()

					localctx.(*CreateTableLikeContext).tableProps = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(916)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 16:
		localctx = NewReplaceTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(917)
			p.ReplaceTableHeader()
		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(918)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(919)
				p.TableElementList()
			}
			{
				p.SetState(920)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(924)
				p.TableProvider()
			}

		}
		{
			p.SetState(927)
			p.CreateTableClauses()
		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			p.SetState(929)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserAS {
				{
					p.SetState(928)
					p.Match(SqlBaseParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(931)
				p.Query()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 17:
		localctx = NewAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(934)
			p.Match(SqlBaseParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(935)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(936)
			p.IdentifierReference()
		}
		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(937)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(940)
			p.Match(SqlBaseParserCOMPUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(941)
			p.Match(SqlBaseParserSTATISTICS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(942)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(943)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(944)
				p.Match(SqlBaseParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(945)
				p.IdentifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(946)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(947)
				p.Match(SqlBaseParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(948)
				p.Match(SqlBaseParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 18:
		localctx = NewAnalyzeTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(951)
			p.Match(SqlBaseParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(952)
			p.Match(SqlBaseParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(953)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(954)
				p.IdentifierReference()
			}

		}
		{
			p.SetState(957)
			p.Match(SqlBaseParserCOMPUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(958)
			p.Match(SqlBaseParserSTATISTICS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(959)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 19:
		localctx = NewAddTableColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(962)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(963)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(964)
			p.IdentifierReference()
		}
		{
			p.SetState(965)
			p.Match(SqlBaseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(966)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCOLUMN || _la == SqlBaseParserCOLUMNS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(967)

			var _x = p.QualifiedColTypeWithPositionList()

			localctx.(*AddTableColumnsContext).columns = _x
		}

	case 20:
		localctx = NewAddTableColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(969)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(970)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(971)
			p.IdentifierReference()
		}
		{
			p.SetState(972)
			p.Match(SqlBaseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(973)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCOLUMN || _la == SqlBaseParserCOLUMNS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(974)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(975)

			var _x = p.QualifiedColTypeWithPositionList()

			localctx.(*AddTableColumnsContext).columns = _x
		}
		{
			p.SetState(976)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewRenameTableColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(978)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(979)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(980)

			var _x = p.IdentifierReference()

			localctx.(*RenameTableColumnContext).table = _x
		}
		{
			p.SetState(981)
			p.Match(SqlBaseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(982)
			p.Match(SqlBaseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)

			var _x = p.MultipartIdentifier()

			localctx.(*RenameTableColumnContext).from = _x
		}
		{
			p.SetState(984)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(985)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*RenameTableColumnContext).to = _x
		}

	case 22:
		localctx = NewDropTableColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(987)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(989)
			p.IdentifierReference()
		}
		{
			p.SetState(990)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(991)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCOLUMN || _la == SqlBaseParserCOLUMNS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIF {
			{
				p.SetState(992)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(993)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(996)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(997)

			var _x = p.MultipartIdentifierList()

			localctx.(*DropTableColumnsContext).columns = _x
		}
		{
			p.SetState(998)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewDropTableColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1000)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1001)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1002)
			p.IdentifierReference()
		}
		{
			p.SetState(1003)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1004)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCOLUMN || _la == SqlBaseParserCOLUMNS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1005)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1006)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1009)

			var _x = p.MultipartIdentifierList()

			localctx.(*DropTableColumnsContext).columns = _x
		}

	case 24:
		localctx = NewRenameTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1011)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1012)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserTABLE || _la == SqlBaseParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1013)

			var _x = p.IdentifierReference()

			localctx.(*RenameTableContext).from = _x
		}
		{
			p.SetState(1014)
			p.Match(SqlBaseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1015)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1016)

			var _x = p.MultipartIdentifier()

			localctx.(*RenameTableContext).to = _x
		}

	case 25:
		localctx = NewSetTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1018)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1019)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserTABLE || _la == SqlBaseParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1020)
			p.IdentifierReference()
		}
		{
			p.SetState(1021)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1022)
			p.Match(SqlBaseParserTBLPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1023)
			p.PropertyList()
		}

	case 26:
		localctx = NewUnsetTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1025)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1026)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserTABLE || _la == SqlBaseParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1027)
			p.IdentifierReference()
		}
		{
			p.SetState(1028)
			p.Match(SqlBaseParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1029)
			p.Match(SqlBaseParserTBLPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIF {
			{
				p.SetState(1030)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1031)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1034)
			p.PropertyList()
		}

	case 27:
		localctx = NewAlterTableAlterColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1036)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1037)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1038)

			var _x = p.IdentifierReference()

			localctx.(*AlterTableAlterColumnContext).table = _x
		}
		{
			p.SetState(1039)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserALTER || _la == SqlBaseParserCHANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1040)
				p.Match(SqlBaseParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1043)

			var _x = p.AlterColumnSpecList()

			localctx.(*AlterTableAlterColumnContext).columns = _x
		}

	case 28:
		localctx = NewHiveChangeColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1045)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1046)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1047)

			var _x = p.IdentifierReference()

			localctx.(*HiveChangeColumnContext).table = _x
		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1048)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(1051)
			p.Match(SqlBaseParserCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1052)
				p.Match(SqlBaseParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1055)

			var _x = p.MultipartIdentifier()

			localctx.(*HiveChangeColumnContext).colName = _x
		}
		{
			p.SetState(1056)
			p.ColType()
		}
		p.SetState(1058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAFTER || _la == SqlBaseParserFIRST {
			{
				p.SetState(1057)
				p.ColPosition()
			}

		}

	case 29:
		localctx = NewHiveReplaceColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1060)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1061)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1062)

			var _x = p.IdentifierReference()

			localctx.(*HiveReplaceColumnsContext).table = _x
		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1063)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(1066)
			p.Match(SqlBaseParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1067)
			p.Match(SqlBaseParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1068)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1069)

			var _x = p.QualifiedColTypeWithPositionList()

			localctx.(*HiveReplaceColumnsContext).columns = _x
		}
		{
			p.SetState(1070)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		localctx = NewSetTableSerDeContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1072)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1073)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1074)
			p.IdentifierReference()
		}
		p.SetState(1076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1075)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(1078)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.Match(SqlBaseParserSERDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.StringLit()
		}
		p.SetState(1084)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1081)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1082)
				p.Match(SqlBaseParserSERDEPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1083)
				p.PropertyList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 31:
		localctx = NewSetTableSerDeContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1086)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1088)
			p.IdentifierReference()
		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1089)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(1092)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1093)
			p.Match(SqlBaseParserSERDEPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1094)
			p.PropertyList()
		}

	case 32:
		localctx = NewAddTablePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1096)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1097)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserTABLE || _la == SqlBaseParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1098)
			p.IdentifierReference()
		}
		{
			p.SetState(1099)
			p.Match(SqlBaseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIF {
			{
				p.SetState(1100)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1101)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(1102)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserPARTITION {
			{
				p.SetState(1106)
				p.PartitionSpecLocation()
			}

			p.SetState(1109)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 33:
		localctx = NewRenameTablePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1111)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1112)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1113)
			p.IdentifierReference()
		}
		{
			p.SetState(1114)

			var _x = p.PartitionSpec()

			localctx.(*RenameTablePartitionContext).from = _x
		}
		{
			p.SetState(1115)
			p.Match(SqlBaseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1116)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1117)

			var _x = p.PartitionSpec()

			localctx.(*RenameTablePartitionContext).to = _x
		}

	case 34:
		localctx = NewDropTablePartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1119)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1120)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserTABLE || _la == SqlBaseParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1121)
			p.IdentifierReference()
		}
		{
			p.SetState(1122)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIF {
			{
				p.SetState(1123)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1124)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1127)
			p.PartitionSpec()
		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(1128)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1129)
				p.PartitionSpec()
			}

			p.SetState(1134)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPURGE {
			{
				p.SetState(1135)
				p.Match(SqlBaseParserPURGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 35:
		localctx = NewSetTableLocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1138)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1139)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1140)
			p.IdentifierReference()
		}
		p.SetState(1142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1141)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(1144)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1145)
			p.LocationSpec()
		}

	case 36:
		localctx = NewRecoverPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1147)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1148)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1149)
			p.IdentifierReference()
		}
		{
			p.SetState(1150)
			p.Match(SqlBaseParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1151)
			p.Match(SqlBaseParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		localctx = NewAlterClusterByContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1153)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1154)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1155)
			p.IdentifierReference()
		}
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1156)
				p.ClusterBySpec()
			}

		case 2:
			{
				p.SetState(1157)
				p.Match(SqlBaseParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1158)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1159)
				p.Match(SqlBaseParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 38:
		localctx = NewAlterTableCollationContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1162)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1163)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1164)
			p.IdentifierReference()
		}
		{
			p.SetState(1165)
			p.CollationSpec()
		}

	case 39:
		localctx = NewAddTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1167)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1168)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1169)
			p.IdentifierReference()
		}
		{
			p.SetState(1170)
			p.Match(SqlBaseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1171)
			p.TableConstraintDefinition()
		}

	case 40:
		localctx = NewDropTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1173)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1174)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1175)
			p.IdentifierReference()
		}
		{
			p.SetState(1176)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1177)
			p.Match(SqlBaseParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1178)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1179)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1182)

			var _x = p.Identifier()

			localctx.(*DropTableConstraintContext).name = _x
		}
		p.SetState(1184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT {
			{
				p.SetState(1183)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 41:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1186)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1187)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1190)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1188)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1189)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1192)
			p.IdentifierReference()
		}
		p.SetState(1194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPURGE {
			{
				p.SetState(1193)
				p.Match(SqlBaseParserPURGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 42:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1196)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1197)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1200)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1198)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1199)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1202)
			p.IdentifierReference()
		}

	case 43:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1203)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(1204)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1205)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGLOBAL || _la == SqlBaseParserTEMPORARY {
			p.SetState(1209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserGLOBAL {
				{
					p.SetState(1208)
					p.Match(SqlBaseParserGLOBAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1211)
				p.Match(SqlBaseParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1214)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1219)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1215)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1216)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(1217)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1221)
			p.IdentifierReference()
		}
		p.SetState(1223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLEFT_PAREN {
			{
				p.SetState(1222)
				p.IdentifierCommentList()
			}

		}
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMENT || _la == SqlBaseParserDEFAULT || _la == SqlBaseParserPARTITIONED || _la == SqlBaseParserTBLPROPERTIES || _la == SqlBaseParserWITH {
			p.SetState(1233)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case SqlBaseParserCOMMENT:
				{
					p.SetState(1225)
					p.CommentSpec()
				}

			case SqlBaseParserWITH:
				{
					p.SetState(1226)
					p.SchemaBinding()
				}

			case SqlBaseParserDEFAULT:
				{
					p.SetState(1227)
					p.CollationSpec()
				}

			case SqlBaseParserPARTITIONED:
				{
					p.SetState(1228)
					p.Match(SqlBaseParserPARTITIONED)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1229)
					p.Match(SqlBaseParserON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1230)
					p.IdentifierList()
				}

			case SqlBaseParserTBLPROPERTIES:
				{
					p.SetState(1231)
					p.Match(SqlBaseParserTBLPROPERTIES)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1232)
					p.PropertyList()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1237)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1238)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1239)
			p.Query()
		}

	case 44:
		localctx = NewCreateTempViewUsingContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1241)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(1242)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1243)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGLOBAL {
			{
				p.SetState(1246)
				p.Match(SqlBaseParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1249)
			p.Match(SqlBaseParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1250)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1251)
			p.TableIdentifier()
		}
		p.SetState(1256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLEFT_PAREN {
			{
				p.SetState(1252)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1253)
				p.ColTypeList()
			}
			{
				p.SetState(1254)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1258)
			p.TableProvider()
		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOPTIONS {
			{
				p.SetState(1259)
				p.Match(SqlBaseParserOPTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1260)
				p.PropertyList()
			}

		}

	case 45:
		localctx = NewAlterViewQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1263)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1264)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1265)
			p.IdentifierReference()
		}
		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(1266)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1269)
			p.Query()
		}

	case 46:
		localctx = NewAlterViewSchemaBindingContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1271)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1272)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1273)
			p.IdentifierReference()
		}
		{
			p.SetState(1274)
			p.SchemaBinding()
		}

	case 47:
		localctx = NewCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(1276)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(1277)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1278)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTEMPORARY {
			{
				p.SetState(1281)
				p.Match(SqlBaseParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1284)
			p.Match(SqlBaseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1289)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1285)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1286)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(1287)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1291)
			p.IdentifierReference()
		}
		{
			p.SetState(1292)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1293)

			var _x = p.StringLit()

			localctx.(*CreateFunctionContext).className = _x
		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(1294)
				p.Match(SqlBaseParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1295)
				p.Resource()
			}
			p.SetState(1300)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(1296)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1297)
					p.Resource()
				}

				p.SetState(1302)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 48:
		localctx = NewCreateUserDefinedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(1305)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(1306)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1307)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTEMPORARY {
			{
				p.SetState(1310)
				p.Match(SqlBaseParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1313)
			p.Match(SqlBaseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1318)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1314)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1315)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(1316)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1320)
			p.IdentifierReference()
		}
		{
			p.SetState(1321)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1322)

				var _x = p.ColDefinitionList()

				localctx.(*CreateUserDefinedFunctionContext).parameters = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1325)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1326)
				p.Match(SqlBaseParserRETURNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1333)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1327)
					p.DataType()
				}

			case 2:
				{
					p.SetState(1328)
					p.Match(SqlBaseParserTABLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1329)
					p.Match(SqlBaseParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1330)

					var _x = p.ColTypeList()

					localctx.(*CreateUserDefinedFunctionContext).returnParams = _x
				}
				{
					p.SetState(1331)
					p.Match(SqlBaseParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1337)
			p.RoutineCharacteristics()
		}
		{
			p.SetState(1338)
			p.Match(SqlBaseParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1339)
				p.Query()
			}

		case 2:
			{
				p.SetState(1340)
				p.Expression()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 49:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(1343)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTEMPORARY {
			{
				p.SetState(1344)
				p.Match(SqlBaseParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1347)
			p.Match(SqlBaseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1350)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1348)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1349)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1352)
			p.IdentifierReference()
		}

	case 50:
		localctx = NewCreateVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(1353)
			p.Match(SqlBaseParserDECLARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1356)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1354)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1355)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1359)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1358)
				p.Variable()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1361)

			var _x = p.IdentifierReference()

			localctx.(*CreateVariableContext)._identifierReference = _x
		}
		localctx.(*CreateVariableContext).identifierReferences = append(localctx.(*CreateVariableContext).identifierReferences, localctx.(*CreateVariableContext)._identifierReference)
		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1362)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1363)

					var _x = p.IdentifierReference()

					localctx.(*CreateVariableContext)._identifierReference = _x
				}
				localctx.(*CreateVariableContext).identifierReferences = append(localctx.(*CreateVariableContext).identifierReferences, localctx.(*CreateVariableContext)._identifierReference)

			}
			p.SetState(1368)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1369)
				p.DataType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserDEFAULT || _la == SqlBaseParserEQ {
			{
				p.SetState(1372)
				p.VariableDefaultExpression()
			}

		}

	case 51:
		localctx = NewDropVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(1375)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1376)
			p.Match(SqlBaseParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1377)
			p.Variable()
		}
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1378)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1379)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1382)
			p.IdentifierReference()
		}

	case 52:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(1384)
			p.Match(SqlBaseParserEXPLAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCODEGEN || _la == SqlBaseParserCOST || _la == SqlBaseParserEXTENDED || _la == SqlBaseParserFORMATTED || _la == SqlBaseParserLOGICAL {
			{
				p.SetState(1385)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserCODEGEN || _la == SqlBaseParserCOST || _la == SqlBaseParserEXTENDED || _la == SqlBaseParserFORMATTED || _la == SqlBaseParserLOGICAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1388)
				p.Statement()
			}

		case 2:
			{
				p.SetState(1389)
				p.SetResetStatement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 53:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(1392)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1393)
			p.Match(SqlBaseParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1396)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1394)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1395)
				p.IdentifierReference()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1402)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			p.SetState(1399)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1398)
					p.Match(SqlBaseParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1401)

				var _x = p.StringLit()

				localctx.(*ShowTablesContext).pattern = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 54:
		localctx = NewShowTableExtendedContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(1404)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1405)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1406)
			p.Match(SqlBaseParserEXTENDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(1407)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1408)

				var _x = p.IdentifierReference()

				localctx.(*ShowTableExtendedContext).ns = _x
			}

		}
		{
			p.SetState(1411)
			p.Match(SqlBaseParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)

			var _x = p.StringLit()

			localctx.(*ShowTableExtendedContext).pattern = _x
		}
		p.SetState(1414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1413)
				p.PartitionSpec()
			}

		}

	case 55:
		localctx = NewShowTblPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(1416)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1417)
			p.Match(SqlBaseParserTBLPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1418)

			var _x = p.IdentifierReference()

			localctx.(*ShowTblPropertiesContext).table = _x
		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1419)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1420)

				var _x = p.PropertyKey()

				localctx.(*ShowTblPropertiesContext).key = _x
			}
			{
				p.SetState(1421)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 56:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(1425)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1426)
			p.Match(SqlBaseParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1428)

			var _x = p.IdentifierReference()

			localctx.(*ShowColumnsContext).table = _x
		}
		p.SetState(1431)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1429)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1430)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowColumnsContext).ns = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 57:
		localctx = NewShowViewsContext(p, localctx)
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(1433)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1434)
			p.Match(SqlBaseParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1437)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1435)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1436)
				p.IdentifierReference()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1443)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			p.SetState(1440)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1439)
					p.Match(SqlBaseParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1442)

				var _x = p.StringLit()

				localctx.(*ShowViewsContext).pattern = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 58:
		localctx = NewShowPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(1445)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.Match(SqlBaseParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1447)
			p.IdentifierReference()
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1448)
				p.PartitionSpec()
			}

		}

	case 59:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(1451)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1453)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1452)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1455)
			p.Match(SqlBaseParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1456)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1457)

				var _x = p.IdentifierReference()

				localctx.(*ShowFunctionsContext).ns = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
			p.SetState(1461)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1460)
					p.Match(SqlBaseParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(1465)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1463)

					var _x = p.MultipartIdentifier()

					localctx.(*ShowFunctionsContext).legacy = _x
				}

			case 2:
				{
					p.SetState(1464)

					var _x = p.StringLit()

					localctx.(*ShowFunctionsContext).pattern = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 60:
		localctx = NewShowProceduresContext(p, localctx)
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(1469)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.Match(SqlBaseParserPROCEDURES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1471)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1472)
				p.IdentifierReference()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 61:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(1475)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1476)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1477)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1478)
			p.IdentifierReference()
		}
		p.SetState(1481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(1479)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1480)
				p.Match(SqlBaseParserSERDE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 62:
		localctx = NewShowCurrentNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(1483)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.Match(SqlBaseParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1485)
			p.Namespace()
		}

	case 63:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(1486)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1487)
			p.Match(SqlBaseParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1492)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
			p.SetState(1489)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1488)
					p.Match(SqlBaseParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1491)

				var _x = p.StringLit()

				localctx.(*ShowCatalogsContext).pattern = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 64:
		localctx = NewDescribeFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(1494)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDESC || _la == SqlBaseParserDESCRIBE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1495)
			p.Match(SqlBaseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1496)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1499)
			p.DescribeFuncName()
		}

	case 65:
		localctx = NewDescribeProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(1500)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDESC || _la == SqlBaseParserDESCRIBE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1501)
			p.Match(SqlBaseParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1502)
			p.IdentifierReference()
		}

	case 66:
		localctx = NewDescribeNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(1503)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDESC || _la == SqlBaseParserDESCRIBE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1504)
			p.Namespace()
		}
		p.SetState(1506)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1505)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1508)
			p.IdentifierReference()
		}

	case 67:
		localctx = NewDescribeRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(1510)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDESC || _la == SqlBaseParserDESCRIBE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1512)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1511)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1515)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1514)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*DescribeRelationContext).option = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserEXTENDED || _la == SqlBaseParserFORMATTED) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*DescribeRelationContext).option = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1517)
			p.IdentifierReference()
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1518)
				p.PartitionSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1522)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1521)
				p.DescribeColName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(1524)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1525)
				p.Match(SqlBaseParserJSON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 68:
		localctx = NewDescribeQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(1528)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDESC || _la == SqlBaseParserDESCRIBE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserQUERY {
			{
				p.SetState(1529)
				p.Match(SqlBaseParserQUERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1532)
			p.Query()
		}

	case 69:
		localctx = NewCommentNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(1533)
			p.Match(SqlBaseParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1534)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1535)
			p.Namespace()
		}
		{
			p.SetState(1536)
			p.IdentifierReference()
		}
		{
			p.SetState(1537)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1538)
			p.Comment()
		}

	case 70:
		localctx = NewCommentTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(1540)
			p.Match(SqlBaseParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1541)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1542)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1543)
			p.IdentifierReference()
		}
		{
			p.SetState(1544)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1545)
			p.Comment()
		}

	case 71:
		localctx = NewRefreshTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(1547)
			p.Match(SqlBaseParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1548)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1549)
			p.IdentifierReference()
		}

	case 72:
		localctx = NewRefreshFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(1550)
			p.Match(SqlBaseParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1551)
			p.Match(SqlBaseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1552)
			p.IdentifierReference()
		}

	case 73:
		localctx = NewRefreshResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(1553)
			p.Match(SqlBaseParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1554)
				p.StringLit()
			}

		case 2:
			p.SetState(1558)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1+1 {
					p.SetState(1555)
					p.MatchWildcard()

				}
				p.SetState(1560)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 74:
		localctx = NewCacheTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(1563)
			p.Match(SqlBaseParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLAZY {
			{
				p.SetState(1564)
				p.Match(SqlBaseParserLAZY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1567)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1568)
			p.IdentifierReference()
		}
		p.SetState(1571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOPTIONS {
			{
				p.SetState(1569)
				p.Match(SqlBaseParserOPTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1570)

				var _x = p.PropertyList()

				localctx.(*CacheTableContext).options = _x
			}

		}
		p.SetState(1577)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
			p.SetState(1574)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserAS {
				{
					p.SetState(1573)
					p.Match(SqlBaseParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1576)
				p.Query()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 75:
		localctx = NewUncacheTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(1579)
			p.Match(SqlBaseParserUNCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1580)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1583)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1581)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1582)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1585)
			p.IdentifierReference()
		}

	case 76:
		localctx = NewClearCacheContext(p, localctx)
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(1586)
			p.Match(SqlBaseParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1587)
			p.Match(SqlBaseParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 77:
		localctx = NewLoadDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(1588)
			p.Match(SqlBaseParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1589)
			p.Match(SqlBaseParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLOCAL {
			{
				p.SetState(1590)
				p.Match(SqlBaseParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1593)
			p.Match(SqlBaseParserINPATH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1594)

			var _x = p.StringLit()

			localctx.(*LoadDataContext).path = _x
		}
		p.SetState(1596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOVERWRITE {
			{
				p.SetState(1595)
				p.Match(SqlBaseParserOVERWRITE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1598)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1599)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1600)
			p.IdentifierReference()
		}
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1601)
				p.PartitionSpec()
			}

		}

	case 78:
		localctx = NewTruncateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(1604)
			p.Match(SqlBaseParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1605)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1606)
			p.IdentifierReference()
		}
		p.SetState(1608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1607)
				p.PartitionSpec()
			}

		}

	case 79:
		localctx = NewRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 79)
		p.SetState(1611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMSCK {
			{
				p.SetState(1610)
				p.Match(SqlBaseParserMSCK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1613)
			p.Match(SqlBaseParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1614)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.IdentifierReference()
		}
		p.SetState(1618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1616)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*RepairTableContext).option = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserADD || _la == SqlBaseParserDROP || _la == SqlBaseParserSYNC) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*RepairTableContext).option = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1617)
				p.Match(SqlBaseParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 80:
		localctx = NewManageResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(1620)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ManageResourceContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserADD || _la == SqlBaseParserLIST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ManageResourceContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1621)
			p.Identifier()
		}
		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(1622)
				p.MatchWildcard()

			}
			p.SetState(1627)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 81:
		localctx = NewCreateIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(1628)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1629)
			p.Match(SqlBaseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1634)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1630)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1631)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(1632)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1636)
			p.Identifier()
		}
		{
			p.SetState(1637)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1639)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1638)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1641)
			p.IdentifierReference()
		}
		p.SetState(1644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(1642)
				p.Match(SqlBaseParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1643)

				var _x = p.Identifier()

				localctx.(*CreateIndexContext).indexType = _x
			}

		}
		{
			p.SetState(1646)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)

			var _x = p.MultipartIdentifierPropertyList()

			localctx.(*CreateIndexContext).columns = _x
		}
		{
			p.SetState(1648)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOPTIONS {
			{
				p.SetState(1649)
				p.Match(SqlBaseParserOPTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1650)

				var _x = p.PropertyList()

				localctx.(*CreateIndexContext).options = _x
			}

		}

	case 82:
		localctx = NewDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(1653)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1654)
			p.Match(SqlBaseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1655)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1656)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1659)
			p.Identifier()
		}
		{
			p.SetState(1660)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1662)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1661)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1664)
			p.IdentifierReference()
		}

	case 83:
		localctx = NewCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(1666)
			p.Match(SqlBaseParserCALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1667)
			p.IdentifierReference()
		}
		{
			p.SetState(1668)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1677)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1669)
				p.FunctionArgument()
			}
			p.SetState(1674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(1670)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1671)
					p.FunctionArgument()
				}

				p.SetState(1676)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1679)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 84:
		localctx = NewFailNativeCommandContext(p, localctx)
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(1681)
			p.UnsupportedHiveNativeCommands()
		}
		p.SetState(1685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(1682)
				p.MatchWildcard()

			}
			p.SetState(1687)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 85:
		localctx = NewCreatePipelineDatasetContext(p, localctx)
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(1688)
			p.CreatePipelineDatasetHeader()
		}
		p.SetState(1694)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1689)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1691)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1690)
					p.TableElementList()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1693)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(1696)
				p.TableProvider()
			}

		}
		{
			p.SetState(1699)
			p.CreateTableClauses()
		}
		p.SetState(1702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(1700)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1701)
				p.Query()
			}

		}

	case 86:
		localctx = NewCreatePipelineInsertIntoFlowContext(p, localctx)
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(1704)
			p.CreatePipelineFlowHeader()
		}
		{
			p.SetState(1705)
			p.InsertInto()
		}
		{
			p.SetState(1706)
			p.Query()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewContext is an interface to support dynamic dispatch.
type IMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsMaterializedViewContext differentiates from other interfaces.
	IsMaterializedViewContext()
}

type MaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewContext() *MaterializedViewContext {
	var p = new(MaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_materializedView
	return p
}

func InitEmptyMaterializedViewContext(p *MaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_materializedView
}

func (*MaterializedViewContext) IsMaterializedViewContext() {}

func NewMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewContext {
	var p = new(MaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_materializedView

	return p
}

func (s *MaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *MaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *MaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMaterializedView(s)
	}
}

func (s *MaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMaterializedView(s)
	}
}

func (p *SqlBaseParser) MaterializedView() (localctx IMaterializedViewContext) {
	localctx = NewMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SqlBaseParserRULE_materializedView)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		p.Match(SqlBaseParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1711)
		p.Match(SqlBaseParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStreamingTableContext is an interface to support dynamic dispatch.
type IStreamingTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STREAMING() antlr.TerminalNode
	TABLE() antlr.TerminalNode

	// IsStreamingTableContext differentiates from other interfaces.
	IsStreamingTableContext()
}

type StreamingTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStreamingTableContext() *StreamingTableContext {
	var p = new(StreamingTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_streamingTable
	return p
}

func InitEmptyStreamingTableContext(p *StreamingTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_streamingTable
}

func (*StreamingTableContext) IsStreamingTableContext() {}

func NewStreamingTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StreamingTableContext {
	var p = new(StreamingTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_streamingTable

	return p
}

func (s *StreamingTableContext) GetParser() antlr.Parser { return s.parser }

func (s *StreamingTableContext) STREAMING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAMING, 0)
}

func (s *StreamingTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *StreamingTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StreamingTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StreamingTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStreamingTable(s)
	}
}

func (s *StreamingTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStreamingTable(s)
	}
}

func (p *SqlBaseParser) StreamingTable() (localctx IStreamingTableContext) {
	localctx = NewStreamingTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SqlBaseParserRULE_streamingTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1713)
		p.Match(SqlBaseParserSTREAMING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1714)
		p.Match(SqlBaseParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatePipelineDatasetHeaderContext is an interface to support dynamic dispatch.
type ICreatePipelineDatasetHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	IdentifierReference() IIdentifierReferenceContext
	MaterializedView() IMaterializedViewContext
	StreamingTable() IStreamingTableContext
	IF() antlr.TerminalNode
	ErrorCapturingNot() IErrorCapturingNotContext
	EXISTS() antlr.TerminalNode

	// IsCreatePipelineDatasetHeaderContext differentiates from other interfaces.
	IsCreatePipelineDatasetHeaderContext()
}

type CreatePipelineDatasetHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatePipelineDatasetHeaderContext() *CreatePipelineDatasetHeaderContext {
	var p = new(CreatePipelineDatasetHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createPipelineDatasetHeader
	return p
}

func InitEmptyCreatePipelineDatasetHeaderContext(p *CreatePipelineDatasetHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createPipelineDatasetHeader
}

func (*CreatePipelineDatasetHeaderContext) IsCreatePipelineDatasetHeaderContext() {}

func NewCreatePipelineDatasetHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatePipelineDatasetHeaderContext {
	var p = new(CreatePipelineDatasetHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_createPipelineDatasetHeader

	return p
}

func (s *CreatePipelineDatasetHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatePipelineDatasetHeaderContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreatePipelineDatasetHeaderContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreatePipelineDatasetHeaderContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *CreatePipelineDatasetHeaderContext) StreamingTable() IStreamingTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStreamingTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStreamingTableContext)
}

func (s *CreatePipelineDatasetHeaderContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreatePipelineDatasetHeaderContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreatePipelineDatasetHeaderContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreatePipelineDatasetHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipelineDatasetHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatePipelineDatasetHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreatePipelineDatasetHeader(s)
	}
}

func (s *CreatePipelineDatasetHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreatePipelineDatasetHeader(s)
	}
}

func (p *SqlBaseParser) CreatePipelineDatasetHeader() (localctx ICreatePipelineDatasetHeaderContext) {
	localctx = NewCreatePipelineDatasetHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SqlBaseParserRULE_createPipelineDatasetHeader)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1716)
		p.Match(SqlBaseParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserMATERIALIZED:
		{
			p.SetState(1717)
			p.MaterializedView()
		}

	case SqlBaseParserSTREAMING:
		{
			p.SetState(1718)
			p.StreamingTable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1721)
			p.Match(SqlBaseParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1722)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(1723)
			p.Match(SqlBaseParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1727)
		p.IdentifierReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStreamRelationPrimaryContext is an interface to support dynamic dispatch.
type IStreamRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStreamRelationPrimaryContext differentiates from other interfaces.
	IsStreamRelationPrimaryContext()
}

type StreamRelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStreamRelationPrimaryContext() *StreamRelationPrimaryContext {
	var p = new(StreamRelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_streamRelationPrimary
	return p
}

func InitEmptyStreamRelationPrimaryContext(p *StreamRelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_streamRelationPrimary
}

func (*StreamRelationPrimaryContext) IsStreamRelationPrimaryContext() {}

func NewStreamRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StreamRelationPrimaryContext {
	var p = new(StreamRelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_streamRelationPrimary

	return p
}

func (s *StreamRelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *StreamRelationPrimaryContext) CopyAll(ctx *StreamRelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StreamRelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StreamRelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StreamTableNameContext struct {
	StreamRelationPrimaryContext
}

func NewStreamTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StreamTableNameContext {
	var p = new(StreamTableNameContext)

	InitEmptyStreamRelationPrimaryContext(&p.StreamRelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*StreamRelationPrimaryContext))

	return p
}

func (s *StreamTableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StreamTableNameContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *StreamTableNameContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *StreamTableNameContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *StreamTableNameContext) OptionsClause() IOptionsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionsClauseContext)
}

func (s *StreamTableNameContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *StreamTableNameContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *StreamTableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStreamTableName(s)
	}
}

func (s *StreamTableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStreamTableName(s)
	}
}

func (p *SqlBaseParser) StreamRelationPrimary() (localctx IStreamRelationPrimaryContext) {
	localctx = NewStreamRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SqlBaseParserRULE_streamRelationPrimary)
	p.SetState(1745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStreamTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1729)
			p.Match(SqlBaseParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1730)
			p.MultipartIdentifier()
		}
		p.SetState(1732)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1731)
				p.OptionsClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1734)
			p.TableAlias()
		}

	case 2:
		localctx = NewStreamTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1736)
			p.Match(SqlBaseParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1737)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1738)
			p.MultipartIdentifier()
		}
		{
			p.SetState(1739)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1741)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1740)
				p.OptionsClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1743)
			p.TableAlias()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetResetStatementContext is an interface to support dynamic dispatch.
type ISetResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetResetStatementContext differentiates from other interfaces.
	IsSetResetStatementContext()
}

type SetResetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetResetStatementContext() *SetResetStatementContext {
	var p = new(SetResetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setResetStatement
	return p
}

func InitEmptySetResetStatementContext(p *SetResetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setResetStatement
}

func (*SetResetStatementContext) IsSetResetStatementContext() {}

func NewSetResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetResetStatementContext {
	var p = new(SetResetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_setResetStatement

	return p
}

func (s *SetResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetResetStatementContext) CopyAll(ctx *SetResetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetQuotedConfigurationContext struct {
	SetResetStatementContext
}

func NewSetQuotedConfigurationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetQuotedConfigurationContext {
	var p = new(SetQuotedConfigurationContext)

	InitEmptySetResetStatementContext(&p.SetResetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetResetStatementContext))

	return p
}

func (s *SetQuotedConfigurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuotedConfigurationContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetQuotedConfigurationContext) ConfigKey() IConfigKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConfigKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConfigKeyContext)
}

func (s *SetQuotedConfigurationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetQuotedConfigurationContext) ConfigValue() IConfigValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConfigValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConfigValueContext)
}

func (s *SetQuotedConfigurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetQuotedConfiguration(s)
	}
}

func (s *SetQuotedConfigurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetQuotedConfiguration(s)
	}
}

type ResetQuotedConfigurationContext struct {
	SetResetStatementContext
}

func NewResetQuotedConfigurationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetQuotedConfigurationContext {
	var p = new(ResetQuotedConfigurationContext)

	InitEmptySetResetStatementContext(&p.SetResetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetResetStatementContext))

	return p
}

func (s *ResetQuotedConfigurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetQuotedConfigurationContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *ResetQuotedConfigurationContext) ConfigKey() IConfigKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConfigKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConfigKeyContext)
}

func (s *ResetQuotedConfigurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterResetQuotedConfiguration(s)
	}
}

func (s *ResetQuotedConfigurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitResetQuotedConfiguration(s)
	}
}

type FailSetRoleContext struct {
	SetResetStatementContext
}

func NewFailSetRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FailSetRoleContext {
	var p = new(FailSetRoleContext)

	InitEmptySetResetStatementContext(&p.SetResetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetResetStatementContext))

	return p
}

func (s *FailSetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FailSetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *FailSetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *FailSetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFailSetRole(s)
	}
}

func (s *FailSetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFailSetRole(s)
	}
}

type ResetConfigurationContext struct {
	SetResetStatementContext
}

func NewResetConfigurationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetConfigurationContext {
	var p = new(ResetConfigurationContext)

	InitEmptySetResetStatementContext(&p.SetResetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetResetStatementContext))

	return p
}

func (s *ResetConfigurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetConfigurationContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *ResetConfigurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterResetConfiguration(s)
	}
}

func (s *ResetConfigurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitResetConfiguration(s)
	}
}

type SetTimeZoneContext struct {
	SetResetStatementContext
}

func NewSetTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTimeZoneContext {
	var p = new(SetTimeZoneContext)

	InitEmptySetResetStatementContext(&p.SetResetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetResetStatementContext))

	return p
}

func (s *SetTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTimeZoneContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetTimeZoneContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *SetTimeZoneContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *SetTimeZoneContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *SetTimeZoneContext) Timezone() ITimezoneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimezoneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimezoneContext)
}

func (s *SetTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetTimeZone(s)
	}
}

func (s *SetTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetTimeZone(s)
	}
}

type SetVariableContext struct {
	SetResetStatementContext
}

func NewSetVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableContext {
	var p = new(SetVariableContext)

	InitEmptySetResetStatementContext(&p.SetResetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetResetStatementContext))

	return p
}

func (s *SetVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetVariableContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *SetVariableContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *SetVariableContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *SetVariableContext) MultipartIdentifierList() IMultipartIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierListContext)
}

func (s *SetVariableContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *SetVariableContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *SetVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetVariableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SetVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetVariable(s)
	}
}

func (s *SetVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetVariable(s)
	}
}

type SetConfigurationContext struct {
	SetResetStatementContext
}

func NewSetConfigurationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetConfigurationContext {
	var p = new(SetConfigurationContext)

	InitEmptySetResetStatementContext(&p.SetResetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetResetStatementContext))

	return p
}

func (s *SetConfigurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetConfigurationContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetConfigurationContext) ConfigKey() IConfigKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConfigKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConfigKeyContext)
}

func (s *SetConfigurationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetConfigurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetConfiguration(s)
	}
}

func (s *SetConfigurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetConfiguration(s)
	}
}

func (p *SqlBaseParser) SetResetStatement() (localctx ISetResetStatementContext) {
	localctx = NewSetResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SqlBaseParserRULE_setResetStatement)
	var _la int

	var _alt int

	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFailSetRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1747)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1748)
			p.Match(SqlBaseParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(1749)
				p.MatchWildcard()

			}
			p.SetState(1754)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewSetTimeZoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1755)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1756)
			p.Match(SqlBaseParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1757)
			p.Match(SqlBaseParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1758)
			p.Interval()
		}

	case 3:
		localctx = NewSetTimeZoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1759)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1760)
			p.Match(SqlBaseParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1761)
			p.Match(SqlBaseParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1762)
			p.Timezone()
		}

	case 4:
		localctx = NewSetTimeZoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1763)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1764)
			p.Match(SqlBaseParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1765)
			p.Match(SqlBaseParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(1766)
				p.MatchWildcard()

			}
			p.SetState(1771)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 5:
		localctx = NewSetVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1772)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1773)
			p.Variable()
		}
		{
			p.SetState(1774)
			p.AssignmentList()
		}

	case 6:
		localctx = NewSetVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1776)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1777)
			p.Variable()
		}
		{
			p.SetState(1778)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1779)
			p.MultipartIdentifierList()
		}
		{
			p.SetState(1780)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1781)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1782)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1783)
			p.Query()
		}
		{
			p.SetState(1784)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewSetQuotedConfigurationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1786)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.ConfigKey()
		}
		{
			p.SetState(1788)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1789)
			p.ConfigValue()
		}

	case 8:
		localctx = NewSetConfigurationContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1791)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1792)
			p.ConfigKey()
		}
		p.SetState(1800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEQ {
			{
				p.SetState(1793)
				p.Match(SqlBaseParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1797)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1+1 {
					p.SetState(1794)
					p.MatchWildcard()

				}
				p.SetState(1799)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewSetQuotedConfigurationContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1802)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(1803)
				p.MatchWildcard()

			}
			p.SetState(1808)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1809)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1810)
			p.ConfigValue()
		}

	case 10:
		localctx = NewSetConfigurationContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1811)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(1812)
				p.MatchWildcard()

			}
			p.SetState(1817)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 11:
		localctx = NewResetQuotedConfigurationContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1818)
			p.Match(SqlBaseParserRESET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1819)
			p.ConfigKey()
		}

	case 12:
		localctx = NewResetConfigurationContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1820)
			p.Match(SqlBaseParserRESET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(1821)
				p.MatchWildcard()

			}
			p.SetState(1826)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteImmediateContext is an interface to support dynamic dispatch.
type IExecuteImmediateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetQueryParam returns the queryParam rule contexts.
	GetQueryParam() IExpressionContext

	// GetTargetVariable returns the targetVariable rule contexts.
	GetTargetVariable() IMultipartIdentifierListContext

	// SetQueryParam sets the queryParam rule contexts.
	SetQueryParam(IExpressionContext)

	// SetTargetVariable sets the targetVariable rule contexts.
	SetTargetVariable(IMultipartIdentifierListContext)

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	Expression() IExpressionContext
	INTO() antlr.TerminalNode
	ExecuteImmediateUsing() IExecuteImmediateUsingContext
	MultipartIdentifierList() IMultipartIdentifierListContext

	// IsExecuteImmediateContext differentiates from other interfaces.
	IsExecuteImmediateContext()
}

type ExecuteImmediateContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	queryParam     IExpressionContext
	targetVariable IMultipartIdentifierListContext
}

func NewEmptyExecuteImmediateContext() *ExecuteImmediateContext {
	var p = new(ExecuteImmediateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_executeImmediate
	return p
}

func InitEmptyExecuteImmediateContext(p *ExecuteImmediateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_executeImmediate
}

func (*ExecuteImmediateContext) IsExecuteImmediateContext() {}

func NewExecuteImmediateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteImmediateContext {
	var p = new(ExecuteImmediateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_executeImmediate

	return p
}

func (s *ExecuteImmediateContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteImmediateContext) GetQueryParam() IExpressionContext { return s.queryParam }

func (s *ExecuteImmediateContext) GetTargetVariable() IMultipartIdentifierListContext {
	return s.targetVariable
}

func (s *ExecuteImmediateContext) SetQueryParam(v IExpressionContext) { s.queryParam = v }

func (s *ExecuteImmediateContext) SetTargetVariable(v IMultipartIdentifierListContext) {
	s.targetVariable = v
}

func (s *ExecuteImmediateContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXECUTE, 0)
}

func (s *ExecuteImmediateContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIMMEDIATE, 0)
}

func (s *ExecuteImmediateContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExecuteImmediateContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *ExecuteImmediateContext) ExecuteImmediateUsing() IExecuteImmediateUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteImmediateUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteImmediateUsingContext)
}

func (s *ExecuteImmediateContext) MultipartIdentifierList() IMultipartIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierListContext)
}

func (s *ExecuteImmediateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteImmediateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteImmediateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExecuteImmediate(s)
	}
}

func (s *ExecuteImmediateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExecuteImmediate(s)
	}
}

func (p *SqlBaseParser) ExecuteImmediate() (localctx IExecuteImmediateContext) {
	localctx = NewExecuteImmediateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SqlBaseParserRULE_executeImmediate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		p.Match(SqlBaseParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1830)
		p.Match(SqlBaseParserIMMEDIATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1831)

		var _x = p.Expression()

		localctx.(*ExecuteImmediateContext).queryParam = _x
	}
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserINTO {
		{
			p.SetState(1832)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1833)

			var _x = p.MultipartIdentifierList()

			localctx.(*ExecuteImmediateContext).targetVariable = _x
		}

	}
	p.SetState(1837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserUSING {
		{
			p.SetState(1836)
			p.ExecuteImmediateUsing()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteImmediateUsingContext is an interface to support dynamic dispatch.
type IExecuteImmediateUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParams returns the params rule contexts.
	GetParams() INamedExpressionSeqContext

	// SetParams sets the params rule contexts.
	SetParams(INamedExpressionSeqContext)

	// Getter signatures
	USING() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	NamedExpressionSeq() INamedExpressionSeqContext

	// IsExecuteImmediateUsingContext differentiates from other interfaces.
	IsExecuteImmediateUsingContext()
}

type ExecuteImmediateUsingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	params INamedExpressionSeqContext
}

func NewEmptyExecuteImmediateUsingContext() *ExecuteImmediateUsingContext {
	var p = new(ExecuteImmediateUsingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_executeImmediateUsing
	return p
}

func InitEmptyExecuteImmediateUsingContext(p *ExecuteImmediateUsingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_executeImmediateUsing
}

func (*ExecuteImmediateUsingContext) IsExecuteImmediateUsingContext() {}

func NewExecuteImmediateUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteImmediateUsingContext {
	var p = new(ExecuteImmediateUsingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_executeImmediateUsing

	return p
}

func (s *ExecuteImmediateUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteImmediateUsingContext) GetParams() INamedExpressionSeqContext { return s.params }

func (s *ExecuteImmediateUsingContext) SetParams(v INamedExpressionSeqContext) { s.params = v }

func (s *ExecuteImmediateUsingContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *ExecuteImmediateUsingContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ExecuteImmediateUsingContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ExecuteImmediateUsingContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ExecuteImmediateUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteImmediateUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteImmediateUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExecuteImmediateUsing(s)
	}
}

func (s *ExecuteImmediateUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExecuteImmediateUsing(s)
	}
}

func (p *SqlBaseParser) ExecuteImmediateUsing() (localctx IExecuteImmediateUsingContext) {
	localctx = NewExecuteImmediateUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SqlBaseParserRULE_executeImmediateUsing)
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1839)
			p.Match(SqlBaseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1840)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1841)

			var _x = p.NamedExpressionSeq()

			localctx.(*ExecuteImmediateUsingContext).params = _x
		}
		{
			p.SetState(1842)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1844)
			p.Match(SqlBaseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1845)

			var _x = p.NamedExpressionSeq()

			localctx.(*ExecuteImmediateUsingContext).params = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimezoneContext is an interface to support dynamic dispatch.
type ITimezoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLit() IStringLitContext
	LOCAL() antlr.TerminalNode

	// IsTimezoneContext differentiates from other interfaces.
	IsTimezoneContext()
}

type TimezoneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimezoneContext() *TimezoneContext {
	var p = new(TimezoneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timezone
	return p
}

func InitEmptyTimezoneContext(p *TimezoneContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timezone
}

func (*TimezoneContext) IsTimezoneContext() {}

func NewTimezoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimezoneContext {
	var p = new(TimezoneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_timezone

	return p
}

func (s *TimezoneContext) GetParser() antlr.Parser { return s.parser }

func (s *TimezoneContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *TimezoneContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCAL, 0)
}

func (s *TimezoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimezoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimezoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTimezone(s)
	}
}

func (s *TimezoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTimezone(s)
	}
}

func (p *SqlBaseParser) Timezone() (localctx ITimezoneContext) {
	localctx = NewTimezoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SqlBaseParserRULE_timezone)
	p.SetState(1850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1848)
			p.StringLit()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1849)
			p.Match(SqlBaseParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConfigKeyContext is an interface to support dynamic dispatch.
type IConfigKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuotedIdentifier() IQuotedIdentifierContext

	// IsConfigKeyContext differentiates from other interfaces.
	IsConfigKeyContext()
}

type ConfigKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigKeyContext() *ConfigKeyContext {
	var p = new(ConfigKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_configKey
	return p
}

func InitEmptyConfigKeyContext(p *ConfigKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_configKey
}

func (*ConfigKeyContext) IsConfigKeyContext() {}

func NewConfigKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigKeyContext {
	var p = new(ConfigKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_configKey

	return p
}

func (s *ConfigKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigKeyContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *ConfigKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterConfigKey(s)
	}
}

func (s *ConfigKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitConfigKey(s)
	}
}

func (p *SqlBaseParser) ConfigKey() (localctx IConfigKeyContext) {
	localctx = NewConfigKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SqlBaseParserRULE_configKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1852)
		p.QuotedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConfigValueContext is an interface to support dynamic dispatch.
type IConfigValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BackQuotedIdentifier() IBackQuotedIdentifierContext

	// IsConfigValueContext differentiates from other interfaces.
	IsConfigValueContext()
}

type ConfigValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigValueContext() *ConfigValueContext {
	var p = new(ConfigValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_configValue
	return p
}

func InitEmptyConfigValueContext(p *ConfigValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_configValue
}

func (*ConfigValueContext) IsConfigValueContext() {}

func NewConfigValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigValueContext {
	var p = new(ConfigValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_configValue

	return p
}

func (s *ConfigValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigValueContext) BackQuotedIdentifier() IBackQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackQuotedIdentifierContext)
}

func (s *ConfigValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterConfigValue(s)
	}
}

func (s *ConfigValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitConfigValue(s)
	}
}

func (p *SqlBaseParser) ConfigValue() (localctx IConfigValueContext) {
	localctx = NewConfigValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SqlBaseParserRULE_configValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1854)
		p.BackQuotedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedHiveNativeCommandsContext is an interface to support dynamic dispatch.
type IUnsupportedHiveNativeCommandsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKw1 returns the kw1 token.
	GetKw1() antlr.Token

	// GetKw2 returns the kw2 token.
	GetKw2() antlr.Token

	// GetKw3 returns the kw3 token.
	GetKw3() antlr.Token

	// GetKw4 returns the kw4 token.
	GetKw4() antlr.Token

	// GetKw5 returns the kw5 token.
	GetKw5() antlr.Token

	// GetKw6 returns the kw6 token.
	GetKw6() antlr.Token

	// SetKw1 sets the kw1 token.
	SetKw1(antlr.Token)

	// SetKw2 sets the kw2 token.
	SetKw2(antlr.Token)

	// SetKw3 sets the kw3 token.
	SetKw3(antlr.Token)

	// SetKw4 sets the kw4 token.
	SetKw4(antlr.Token)

	// SetKw5 sets the kw5 token.
	SetKw5(antlr.Token)

	// SetKw6 sets the kw6 token.
	SetKw6(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	PRINCIPALS() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	COMPACTIONS() antlr.TerminalNode
	TRANSACTIONS() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	LOCKS() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	MACRO() antlr.TerminalNode
	TableIdentifier() ITableIdentifierContext
	NOT() antlr.TerminalNode
	CLUSTERED() antlr.TerminalNode
	BY() antlr.TerminalNode
	SORTED() antlr.TerminalNode
	SKEWED() antlr.TerminalNode
	STORED() antlr.TerminalNode
	AS() antlr.TerminalNode
	DIRECTORIES() antlr.TerminalNode
	SET() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	ARCHIVE() antlr.TerminalNode
	UNARCHIVE() antlr.TerminalNode
	TOUCH() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	CONCATENATE() antlr.TerminalNode
	FILEFORMAT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	DFS() antlr.TerminalNode

	// IsUnsupportedHiveNativeCommandsContext differentiates from other interfaces.
	IsUnsupportedHiveNativeCommandsContext()
}

type UnsupportedHiveNativeCommandsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	kw1    antlr.Token
	kw2    antlr.Token
	kw3    antlr.Token
	kw4    antlr.Token
	kw5    antlr.Token
	kw6    antlr.Token
}

func NewEmptyUnsupportedHiveNativeCommandsContext() *UnsupportedHiveNativeCommandsContext {
	var p = new(UnsupportedHiveNativeCommandsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unsupportedHiveNativeCommands
	return p
}

func InitEmptyUnsupportedHiveNativeCommandsContext(p *UnsupportedHiveNativeCommandsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unsupportedHiveNativeCommands
}

func (*UnsupportedHiveNativeCommandsContext) IsUnsupportedHiveNativeCommandsContext() {}

func NewUnsupportedHiveNativeCommandsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedHiveNativeCommandsContext {
	var p = new(UnsupportedHiveNativeCommandsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unsupportedHiveNativeCommands

	return p
}

func (s *UnsupportedHiveNativeCommandsContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedHiveNativeCommandsContext) GetKw1() antlr.Token { return s.kw1 }

func (s *UnsupportedHiveNativeCommandsContext) GetKw2() antlr.Token { return s.kw2 }

func (s *UnsupportedHiveNativeCommandsContext) GetKw3() antlr.Token { return s.kw3 }

func (s *UnsupportedHiveNativeCommandsContext) GetKw4() antlr.Token { return s.kw4 }

func (s *UnsupportedHiveNativeCommandsContext) GetKw5() antlr.Token { return s.kw5 }

func (s *UnsupportedHiveNativeCommandsContext) GetKw6() antlr.Token { return s.kw6 }

func (s *UnsupportedHiveNativeCommandsContext) SetKw1(v antlr.Token) { s.kw1 = v }

func (s *UnsupportedHiveNativeCommandsContext) SetKw2(v antlr.Token) { s.kw2 = v }

func (s *UnsupportedHiveNativeCommandsContext) SetKw3(v antlr.Token) { s.kw3 = v }

func (s *UnsupportedHiveNativeCommandsContext) SetKw4(v antlr.Token) { s.kw4 = v }

func (s *UnsupportedHiveNativeCommandsContext) SetKw5(v antlr.Token) { s.kw5 = v }

func (s *UnsupportedHiveNativeCommandsContext) SetKw6(v antlr.Token) { s.kw6 = v }

func (s *UnsupportedHiveNativeCommandsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) PRINCIPALS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRINCIPALS, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPORT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIMPORT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) COMPACTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPACTIONS, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTIONS, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEXES, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) LOCKS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCKS, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) LOCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCK, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNLOCK, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) MACRO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMACRO, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *UnsupportedHiveNativeCommandsContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTERED, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) SORTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORTED, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) SKEWED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSKEWED, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) STORED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTORED, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORIES, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCATION, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCHANGE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARCHIVE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) UNARCHIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNARCHIVE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) TOUCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTOUCH, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPACT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *UnsupportedHiveNativeCommandsContext) CONCATENATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCATENATE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) FILEFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILEFORMAT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) DFS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDFS, 0)
}

func (s *UnsupportedHiveNativeCommandsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedHiveNativeCommandsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedHiveNativeCommandsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnsupportedHiveNativeCommands(s)
	}
}

func (s *UnsupportedHiveNativeCommandsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnsupportedHiveNativeCommands(s)
	}
}

func (p *SqlBaseParser) UnsupportedHiveNativeCommands() (localctx IUnsupportedHiveNativeCommandsContext) {
	localctx = NewUnsupportedHiveNativeCommandsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SqlBaseParserRULE_unsupportedHiveNativeCommands)
	var _la int

	p.SetState(2024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1856)

			var _m = p.Match(SqlBaseParserCREATE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1857)

			var _m = p.Match(SqlBaseParserROLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1858)

			var _m = p.Match(SqlBaseParserDROP)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1859)

			var _m = p.Match(SqlBaseParserROLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1860)

			var _m = p.Match(SqlBaseParserGRANT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1862)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1861)

				var _m = p.Match(SqlBaseParserROLE)

				localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1864)

			var _m = p.Match(SqlBaseParserREVOKE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1866)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1865)

				var _m = p.Match(SqlBaseParserROLE)

				localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1868)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)

			var _m = p.Match(SqlBaseParserGRANT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1870)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1871)

			var _m = p.Match(SqlBaseParserROLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1873)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1872)

				var _m = p.Match(SqlBaseParserGRANT)

				localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1875)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1876)

			var _m = p.Match(SqlBaseParserPRINCIPALS)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1877)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)

			var _m = p.Match(SqlBaseParserROLES)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1879)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1880)

			var _m = p.Match(SqlBaseParserCURRENT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1881)

			var _m = p.Match(SqlBaseParserROLES)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1882)

			var _m = p.Match(SqlBaseParserEXPORT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1883)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1884)

			var _m = p.Match(SqlBaseParserIMPORT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1885)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1886)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1887)

			var _m = p.Match(SqlBaseParserCOMPACTIONS)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1888)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1889)

			var _m = p.Match(SqlBaseParserCREATE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1890)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1891)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1892)

			var _m = p.Match(SqlBaseParserTRANSACTIONS)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1893)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1894)

			var _m = p.Match(SqlBaseParserINDEXES)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1895)

			var _m = p.Match(SqlBaseParserSHOW)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1896)

			var _m = p.Match(SqlBaseParserLOCKS)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1897)

			var _m = p.Match(SqlBaseParserCREATE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1898)

			var _m = p.Match(SqlBaseParserINDEX)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1899)

			var _m = p.Match(SqlBaseParserDROP)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1900)

			var _m = p.Match(SqlBaseParserINDEX)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1901)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1902)

			var _m = p.Match(SqlBaseParserINDEX)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1903)

			var _m = p.Match(SqlBaseParserLOCK)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1904)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1905)

			var _m = p.Match(SqlBaseParserLOCK)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1906)

			var _m = p.Match(SqlBaseParserDATABASE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1907)

			var _m = p.Match(SqlBaseParserUNLOCK)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1908)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1909)

			var _m = p.Match(SqlBaseParserUNLOCK)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1910)

			var _m = p.Match(SqlBaseParserDATABASE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1911)

			var _m = p.Match(SqlBaseParserCREATE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1912)

			var _m = p.Match(SqlBaseParserTEMPORARY)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1913)

			var _m = p.Match(SqlBaseParserMACRO)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1914)

			var _m = p.Match(SqlBaseParserDROP)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1915)

			var _m = p.Match(SqlBaseParserTEMPORARY)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1916)

			var _m = p.Match(SqlBaseParserMACRO)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1917)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1918)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1919)
			p.TableIdentifier()
		}
		{
			p.SetState(1920)

			var _m = p.Match(SqlBaseParserNOT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1921)

			var _m = p.Match(SqlBaseParserCLUSTERED)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1923)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1924)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1925)
			p.TableIdentifier()
		}
		{
			p.SetState(1926)

			var _m = p.Match(SqlBaseParserCLUSTERED)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1927)

			var _m = p.Match(SqlBaseParserBY)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1929)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1930)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1931)
			p.TableIdentifier()
		}
		{
			p.SetState(1932)

			var _m = p.Match(SqlBaseParserNOT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1933)

			var _m = p.Match(SqlBaseParserSORTED)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1935)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1936)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1937)
			p.TableIdentifier()
		}
		{
			p.SetState(1938)

			var _m = p.Match(SqlBaseParserSKEWED)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1939)

			var _m = p.Match(SqlBaseParserBY)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1941)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1942)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1943)
			p.TableIdentifier()
		}
		{
			p.SetState(1944)

			var _m = p.Match(SqlBaseParserNOT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1945)

			var _m = p.Match(SqlBaseParserSKEWED)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1947)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1948)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1949)
			p.TableIdentifier()
		}
		{
			p.SetState(1950)

			var _m = p.Match(SqlBaseParserNOT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1951)

			var _m = p.Match(SqlBaseParserSTORED)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1952)

			var _m = p.Match(SqlBaseParserAS)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw5 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1953)

			var _m = p.Match(SqlBaseParserDIRECTORIES)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw6 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1955)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1956)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1957)
			p.TableIdentifier()
		}
		{
			p.SetState(1958)

			var _m = p.Match(SqlBaseParserSET)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1959)

			var _m = p.Match(SqlBaseParserSKEWED)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1960)

			var _m = p.Match(SqlBaseParserLOCATION)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw5 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1962)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1963)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1964)
			p.TableIdentifier()
		}
		{
			p.SetState(1965)

			var _m = p.Match(SqlBaseParserEXCHANGE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1966)

			var _m = p.Match(SqlBaseParserPARTITION)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1968)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1969)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1970)
			p.TableIdentifier()
		}
		{
			p.SetState(1971)

			var _m = p.Match(SqlBaseParserARCHIVE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1972)

			var _m = p.Match(SqlBaseParserPARTITION)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1974)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1975)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1976)
			p.TableIdentifier()
		}
		{
			p.SetState(1977)

			var _m = p.Match(SqlBaseParserUNARCHIVE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1978)

			var _m = p.Match(SqlBaseParserPARTITION)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1980)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1981)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1982)
			p.TableIdentifier()
		}
		{
			p.SetState(1983)

			var _m = p.Match(SqlBaseParserTOUCH)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1985)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1986)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1987)
			p.TableIdentifier()
		}
		p.SetState(1989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1988)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(1991)

			var _m = p.Match(SqlBaseParserCOMPACT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1993)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1994)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1995)
			p.TableIdentifier()
		}
		p.SetState(1997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(1996)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(1999)

			var _m = p.Match(SqlBaseParserCONCATENATE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2001)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2002)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2003)
			p.TableIdentifier()
		}
		p.SetState(2005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(2004)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(2007)

			var _m = p.Match(SqlBaseParserSET)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)

			var _m = p.Match(SqlBaseParserFILEFORMAT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2010)

			var _m = p.Match(SqlBaseParserALTER)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2011)

			var _m = p.Match(SqlBaseParserTABLE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2012)
			p.TableIdentifier()
		}
		p.SetState(2014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(2013)
				p.PartitionSpec()
			}

		}
		{
			p.SetState(2016)

			var _m = p.Match(SqlBaseParserREPLACE)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw3 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2017)

			var _m = p.Match(SqlBaseParserCOLUMNS)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2019)

			var _m = p.Match(SqlBaseParserSTART)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2020)

			var _m = p.Match(SqlBaseParserTRANSACTION)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2021)

			var _m = p.Match(SqlBaseParserCOMMIT)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2022)

			var _m = p.Match(SqlBaseParserROLLBACK)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2023)

			var _m = p.Match(SqlBaseParserDFS)

			localctx.(*UnsupportedHiveNativeCommandsContext).kw1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableHeaderContext is an interface to support dynamic dispatch.
type ICreateTableHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	IdentifierReference() IIdentifierReferenceContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	ErrorCapturingNot() IErrorCapturingNotContext
	EXISTS() antlr.TerminalNode

	// IsCreateTableHeaderContext differentiates from other interfaces.
	IsCreateTableHeaderContext()
}

type CreateTableHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableHeaderContext() *CreateTableHeaderContext {
	var p = new(CreateTableHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createTableHeader
	return p
}

func InitEmptyCreateTableHeaderContext(p *CreateTableHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createTableHeader
}

func (*CreateTableHeaderContext) IsCreateTableHeaderContext() {}

func NewCreateTableHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableHeaderContext {
	var p = new(CreateTableHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_createTableHeader

	return p
}

func (s *CreateTableHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableHeaderContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableHeaderContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableHeaderContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreateTableHeaderContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *CreateTableHeaderContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *CreateTableHeaderContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableHeaderContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *CreateTableHeaderContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateTableHeader(s)
	}
}

func (s *CreateTableHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateTableHeader(s)
	}
}

func (p *SqlBaseParser) CreateTableHeader() (localctx ICreateTableHeaderContext) {
	localctx = NewCreateTableHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SqlBaseParserRULE_createTableHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2026)
		p.Match(SqlBaseParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserTEMPORARY {
		{
			p.SetState(2027)
			p.Match(SqlBaseParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserEXTERNAL {
		{
			p.SetState(2030)
			p.Match(SqlBaseParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2033)
		p.Match(SqlBaseParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2038)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2034)
			p.Match(SqlBaseParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2035)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(2036)
			p.Match(SqlBaseParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2040)
		p.IdentifierReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceTableHeaderContext is an interface to support dynamic dispatch.
type IReplaceTableHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	IdentifierReference() IIdentifierReferenceContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsReplaceTableHeaderContext differentiates from other interfaces.
	IsReplaceTableHeaderContext()
}

type ReplaceTableHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceTableHeaderContext() *ReplaceTableHeaderContext {
	var p = new(ReplaceTableHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_replaceTableHeader
	return p
}

func InitEmptyReplaceTableHeaderContext(p *ReplaceTableHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_replaceTableHeader
}

func (*ReplaceTableHeaderContext) IsReplaceTableHeaderContext() {}

func NewReplaceTableHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceTableHeaderContext {
	var p = new(ReplaceTableHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_replaceTableHeader

	return p
}

func (s *ReplaceTableHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceTableHeaderContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *ReplaceTableHeaderContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *ReplaceTableHeaderContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *ReplaceTableHeaderContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ReplaceTableHeaderContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *ReplaceTableHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceTableHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceTableHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterReplaceTableHeader(s)
	}
}

func (s *ReplaceTableHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitReplaceTableHeader(s)
	}
}

func (p *SqlBaseParser) ReplaceTableHeader() (localctx IReplaceTableHeaderContext) {
	localctx = NewReplaceTableHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SqlBaseParserRULE_replaceTableHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCREATE {
		{
			p.SetState(2042)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2043)
			p.Match(SqlBaseParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2046)
		p.Match(SqlBaseParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2047)
		p.Match(SqlBaseParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2048)
		p.IdentifierReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusterBySpecContext is an interface to support dynamic dispatch.
type IClusterBySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLUSTER() antlr.TerminalNode
	BY() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	MultipartIdentifierList() IMultipartIdentifierListContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsClusterBySpecContext differentiates from other interfaces.
	IsClusterBySpecContext()
}

type ClusterBySpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusterBySpecContext() *ClusterBySpecContext {
	var p = new(ClusterBySpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_clusterBySpec
	return p
}

func InitEmptyClusterBySpecContext(p *ClusterBySpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_clusterBySpec
}

func (*ClusterBySpecContext) IsClusterBySpecContext() {}

func NewClusterBySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterBySpecContext {
	var p = new(ClusterBySpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_clusterBySpec

	return p
}

func (s *ClusterBySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterBySpecContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTER, 0)
}

func (s *ClusterBySpecContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *ClusterBySpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ClusterBySpecContext) MultipartIdentifierList() IMultipartIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierListContext)
}

func (s *ClusterBySpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ClusterBySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterBySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusterBySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterClusterBySpec(s)
	}
}

func (s *ClusterBySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitClusterBySpec(s)
	}
}

func (p *SqlBaseParser) ClusterBySpec() (localctx IClusterBySpecContext) {
	localctx = NewClusterBySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SqlBaseParserRULE_clusterBySpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2050)
		p.Match(SqlBaseParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2051)
		p.Match(SqlBaseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2052)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2053)
		p.MultipartIdentifierList()
	}
	{
		p.SetState(2054)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBucketSpecContext is an interface to support dynamic dispatch.
type IBucketSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLUSTERED() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	INTO() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	SORTED() antlr.TerminalNode
	OrderedIdentifierList() IOrderedIdentifierListContext

	// IsBucketSpecContext differentiates from other interfaces.
	IsBucketSpecContext()
}

type BucketSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBucketSpecContext() *BucketSpecContext {
	var p = new(BucketSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_bucketSpec
	return p
}

func InitEmptyBucketSpecContext(p *BucketSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_bucketSpec
}

func (*BucketSpecContext) IsBucketSpecContext() {}

func NewBucketSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BucketSpecContext {
	var p = new(BucketSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_bucketSpec

	return p
}

func (s *BucketSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *BucketSpecContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTERED, 0)
}

func (s *BucketSpecContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *BucketSpecContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *BucketSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *BucketSpecContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *BucketSpecContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *BucketSpecContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBUCKETS, 0)
}

func (s *BucketSpecContext) SORTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORTED, 0)
}

func (s *BucketSpecContext) OrderedIdentifierList() IOrderedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderedIdentifierListContext)
}

func (s *BucketSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BucketSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BucketSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBucketSpec(s)
	}
}

func (s *BucketSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBucketSpec(s)
	}
}

func (p *SqlBaseParser) BucketSpec() (localctx IBucketSpecContext) {
	localctx = NewBucketSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SqlBaseParserRULE_bucketSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2056)
		p.Match(SqlBaseParserCLUSTERED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2057)
		p.Match(SqlBaseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2058)
		p.IdentifierList()
	}
	p.SetState(2062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserSORTED {
		{
			p.SetState(2059)
			p.Match(SqlBaseParserSORTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2060)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2061)
			p.OrderedIdentifierList()
		}

	}
	{
		p.SetState(2064)
		p.Match(SqlBaseParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2065)
		p.Match(SqlBaseParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2066)
		p.Match(SqlBaseParserBUCKETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkewSpecContext is an interface to support dynamic dispatch.
type ISkewSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SKEWED() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	ON() antlr.TerminalNode
	ConstantList() IConstantListContext
	NestedConstantList() INestedConstantListContext
	STORED() antlr.TerminalNode
	AS() antlr.TerminalNode
	DIRECTORIES() antlr.TerminalNode

	// IsSkewSpecContext differentiates from other interfaces.
	IsSkewSpecContext()
}

type SkewSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewSpecContext() *SkewSpecContext {
	var p = new(SkewSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_skewSpec
	return p
}

func InitEmptySkewSpecContext(p *SkewSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_skewSpec
}

func (*SkewSpecContext) IsSkewSpecContext() {}

func NewSkewSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewSpecContext {
	var p = new(SkewSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_skewSpec

	return p
}

func (s *SkewSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewSpecContext) SKEWED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSKEWED, 0)
}

func (s *SkewSpecContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *SkewSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *SkewSpecContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *SkewSpecContext) ConstantList() IConstantListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantListContext)
}

func (s *SkewSpecContext) NestedConstantList() INestedConstantListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedConstantListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedConstantListContext)
}

func (s *SkewSpecContext) STORED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTORED, 0)
}

func (s *SkewSpecContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *SkewSpecContext) DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORIES, 0)
}

func (s *SkewSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkewSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSkewSpec(s)
	}
}

func (s *SkewSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSkewSpec(s)
	}
}

func (p *SqlBaseParser) SkewSpec() (localctx ISkewSpecContext) {
	localctx = NewSkewSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SqlBaseParserRULE_skewSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2068)
		p.Match(SqlBaseParserSKEWED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2069)
		p.Match(SqlBaseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2070)
		p.IdentifierList()
	}
	{
		p.SetState(2071)
		p.Match(SqlBaseParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2072)
			p.ConstantList()
		}

	case 2:
		{
			p.SetState(2073)
			p.NestedConstantList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2079)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2076)
			p.Match(SqlBaseParserSTORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2077)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2078)
			p.Match(SqlBaseParserDIRECTORIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocationSpecContext is an interface to support dynamic dispatch.
type ILocationSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCATION() antlr.TerminalNode
	StringLit() IStringLitContext

	// IsLocationSpecContext differentiates from other interfaces.
	IsLocationSpecContext()
}

type LocationSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationSpecContext() *LocationSpecContext {
	var p = new(LocationSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_locationSpec
	return p
}

func InitEmptyLocationSpecContext(p *LocationSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_locationSpec
}

func (*LocationSpecContext) IsLocationSpecContext() {}

func NewLocationSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationSpecContext {
	var p = new(LocationSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_locationSpec

	return p
}

func (s *LocationSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationSpecContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCATION, 0)
}

func (s *LocationSpecContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *LocationSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocationSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLocationSpec(s)
	}
}

func (s *LocationSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLocationSpec(s)
	}
}

func (p *SqlBaseParser) LocationSpec() (localctx ILocationSpecContext) {
	localctx = NewLocationSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SqlBaseParserRULE_locationSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2081)
		p.Match(SqlBaseParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2082)
		p.StringLit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaBindingContext is an interface to support dynamic dispatch.
type ISchemaBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	BINDING() antlr.TerminalNode
	COMPENSATION() antlr.TerminalNode
	EVOLUTION() antlr.TerminalNode
	TYPE() antlr.TerminalNode

	// IsSchemaBindingContext differentiates from other interfaces.
	IsSchemaBindingContext()
}

type SchemaBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaBindingContext() *SchemaBindingContext {
	var p = new(SchemaBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_schemaBinding
	return p
}

func InitEmptySchemaBindingContext(p *SchemaBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_schemaBinding
}

func (*SchemaBindingContext) IsSchemaBindingContext() {}

func NewSchemaBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaBindingContext {
	var p = new(SchemaBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_schemaBinding

	return p
}

func (s *SchemaBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaBindingContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *SchemaBindingContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *SchemaBindingContext) BINDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINDING, 0)
}

func (s *SchemaBindingContext) COMPENSATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPENSATION, 0)
}

func (s *SchemaBindingContext) EVOLUTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEVOLUTION, 0)
}

func (s *SchemaBindingContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *SchemaBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSchemaBinding(s)
	}
}

func (s *SchemaBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSchemaBinding(s)
	}
}

func (p *SqlBaseParser) SchemaBinding() (localctx ISchemaBindingContext) {
	localctx = NewSchemaBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SqlBaseParserRULE_schemaBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2084)
		p.Match(SqlBaseParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2085)
		p.Match(SqlBaseParserSCHEMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserBINDING:
		{
			p.SetState(2086)
			p.Match(SqlBaseParserBINDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserCOMPENSATION:
		{
			p.SetState(2087)
			p.Match(SqlBaseParserCOMPENSATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserEVOLUTION:
		{
			p.SetState(2088)
			p.Match(SqlBaseParserEVOLUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserTYPE:
		{
			p.SetState(2089)
			p.Match(SqlBaseParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.Match(SqlBaseParserEVOLUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentSpecContext is an interface to support dynamic dispatch.
type ICommentSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	StringLit() IStringLitContext

	// IsCommentSpecContext differentiates from other interfaces.
	IsCommentSpecContext()
}

type CommentSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentSpecContext() *CommentSpecContext {
	var p = new(CommentSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_commentSpec
	return p
}

func InitEmptyCommentSpecContext(p *CommentSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_commentSpec
}

func (*CommentSpecContext) IsCommentSpecContext() {}

func NewCommentSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentSpecContext {
	var p = new(CommentSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_commentSpec

	return p
}

func (s *CommentSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentSpecContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CommentSpecContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *CommentSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCommentSpec(s)
	}
}

func (s *CommentSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCommentSpec(s)
	}
}

func (p *SqlBaseParser) CommentSpec() (localctx ICommentSpecContext) {
	localctx = NewCommentSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SqlBaseParserRULE_commentSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2093)
		p.Match(SqlBaseParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2094)
		p.StringLit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQueryContext is an interface to support dynamic dispatch.
type ISingleQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query() IQueryContext
	EOF() antlr.TerminalNode

	// IsSingleQueryContext differentiates from other interfaces.
	IsSingleQueryContext()
}

type SingleQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQueryContext() *SingleQueryContext {
	var p = new(SingleQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleQuery
	return p
}

func InitEmptySingleQueryContext(p *SingleQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleQuery
}

func (*SingleQueryContext) IsSingleQueryContext() {}

func NewSingleQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQueryContext {
	var p = new(SingleQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleQuery

	return p
}

func (s *SingleQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SingleQueryContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleQuery(s)
	}
}

func (s *SingleQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleQuery(s)
	}
}

func (p *SqlBaseParser) SingleQuery() (localctx ISingleQueryContext) {
	localctx = NewSingleQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SqlBaseParserRULE_singleQuery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2096)
		p.Query()
	}
	{
		p.SetState(2097)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryTerm() IQueryTermContext
	QueryOrganization() IQueryOrganizationContext
	Ctes() ICtesContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *QueryContext) Ctes() ICtesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICtesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICtesContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *SqlBaseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SqlBaseParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWITH {
		{
			p.SetState(2099)
			p.Ctes()
		}

	}
	{
		p.SetState(2102)
		p.queryTerm(0)
	}
	{
		p.SetState(2103)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertIntoContext is an interface to support dynamic dispatch.
type IInsertIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInsertIntoContext differentiates from other interfaces.
	IsInsertIntoContext()
}

type InsertIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertIntoContext() *InsertIntoContext {
	var p = new(InsertIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_insertInto
	return p
}

func InitEmptyInsertIntoContext(p *InsertIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_insertInto
}

func (*InsertIntoContext) IsInsertIntoContext() {}

func NewInsertIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertIntoContext {
	var p = new(InsertIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_insertInto

	return p
}

func (s *InsertIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertIntoContext) CopyAll(ctx *InsertIntoContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InsertIntoReplaceWhereContext struct {
	InsertIntoContext
}

func NewInsertIntoReplaceWhereContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoReplaceWhereContext {
	var p = new(InsertIntoReplaceWhereContext)

	InitEmptyInsertIntoContext(&p.InsertIntoContext)
	p.parser = parser
	p.CopyAll(ctx.(*InsertIntoContext))

	return p
}

func (s *InsertIntoReplaceWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoReplaceWhereContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertIntoReplaceWhereContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *InsertIntoReplaceWhereContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *InsertIntoReplaceWhereContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *InsertIntoReplaceWhereContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *InsertIntoReplaceWhereContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *InsertIntoReplaceWhereContext) OptionsClause() IOptionsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionsClauseContext)
}

func (s *InsertIntoReplaceWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInsertIntoReplaceWhere(s)
	}
}

func (s *InsertIntoReplaceWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInsertIntoReplaceWhere(s)
	}
}

type InsertOverwriteHiveDirContext struct {
	InsertIntoContext
	path IStringLitContext
}

func NewInsertOverwriteHiveDirContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertOverwriteHiveDirContext {
	var p = new(InsertOverwriteHiveDirContext)

	InitEmptyInsertIntoContext(&p.InsertIntoContext)
	p.parser = parser
	p.CopyAll(ctx.(*InsertIntoContext))

	return p
}

func (s *InsertOverwriteHiveDirContext) GetPath() IStringLitContext { return s.path }

func (s *InsertOverwriteHiveDirContext) SetPath(v IStringLitContext) { s.path = v }

func (s *InsertOverwriteHiveDirContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertOverwriteHiveDirContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertOverwriteHiveDirContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *InsertOverwriteHiveDirContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORY, 0)
}

func (s *InsertOverwriteHiveDirContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *InsertOverwriteHiveDirContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCAL, 0)
}

func (s *InsertOverwriteHiveDirContext) RowFormat() IRowFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatContext)
}

func (s *InsertOverwriteHiveDirContext) CreateFileFormat() ICreateFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFileFormatContext)
}

func (s *InsertOverwriteHiveDirContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInsertOverwriteHiveDir(s)
	}
}

func (s *InsertOverwriteHiveDirContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInsertOverwriteHiveDir(s)
	}
}

type InsertOverwriteDirContext struct {
	InsertIntoContext
	path    IStringLitContext
	options IPropertyListContext
}

func NewInsertOverwriteDirContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertOverwriteDirContext {
	var p = new(InsertOverwriteDirContext)

	InitEmptyInsertIntoContext(&p.InsertIntoContext)
	p.parser = parser
	p.CopyAll(ctx.(*InsertIntoContext))

	return p
}

func (s *InsertOverwriteDirContext) GetPath() IStringLitContext { return s.path }

func (s *InsertOverwriteDirContext) GetOptions() IPropertyListContext { return s.options }

func (s *InsertOverwriteDirContext) SetPath(v IStringLitContext) { s.path = v }

func (s *InsertOverwriteDirContext) SetOptions(v IPropertyListContext) { s.options = v }

func (s *InsertOverwriteDirContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertOverwriteDirContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertOverwriteDirContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *InsertOverwriteDirContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORY, 0)
}

func (s *InsertOverwriteDirContext) TableProvider() ITableProviderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProviderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProviderContext)
}

func (s *InsertOverwriteDirContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCAL, 0)
}

func (s *InsertOverwriteDirContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, 0)
}

func (s *InsertOverwriteDirContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *InsertOverwriteDirContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *InsertOverwriteDirContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInsertOverwriteDir(s)
	}
}

func (s *InsertOverwriteDirContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInsertOverwriteDir(s)
	}
}

type InsertOverwriteTableContext struct {
	InsertIntoContext
}

func NewInsertOverwriteTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertOverwriteTableContext {
	var p = new(InsertOverwriteTableContext)

	InitEmptyInsertIntoContext(&p.InsertIntoContext)
	p.parser = parser
	p.CopyAll(ctx.(*InsertIntoContext))

	return p
}

func (s *InsertOverwriteTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertOverwriteTableContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertOverwriteTableContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *InsertOverwriteTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *InsertOverwriteTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *InsertOverwriteTableContext) OptionsClause() IOptionsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionsClauseContext)
}

func (s *InsertOverwriteTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertOverwriteTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *InsertOverwriteTableContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *InsertOverwriteTableContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *InsertOverwriteTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *InsertOverwriteTableContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *InsertOverwriteTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *InsertOverwriteTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInsertOverwriteTable(s)
	}
}

func (s *InsertOverwriteTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInsertOverwriteTable(s)
	}
}

type InsertIntoTableContext struct {
	InsertIntoContext
}

func NewInsertIntoTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoTableContext {
	var p = new(InsertIntoTableContext)

	InitEmptyInsertIntoContext(&p.InsertIntoContext)
	p.parser = parser
	p.CopyAll(ctx.(*InsertIntoContext))

	return p
}

func (s *InsertIntoTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoTableContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertIntoTableContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *InsertIntoTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *InsertIntoTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *InsertIntoTableContext) OptionsClause() IOptionsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionsClauseContext)
}

func (s *InsertIntoTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertIntoTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *InsertIntoTableContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *InsertIntoTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *InsertIntoTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *InsertIntoTableContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *InsertIntoTableContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *InsertIntoTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInsertIntoTable(s)
	}
}

func (s *InsertIntoTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInsertIntoTable(s)
	}
}

func (p *SqlBaseParser) InsertInto() (localctx IInsertIntoContext) {
	localctx = NewInsertIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SqlBaseParserRULE_insertInto)
	var _la int

	p.SetState(2190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInsertOverwriteTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2105)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2106)
			p.Match(SqlBaseParserOVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2108)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2107)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2110)
			p.IdentifierReference()
		}
		p.SetState(2112)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2111)
				p.OptionsClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(2114)
				p.PartitionSpec()
			}
			p.SetState(2119)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserIF {
				{
					p.SetState(2115)
					p.Match(SqlBaseParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2116)
					p.ErrorCapturingNot()
				}
				{
					p.SetState(2117)
					p.Match(SqlBaseParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		p.SetState(2126)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2123)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2124)
				p.Match(SqlBaseParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2125)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewInsertIntoTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2128)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2129)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2131)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2130)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2133)
			p.IdentifierReference()
		}
		p.SetState(2135)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2134)
				p.OptionsClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(2137)
				p.PartitionSpec()
			}

		}
		p.SetState(2144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIF {
			{
				p.SetState(2140)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2141)
				p.ErrorCapturingNot()
			}
			{
				p.SetState(2142)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2149)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2146)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2147)
				p.Match(SqlBaseParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2148)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewInsertIntoReplaceWhereContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2151)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2152)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2154)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2153)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2156)
			p.IdentifierReference()
		}
		p.SetState(2158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(2157)
				p.OptionsClause()
			}

		}
		{
			p.SetState(2160)
			p.Match(SqlBaseParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2161)
			p.WhereClause()
		}

	case 4:
		localctx = NewInsertOverwriteHiveDirContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2163)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2164)
			p.Match(SqlBaseParserOVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLOCAL {
			{
				p.SetState(2165)
				p.Match(SqlBaseParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2168)
			p.Match(SqlBaseParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2169)

			var _x = p.StringLit()

			localctx.(*InsertOverwriteHiveDirContext).path = _x
		}
		p.SetState(2171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserROW {
			{
				p.SetState(2170)
				p.RowFormat()
			}

		}
		p.SetState(2174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserSTORED {
			{
				p.SetState(2173)
				p.CreateFileFormat()
			}

		}

	case 5:
		localctx = NewInsertOverwriteDirContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2176)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2177)
			p.Match(SqlBaseParserOVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLOCAL {
			{
				p.SetState(2178)
				p.Match(SqlBaseParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2181)
			p.Match(SqlBaseParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2183)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2182)

				var _x = p.StringLit()

				localctx.(*InsertOverwriteDirContext).path = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2185)
			p.TableProvider()
		}
		p.SetState(2188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOPTIONS {
			{
				p.SetState(2186)
				p.Match(SqlBaseParserOPTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2187)

				var _x = p.PropertyList()

				localctx.(*InsertOverwriteDirContext).options = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecLocationContext is an interface to support dynamic dispatch.
type IPartitionSpecLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionSpec() IPartitionSpecContext
	LocationSpec() ILocationSpecContext

	// IsPartitionSpecLocationContext differentiates from other interfaces.
	IsPartitionSpecLocationContext()
}

type PartitionSpecLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSpecLocationContext() *PartitionSpecLocationContext {
	var p = new(PartitionSpecLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionSpecLocation
	return p
}

func InitEmptyPartitionSpecLocationContext(p *PartitionSpecLocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionSpecLocation
}

func (*PartitionSpecLocationContext) IsPartitionSpecLocationContext() {}

func NewPartitionSpecLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecLocationContext {
	var p = new(PartitionSpecLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_partitionSpecLocation

	return p
}

func (s *PartitionSpecLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecLocationContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *PartitionSpecLocationContext) LocationSpec() ILocationSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationSpecContext)
}

func (s *PartitionSpecLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPartitionSpecLocation(s)
	}
}

func (s *PartitionSpecLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPartitionSpecLocation(s)
	}
}

func (p *SqlBaseParser) PartitionSpecLocation() (localctx IPartitionSpecLocationContext) {
	localctx = NewPartitionSpecLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SqlBaseParserRULE_partitionSpecLocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2192)
		p.PartitionSpec()
	}
	p.SetState(2194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserLOCATION {
		{
			p.SetState(2193)
			p.LocationSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllPartitionVal() []IPartitionValContext
	PartitionVal(i int) IPartitionValContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *PartitionSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *PartitionSpecContext) AllPartitionVal() []IPartitionValContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValContext); ok {
			tst[i] = t.(IPartitionValContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSpecContext) PartitionVal(i int) IPartitionValContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValContext)
}

func (s *PartitionSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *PartitionSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *PartitionSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPartitionSpec(s)
	}
}

func (p *SqlBaseParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SqlBaseParserRULE_partitionSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		p.Match(SqlBaseParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2197)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2198)
		p.PartitionVal()
	}
	p.SetState(2203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(2199)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2200)
			p.PartitionVal()
		}

		p.SetState(2205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2206)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValContext is an interface to support dynamic dispatch.
type IPartitionValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	Constant() IConstantContext
	DEFAULT() antlr.TerminalNode

	// IsPartitionValContext differentiates from other interfaces.
	IsPartitionValContext()
}

type PartitionValContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValContext() *PartitionValContext {
	var p = new(PartitionValContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionVal
	return p
}

func InitEmptyPartitionValContext(p *PartitionValContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionVal
}

func (*PartitionValContext) IsPartitionValContext() {}

func NewPartitionValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValContext {
	var p = new(PartitionValContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_partitionVal

	return p
}

func (s *PartitionValContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionValContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *PartitionValContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionValContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *PartitionValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPartitionVal(s)
	}
}

func (s *PartitionValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPartitionVal(s)
	}
}

func (p *SqlBaseParser) PartitionVal() (localctx IPartitionValContext) {
	localctx = NewPartitionValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SqlBaseParserRULE_partitionVal)
	var _la int

	p.SetState(2217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2208)
			p.Identifier()
		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEQ {
			{
				p.SetState(2209)
				p.Match(SqlBaseParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2210)
				p.Constant()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2213)
			p.Identifier()
		}
		{
			p.SetState(2214)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2215)
			p.Match(SqlBaseParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatePipelineFlowHeaderContext is an interface to support dynamic dispatch.
type ICreatePipelineFlowHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFlowName returns the flowName rule contexts.
	GetFlowName() IIdentifierReferenceContext

	// SetFlowName sets the flowName rule contexts.
	SetFlowName(IIdentifierReferenceContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FLOW() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierReference() IIdentifierReferenceContext
	CommentSpec() ICommentSpecContext

	// IsCreatePipelineFlowHeaderContext differentiates from other interfaces.
	IsCreatePipelineFlowHeaderContext()
}

type CreatePipelineFlowHeaderContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	flowName IIdentifierReferenceContext
}

func NewEmptyCreatePipelineFlowHeaderContext() *CreatePipelineFlowHeaderContext {
	var p = new(CreatePipelineFlowHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createPipelineFlowHeader
	return p
}

func InitEmptyCreatePipelineFlowHeaderContext(p *CreatePipelineFlowHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createPipelineFlowHeader
}

func (*CreatePipelineFlowHeaderContext) IsCreatePipelineFlowHeaderContext() {}

func NewCreatePipelineFlowHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatePipelineFlowHeaderContext {
	var p = new(CreatePipelineFlowHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_createPipelineFlowHeader

	return p
}

func (s *CreatePipelineFlowHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatePipelineFlowHeaderContext) GetFlowName() IIdentifierReferenceContext {
	return s.flowName
}

func (s *CreatePipelineFlowHeaderContext) SetFlowName(v IIdentifierReferenceContext) { s.flowName = v }

func (s *CreatePipelineFlowHeaderContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreatePipelineFlowHeaderContext) FLOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOW, 0)
}

func (s *CreatePipelineFlowHeaderContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreatePipelineFlowHeaderContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *CreatePipelineFlowHeaderContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreatePipelineFlowHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipelineFlowHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatePipelineFlowHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreatePipelineFlowHeader(s)
	}
}

func (s *CreatePipelineFlowHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreatePipelineFlowHeader(s)
	}
}

func (p *SqlBaseParser) CreatePipelineFlowHeader() (localctx ICreatePipelineFlowHeaderContext) {
	localctx = NewCreatePipelineFlowHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SqlBaseParserRULE_createPipelineFlowHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2219)
		p.Match(SqlBaseParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2220)
		p.Match(SqlBaseParserFLOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2221)

		var _x = p.IdentifierReference()

		localctx.(*CreatePipelineFlowHeaderContext).flowName = _x
	}
	p.SetState(2223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCOMMENT {
		{
			p.SetState(2222)
			p.CommentSpec()
		}

	}
	{
		p.SetState(2225)
		p.Match(SqlBaseParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceContext is an interface to support dynamic dispatch.
type INamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAMESPACE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsNamespaceContext differentiates from other interfaces.
	IsNamespaceContext()
}

type NamespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceContext() *NamespaceContext {
	var p = new(NamespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namespace
	return p
}

func InitEmptyNamespaceContext(p *NamespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namespace
}

func (*NamespaceContext) IsNamespaceContext() {}

func NewNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceContext {
	var p = new(NamespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namespace

	return p
}

func (s *NamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAMESPACE, 0)
}

func (s *NamespaceContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *NamespaceContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *NamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamespace(s)
	}
}

func (s *NamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamespace(s)
	}
}

func (p *SqlBaseParser) Namespace() (localctx INamespaceContext) {
	localctx = NewNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SqlBaseParserRULE_namespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2227)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDATABASE || _la == SqlBaseParserNAMESPACE || _la == SqlBaseParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespacesContext is an interface to support dynamic dispatch.
type INamespacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAMESPACES() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode

	// IsNamespacesContext differentiates from other interfaces.
	IsNamespacesContext()
}

type NamespacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespacesContext() *NamespacesContext {
	var p = new(NamespacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namespaces
	return p
}

func InitEmptyNamespacesContext(p *NamespacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namespaces
}

func (*NamespacesContext) IsNamespacesContext() {}

func NewNamespacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespacesContext {
	var p = new(NamespacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namespaces

	return p
}

func (s *NamespacesContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespacesContext) NAMESPACES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAMESPACES, 0)
}

func (s *NamespacesContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASES, 0)
}

func (s *NamespacesContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *NamespacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamespaces(s)
	}
}

func (s *NamespacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamespaces(s)
	}
}

func (p *SqlBaseParser) Namespaces() (localctx INamespacesContext) {
	localctx = NewNamespacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SqlBaseParserRULE_namespaces)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2229)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDATABASES || _la == SqlBaseParserNAMESPACES || _la == SqlBaseParserSCHEMAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIABLE() antlr.TerminalNode
	VAR() antlr.TerminalNode

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIABLE, 0)
}

func (s *VariableContext) VAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVAR, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (p *SqlBaseParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SqlBaseParserRULE_variable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2231)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserVAR || _la == SqlBaseParserVARIABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeFuncNameContext is an interface to support dynamic dispatch.
type IDescribeFuncNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierReference() IIdentifierReferenceContext
	StringLit() IStringLitContext
	ComparisonOperator() IComparisonOperatorContext
	ArithmeticOperator() IArithmeticOperatorContext
	PredicateOperator() IPredicateOperatorContext
	ShiftOperator() IShiftOperatorContext
	BANG() antlr.TerminalNode

	// IsDescribeFuncNameContext differentiates from other interfaces.
	IsDescribeFuncNameContext()
}

type DescribeFuncNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeFuncNameContext() *DescribeFuncNameContext {
	var p = new(DescribeFuncNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_describeFuncName
	return p
}

func InitEmptyDescribeFuncNameContext(p *DescribeFuncNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_describeFuncName
}

func (*DescribeFuncNameContext) IsDescribeFuncNameContext() {}

func NewDescribeFuncNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeFuncNameContext {
	var p = new(DescribeFuncNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_describeFuncName

	return p
}

func (s *DescribeFuncNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeFuncNameContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DescribeFuncNameContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *DescribeFuncNameContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *DescribeFuncNameContext) ArithmeticOperator() IArithmeticOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticOperatorContext)
}

func (s *DescribeFuncNameContext) PredicateOperator() IPredicateOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateOperatorContext)
}

func (s *DescribeFuncNameContext) ShiftOperator() IShiftOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftOperatorContext)
}

func (s *DescribeFuncNameContext) BANG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBANG, 0)
}

func (s *DescribeFuncNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeFuncNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeFuncNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDescribeFuncName(s)
	}
}

func (s *DescribeFuncNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDescribeFuncName(s)
	}
}

func (p *SqlBaseParser) DescribeFuncName() (localctx IDescribeFuncNameContext) {
	localctx = NewDescribeFuncNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SqlBaseParserRULE_describeFuncName)
	p.SetState(2240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2233)
			p.IdentifierReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2234)
			p.StringLit()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2235)
			p.ComparisonOperator()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2236)
			p.ArithmeticOperator()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2237)
			p.PredicateOperator()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2238)
			p.ShiftOperator()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2239)
			p.Match(SqlBaseParserBANG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeColNameContext is an interface to support dynamic dispatch.
type IDescribeColNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetNameParts returns the nameParts rule context list.
	GetNameParts() []IErrorCapturingIdentifierContext

	// SetNameParts sets the nameParts rule context list.
	SetNameParts([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsDescribeColNameContext differentiates from other interfaces.
	IsDescribeColNameContext()
}

type DescribeColNameContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	nameParts                 []IErrorCapturingIdentifierContext
}

func NewEmptyDescribeColNameContext() *DescribeColNameContext {
	var p = new(DescribeColNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_describeColName
	return p
}

func InitEmptyDescribeColNameContext(p *DescribeColNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_describeColName
}

func (*DescribeColNameContext) IsDescribeColNameContext() {}

func NewDescribeColNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeColNameContext {
	var p = new(DescribeColNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_describeColName

	return p
}

func (s *DescribeColNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeColNameContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *DescribeColNameContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *DescribeColNameContext) GetNameParts() []IErrorCapturingIdentifierContext {
	return s.nameParts
}

func (s *DescribeColNameContext) SetNameParts(v []IErrorCapturingIdentifierContext) { s.nameParts = v }

func (s *DescribeColNameContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DescribeColNameContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *DescribeColNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserDOT)
}

func (s *DescribeColNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, i)
}

func (s *DescribeColNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeColNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeColNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDescribeColName(s)
	}
}

func (s *DescribeColNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDescribeColName(s)
	}
}

func (p *SqlBaseParser) DescribeColName() (localctx IDescribeColNameContext) {
	localctx = NewDescribeColNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SqlBaseParserRULE_describeColName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2242)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*DescribeColNameContext)._errorCapturingIdentifier = _x
	}
	localctx.(*DescribeColNameContext).nameParts = append(localctx.(*DescribeColNameContext).nameParts, localctx.(*DescribeColNameContext)._errorCapturingIdentifier)
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserDOT {
		{
			p.SetState(2243)
			p.Match(SqlBaseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*DescribeColNameContext)._errorCapturingIdentifier = _x
		}
		localctx.(*DescribeColNameContext).nameParts = append(localctx.(*DescribeColNameContext).nameParts, localctx.(*DescribeColNameContext)._errorCapturingIdentifier)

		p.SetState(2249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICtesContext is an interface to support dynamic dispatch.
type ICtesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllNamedQuery() []INamedQueryContext
	NamedQuery(i int) INamedQueryContext
	RECURSIVE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCtesContext differentiates from other interfaces.
	IsCtesContext()
}

type CtesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCtesContext() *CtesContext {
	var p = new(CtesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_ctes
	return p
}

func InitEmptyCtesContext(p *CtesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_ctes
}

func (*CtesContext) IsCtesContext() {}

func NewCtesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CtesContext {
	var p = new(CtesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_ctes

	return p
}

func (s *CtesContext) GetParser() antlr.Parser { return s.parser }

func (s *CtesContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CtesContext) AllNamedQuery() []INamedQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedQueryContext); ok {
			len++
		}
	}

	tst := make([]INamedQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedQueryContext); ok {
			tst[i] = t.(INamedQueryContext)
			i++
		}
	}

	return tst
}

func (s *CtesContext) NamedQuery(i int) INamedQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *CtesContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSIVE, 0)
}

func (s *CtesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *CtesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *CtesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CtesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CtesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCtes(s)
	}
}

func (s *CtesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCtes(s)
	}
}

func (p *SqlBaseParser) Ctes() (localctx ICtesContext) {
	localctx = NewCtesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SqlBaseParserRULE_ctes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2250)
		p.Match(SqlBaseParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2252)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2251)
			p.Match(SqlBaseParserRECURSIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2254)
		p.NamedQuery()
	}
	p.SetState(2259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(2255)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2256)
			p.NamedQuery()
		}

		p.SetState(2261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IErrorCapturingIdentifierContext

	// GetColumnAliases returns the columnAliases rule contexts.
	GetColumnAliases() IIdentifierListContext

	// SetName sets the name rule contexts.
	SetName(IErrorCapturingIdentifierContext)

	// SetColumnAliases sets the columnAliases rule contexts.
	SetColumnAliases(IIdentifierListContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	MAX() antlr.TerminalNode
	RECURSION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	name          IErrorCapturingIdentifierContext
	columnAliases IIdentifierListContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedQuery
	return p
}

func InitEmptyNamedQueryContext(p *NamedQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedQuery
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *NamedQueryContext) GetColumnAliases() IIdentifierListContext { return s.columnAliases }

func (s *NamedQueryContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *NamedQueryContext) SetColumnAliases(v IIdentifierListContext) { s.columnAliases = v }

func (s *NamedQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *NamedQueryContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *NamedQueryContext) MAX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAX, 0)
}

func (s *NamedQueryContext) RECURSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSION, 0)
}

func (s *NamedQueryContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *NamedQueryContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *NamedQueryContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (p *SqlBaseParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SqlBaseParserRULE_namedQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2262)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(2264)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2263)

			var _x = p.IdentifierList()

			localctx.(*NamedQueryContext).columnAliases = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserMAX {
		{
			p.SetState(2266)
			p.Match(SqlBaseParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2267)
			p.Match(SqlBaseParserRECURSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2268)
			p.Match(SqlBaseParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2269)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserAS {
		{
			p.SetState(2272)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2275)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2276)
		p.Query()
	}
	{
		p.SetState(2277)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableProviderContext is an interface to support dynamic dispatch.
type ITableProviderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsTableProviderContext differentiates from other interfaces.
	IsTableProviderContext()
}

type TableProviderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableProviderContext() *TableProviderContext {
	var p = new(TableProviderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableProvider
	return p
}

func InitEmptyTableProviderContext(p *TableProviderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableProvider
}

func (*TableProviderContext) IsTableProviderContext() {}

func NewTableProviderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableProviderContext {
	var p = new(TableProviderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableProvider

	return p
}

func (s *TableProviderContext) GetParser() antlr.Parser { return s.parser }

func (s *TableProviderContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *TableProviderContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TableProviderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableProviderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableProviderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableProvider(s)
	}
}

func (s *TableProviderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableProvider(s)
	}
}

func (p *SqlBaseParser) TableProvider() (localctx ITableProviderContext) {
	localctx = NewTableProviderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SqlBaseParserRULE_tableProvider)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2279)
		p.Match(SqlBaseParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2280)
		p.MultipartIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableClausesContext is an interface to support dynamic dispatch.
type ICreateTableClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptions returns the options rule contexts.
	GetOptions() IExpressionPropertyListContext

	// GetPartitioning returns the partitioning rule contexts.
	GetPartitioning() IPartitionFieldListContext

	// GetTableProps returns the tableProps rule contexts.
	GetTableProps() IPropertyListContext

	// SetOptions sets the options rule contexts.
	SetOptions(IExpressionPropertyListContext)

	// SetPartitioning sets the partitioning rule contexts.
	SetPartitioning(IPartitionFieldListContext)

	// SetTableProps sets the tableProps rule contexts.
	SetTableProps(IPropertyListContext)

	// Getter signatures
	AllSkewSpec() []ISkewSpecContext
	SkewSpec(i int) ISkewSpecContext
	AllClusterBySpec() []IClusterBySpecContext
	ClusterBySpec(i int) IClusterBySpecContext
	AllBucketSpec() []IBucketSpecContext
	BucketSpec(i int) IBucketSpecContext
	AllRowFormat() []IRowFormatContext
	RowFormat(i int) IRowFormatContext
	AllCreateFileFormat() []ICreateFileFormatContext
	CreateFileFormat(i int) ICreateFileFormatContext
	AllLocationSpec() []ILocationSpecContext
	LocationSpec(i int) ILocationSpecContext
	AllCommentSpec() []ICommentSpecContext
	CommentSpec(i int) ICommentSpecContext
	AllCollationSpec() []ICollationSpecContext
	CollationSpec(i int) ICollationSpecContext
	AllOPTIONS() []antlr.TerminalNode
	OPTIONS(i int) antlr.TerminalNode
	AllPARTITIONED() []antlr.TerminalNode
	PARTITIONED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	AllTBLPROPERTIES() []antlr.TerminalNode
	TBLPROPERTIES(i int) antlr.TerminalNode
	AllExpressionPropertyList() []IExpressionPropertyListContext
	ExpressionPropertyList(i int) IExpressionPropertyListContext
	AllPartitionFieldList() []IPartitionFieldListContext
	PartitionFieldList(i int) IPartitionFieldListContext
	AllPropertyList() []IPropertyListContext
	PropertyList(i int) IPropertyListContext

	// IsCreateTableClausesContext differentiates from other interfaces.
	IsCreateTableClausesContext()
}

type CreateTableClausesContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	options      IExpressionPropertyListContext
	partitioning IPartitionFieldListContext
	tableProps   IPropertyListContext
}

func NewEmptyCreateTableClausesContext() *CreateTableClausesContext {
	var p = new(CreateTableClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createTableClauses
	return p
}

func InitEmptyCreateTableClausesContext(p *CreateTableClausesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createTableClauses
}

func (*CreateTableClausesContext) IsCreateTableClausesContext() {}

func NewCreateTableClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableClausesContext {
	var p = new(CreateTableClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_createTableClauses

	return p
}

func (s *CreateTableClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableClausesContext) GetOptions() IExpressionPropertyListContext { return s.options }

func (s *CreateTableClausesContext) GetPartitioning() IPartitionFieldListContext {
	return s.partitioning
}

func (s *CreateTableClausesContext) GetTableProps() IPropertyListContext { return s.tableProps }

func (s *CreateTableClausesContext) SetOptions(v IExpressionPropertyListContext) { s.options = v }

func (s *CreateTableClausesContext) SetPartitioning(v IPartitionFieldListContext) { s.partitioning = v }

func (s *CreateTableClausesContext) SetTableProps(v IPropertyListContext) { s.tableProps = v }

func (s *CreateTableClausesContext) AllSkewSpec() []ISkewSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISkewSpecContext); ok {
			len++
		}
	}

	tst := make([]ISkewSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISkewSpecContext); ok {
			tst[i] = t.(ISkewSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) SkewSpec(i int) ISkewSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewSpecContext)
}

func (s *CreateTableClausesContext) AllClusterBySpec() []IClusterBySpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClusterBySpecContext); ok {
			len++
		}
	}

	tst := make([]IClusterBySpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClusterBySpecContext); ok {
			tst[i] = t.(IClusterBySpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) ClusterBySpec(i int) IClusterBySpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterBySpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterBySpecContext)
}

func (s *CreateTableClausesContext) AllBucketSpec() []IBucketSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBucketSpecContext); ok {
			len++
		}
	}

	tst := make([]IBucketSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBucketSpecContext); ok {
			tst[i] = t.(IBucketSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) BucketSpec(i int) IBucketSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketSpecContext)
}

func (s *CreateTableClausesContext) AllRowFormat() []IRowFormatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowFormatContext); ok {
			len++
		}
	}

	tst := make([]IRowFormatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowFormatContext); ok {
			tst[i] = t.(IRowFormatContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) RowFormat(i int) IRowFormatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatContext)
}

func (s *CreateTableClausesContext) AllCreateFileFormat() []ICreateFileFormatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateFileFormatContext); ok {
			len++
		}
	}

	tst := make([]ICreateFileFormatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateFileFormatContext); ok {
			tst[i] = t.(ICreateFileFormatContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) CreateFileFormat(i int) ICreateFileFormatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFileFormatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFileFormatContext)
}

func (s *CreateTableClausesContext) AllLocationSpec() []ILocationSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILocationSpecContext); ok {
			len++
		}
	}

	tst := make([]ILocationSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILocationSpecContext); ok {
			tst[i] = t.(ILocationSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) LocationSpec(i int) ILocationSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationSpecContext)
}

func (s *CreateTableClausesContext) AllCommentSpec() []ICommentSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentSpecContext); ok {
			len++
		}
	}

	tst := make([]ICommentSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentSpecContext); ok {
			tst[i] = t.(ICommentSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) CommentSpec(i int) ICommentSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateTableClausesContext) AllCollationSpec() []ICollationSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICollationSpecContext); ok {
			len++
		}
	}

	tst := make([]ICollationSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICollationSpecContext); ok {
			tst[i] = t.(ICollationSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) CollationSpec(i int) ICollationSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationSpecContext)
}

func (s *CreateTableClausesContext) AllOPTIONS() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserOPTIONS)
}

func (s *CreateTableClausesContext) OPTIONS(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, i)
}

func (s *CreateTableClausesContext) AllPARTITIONED() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserPARTITIONED)
}

func (s *CreateTableClausesContext) PARTITIONED(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONED, i)
}

func (s *CreateTableClausesContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *CreateTableClausesContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *CreateTableClausesContext) AllTBLPROPERTIES() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTBLPROPERTIES)
}

func (s *CreateTableClausesContext) TBLPROPERTIES(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, i)
}

func (s *CreateTableClausesContext) AllExpressionPropertyList() []IExpressionPropertyListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionPropertyListContext); ok {
			len++
		}
	}

	tst := make([]IExpressionPropertyListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionPropertyListContext); ok {
			tst[i] = t.(IExpressionPropertyListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) ExpressionPropertyList(i int) IExpressionPropertyListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionPropertyListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionPropertyListContext)
}

func (s *CreateTableClausesContext) AllPartitionFieldList() []IPartitionFieldListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionFieldListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionFieldListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionFieldListContext); ok {
			tst[i] = t.(IPartitionFieldListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) PartitionFieldList(i int) IPartitionFieldListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFieldListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFieldListContext)
}

func (s *CreateTableClausesContext) AllPropertyList() []IPropertyListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyListContext); ok {
			len++
		}
	}

	tst := make([]IPropertyListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyListContext); ok {
			tst[i] = t.(IPropertyListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableClausesContext) PropertyList(i int) IPropertyListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateTableClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateTableClauses(s)
	}
}

func (s *CreateTableClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateTableClauses(s)
	}
}

func (p *SqlBaseParser) CreateTableClauses() (localctx ICreateTableClausesContext) {
	localctx = NewCreateTableClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SqlBaseParserRULE_createTableClauses)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2297)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case SqlBaseParserOPTIONS:
				{
					p.SetState(2282)
					p.Match(SqlBaseParserOPTIONS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2283)

					var _x = p.ExpressionPropertyList()

					localctx.(*CreateTableClausesContext).options = _x
				}

			case SqlBaseParserPARTITIONED:
				{
					p.SetState(2284)
					p.Match(SqlBaseParserPARTITIONED)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2285)
					p.Match(SqlBaseParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2286)

					var _x = p.PartitionFieldList()

					localctx.(*CreateTableClausesContext).partitioning = _x
				}

			case SqlBaseParserSKEWED:
				{
					p.SetState(2287)
					p.SkewSpec()
				}

			case SqlBaseParserCLUSTER:
				{
					p.SetState(2288)
					p.ClusterBySpec()
				}

			case SqlBaseParserCLUSTERED:
				{
					p.SetState(2289)
					p.BucketSpec()
				}

			case SqlBaseParserROW:
				{
					p.SetState(2290)
					p.RowFormat()
				}

			case SqlBaseParserSTORED:
				{
					p.SetState(2291)
					p.CreateFileFormat()
				}

			case SqlBaseParserLOCATION:
				{
					p.SetState(2292)
					p.LocationSpec()
				}

			case SqlBaseParserCOMMENT:
				{
					p.SetState(2293)
					p.CommentSpec()
				}

			case SqlBaseParserDEFAULT:
				{
					p.SetState(2294)
					p.CollationSpec()
				}

			case SqlBaseParserTBLPROPERTIES:
				{
					p.SetState(2295)
					p.Match(SqlBaseParserTBLPROPERTIES)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2296)

					var _x = p.PropertyList()

					localctx.(*CreateTableClausesContext).tableProps = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(2301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *PropertyListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *PropertyListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (p *SqlBaseParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SqlBaseParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2302)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2303)
		p.Property()
	}
	p.SetState(2308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(2304)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2305)
			p.Property()
		}

		p.SetState(2310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2311)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IPropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() IPropertyValueContext

	// SetKey sets the key rule contexts.
	SetKey(IPropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(IPropertyValueContext)

	// Getter signatures
	PropertyKey() IPropertyKeyContext
	PropertyValue() IPropertyValueContext
	EQ() antlr.TerminalNode

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IPropertyKeyContext
	value  IPropertyValueContext
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) GetKey() IPropertyKeyContext { return s.key }

func (s *PropertyContext) GetValue() IPropertyValueContext { return s.value }

func (s *PropertyContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *PropertyContext) SetValue(v IPropertyValueContext) { s.value = v }

func (s *PropertyContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *PropertyContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (p *SqlBaseParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SqlBaseParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2313)

		var _x = p.PropertyKey()

		localctx.(*PropertyContext).key = _x
	}
	p.SetState(2318)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
		p.SetState(2315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 242, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2314)
				p.Match(SqlBaseParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2317)

			var _x = p.PropertyValue()

			localctx.(*PropertyContext).value = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyContext is an interface to support dynamic dispatch.
type IPropertyKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	StringLit() IStringLitContext

	// IsPropertyKeyContext differentiates from other interfaces.
	IsPropertyKeyContext()
}

type PropertyKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyContext() *PropertyKeyContext {
	var p = new(PropertyKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyKey
	return p
}

func InitEmptyPropertyKeyContext(p *PropertyKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyKey
}

func (*PropertyKeyContext) IsPropertyKeyContext() {}

func NewPropertyKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyContext {
	var p = new(PropertyKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_propertyKey

	return p
}

func (s *PropertyKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PropertyKeyContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *PropertyKeyContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserDOT)
}

func (s *PropertyKeyContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, i)
}

func (s *PropertyKeyContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *PropertyKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPropertyKey(s)
	}
}

func (s *PropertyKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPropertyKey(s)
	}
}

func (p *SqlBaseParser) PropertyKey() (localctx IPropertyKeyContext) {
	localctx = NewPropertyKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SqlBaseParserRULE_propertyKey)
	var _alt int

	p.SetState(2329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2320)
			p.ErrorCapturingIdentifier()
		}
		p.SetState(2325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2321)
					p.Match(SqlBaseParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2322)
					p.ErrorCapturingIdentifier()
				}

			}
			p.SetState(2327)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2328)
			p.StringLit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	StringLit() IStringLitContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *PropertyValueContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *PropertyValueContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *PropertyValueContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPropertyValue(s)
	}
}

func (s *PropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPropertyValue(s)
	}
}

func (p *SqlBaseParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SqlBaseParserRULE_propertyValue)
	p.SetState(2335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2331)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2332)
			p.Match(SqlBaseParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2333)
			p.BooleanValue()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2334)
			p.StringLit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionPropertyListContext is an interface to support dynamic dispatch.
type IExpressionPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllExpressionProperty() []IExpressionPropertyContext
	ExpressionProperty(i int) IExpressionPropertyContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionPropertyListContext differentiates from other interfaces.
	IsExpressionPropertyListContext()
}

type ExpressionPropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionPropertyListContext() *ExpressionPropertyListContext {
	var p = new(ExpressionPropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expressionPropertyList
	return p
}

func InitEmptyExpressionPropertyListContext(p *ExpressionPropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expressionPropertyList
}

func (*ExpressionPropertyListContext) IsExpressionPropertyListContext() {}

func NewExpressionPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionPropertyListContext {
	var p = new(ExpressionPropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expressionPropertyList

	return p
}

func (s *ExpressionPropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionPropertyListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ExpressionPropertyListContext) AllExpressionProperty() []IExpressionPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionPropertyContext); ok {
			len++
		}
	}

	tst := make([]IExpressionPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionPropertyContext); ok {
			tst[i] = t.(IExpressionPropertyContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionPropertyListContext) ExpressionProperty(i int) IExpressionPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionPropertyContext)
}

func (s *ExpressionPropertyListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ExpressionPropertyListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ExpressionPropertyListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ExpressionPropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionPropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionPropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExpressionPropertyList(s)
	}
}

func (s *ExpressionPropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExpressionPropertyList(s)
	}
}

func (p *SqlBaseParser) ExpressionPropertyList() (localctx IExpressionPropertyListContext) {
	localctx = NewExpressionPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SqlBaseParserRULE_expressionPropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2337)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2338)
		p.ExpressionProperty()
	}
	p.SetState(2343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(2339)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2340)
			p.ExpressionProperty()
		}

		p.SetState(2345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2346)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionPropertyContext is an interface to support dynamic dispatch.
type IExpressionPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IPropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetKey sets the key rule contexts.
	SetKey(IPropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	PropertyKey() IPropertyKeyContext
	Expression() IExpressionContext
	EQ() antlr.TerminalNode

	// IsExpressionPropertyContext differentiates from other interfaces.
	IsExpressionPropertyContext()
}

type ExpressionPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IPropertyKeyContext
	value  IExpressionContext
}

func NewEmptyExpressionPropertyContext() *ExpressionPropertyContext {
	var p = new(ExpressionPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expressionProperty
	return p
}

func InitEmptyExpressionPropertyContext(p *ExpressionPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expressionProperty
}

func (*ExpressionPropertyContext) IsExpressionPropertyContext() {}

func NewExpressionPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionPropertyContext {
	var p = new(ExpressionPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expressionProperty

	return p
}

func (s *ExpressionPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionPropertyContext) GetKey() IPropertyKeyContext { return s.key }

func (s *ExpressionPropertyContext) GetValue() IExpressionContext { return s.value }

func (s *ExpressionPropertyContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *ExpressionPropertyContext) SetValue(v IExpressionContext) { s.value = v }

func (s *ExpressionPropertyContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *ExpressionPropertyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionPropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *ExpressionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExpressionProperty(s)
	}
}

func (s *ExpressionPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExpressionProperty(s)
	}
}

func (p *SqlBaseParser) ExpressionProperty() (localctx IExpressionPropertyContext) {
	localctx = NewExpressionPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SqlBaseParserRULE_expressionProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2348)

		var _x = p.PropertyKey()

		localctx.(*ExpressionPropertyContext).key = _x
	}
	p.SetState(2353)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
		p.SetState(2350)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2349)
				p.Match(SqlBaseParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2352)

			var _x = p.Expression()

			localctx.(*ExpressionPropertyContext).value = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantListContext is an interface to support dynamic dispatch.
type IConstantListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstantListContext differentiates from other interfaces.
	IsConstantListContext()
}

type ConstantListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantListContext() *ConstantListContext {
	var p = new(ConstantListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_constantList
	return p
}

func InitEmptyConstantListContext(p *ConstantListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_constantList
}

func (*ConstantListContext) IsConstantListContext() {}

func NewConstantListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantListContext {
	var p = new(ConstantListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_constantList

	return p
}

func (s *ConstantListContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ConstantListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ConstantListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ConstantListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ConstantListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterConstantList(s)
	}
}

func (s *ConstantListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitConstantList(s)
	}
}

func (p *SqlBaseParser) ConstantList() (localctx IConstantListContext) {
	localctx = NewConstantListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SqlBaseParserRULE_constantList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2355)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2356)
		p.Constant()
	}
	p.SetState(2361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(2357)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2358)
			p.Constant()
		}

		p.SetState(2363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2364)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedConstantListContext is an interface to support dynamic dispatch.
type INestedConstantListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllConstantList() []IConstantListContext
	ConstantList(i int) IConstantListContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNestedConstantListContext differentiates from other interfaces.
	IsNestedConstantListContext()
}

type NestedConstantListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedConstantListContext() *NestedConstantListContext {
	var p = new(NestedConstantListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nestedConstantList
	return p
}

func InitEmptyNestedConstantListContext(p *NestedConstantListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nestedConstantList
}

func (*NestedConstantListContext) IsNestedConstantListContext() {}

func NewNestedConstantListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedConstantListContext {
	var p = new(NestedConstantListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nestedConstantList

	return p
}

func (s *NestedConstantListContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedConstantListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *NestedConstantListContext) AllConstantList() []IConstantListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantListContext); ok {
			len++
		}
	}

	tst := make([]IConstantListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantListContext); ok {
			tst[i] = t.(IConstantListContext)
			i++
		}
	}

	return tst
}

func (s *NestedConstantListContext) ConstantList(i int) IConstantListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantListContext)
}

func (s *NestedConstantListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *NestedConstantListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *NestedConstantListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *NestedConstantListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedConstantListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedConstantListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNestedConstantList(s)
	}
}

func (s *NestedConstantListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNestedConstantList(s)
	}
}

func (p *SqlBaseParser) NestedConstantList() (localctx INestedConstantListContext) {
	localctx = NewNestedConstantListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SqlBaseParserRULE_nestedConstantList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2366)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2367)
		p.ConstantList()
	}
	p.SetState(2372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(2368)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2369)
			p.ConstantList()
		}

		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2375)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFileFormatContext is an interface to support dynamic dispatch.
type ICreateFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORED() antlr.TerminalNode
	AS() antlr.TerminalNode
	FileFormat() IFileFormatContext
	BY() antlr.TerminalNode
	StorageHandler() IStorageHandlerContext

	// IsCreateFileFormatContext differentiates from other interfaces.
	IsCreateFileFormatContext()
}

type CreateFileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFileFormatContext() *CreateFileFormatContext {
	var p = new(CreateFileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createFileFormat
	return p
}

func InitEmptyCreateFileFormatContext(p *CreateFileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_createFileFormat
}

func (*CreateFileFormatContext) IsCreateFileFormatContext() {}

func NewCreateFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFileFormatContext {
	var p = new(CreateFileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_createFileFormat

	return p
}

func (s *CreateFileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFileFormatContext) STORED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTORED, 0)
}

func (s *CreateFileFormatContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateFileFormatContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *CreateFileFormatContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *CreateFileFormatContext) StorageHandler() IStorageHandlerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageHandlerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageHandlerContext)
}

func (s *CreateFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCreateFileFormat(s)
	}
}

func (s *CreateFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCreateFileFormat(s)
	}
}

func (p *SqlBaseParser) CreateFileFormat() (localctx ICreateFileFormatContext) {
	localctx = NewCreateFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SqlBaseParserRULE_createFileFormat)
	p.SetState(2383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2377)
			p.Match(SqlBaseParserSTORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2378)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2379)
			p.FileFormat()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2380)
			p.Match(SqlBaseParserSTORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2381)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2382)
			p.StorageHandler()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileFormatContext is an interface to support dynamic dispatch.
type IFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFileFormatContext differentiates from other interfaces.
	IsFileFormatContext()
}

type FileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileFormatContext() *FileFormatContext {
	var p = new(FileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fileFormat
	return p
}

func InitEmptyFileFormatContext(p *FileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fileFormat
}

func (*FileFormatContext) IsFileFormatContext() {}

func NewFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileFormatContext {
	var p = new(FileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_fileFormat

	return p
}

func (s *FileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *FileFormatContext) CopyAll(ctx *FileFormatContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableFileFormatContext struct {
	FileFormatContext
	inFmt  IStringLitContext
	outFmt IStringLitContext
}

func NewTableFileFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFileFormatContext {
	var p = new(TableFileFormatContext)

	InitEmptyFileFormatContext(&p.FileFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*FileFormatContext))

	return p
}

func (s *TableFileFormatContext) GetInFmt() IStringLitContext { return s.inFmt }

func (s *TableFileFormatContext) GetOutFmt() IStringLitContext { return s.outFmt }

func (s *TableFileFormatContext) SetInFmt(v IStringLitContext) { s.inFmt = v }

func (s *TableFileFormatContext) SetOutFmt(v IStringLitContext) { s.outFmt = v }

func (s *TableFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFileFormatContext) INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUTFORMAT, 0)
}

func (s *TableFileFormatContext) OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUTFORMAT, 0)
}

func (s *TableFileFormatContext) AllStringLit() []IStringLitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLitContext); ok {
			len++
		}
	}

	tst := make([]IStringLitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLitContext); ok {
			tst[i] = t.(IStringLitContext)
			i++
		}
	}

	return tst
}

func (s *TableFileFormatContext) StringLit(i int) IStringLitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *TableFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableFileFormat(s)
	}
}

func (s *TableFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableFileFormat(s)
	}
}

type GenericFileFormatContext struct {
	FileFormatContext
}

func NewGenericFileFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GenericFileFormatContext {
	var p = new(GenericFileFormatContext)

	InitEmptyFileFormatContext(&p.FileFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*FileFormatContext))

	return p
}

func (s *GenericFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericFileFormatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GenericFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterGenericFileFormat(s)
	}
}

func (s *GenericFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitGenericFileFormat(s)
	}
}

func (p *SqlBaseParser) FileFormat() (localctx IFileFormatContext) {
	localctx = NewFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SqlBaseParserRULE_fileFormat)
	p.SetState(2391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableFileFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2385)
			p.Match(SqlBaseParserINPUTFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2386)

			var _x = p.StringLit()

			localctx.(*TableFileFormatContext).inFmt = _x
		}
		{
			p.SetState(2387)
			p.Match(SqlBaseParserOUTPUTFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2388)

			var _x = p.StringLit()

			localctx.(*TableFileFormatContext).outFmt = _x
		}

	case 2:
		localctx = NewGenericFileFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2390)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageHandlerContext is an interface to support dynamic dispatch.
type IStorageHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLit() IStringLitContext
	WITH() antlr.TerminalNode
	SERDEPROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsStorageHandlerContext differentiates from other interfaces.
	IsStorageHandlerContext()
}

type StorageHandlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageHandlerContext() *StorageHandlerContext {
	var p = new(StorageHandlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_storageHandler
	return p
}

func InitEmptyStorageHandlerContext(p *StorageHandlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_storageHandler
}

func (*StorageHandlerContext) IsStorageHandlerContext() {}

func NewStorageHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageHandlerContext {
	var p = new(StorageHandlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_storageHandler

	return p
}

func (s *StorageHandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageHandlerContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *StorageHandlerContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *StorageHandlerContext) SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDEPROPERTIES, 0)
}

func (s *StorageHandlerContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *StorageHandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageHandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageHandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStorageHandler(s)
	}
}

func (s *StorageHandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStorageHandler(s)
	}
}

func (p *SqlBaseParser) StorageHandler() (localctx IStorageHandlerContext) {
	localctx = NewStorageHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SqlBaseParserRULE_storageHandler)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2393)
		p.StringLit()
	}
	p.SetState(2397)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2394)
			p.Match(SqlBaseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2395)
			p.Match(SqlBaseParserSERDEPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2396)
			p.PropertyList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	StringLit() IStringLitContext

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *SqlBaseParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SqlBaseParserRULE_resource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2399)
		p.Identifier()
	}
	{
		p.SetState(2400)
		p.StringLit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDmlStatementNoWithContext is an interface to support dynamic dispatch.
type IDmlStatementNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDmlStatementNoWithContext differentiates from other interfaces.
	IsDmlStatementNoWithContext()
}

type DmlStatementNoWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementNoWithContext() *DmlStatementNoWithContext {
	var p = new(DmlStatementNoWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_dmlStatementNoWith
	return p
}

func InitEmptyDmlStatementNoWithContext(p *DmlStatementNoWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_dmlStatementNoWith
}

func (*DmlStatementNoWithContext) IsDmlStatementNoWithContext() {}

func NewDmlStatementNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementNoWithContext {
	var p = new(DmlStatementNoWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_dmlStatementNoWith

	return p
}

func (s *DmlStatementNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementNoWithContext) CopyAll(ctx *DmlStatementNoWithContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DmlStatementNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DeleteFromTableContext struct {
	DmlStatementNoWithContext
}

func NewDeleteFromTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteFromTableContext {
	var p = new(DeleteFromTableContext)

	InitEmptyDmlStatementNoWithContext(&p.DmlStatementNoWithContext)
	p.parser = parser
	p.CopyAll(ctx.(*DmlStatementNoWithContext))

	return p
}

func (s *DeleteFromTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteFromTableContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *DeleteFromTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *DeleteFromTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *DeleteFromTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DeleteFromTableContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteFromTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDeleteFromTable(s)
	}
}

func (s *DeleteFromTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDeleteFromTable(s)
	}
}

type SingleInsertQueryContext struct {
	DmlStatementNoWithContext
}

func NewSingleInsertQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleInsertQueryContext {
	var p = new(SingleInsertQueryContext)

	InitEmptyDmlStatementNoWithContext(&p.DmlStatementNoWithContext)
	p.parser = parser
	p.CopyAll(ctx.(*DmlStatementNoWithContext))

	return p
}

func (s *SingleInsertQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleInsertQueryContext) InsertInto() IInsertIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertIntoContext)
}

func (s *SingleInsertQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SingleInsertQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSingleInsertQuery(s)
	}
}

func (s *SingleInsertQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSingleInsertQuery(s)
	}
}

type MultiInsertQueryContext struct {
	DmlStatementNoWithContext
}

func NewMultiInsertQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiInsertQueryContext {
	var p = new(MultiInsertQueryContext)

	InitEmptyDmlStatementNoWithContext(&p.DmlStatementNoWithContext)
	p.parser = parser
	p.CopyAll(ctx.(*DmlStatementNoWithContext))

	return p
}

func (s *MultiInsertQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiInsertQueryContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *MultiInsertQueryContext) AllMultiInsertQueryBody() []IMultiInsertQueryBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiInsertQueryBodyContext); ok {
			len++
		}
	}

	tst := make([]IMultiInsertQueryBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiInsertQueryBodyContext); ok {
			tst[i] = t.(IMultiInsertQueryBodyContext)
			i++
		}
	}

	return tst
}

func (s *MultiInsertQueryContext) MultiInsertQueryBody(i int) IMultiInsertQueryBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiInsertQueryBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiInsertQueryBodyContext)
}

func (s *MultiInsertQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMultiInsertQuery(s)
	}
}

func (s *MultiInsertQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMultiInsertQuery(s)
	}
}

type UpdateTableContext struct {
	DmlStatementNoWithContext
}

func NewUpdateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateTableContext {
	var p = new(UpdateTableContext)

	InitEmptyDmlStatementNoWithContext(&p.DmlStatementNoWithContext)
	p.parser = parser
	p.CopyAll(ctx.(*DmlStatementNoWithContext))

	return p
}

func (s *UpdateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateTableContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *UpdateTableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *UpdateTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *UpdateTableContext) SetClause() ISetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetClauseContext)
}

func (s *UpdateTableContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUpdateTable(s)
	}
}

func (s *UpdateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUpdateTable(s)
	}
}

type MergeIntoTableContext struct {
	DmlStatementNoWithContext
	target         IIdentifierReferenceContext
	targetAlias    ITableAliasContext
	source         IIdentifierReferenceContext
	sourceQuery    IQueryContext
	sourceAlias    ITableAliasContext
	mergeCondition IBooleanExpressionContext
}

func NewMergeIntoTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MergeIntoTableContext {
	var p = new(MergeIntoTableContext)

	InitEmptyDmlStatementNoWithContext(&p.DmlStatementNoWithContext)
	p.parser = parser
	p.CopyAll(ctx.(*DmlStatementNoWithContext))

	return p
}

func (s *MergeIntoTableContext) GetTarget() IIdentifierReferenceContext { return s.target }

func (s *MergeIntoTableContext) GetTargetAlias() ITableAliasContext { return s.targetAlias }

func (s *MergeIntoTableContext) GetSource() IIdentifierReferenceContext { return s.source }

func (s *MergeIntoTableContext) GetSourceQuery() IQueryContext { return s.sourceQuery }

func (s *MergeIntoTableContext) GetSourceAlias() ITableAliasContext { return s.sourceAlias }

func (s *MergeIntoTableContext) GetMergeCondition() IBooleanExpressionContext {
	return s.mergeCondition
}

func (s *MergeIntoTableContext) SetTarget(v IIdentifierReferenceContext) { s.target = v }

func (s *MergeIntoTableContext) SetTargetAlias(v ITableAliasContext) { s.targetAlias = v }

func (s *MergeIntoTableContext) SetSource(v IIdentifierReferenceContext) { s.source = v }

func (s *MergeIntoTableContext) SetSourceQuery(v IQueryContext) { s.sourceQuery = v }

func (s *MergeIntoTableContext) SetSourceAlias(v ITableAliasContext) { s.sourceAlias = v }

func (s *MergeIntoTableContext) SetMergeCondition(v IBooleanExpressionContext) { s.mergeCondition = v }

func (s *MergeIntoTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeIntoTableContext) MERGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMERGE, 0)
}

func (s *MergeIntoTableContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *MergeIntoTableContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *MergeIntoTableContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *MergeIntoTableContext) AllIdentifierReference() []IIdentifierReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierReferenceContext); ok {
			tst[i] = t.(IIdentifierReferenceContext)
			i++
		}
	}

	return tst
}

func (s *MergeIntoTableContext) IdentifierReference(i int) IIdentifierReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *MergeIntoTableContext) AllTableAlias() []ITableAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableAliasContext); ok {
			len++
		}
	}

	tst := make([]ITableAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableAliasContext); ok {
			tst[i] = t.(ITableAliasContext)
			i++
		}
	}

	return tst
}

func (s *MergeIntoTableContext) TableAlias(i int) ITableAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *MergeIntoTableContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *MergeIntoTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *MergeIntoTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *MergeIntoTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *MergeIntoTableContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *MergeIntoTableContext) EVOLUTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEVOLUTION, 0)
}

func (s *MergeIntoTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *MergeIntoTableContext) AllMatchedClause() []IMatchedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchedClauseContext); ok {
			len++
		}
	}

	tst := make([]IMatchedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchedClauseContext); ok {
			tst[i] = t.(IMatchedClauseContext)
			i++
		}
	}

	return tst
}

func (s *MergeIntoTableContext) MatchedClause(i int) IMatchedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchedClauseContext)
}

func (s *MergeIntoTableContext) AllNotMatchedClause() []INotMatchedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INotMatchedClauseContext); ok {
			len++
		}
	}

	tst := make([]INotMatchedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INotMatchedClauseContext); ok {
			tst[i] = t.(INotMatchedClauseContext)
			i++
		}
	}

	return tst
}

func (s *MergeIntoTableContext) NotMatchedClause(i int) INotMatchedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotMatchedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotMatchedClauseContext)
}

func (s *MergeIntoTableContext) AllNotMatchedBySourceClause() []INotMatchedBySourceClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INotMatchedBySourceClauseContext); ok {
			len++
		}
	}

	tst := make([]INotMatchedBySourceClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INotMatchedBySourceClauseContext); ok {
			tst[i] = t.(INotMatchedBySourceClauseContext)
			i++
		}
	}

	return tst
}

func (s *MergeIntoTableContext) NotMatchedBySourceClause(i int) INotMatchedBySourceClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotMatchedBySourceClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotMatchedBySourceClauseContext)
}

func (s *MergeIntoTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMergeIntoTable(s)
	}
}

func (s *MergeIntoTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMergeIntoTable(s)
	}
}

func (p *SqlBaseParser) DmlStatementNoWith() (localctx IDmlStatementNoWithContext) {
	localctx = NewDmlStatementNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SqlBaseParserRULE_dmlStatementNoWith)
	var _la int

	var _alt int

	p.SetState(2463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserINSERT:
		localctx = NewSingleInsertQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2402)
			p.InsertInto()
		}
		{
			p.SetState(2403)
			p.Query()
		}

	case SqlBaseParserFROM:
		localctx = NewMultiInsertQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2405)
			p.FromClause()
		}
		p.SetState(2407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2406)
					p.MultiInsertQueryBody()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(2409)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case SqlBaseParserDELETE:
		localctx = NewDeleteFromTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2411)
			p.Match(SqlBaseParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2412)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2413)
			p.IdentifierReference()
		}
		{
			p.SetState(2414)
			p.TableAlias()
		}
		p.SetState(2416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(2415)
				p.WhereClause()
			}

		}

	case SqlBaseParserUPDATE:
		localctx = NewUpdateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2418)
			p.Match(SqlBaseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2419)
			p.IdentifierReference()
		}
		{
			p.SetState(2420)
			p.TableAlias()
		}
		{
			p.SetState(2421)
			p.SetClause()
		}
		p.SetState(2423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(2422)
				p.WhereClause()
			}

		}

	case SqlBaseParserMERGE:
		localctx = NewMergeIntoTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2425)
			p.Match(SqlBaseParserMERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(2426)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2427)
				p.Match(SqlBaseParserSCHEMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2428)
				p.Match(SqlBaseParserEVOLUTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2431)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2432)

			var _x = p.IdentifierReference()

			localctx.(*MergeIntoTableContext).target = _x
		}
		{
			p.SetState(2433)

			var _x = p.TableAlias()

			localctx.(*MergeIntoTableContext).targetAlias = _x
		}
		{
			p.SetState(2434)
			p.Match(SqlBaseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2435)

				var _x = p.IdentifierReference()

				localctx.(*MergeIntoTableContext).source = _x
			}

		case 2:
			{
				p.SetState(2436)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2437)

				var _x = p.Query()

				localctx.(*MergeIntoTableContext).sourceQuery = _x
			}
			{
				p.SetState(2438)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(2442)

			var _x = p.TableAlias()

			localctx.(*MergeIntoTableContext).sourceAlias = _x
		}
		{
			p.SetState(2443)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2444)

			var _x = p.booleanExpression(0)

			localctx.(*MergeIntoTableContext).mergeCondition = _x
		}
		p.SetState(2448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2445)
					p.MatchedClause()
				}

			}
			p.SetState(2450)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2451)
					p.NotMatchedClause()
				}

			}
			p.SetState(2456)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserWHEN {
			{
				p.SetState(2457)
				p.NotMatchedBySourceClause()
			}

			p.SetState(2462)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierReferenceContext is an interface to support dynamic dispatch.
type IIdentifierReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER_KW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsIdentifierReferenceContext differentiates from other interfaces.
	IsIdentifierReferenceContext()
}

type IdentifierReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierReferenceContext() *IdentifierReferenceContext {
	var p = new(IdentifierReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierReference
	return p
}

func InitEmptyIdentifierReferenceContext(p *IdentifierReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierReference
}

func (*IdentifierReferenceContext) IsIdentifierReferenceContext() {}

func NewIdentifierReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierReferenceContext {
	var p = new(IdentifierReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifierReference

	return p
}

func (s *IdentifierReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierReferenceContext) IDENTIFIER_KW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER_KW, 0)
}

func (s *IdentifierReferenceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *IdentifierReferenceContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IdentifierReferenceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *IdentifierReferenceContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *IdentifierReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentifierReference(s)
	}
}

func (s *IdentifierReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentifierReference(s)
	}
}

func (p *SqlBaseParser) IdentifierReference() (localctx IIdentifierReferenceContext) {
	localctx = NewIdentifierReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SqlBaseParserRULE_identifierReference)
	p.SetState(2471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2465)
			p.Match(SqlBaseParserIDENTIFIER_KW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2466)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2467)
			p.Expression()
		}
		{
			p.SetState(2468)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2470)
			p.MultipartIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogIdentifierReferenceContext is an interface to support dynamic dispatch.
type ICatalogIdentifierReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER_KW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	StringLit() IStringLitContext

	// IsCatalogIdentifierReferenceContext differentiates from other interfaces.
	IsCatalogIdentifierReferenceContext()
}

type CatalogIdentifierReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogIdentifierReferenceContext() *CatalogIdentifierReferenceContext {
	var p = new(CatalogIdentifierReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_catalogIdentifierReference
	return p
}

func InitEmptyCatalogIdentifierReferenceContext(p *CatalogIdentifierReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_catalogIdentifierReference
}

func (*CatalogIdentifierReferenceContext) IsCatalogIdentifierReferenceContext() {}

func NewCatalogIdentifierReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogIdentifierReferenceContext {
	var p = new(CatalogIdentifierReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_catalogIdentifierReference

	return p
}

func (s *CatalogIdentifierReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogIdentifierReferenceContext) IDENTIFIER_KW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER_KW, 0)
}

func (s *CatalogIdentifierReferenceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CatalogIdentifierReferenceContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CatalogIdentifierReferenceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CatalogIdentifierReferenceContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *CatalogIdentifierReferenceContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *CatalogIdentifierReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogIdentifierReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogIdentifierReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCatalogIdentifierReference(s)
	}
}

func (s *CatalogIdentifierReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCatalogIdentifierReference(s)
	}
}

func (p *SqlBaseParser) CatalogIdentifierReference() (localctx ICatalogIdentifierReferenceContext) {
	localctx = NewCatalogIdentifierReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SqlBaseParserRULE_catalogIdentifierReference)
	p.SetState(2480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 265, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2473)
			p.Match(SqlBaseParserIDENTIFIER_KW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2474)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2475)
			p.Expression()
		}
		{
			p.SetState(2476)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2478)
			p.ErrorCapturingIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2479)
			p.StringLit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryOrganizationContext is an interface to support dynamic dispatch.
type IQueryOrganizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_sortItem returns the _sortItem rule contexts.
	Get_sortItem() ISortItemContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetLimit returns the limit rule contexts.
	GetLimit() IExpressionContext

	// GetOffset returns the offset rule contexts.
	GetOffset() IExpressionContext

	// Set_sortItem sets the _sortItem rule contexts.
	Set_sortItem(ISortItemContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(IExpressionContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(IExpressionContext)

	// GetOrder returns the order rule context list.
	GetOrder() []ISortItemContext

	// GetClusterBy returns the clusterBy rule context list.
	GetClusterBy() []IExpressionContext

	// GetDistributeBy returns the distributeBy rule context list.
	GetDistributeBy() []IExpressionContext

	// GetSort returns the sort rule context list.
	GetSort() []ISortItemContext

	// SetOrder sets the order rule context list.
	SetOrder([]ISortItemContext)

	// SetClusterBy sets the clusterBy rule context list.
	SetClusterBy([]IExpressionContext)

	// SetDistributeBy sets the distributeBy rule context list.
	SetDistributeBy([]IExpressionContext)

	// SetSort sets the sort rule context list.
	SetSort([]ISortItemContext)

	// Getter signatures
	ORDER() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	DISTRIBUTE() antlr.TerminalNode
	SORT() antlr.TerminalNode
	WindowClause() IWindowClauseContext
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	ALL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsQueryOrganizationContext differentiates from other interfaces.
	IsQueryOrganizationContext()
}

type QueryOrganizationContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_sortItem    ISortItemContext
	order        []ISortItemContext
	_expression  IExpressionContext
	clusterBy    []IExpressionContext
	distributeBy []IExpressionContext
	sort         []ISortItemContext
	limit        IExpressionContext
	offset       IExpressionContext
}

func NewEmptyQueryOrganizationContext() *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryOrganization
	return p
}

func InitEmptyQueryOrganizationContext(p *QueryOrganizationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryOrganization
}

func (*QueryOrganizationContext) IsQueryOrganizationContext() {}

func NewQueryOrganizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryOrganization

	return p
}

func (s *QueryOrganizationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryOrganizationContext) Get_sortItem() ISortItemContext { return s._sortItem }

func (s *QueryOrganizationContext) Get_expression() IExpressionContext { return s._expression }

func (s *QueryOrganizationContext) GetLimit() IExpressionContext { return s.limit }

func (s *QueryOrganizationContext) GetOffset() IExpressionContext { return s.offset }

func (s *QueryOrganizationContext) Set_sortItem(v ISortItemContext) { s._sortItem = v }

func (s *QueryOrganizationContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *QueryOrganizationContext) SetLimit(v IExpressionContext) { s.limit = v }

func (s *QueryOrganizationContext) SetOffset(v IExpressionContext) { s.offset = v }

func (s *QueryOrganizationContext) GetOrder() []ISortItemContext { return s.order }

func (s *QueryOrganizationContext) GetClusterBy() []IExpressionContext { return s.clusterBy }

func (s *QueryOrganizationContext) GetDistributeBy() []IExpressionContext { return s.distributeBy }

func (s *QueryOrganizationContext) GetSort() []ISortItemContext { return s.sort }

func (s *QueryOrganizationContext) SetOrder(v []ISortItemContext) { s.order = v }

func (s *QueryOrganizationContext) SetClusterBy(v []IExpressionContext) { s.clusterBy = v }

func (s *QueryOrganizationContext) SetDistributeBy(v []IExpressionContext) { s.distributeBy = v }

func (s *QueryOrganizationContext) SetSort(v []ISortItemContext) { s.sort = v }

func (s *QueryOrganizationContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *QueryOrganizationContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *QueryOrganizationContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *QueryOrganizationContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTER, 0)
}

func (s *QueryOrganizationContext) DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTE, 0)
}

func (s *QueryOrganizationContext) SORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORT, 0)
}

func (s *QueryOrganizationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QueryOrganizationContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *QueryOrganizationContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *QueryOrganizationContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryOrganizationContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryOrganizationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QueryOrganizationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QueryOrganizationContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *QueryOrganizationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *QueryOrganizationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *QueryOrganizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryOrganizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryOrganizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQueryOrganization(s)
	}
}

func (s *QueryOrganizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQueryOrganization(s)
	}
}

func (p *SqlBaseParser) QueryOrganization() (localctx IQueryOrganizationContext) {
	localctx = NewQueryOrganizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SqlBaseParserRULE_queryOrganization)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2492)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2482)
			p.Match(SqlBaseParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2483)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2484)

			var _x = p.SortItem()

			localctx.(*QueryOrganizationContext)._sortItem = _x
		}
		localctx.(*QueryOrganizationContext).order = append(localctx.(*QueryOrganizationContext).order, localctx.(*QueryOrganizationContext)._sortItem)
		p.SetState(2489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2485)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2486)

					var _x = p.SortItem()

					localctx.(*QueryOrganizationContext)._sortItem = _x
				}
				localctx.(*QueryOrganizationContext).order = append(localctx.(*QueryOrganizationContext).order, localctx.(*QueryOrganizationContext)._sortItem)

			}
			p.SetState(2491)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2504)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2494)
			p.Match(SqlBaseParserCLUSTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2495)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2496)

			var _x = p.Expression()

			localctx.(*QueryOrganizationContext)._expression = _x
		}
		localctx.(*QueryOrganizationContext).clusterBy = append(localctx.(*QueryOrganizationContext).clusterBy, localctx.(*QueryOrganizationContext)._expression)
		p.SetState(2501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2497)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2498)

					var _x = p.Expression()

					localctx.(*QueryOrganizationContext)._expression = _x
				}
				localctx.(*QueryOrganizationContext).clusterBy = append(localctx.(*QueryOrganizationContext).clusterBy, localctx.(*QueryOrganizationContext)._expression)

			}
			p.SetState(2503)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2516)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2506)
			p.Match(SqlBaseParserDISTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2507)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2508)

			var _x = p.Expression()

			localctx.(*QueryOrganizationContext)._expression = _x
		}
		localctx.(*QueryOrganizationContext).distributeBy = append(localctx.(*QueryOrganizationContext).distributeBy, localctx.(*QueryOrganizationContext)._expression)
		p.SetState(2513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2509)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2510)

					var _x = p.Expression()

					localctx.(*QueryOrganizationContext)._expression = _x
				}
				localctx.(*QueryOrganizationContext).distributeBy = append(localctx.(*QueryOrganizationContext).distributeBy, localctx.(*QueryOrganizationContext)._expression)

			}
			p.SetState(2515)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2518)
			p.Match(SqlBaseParserSORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2519)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2520)

			var _x = p.SortItem()

			localctx.(*QueryOrganizationContext)._sortItem = _x
		}
		localctx.(*QueryOrganizationContext).sort = append(localctx.(*QueryOrganizationContext).sort, localctx.(*QueryOrganizationContext)._sortItem)
		p.SetState(2525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2521)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2522)

					var _x = p.SortItem()

					localctx.(*QueryOrganizationContext)._sortItem = _x
				}
				localctx.(*QueryOrganizationContext).sort = append(localctx.(*QueryOrganizationContext).sort, localctx.(*QueryOrganizationContext)._sortItem)

			}
			p.SetState(2527)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2531)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2530)
			p.WindowClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2538)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2533)
			p.Match(SqlBaseParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2534)
				p.Match(SqlBaseParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(2535)

				var _x = p.Expression()

				localctx.(*QueryOrganizationContext).limit = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2542)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2540)
			p.Match(SqlBaseParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2541)

			var _x = p.Expression()

			localctx.(*QueryOrganizationContext).offset = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiInsertQueryBodyContext is an interface to support dynamic dispatch.
type IMultiInsertQueryBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertInto() IInsertIntoContext
	FromStatementBody() IFromStatementBodyContext

	// IsMultiInsertQueryBodyContext differentiates from other interfaces.
	IsMultiInsertQueryBodyContext()
}

type MultiInsertQueryBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiInsertQueryBodyContext() *MultiInsertQueryBodyContext {
	var p = new(MultiInsertQueryBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multiInsertQueryBody
	return p
}

func InitEmptyMultiInsertQueryBodyContext(p *MultiInsertQueryBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multiInsertQueryBody
}

func (*MultiInsertQueryBodyContext) IsMultiInsertQueryBodyContext() {}

func NewMultiInsertQueryBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiInsertQueryBodyContext {
	var p = new(MultiInsertQueryBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_multiInsertQueryBody

	return p
}

func (s *MultiInsertQueryBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiInsertQueryBodyContext) InsertInto() IInsertIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertIntoContext)
}

func (s *MultiInsertQueryBodyContext) FromStatementBody() IFromStatementBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromStatementBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromStatementBodyContext)
}

func (s *MultiInsertQueryBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiInsertQueryBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiInsertQueryBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMultiInsertQueryBody(s)
	}
}

func (s *MultiInsertQueryBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMultiInsertQueryBody(s)
	}
}

func (p *SqlBaseParser) MultiInsertQueryBody() (localctx IMultiInsertQueryBodyContext) {
	localctx = NewMultiInsertQueryBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SqlBaseParserRULE_multiInsertQueryBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2544)
		p.InsertInto()
	}
	{
		p.SetState(2545)
		p.FromStatementBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type OperatorPipeStatementContext struct {
	QueryTermContext
	left IQueryTermContext
}

func NewOperatorPipeStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OperatorPipeStatementContext {
	var p = new(OperatorPipeStatementContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *OperatorPipeStatementContext) GetLeft() IQueryTermContext { return s.left }

func (s *OperatorPipeStatementContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *OperatorPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorPipeStatementContext) OPERATOR_PIPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPERATOR_PIPE, 0)
}

func (s *OperatorPipeStatementContext) OperatorPipeRightSide() IOperatorPipeRightSideContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorPipeRightSideContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorPipeRightSideContext)
}

func (s *OperatorPipeStatementContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *OperatorPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterOperatorPipeStatement(s)
	}
}

func (s *OperatorPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitOperatorPipeStatement(s)
	}
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

type SetOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERSECT, 0)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCEPT, 0)
}

func (s *SetOperationContext) SETMINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETMINUS, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (p *SqlBaseParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *SqlBaseParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, SqlBaseParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(2548)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2574)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(2550)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(2551)

				if !(legacy_setops_precedence_enabled) {
					p.SetError(antlr.NewFailedPredicateException(p, "legacy_setops_precedence_enabled", ""))
					goto errorExit
				}
				{
					p.SetState(2552)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserEXCEPT || _la == SqlBaseParserINTERSECT || _la == SqlBaseParserSETMINUS || _la == SqlBaseParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(2554)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(2553)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(2556)

					var _x = p.queryTerm(5)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(2557)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				p.SetState(2558)

				if !(!legacy_setops_precedence_enabled) {
					p.SetError(antlr.NewFailedPredicateException(p, "!legacy_setops_precedence_enabled", ""))
					goto errorExit
				}
				{
					p.SetState(2559)

					var _m = p.Match(SqlBaseParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2561)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(2560)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(2563)

					var _x = p.queryTerm(4)

					localctx.(*SetOperationContext).right = _x
				}

			case 3:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(2564)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				p.SetState(2565)

				if !(!legacy_setops_precedence_enabled) {
					p.SetError(antlr.NewFailedPredicateException(p, "!legacy_setops_precedence_enabled", ""))
					goto errorExit
				}
				{
					p.SetState(2566)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserEXCEPT || _la == SqlBaseParserSETMINUS || _la == SqlBaseParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(2568)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(2567)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(2570)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 4:
				localctx = NewOperatorPipeStatementContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*OperatorPipeStatementContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(2571)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2572)
					p.Match(SqlBaseParserOPERATOR_PIPE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2573)
					p.OperatorPipeRightSide()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *SubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

type InlineTableDefault1Context struct {
	QueryPrimaryContext
}

func NewInlineTableDefault1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableDefault1Context {
	var p = new(InlineTableDefault1Context)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableDefault1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableDefault1Context) InlineTable() IInlineTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineTableContext)
}

func (s *InlineTableDefault1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInlineTableDefault1(s)
	}
}

func (s *InlineTableDefault1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInlineTableDefault1(s)
	}
}

type FromStmtContext struct {
	QueryPrimaryContext
}

func NewFromStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FromStmtContext {
	var p = new(FromStmtContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *FromStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromStmtContext) FromStatement() IFromStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromStatementContext)
}

func (s *FromStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFromStmt(s)
	}
}

func (s *FromStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFromStmt(s)
	}
}

type TableContext struct {
	QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *TableContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *SqlBaseParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SqlBaseParserRULE_queryPrimary)
	p.SetState(2588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserMAP, SqlBaseParserREDUCE, SqlBaseParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2579)
			p.QuerySpecification()
		}

	case SqlBaseParserFROM:
		localctx = NewFromStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2580)
			p.FromStatement()
		}

	case SqlBaseParserTABLE:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2581)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2582)
			p.IdentifierReference()
		}

	case SqlBaseParserVALUES:
		localctx = NewInlineTableDefault1Context(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2583)
			p.InlineTable()
		}

	case SqlBaseParserLEFT_PAREN:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2584)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2585)
			p.Query()
		}
		{
			p.SetState(2586)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrder returns the nullOrder token.
	GetNullOrder() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrder sets the nullOrder token.
	SetNullOrder(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	LAST() antlr.TerminalNode
	FIRST() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	ordering  antlr.Token
	nullOrder antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrder() antlr.Token { return s.nullOrder }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrder(v antlr.Token) { s.nullOrder = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *SqlBaseParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SqlBaseParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2590)
		p.Expression()
	}
	p.SetState(2592)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2591)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserASC || _la == SqlBaseParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2596)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2594)
			p.Match(SqlBaseParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2595)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrder = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFIRST || _la == SqlBaseParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrder = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromStatementContext is an interface to support dynamic dispatch.
type IFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FromClause() IFromClauseContext
	AllFromStatementBody() []IFromStatementBodyContext
	FromStatementBody(i int) IFromStatementBodyContext

	// IsFromStatementContext differentiates from other interfaces.
	IsFromStatementContext()
}

type FromStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromStatementContext() *FromStatementContext {
	var p = new(FromStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fromStatement
	return p
}

func InitEmptyFromStatementContext(p *FromStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fromStatement
}

func (*FromStatementContext) IsFromStatementContext() {}

func NewFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromStatementContext {
	var p = new(FromStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_fromStatement

	return p
}

func (s *FromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FromStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *FromStatementContext) AllFromStatementBody() []IFromStatementBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFromStatementBodyContext); ok {
			len++
		}
	}

	tst := make([]IFromStatementBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFromStatementBodyContext); ok {
			tst[i] = t.(IFromStatementBodyContext)
			i++
		}
	}

	return tst
}

func (s *FromStatementContext) FromStatementBody(i int) IFromStatementBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromStatementBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromStatementBodyContext)
}

func (s *FromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFromStatement(s)
	}
}

func (s *FromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFromStatement(s)
	}
}

func (p *SqlBaseParser) FromStatement() (localctx IFromStatementContext) {
	localctx = NewFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SqlBaseParserRULE_fromStatement)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2598)
		p.FromClause()
	}
	p.SetState(2602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2599)
				p.FromStatementBody()
			}

		}
		p.SetState(2604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromStatementBodyContext is an interface to support dynamic dispatch.
type IFromStatementBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TransformClause() ITransformClauseContext
	QueryOrganization() IQueryOrganizationContext
	WhereClause() IWhereClauseContext
	SelectClause() ISelectClauseContext
	AllLateralView() []ILateralViewContext
	LateralView(i int) ILateralViewContext
	AggregationClause() IAggregationClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext

	// IsFromStatementBodyContext differentiates from other interfaces.
	IsFromStatementBodyContext()
}

type FromStatementBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromStatementBodyContext() *FromStatementBodyContext {
	var p = new(FromStatementBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fromStatementBody
	return p
}

func InitEmptyFromStatementBodyContext(p *FromStatementBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fromStatementBody
}

func (*FromStatementBodyContext) IsFromStatementBodyContext() {}

func NewFromStatementBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromStatementBodyContext {
	var p = new(FromStatementBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_fromStatementBody

	return p
}

func (s *FromStatementBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FromStatementBodyContext) TransformClause() ITransformClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransformClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransformClauseContext)
}

func (s *FromStatementBodyContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *FromStatementBodyContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *FromStatementBodyContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *FromStatementBodyContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *FromStatementBodyContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *FromStatementBodyContext) AggregationClause() IAggregationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationClauseContext)
}

func (s *FromStatementBodyContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *FromStatementBodyContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *FromStatementBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromStatementBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromStatementBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFromStatementBody(s)
	}
}

func (s *FromStatementBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFromStatementBody(s)
	}
}

func (p *SqlBaseParser) FromStatementBody() (localctx IFromStatementBodyContext) {
	localctx = NewFromStatementBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SqlBaseParserRULE_fromStatementBody)
	var _alt int

	p.SetState(2632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2605)
			p.TransformClause()
		}
		p.SetState(2607)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2606)
				p.WhereClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2609)
			p.QueryOrganization()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2611)
			p.SelectClause()
		}
		p.SetState(2615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2612)
					p.LateralView()
				}

			}
			p.SetState(2617)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2619)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2618)
				p.WhereClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2622)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2621)
				p.AggregationClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2625)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2624)
				p.HavingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2628)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2627)
				p.WindowClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2630)
			p.QueryOrganization()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) CopyAll(ctx *QuerySpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RegularQuerySpecificationContext struct {
	QuerySpecificationContext
}

func NewRegularQuerySpecificationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularQuerySpecificationContext {
	var p = new(RegularQuerySpecificationContext)

	InitEmptyQuerySpecificationContext(&p.QuerySpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QuerySpecificationContext))

	return p
}

func (s *RegularQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQuerySpecificationContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *RegularQuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *RegularQuerySpecificationContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *RegularQuerySpecificationContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *RegularQuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *RegularQuerySpecificationContext) AggregationClause() IAggregationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationClauseContext)
}

func (s *RegularQuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *RegularQuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *RegularQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRegularQuerySpecification(s)
	}
}

func (s *RegularQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRegularQuerySpecification(s)
	}
}

type TransformQuerySpecificationContext struct {
	QuerySpecificationContext
}

func NewTransformQuerySpecificationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransformQuerySpecificationContext {
	var p = new(TransformQuerySpecificationContext)

	InitEmptyQuerySpecificationContext(&p.QuerySpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QuerySpecificationContext))

	return p
}

func (s *TransformQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformQuerySpecificationContext) TransformClause() ITransformClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransformClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransformClauseContext)
}

func (s *TransformQuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *TransformQuerySpecificationContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *TransformQuerySpecificationContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *TransformQuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *TransformQuerySpecificationContext) AggregationClause() IAggregationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationClauseContext)
}

func (s *TransformQuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *TransformQuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *TransformQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTransformQuerySpecification(s)
	}
}

func (s *TransformQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTransformQuerySpecification(s)
	}
}

func (p *SqlBaseParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SqlBaseParserRULE_querySpecification)
	var _alt int

	p.SetState(2678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 306, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTransformQuerySpecificationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2634)
			p.TransformClause()
		}
		p.SetState(2636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2635)
				p.FromClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2638)
					p.LateralView()
				}

			}
			p.SetState(2643)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2645)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2644)
				p.WhereClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2648)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2647)
				p.AggregationClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2651)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2650)
				p.HavingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2654)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2653)
				p.WindowClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewRegularQuerySpecificationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2656)
			p.SelectClause()
		}
		p.SetState(2658)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2657)
				p.FromClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2660)
					p.LateralView()
				}

			}
			p.SetState(2665)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2667)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2666)
				p.WhereClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2670)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2669)
				p.AggregationClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2673)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2672)
				p.HavingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2676)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2675)
				p.WindowClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransformClauseContext is an interface to support dynamic dispatch.
type ITransformClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetInRowFormat returns the inRowFormat rule contexts.
	GetInRowFormat() IRowFormatContext

	// GetRecordWriter returns the recordWriter rule contexts.
	GetRecordWriter() IStringLitContext

	// GetScript returns the script rule contexts.
	GetScript() IStringLitContext

	// GetOutRowFormat returns the outRowFormat rule contexts.
	GetOutRowFormat() IRowFormatContext

	// GetRecordReader returns the recordReader rule contexts.
	GetRecordReader() IStringLitContext

	// SetInRowFormat sets the inRowFormat rule contexts.
	SetInRowFormat(IRowFormatContext)

	// SetRecordWriter sets the recordWriter rule contexts.
	SetRecordWriter(IStringLitContext)

	// SetScript sets the script rule contexts.
	SetScript(IStringLitContext)

	// SetOutRowFormat sets the outRowFormat rule contexts.
	SetOutRowFormat(IRowFormatContext)

	// SetRecordReader sets the recordReader rule contexts.
	SetRecordReader(IStringLitContext)

	// Getter signatures
	USING() antlr.TerminalNode
	AllStringLit() []IStringLitContext
	StringLit(i int) IStringLitContext
	SELECT() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	ExpressionSeq() IExpressionSeqContext
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	TRANSFORM() antlr.TerminalNode
	MAP() antlr.TerminalNode
	REDUCE() antlr.TerminalNode
	RECORDWRITER() antlr.TerminalNode
	AS() antlr.TerminalNode
	RECORDREADER() antlr.TerminalNode
	AllRowFormat() []IRowFormatContext
	RowFormat(i int) IRowFormatContext
	SetQuantifier() ISetQuantifierContext
	IdentifierSeq() IIdentifierSeqContext
	ColTypeList() IColTypeListContext

	// IsTransformClauseContext differentiates from other interfaces.
	IsTransformClauseContext()
}

type TransformClauseContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	kind         antlr.Token
	inRowFormat  IRowFormatContext
	recordWriter IStringLitContext
	script       IStringLitContext
	outRowFormat IRowFormatContext
	recordReader IStringLitContext
}

func NewEmptyTransformClauseContext() *TransformClauseContext {
	var p = new(TransformClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transformClause
	return p
}

func InitEmptyTransformClauseContext(p *TransformClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transformClause
}

func (*TransformClauseContext) IsTransformClauseContext() {}

func NewTransformClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformClauseContext {
	var p = new(TransformClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_transformClause

	return p
}

func (s *TransformClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformClauseContext) GetKind() antlr.Token { return s.kind }

func (s *TransformClauseContext) SetKind(v antlr.Token) { s.kind = v }

func (s *TransformClauseContext) GetInRowFormat() IRowFormatContext { return s.inRowFormat }

func (s *TransformClauseContext) GetRecordWriter() IStringLitContext { return s.recordWriter }

func (s *TransformClauseContext) GetScript() IStringLitContext { return s.script }

func (s *TransformClauseContext) GetOutRowFormat() IRowFormatContext { return s.outRowFormat }

func (s *TransformClauseContext) GetRecordReader() IStringLitContext { return s.recordReader }

func (s *TransformClauseContext) SetInRowFormat(v IRowFormatContext) { s.inRowFormat = v }

func (s *TransformClauseContext) SetRecordWriter(v IStringLitContext) { s.recordWriter = v }

func (s *TransformClauseContext) SetScript(v IStringLitContext) { s.script = v }

func (s *TransformClauseContext) SetOutRowFormat(v IRowFormatContext) { s.outRowFormat = v }

func (s *TransformClauseContext) SetRecordReader(v IStringLitContext) { s.recordReader = v }

func (s *TransformClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *TransformClauseContext) AllStringLit() []IStringLitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLitContext); ok {
			len++
		}
	}

	tst := make([]IStringLitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLitContext); ok {
			tst[i] = t.(IStringLitContext)
			i++
		}
	}

	return tst
}

func (s *TransformClauseContext) StringLit(i int) IStringLitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *TransformClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *TransformClauseContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *TransformClauseContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *TransformClauseContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *TransformClauseContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *TransformClauseContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *TransformClauseContext) TRANSFORM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSFORM, 0)
}

func (s *TransformClauseContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *TransformClauseContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREDUCE, 0)
}

func (s *TransformClauseContext) RECORDWRITER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECORDWRITER, 0)
}

func (s *TransformClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *TransformClauseContext) RECORDREADER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECORDREADER, 0)
}

func (s *TransformClauseContext) AllRowFormat() []IRowFormatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowFormatContext); ok {
			len++
		}
	}

	tst := make([]IRowFormatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowFormatContext); ok {
			tst[i] = t.(IRowFormatContext)
			i++
		}
	}

	return tst
}

func (s *TransformClauseContext) RowFormat(i int) IRowFormatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatContext)
}

func (s *TransformClauseContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *TransformClauseContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *TransformClauseContext) ColTypeList() IColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeListContext)
}

func (s *TransformClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTransformClause(s)
	}
}

func (s *TransformClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTransformClause(s)
	}
}

func (p *SqlBaseParser) TransformClause() (localctx ITransformClauseContext) {
	localctx = NewTransformClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SqlBaseParserRULE_transformClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSELECT:
		{
			p.SetState(2680)
			p.Match(SqlBaseParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2681)

			var _m = p.Match(SqlBaseParserTRANSFORM)

			localctx.(*TransformClauseContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2682)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2684)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2683)
				p.SetQuantifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2686)
			p.ExpressionSeq()
		}
		{
			p.SetState(2687)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserMAP:
		{
			p.SetState(2689)

			var _m = p.Match(SqlBaseParserMAP)

			localctx.(*TransformClauseContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2691)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2690)
				p.SetQuantifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2693)
			p.ExpressionSeq()
		}

	case SqlBaseParserREDUCE:
		{
			p.SetState(2694)

			var _m = p.Match(SqlBaseParserREDUCE)

			localctx.(*TransformClauseContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2696)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2695)
				p.SetQuantifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2698)
			p.ExpressionSeq()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserROW {
		{
			p.SetState(2701)

			var _x = p.RowFormat()

			localctx.(*TransformClauseContext).inRowFormat = _x
		}

	}
	p.SetState(2706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserRECORDWRITER {
		{
			p.SetState(2704)
			p.Match(SqlBaseParserRECORDWRITER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2705)

			var _x = p.StringLit()

			localctx.(*TransformClauseContext).recordWriter = _x
		}

	}
	{
		p.SetState(2708)
		p.Match(SqlBaseParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2709)

		var _x = p.StringLit()

		localctx.(*TransformClauseContext).script = _x
	}
	p.SetState(2722)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2710)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2711)
				p.IdentifierSeq()
			}

		case 2:
			{
				p.SetState(2712)
				p.ColTypeList()
			}

		case 3:
			{
				p.SetState(2713)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2716)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2714)
					p.IdentifierSeq()
				}

			case 2:
				{
					p.SetState(2715)
					p.ColTypeList()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(2718)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2725)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2724)

			var _x = p.RowFormat()

			localctx.(*TransformClauseContext).outRowFormat = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2729)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2727)
			p.Match(SqlBaseParserRECORDREADER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2728)

			var _x = p.StringLit()

			localctx.(*TransformClauseContext).recordReader = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hint returns the _hint rule contexts.
	Get_hint() IHintContext

	// Set_hint sets the _hint rule contexts.
	Set_hint(IHintContext)

	// GetHints returns the hints rule context list.
	GetHints() []IHintContext

	// SetHints sets the hints rule context list.
	SetHints([]IHintContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	NamedExpressionSeq() INamedExpressionSeqContext
	SetQuantifier() ISetQuantifierContext
	AllHint() []IHintContext
	Hint(i int) IHintContext

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_hint  IHintContext
	hints  []IHintContext
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) Get_hint() IHintContext { return s._hint }

func (s *SelectClauseContext) Set_hint(v IHintContext) { s._hint = v }

func (s *SelectClauseContext) GetHints() []IHintContext { return s.hints }

func (s *SelectClauseContext) SetHints(v []IHintContext) { s.hints = v }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *SelectClauseContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *SelectClauseContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SelectClauseContext) AllHint() []IHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintContext); ok {
			len++
		}
	}

	tst := make([]IHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintContext); ok {
			tst[i] = t.(IHintContext)
			i++
		}
	}

	return tst
}

func (s *SelectClauseContext) Hint(i int) IHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (p *SqlBaseParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SqlBaseParserRULE_selectClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2731)
		p.Match(SqlBaseParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2732)

				var _x = p.Hint()

				localctx.(*SelectClauseContext)._hint = _x
			}
			localctx.(*SelectClauseContext).hints = append(localctx.(*SelectClauseContext).hints, localctx.(*SelectClauseContext)._hint)

		}
		p.SetState(2737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2739)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2738)
			p.SetQuantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2741)
		p.NamedExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetClauseContext is an interface to support dynamic dispatch.
type ISetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	AssignmentList() IAssignmentListContext

	// IsSetClauseContext differentiates from other interfaces.
	IsSetClauseContext()
}

type SetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetClauseContext() *SetClauseContext {
	var p = new(SetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setClause
	return p
}

func InitEmptySetClauseContext(p *SetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setClause
}

func (*SetClauseContext) IsSetClauseContext() {}

func NewSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetClauseContext {
	var p = new(SetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_setClause

	return p
}

func (s *SetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetClauseContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *SetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetClause(s)
	}
}

func (s *SetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetClause(s)
	}
}

func (p *SqlBaseParser) SetClause() (localctx ISetClauseContext) {
	localctx = NewSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SqlBaseParserRULE_setClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2743)
		p.Match(SqlBaseParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2744)
		p.AssignmentList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchedClauseContext is an interface to support dynamic dispatch.
type IMatchedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatchedCond returns the matchedCond rule contexts.
	GetMatchedCond() IBooleanExpressionContext

	// SetMatchedCond sets the matchedCond rule contexts.
	SetMatchedCond(IBooleanExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	MATCHED() antlr.TerminalNode
	THEN() antlr.TerminalNode
	MatchedAction() IMatchedActionContext
	AND() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsMatchedClauseContext differentiates from other interfaces.
	IsMatchedClauseContext()
}

type MatchedClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	matchedCond IBooleanExpressionContext
}

func NewEmptyMatchedClauseContext() *MatchedClauseContext {
	var p = new(MatchedClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_matchedClause
	return p
}

func InitEmptyMatchedClauseContext(p *MatchedClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_matchedClause
}

func (*MatchedClauseContext) IsMatchedClauseContext() {}

func NewMatchedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchedClauseContext {
	var p = new(MatchedClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_matchedClause

	return p
}

func (s *MatchedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchedClauseContext) GetMatchedCond() IBooleanExpressionContext { return s.matchedCond }

func (s *MatchedClauseContext) SetMatchedCond(v IBooleanExpressionContext) { s.matchedCond = v }

func (s *MatchedClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *MatchedClauseContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATCHED, 0)
}

func (s *MatchedClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *MatchedClauseContext) MatchedAction() IMatchedActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchedActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchedActionContext)
}

func (s *MatchedClauseContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *MatchedClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *MatchedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMatchedClause(s)
	}
}

func (s *MatchedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMatchedClause(s)
	}
}

func (p *SqlBaseParser) MatchedClause() (localctx IMatchedClauseContext) {
	localctx = NewMatchedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SqlBaseParserRULE_matchedClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2746)
		p.Match(SqlBaseParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2747)
		p.Match(SqlBaseParserMATCHED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserAND {
		{
			p.SetState(2748)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2749)

			var _x = p.booleanExpression(0)

			localctx.(*MatchedClauseContext).matchedCond = _x
		}

	}
	{
		p.SetState(2752)
		p.Match(SqlBaseParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2753)
		p.MatchedAction()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotMatchedClauseContext is an interface to support dynamic dispatch.
type INotMatchedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNotMatchedCond returns the notMatchedCond rule contexts.
	GetNotMatchedCond() IBooleanExpressionContext

	// SetNotMatchedCond sets the notMatchedCond rule contexts.
	SetNotMatchedCond(IBooleanExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	ErrorCapturingNot() IErrorCapturingNotContext
	MATCHED() antlr.TerminalNode
	THEN() antlr.TerminalNode
	NotMatchedAction() INotMatchedActionContext
	BY() antlr.TerminalNode
	TARGET() antlr.TerminalNode
	AND() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsNotMatchedClauseContext differentiates from other interfaces.
	IsNotMatchedClauseContext()
}

type NotMatchedClauseContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	notMatchedCond IBooleanExpressionContext
}

func NewEmptyNotMatchedClauseContext() *NotMatchedClauseContext {
	var p = new(NotMatchedClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedClause
	return p
}

func InitEmptyNotMatchedClauseContext(p *NotMatchedClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedClause
}

func (*NotMatchedClauseContext) IsNotMatchedClauseContext() {}

func NewNotMatchedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotMatchedClauseContext {
	var p = new(NotMatchedClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_notMatchedClause

	return p
}

func (s *NotMatchedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotMatchedClauseContext) GetNotMatchedCond() IBooleanExpressionContext {
	return s.notMatchedCond
}

func (s *NotMatchedClauseContext) SetNotMatchedCond(v IBooleanExpressionContext) {
	s.notMatchedCond = v
}

func (s *NotMatchedClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *NotMatchedClauseContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *NotMatchedClauseContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATCHED, 0)
}

func (s *NotMatchedClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *NotMatchedClauseContext) NotMatchedAction() INotMatchedActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotMatchedActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotMatchedActionContext)
}

func (s *NotMatchedClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *NotMatchedClauseContext) TARGET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTARGET, 0)
}

func (s *NotMatchedClauseContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *NotMatchedClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *NotMatchedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotMatchedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotMatchedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNotMatchedClause(s)
	}
}

func (s *NotMatchedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNotMatchedClause(s)
	}
}

func (p *SqlBaseParser) NotMatchedClause() (localctx INotMatchedClauseContext) {
	localctx = NewNotMatchedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SqlBaseParserRULE_notMatchedClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2755)
		p.Match(SqlBaseParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2756)
		p.ErrorCapturingNot()
	}
	{
		p.SetState(2757)
		p.Match(SqlBaseParserMATCHED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserBY {
		{
			p.SetState(2758)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2759)
			p.Match(SqlBaseParserTARGET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserAND {
		{
			p.SetState(2762)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2763)

			var _x = p.booleanExpression(0)

			localctx.(*NotMatchedClauseContext).notMatchedCond = _x
		}

	}
	{
		p.SetState(2766)
		p.Match(SqlBaseParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2767)
		p.NotMatchedAction()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotMatchedBySourceClauseContext is an interface to support dynamic dispatch.
type INotMatchedBySourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNotMatchedBySourceCond returns the notMatchedBySourceCond rule contexts.
	GetNotMatchedBySourceCond() IBooleanExpressionContext

	// SetNotMatchedBySourceCond sets the notMatchedBySourceCond rule contexts.
	SetNotMatchedBySourceCond(IBooleanExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	ErrorCapturingNot() IErrorCapturingNotContext
	MATCHED() antlr.TerminalNode
	BY() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	THEN() antlr.TerminalNode
	NotMatchedBySourceAction() INotMatchedBySourceActionContext
	AND() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsNotMatchedBySourceClauseContext differentiates from other interfaces.
	IsNotMatchedBySourceClauseContext()
}

type NotMatchedBySourceClauseContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	notMatchedBySourceCond IBooleanExpressionContext
}

func NewEmptyNotMatchedBySourceClauseContext() *NotMatchedBySourceClauseContext {
	var p = new(NotMatchedBySourceClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedBySourceClause
	return p
}

func InitEmptyNotMatchedBySourceClauseContext(p *NotMatchedBySourceClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedBySourceClause
}

func (*NotMatchedBySourceClauseContext) IsNotMatchedBySourceClauseContext() {}

func NewNotMatchedBySourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotMatchedBySourceClauseContext {
	var p = new(NotMatchedBySourceClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_notMatchedBySourceClause

	return p
}

func (s *NotMatchedBySourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotMatchedBySourceClauseContext) GetNotMatchedBySourceCond() IBooleanExpressionContext {
	return s.notMatchedBySourceCond
}

func (s *NotMatchedBySourceClauseContext) SetNotMatchedBySourceCond(v IBooleanExpressionContext) {
	s.notMatchedBySourceCond = v
}

func (s *NotMatchedBySourceClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *NotMatchedBySourceClauseContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *NotMatchedBySourceClauseContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATCHED, 0)
}

func (s *NotMatchedBySourceClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *NotMatchedBySourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *NotMatchedBySourceClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *NotMatchedBySourceClauseContext) NotMatchedBySourceAction() INotMatchedBySourceActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotMatchedBySourceActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotMatchedBySourceActionContext)
}

func (s *NotMatchedBySourceClauseContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *NotMatchedBySourceClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *NotMatchedBySourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotMatchedBySourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotMatchedBySourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNotMatchedBySourceClause(s)
	}
}

func (s *NotMatchedBySourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNotMatchedBySourceClause(s)
	}
}

func (p *SqlBaseParser) NotMatchedBySourceClause() (localctx INotMatchedBySourceClauseContext) {
	localctx = NewNotMatchedBySourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SqlBaseParserRULE_notMatchedBySourceClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2769)
		p.Match(SqlBaseParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2770)
		p.ErrorCapturingNot()
	}
	{
		p.SetState(2771)
		p.Match(SqlBaseParserMATCHED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2772)
		p.Match(SqlBaseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2773)
		p.Match(SqlBaseParserSOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserAND {
		{
			p.SetState(2774)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2775)

			var _x = p.booleanExpression(0)

			localctx.(*NotMatchedBySourceClauseContext).notMatchedBySourceCond = _x
		}

	}
	{
		p.SetState(2778)
		p.Match(SqlBaseParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2779)
		p.NotMatchedBySourceAction()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchedActionContext is an interface to support dynamic dispatch.
type IMatchedActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	AssignmentList() IAssignmentListContext

	// IsMatchedActionContext differentiates from other interfaces.
	IsMatchedActionContext()
}

type MatchedActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchedActionContext() *MatchedActionContext {
	var p = new(MatchedActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_matchedAction
	return p
}

func InitEmptyMatchedActionContext(p *MatchedActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_matchedAction
}

func (*MatchedActionContext) IsMatchedActionContext() {}

func NewMatchedActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchedActionContext {
	var p = new(MatchedActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_matchedAction

	return p
}

func (s *MatchedActionContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchedActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *MatchedActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *MatchedActionContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *MatchedActionContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *MatchedActionContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *MatchedActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchedActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchedActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMatchedAction(s)
	}
}

func (s *MatchedActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMatchedAction(s)
	}
}

func (p *SqlBaseParser) MatchedAction() (localctx IMatchedActionContext) {
	localctx = NewMatchedActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SqlBaseParserRULE_matchedAction)
	p.SetState(2788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2781)
			p.Match(SqlBaseParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2782)
			p.Match(SqlBaseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2783)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2784)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2785)
			p.Match(SqlBaseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2786)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2787)
			p.AssignmentList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotMatchedActionContext is an interface to support dynamic dispatch.
type INotMatchedActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumns returns the columns rule contexts.
	GetColumns() IMultipartIdentifierListContext

	// SetColumns sets the columns rule contexts.
	SetColumns(IMultipartIdentifierListContext)

	// Getter signatures
	INSERT() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	VALUES() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	MultipartIdentifierList() IMultipartIdentifierListContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNotMatchedActionContext differentiates from other interfaces.
	IsNotMatchedActionContext()
}

type NotMatchedActionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	columns IMultipartIdentifierListContext
}

func NewEmptyNotMatchedActionContext() *NotMatchedActionContext {
	var p = new(NotMatchedActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedAction
	return p
}

func InitEmptyNotMatchedActionContext(p *NotMatchedActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedAction
}

func (*NotMatchedActionContext) IsNotMatchedActionContext() {}

func NewNotMatchedActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotMatchedActionContext {
	var p = new(NotMatchedActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_notMatchedAction

	return p
}

func (s *NotMatchedActionContext) GetParser() antlr.Parser { return s.parser }

func (s *NotMatchedActionContext) GetColumns() IMultipartIdentifierListContext { return s.columns }

func (s *NotMatchedActionContext) SetColumns(v IMultipartIdentifierListContext) { s.columns = v }

func (s *NotMatchedActionContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *NotMatchedActionContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *NotMatchedActionContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *NotMatchedActionContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *NotMatchedActionContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *NotMatchedActionContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *NotMatchedActionContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *NotMatchedActionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NotMatchedActionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotMatchedActionContext) MultipartIdentifierList() IMultipartIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierListContext)
}

func (s *NotMatchedActionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *NotMatchedActionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *NotMatchedActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotMatchedActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotMatchedActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNotMatchedAction(s)
	}
}

func (s *NotMatchedActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNotMatchedAction(s)
	}
}

func (p *SqlBaseParser) NotMatchedAction() (localctx INotMatchedActionContext) {
	localctx = NewNotMatchedActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SqlBaseParserRULE_notMatchedAction)
	var _la int

	p.SetState(2808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2790)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2791)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2792)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2793)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2794)

			var _x = p.MultipartIdentifierList()

			localctx.(*NotMatchedActionContext).columns = _x
		}
		{
			p.SetState(2795)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2796)
			p.Match(SqlBaseParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2797)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2798)
			p.Expression()
		}
		p.SetState(2803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(2799)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2800)
				p.Expression()
			}

			p.SetState(2805)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2806)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotMatchedBySourceActionContext is an interface to support dynamic dispatch.
type INotMatchedBySourceActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	AssignmentList() IAssignmentListContext

	// IsNotMatchedBySourceActionContext differentiates from other interfaces.
	IsNotMatchedBySourceActionContext()
}

type NotMatchedBySourceActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotMatchedBySourceActionContext() *NotMatchedBySourceActionContext {
	var p = new(NotMatchedBySourceActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedBySourceAction
	return p
}

func InitEmptyNotMatchedBySourceActionContext(p *NotMatchedBySourceActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_notMatchedBySourceAction
}

func (*NotMatchedBySourceActionContext) IsNotMatchedBySourceActionContext() {}

func NewNotMatchedBySourceActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotMatchedBySourceActionContext {
	var p = new(NotMatchedBySourceActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_notMatchedBySourceAction

	return p
}

func (s *NotMatchedBySourceActionContext) GetParser() antlr.Parser { return s.parser }

func (s *NotMatchedBySourceActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *NotMatchedBySourceActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *NotMatchedBySourceActionContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *NotMatchedBySourceActionContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *NotMatchedBySourceActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotMatchedBySourceActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotMatchedBySourceActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNotMatchedBySourceAction(s)
	}
}

func (s *NotMatchedBySourceActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNotMatchedBySourceAction(s)
	}
}

func (p *SqlBaseParser) NotMatchedBySourceAction() (localctx INotMatchedBySourceActionContext) {
	localctx = NewNotMatchedBySourceActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SqlBaseParserRULE_notMatchedBySourceAction)
	p.SetState(2814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserDELETE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2810)
			p.Match(SqlBaseParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserUPDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2811)
			p.Match(SqlBaseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2812)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2813)
			p.AssignmentList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptClauseContext is an interface to support dynamic dispatch.
type IExceptClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExceptCols returns the exceptCols rule contexts.
	GetExceptCols() IMultipartIdentifierListContext

	// SetExceptCols sets the exceptCols rule contexts.
	SetExceptCols(IMultipartIdentifierListContext)

	// Getter signatures
	EXCEPT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	MultipartIdentifierList() IMultipartIdentifierListContext

	// IsExceptClauseContext differentiates from other interfaces.
	IsExceptClauseContext()
}

type ExceptClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	exceptCols IMultipartIdentifierListContext
}

func NewEmptyExceptClauseContext() *ExceptClauseContext {
	var p = new(ExceptClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_exceptClause
	return p
}

func InitEmptyExceptClauseContext(p *ExceptClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_exceptClause
}

func (*ExceptClauseContext) IsExceptClauseContext() {}

func NewExceptClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptClauseContext {
	var p = new(ExceptClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_exceptClause

	return p
}

func (s *ExceptClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptClauseContext) GetExceptCols() IMultipartIdentifierListContext { return s.exceptCols }

func (s *ExceptClauseContext) SetExceptCols(v IMultipartIdentifierListContext) { s.exceptCols = v }

func (s *ExceptClauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCEPT, 0)
}

func (s *ExceptClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ExceptClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ExceptClauseContext) MultipartIdentifierList() IMultipartIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierListContext)
}

func (s *ExceptClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExceptClause(s)
	}
}

func (s *ExceptClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExceptClause(s)
	}
}

func (p *SqlBaseParser) ExceptClause() (localctx IExceptClauseContext) {
	localctx = NewExceptClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SqlBaseParserRULE_exceptClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2816)
		p.Match(SqlBaseParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2817)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2818)

		var _x = p.MultipartIdentifierList()

		localctx.(*ExceptClauseContext).exceptCols = _x
	}
	{
		p.SetState(2819)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *AssignmentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *SqlBaseParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SqlBaseParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2821)
		p.Assignment()
	}
	p.SetState(2826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(2822)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2823)
			p.Assignment()
		}

		p.SetState(2828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IMultipartIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetKey sets the key rule contexts.
	SetKey(IMultipartIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	Expression() IExpressionContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IMultipartIdentifierContext
	value  IExpressionContext
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) GetKey() IMultipartIdentifierContext { return s.key }

func (s *AssignmentContext) GetValue() IExpressionContext { return s.value }

func (s *AssignmentContext) SetKey(v IMultipartIdentifierContext) { s.key = v }

func (s *AssignmentContext) SetValue(v IExpressionContext) { s.value = v }

func (s *AssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *AssignmentContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *SqlBaseParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SqlBaseParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2829)

		var _x = p.MultipartIdentifier()

		localctx.(*AssignmentContext).key = _x
	}
	{
		p.SetState(2830)
		p.Match(SqlBaseParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2831)

		var _x = p.Expression()

		localctx.(*AssignmentContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *WhereClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *SqlBaseParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SqlBaseParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2833)
		p.Match(SqlBaseParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2834)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAVING, 0)
}

func (s *HavingClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *SqlBaseParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SqlBaseParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2836)
		p.Match(SqlBaseParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2837)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintContext is an interface to support dynamic dispatch.
type IHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hintStatement returns the _hintStatement rule contexts.
	Get_hintStatement() IHintStatementContext

	// Set_hintStatement sets the _hintStatement rule contexts.
	Set_hintStatement(IHintStatementContext)

	// GetHintStatements returns the hintStatements rule context list.
	GetHintStatements() []IHintStatementContext

	// SetHintStatements sets the hintStatements rule context list.
	SetHintStatements([]IHintStatementContext)

	// Getter signatures
	HENT_START() antlr.TerminalNode
	HENT_END() antlr.TerminalNode
	AllHintStatement() []IHintStatementContext
	HintStatement(i int) IHintStatementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsHintContext differentiates from other interfaces.
	IsHintContext()
}

type HintContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_hintStatement IHintStatementContext
	hintStatements []IHintStatementContext
}

func NewEmptyHintContext() *HintContext {
	var p = new(HintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_hint
	return p
}

func InitEmptyHintContext(p *HintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_hint
}

func (*HintContext) IsHintContext() {}

func NewHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintContext {
	var p = new(HintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_hint

	return p
}

func (s *HintContext) GetParser() antlr.Parser { return s.parser }

func (s *HintContext) Get_hintStatement() IHintStatementContext { return s._hintStatement }

func (s *HintContext) Set_hintStatement(v IHintStatementContext) { s._hintStatement = v }

func (s *HintContext) GetHintStatements() []IHintStatementContext { return s.hintStatements }

func (s *HintContext) SetHintStatements(v []IHintStatementContext) { s.hintStatements = v }

func (s *HintContext) HENT_START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHENT_START, 0)
}

func (s *HintContext) HENT_END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHENT_END, 0)
}

func (s *HintContext) AllHintStatement() []IHintStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintStatementContext); ok {
			len++
		}
	}

	tst := make([]IHintStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintStatementContext); ok {
			tst[i] = t.(IHintStatementContext)
			i++
		}
	}

	return tst
}

func (s *HintContext) HintStatement(i int) IHintStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintStatementContext)
}

func (s *HintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *HintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *HintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterHint(s)
	}
}

func (s *HintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitHint(s)
	}
}

func (p *SqlBaseParser) Hint() (localctx IHintContext) {
	localctx = NewHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SqlBaseParserRULE_hint)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2839)
		p.Match(SqlBaseParserHENT_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2840)

		var _x = p.HintStatement()

		localctx.(*HintContext)._hintStatement = _x
	}
	localctx.(*HintContext).hintStatements = append(localctx.(*HintContext).hintStatements, localctx.(*HintContext)._hintStatement)
	p.SetState(2847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2842)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2841)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2844)

				var _x = p.HintStatement()

				localctx.(*HintContext)._hintStatement = _x
			}
			localctx.(*HintContext).hintStatements = append(localctx.(*HintContext).hintStatements, localctx.(*HintContext)._hintStatement)

		}
		p.SetState(2849)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2850)
		p.Match(SqlBaseParserHENT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintStatementContext is an interface to support dynamic dispatch.
type IHintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHintName returns the hintName rule contexts.
	GetHintName() IIdentifierContext

	// Get_primaryExpression returns the _primaryExpression rule contexts.
	Get_primaryExpression() IPrimaryExpressionContext

	// SetHintName sets the hintName rule contexts.
	SetHintName(IIdentifierContext)

	// Set_primaryExpression sets the _primaryExpression rule contexts.
	Set_primaryExpression(IPrimaryExpressionContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IPrimaryExpressionContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IPrimaryExpressionContext)

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsHintStatementContext differentiates from other interfaces.
	IsHintStatementContext()
}

type HintStatementContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	hintName           IIdentifierContext
	_primaryExpression IPrimaryExpressionContext
	parameters         []IPrimaryExpressionContext
}

func NewEmptyHintStatementContext() *HintStatementContext {
	var p = new(HintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_hintStatement
	return p
}

func InitEmptyHintStatementContext(p *HintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_hintStatement
}

func (*HintStatementContext) IsHintStatementContext() {}

func NewHintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintStatementContext {
	var p = new(HintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_hintStatement

	return p
}

func (s *HintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HintStatementContext) GetHintName() IIdentifierContext { return s.hintName }

func (s *HintStatementContext) Get_primaryExpression() IPrimaryExpressionContext {
	return s._primaryExpression
}

func (s *HintStatementContext) SetHintName(v IIdentifierContext) { s.hintName = v }

func (s *HintStatementContext) Set_primaryExpression(v IPrimaryExpressionContext) {
	s._primaryExpression = v
}

func (s *HintStatementContext) GetParameters() []IPrimaryExpressionContext { return s.parameters }

func (s *HintStatementContext) SetParameters(v []IPrimaryExpressionContext) { s.parameters = v }

func (s *HintStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *HintStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *HintStatementContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *HintStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *HintStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *HintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterHintStatement(s)
	}
}

func (s *HintStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitHintStatement(s)
	}
}

func (p *SqlBaseParser) HintStatement() (localctx IHintStatementContext) {
	localctx = NewHintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SqlBaseParserRULE_hintStatement)
	var _la int

	p.SetState(2865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2852)

			var _x = p.Identifier()

			localctx.(*HintStatementContext).hintName = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2853)

			var _x = p.Identifier()

			localctx.(*HintStatementContext).hintName = _x
		}
		{
			p.SetState(2854)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2855)

			var _x = p.primaryExpression(0)

			localctx.(*HintStatementContext)._primaryExpression = _x
		}
		localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._primaryExpression)
		p.SetState(2860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(2856)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2857)

				var _x = p.primaryExpression(0)

				localctx.(*HintStatementContext)._primaryExpression = _x
			}
			localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._primaryExpression)

			p.SetState(2862)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2863)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllLateralView() []ILateralViewContext
	LateralView(i int) ILateralViewContext
	PivotClause() IPivotClauseContext
	UnpivotClause() IUnpivotClauseContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *FromClauseContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *FromClauseContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *FromClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *FromClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *FromClauseContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *FromClauseContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *FromClauseContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *FromClauseContext) UnpivotClause() IUnpivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotClauseContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *SqlBaseParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SqlBaseParserRULE_fromClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2867)
		p.Match(SqlBaseParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2868)
		p.Relation()
	}
	p.SetState(2873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2869)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2870)
				p.Relation()
			}

		}
		p.SetState(2875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2876)
				p.LateralView()
			}

		}
		p.SetState(2881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2883)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2882)
			p.PivotClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2886)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2885)
			p.UnpivotClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalClauseContext is an interface to support dynamic dispatch.
type ITemporalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimestamp returns the timestamp rule contexts.
	GetTimestamp() IValueExpressionContext

	// SetTimestamp sets the timestamp rule contexts.
	SetTimestamp(IValueExpressionContext)

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	Version() IVersionContext
	SYSTEM_VERSION() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsTemporalClauseContext differentiates from other interfaces.
	IsTemporalClauseContext()
}

type TemporalClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	timestamp IValueExpressionContext
}

func NewEmptyTemporalClauseContext() *TemporalClauseContext {
	var p = new(TemporalClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_temporalClause
	return p
}

func InitEmptyTemporalClauseContext(p *TemporalClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_temporalClause
}

func (*TemporalClauseContext) IsTemporalClauseContext() {}

func NewTemporalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalClauseContext {
	var p = new(TemporalClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_temporalClause

	return p
}

func (s *TemporalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalClauseContext) GetTimestamp() IValueExpressionContext { return s.timestamp }

func (s *TemporalClauseContext) SetTimestamp(v IValueExpressionContext) { s.timestamp = v }

func (s *TemporalClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *TemporalClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOF, 0)
}

func (s *TemporalClauseContext) Version() IVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *TemporalClauseContext) SYSTEM_VERSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM_VERSION, 0)
}

func (s *TemporalClauseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERSION, 0)
}

func (s *TemporalClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *TemporalClauseContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM_TIME, 0)
}

func (s *TemporalClauseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *TemporalClauseContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TemporalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTemporalClause(s)
	}
}

func (s *TemporalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTemporalClause(s)
	}
}

func (p *SqlBaseParser) TemporalClause() (localctx ITemporalClauseContext) {
	localctx = NewTemporalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SqlBaseParserRULE_temporalClause)
	var _la int

	p.SetState(2902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(2888)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2891)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSYSTEM_VERSION || _la == SqlBaseParserVERSION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2892)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2893)
			p.Match(SqlBaseParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2894)
			p.Version()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(2895)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2898)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSYSTEM_TIME || _la == SqlBaseParserTIMESTAMP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2899)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2900)
			p.Match(SqlBaseParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2901)

			var _x = p.valueExpression(0)

			localctx.(*TemporalClauseContext).timestamp = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationClauseContext is an interface to support dynamic dispatch.
type IAggregationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// Get_groupByClause returns the _groupByClause rule contexts.
	Get_groupByClause() IGroupByClauseContext

	// Get_namedExpression returns the _namedExpression rule contexts.
	Get_namedExpression() INamedExpressionContext

	// Set_groupByClause sets the _groupByClause rule contexts.
	Set_groupByClause(IGroupByClauseContext)

	// Set_namedExpression sets the _namedExpression rule contexts.
	Set_namedExpression(INamedExpressionContext)

	// GetGroupingExpressionsWithGroupingAnalytics returns the groupingExpressionsWithGroupingAnalytics rule context list.
	GetGroupingExpressionsWithGroupingAnalytics() []IGroupByClauseContext

	// GetGroupingExpressions returns the groupingExpressions rule context list.
	GetGroupingExpressions() []INamedExpressionContext

	// SetGroupingExpressionsWithGroupingAnalytics sets the groupingExpressionsWithGroupingAnalytics rule context list.
	SetGroupingExpressionsWithGroupingAnalytics([]IGroupByClauseContext)

	// SetGroupingExpressions sets the groupingExpressions rule context list.
	SetGroupingExpressions([]INamedExpressionContext)

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllGroupByClause() []IGroupByClauseContext
	GroupByClause(i int) IGroupByClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	WITH() antlr.TerminalNode
	SETS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllGroupingSet() []IGroupingSetContext
	GroupingSet(i int) IGroupingSetContext
	RIGHT_PAREN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	GROUPING() antlr.TerminalNode

	// IsAggregationClauseContext differentiates from other interfaces.
	IsAggregationClauseContext()
}

type AggregationClauseContext struct {
	antlr.BaseParserRuleContext
	parser                                   antlr.Parser
	_groupByClause                           IGroupByClauseContext
	groupingExpressionsWithGroupingAnalytics []IGroupByClauseContext
	_namedExpression                         INamedExpressionContext
	groupingExpressions                      []INamedExpressionContext
	kind                                     antlr.Token
}

func NewEmptyAggregationClauseContext() *AggregationClauseContext {
	var p = new(AggregationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aggregationClause
	return p
}

func InitEmptyAggregationClauseContext(p *AggregationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aggregationClause
}

func (*AggregationClauseContext) IsAggregationClauseContext() {}

func NewAggregationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationClauseContext {
	var p = new(AggregationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_aggregationClause

	return p
}

func (s *AggregationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationClauseContext) GetKind() antlr.Token { return s.kind }

func (s *AggregationClauseContext) SetKind(v antlr.Token) { s.kind = v }

func (s *AggregationClauseContext) Get_groupByClause() IGroupByClauseContext { return s._groupByClause }

func (s *AggregationClauseContext) Get_namedExpression() INamedExpressionContext {
	return s._namedExpression
}

func (s *AggregationClauseContext) Set_groupByClause(v IGroupByClauseContext) { s._groupByClause = v }

func (s *AggregationClauseContext) Set_namedExpression(v INamedExpressionContext) {
	s._namedExpression = v
}

func (s *AggregationClauseContext) GetGroupingExpressionsWithGroupingAnalytics() []IGroupByClauseContext {
	return s.groupingExpressionsWithGroupingAnalytics
}

func (s *AggregationClauseContext) GetGroupingExpressions() []INamedExpressionContext {
	return s.groupingExpressions
}

func (s *AggregationClauseContext) SetGroupingExpressionsWithGroupingAnalytics(v []IGroupByClauseContext) {
	s.groupingExpressionsWithGroupingAnalytics = v
}

func (s *AggregationClauseContext) SetGroupingExpressions(v []INamedExpressionContext) {
	s.groupingExpressions = v
}

func (s *AggregationClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *AggregationClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *AggregationClauseContext) AllGroupByClause() []IGroupByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			len++
		}
	}

	tst := make([]IGroupByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByClauseContext); ok {
			tst[i] = t.(IGroupByClauseContext)
			i++
		}
	}

	return tst
}

func (s *AggregationClauseContext) GroupByClause(i int) IGroupByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *AggregationClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *AggregationClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *AggregationClauseContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregationClauseContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *AggregationClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *AggregationClauseContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *AggregationClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *AggregationClauseContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *AggregationClauseContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *AggregationClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *AggregationClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLUP, 0)
}

func (s *AggregationClauseContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *AggregationClauseContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *AggregationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAggregationClause(s)
	}
}

func (s *AggregationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAggregationClause(s)
	}
}

func (p *SqlBaseParser) AggregationClause() (localctx IAggregationClauseContext) {
	localctx = NewAggregationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SqlBaseParserRULE_aggregationClause)
	var _la int

	var _alt int

	p.SetState(2943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2904)
			p.Match(SqlBaseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2905)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2906)

			var _x = p.GroupByClause()

			localctx.(*AggregationClauseContext)._groupByClause = _x
		}
		localctx.(*AggregationClauseContext).groupingExpressionsWithGroupingAnalytics = append(localctx.(*AggregationClauseContext).groupingExpressionsWithGroupingAnalytics, localctx.(*AggregationClauseContext)._groupByClause)
		p.SetState(2911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2907)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2908)

					var _x = p.GroupByClause()

					localctx.(*AggregationClauseContext)._groupByClause = _x
				}
				localctx.(*AggregationClauseContext).groupingExpressionsWithGroupingAnalytics = append(localctx.(*AggregationClauseContext).groupingExpressionsWithGroupingAnalytics, localctx.(*AggregationClauseContext)._groupByClause)

			}
			p.SetState(2913)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2914)
			p.Match(SqlBaseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2915)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2916)

			var _x = p.NamedExpression()

			localctx.(*AggregationClauseContext)._namedExpression = _x
		}
		localctx.(*AggregationClauseContext).groupingExpressions = append(localctx.(*AggregationClauseContext).groupingExpressions, localctx.(*AggregationClauseContext)._namedExpression)
		p.SetState(2921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2917)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2918)

					var _x = p.NamedExpression()

					localctx.(*AggregationClauseContext)._namedExpression = _x
				}
				localctx.(*AggregationClauseContext).groupingExpressions = append(localctx.(*AggregationClauseContext).groupingExpressions, localctx.(*AggregationClauseContext)._namedExpression)

			}
			p.SetState(2923)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2941)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2924)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2925)

				var _m = p.Match(SqlBaseParserROLLUP)

				localctx.(*AggregationClauseContext).kind = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2926)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2927)

				var _m = p.Match(SqlBaseParserCUBE)

				localctx.(*AggregationClauseContext).kind = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(2928)

				var _m = p.Match(SqlBaseParserGROUPING)

				localctx.(*AggregationClauseContext).kind = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2929)
				p.Match(SqlBaseParserSETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2930)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2931)
				p.GroupingSet()
			}
			p.SetState(2936)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(2932)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2933)
					p.GroupingSet()
				}

				p.SetState(2938)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2939)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GroupingAnalytics() IGroupingAnalyticsContext
	Expression() IExpressionContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GroupingAnalytics() IGroupingAnalyticsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingAnalyticsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingAnalyticsContext)
}

func (s *GroupByClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (p *SqlBaseParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SqlBaseParserRULE_groupByClause)
	p.SetState(2947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2945)
			p.GroupingAnalytics()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2946)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingAnalyticsContext is an interface to support dynamic dispatch.
type IGroupingAnalyticsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllGroupingSet() []IGroupingSetContext
	GroupingSet(i int) IGroupingSetContext
	RIGHT_PAREN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	SETS() antlr.TerminalNode
	AllGroupingElement() []IGroupingElementContext
	GroupingElement(i int) IGroupingElementContext

	// IsGroupingAnalyticsContext differentiates from other interfaces.
	IsGroupingAnalyticsContext()
}

type GroupingAnalyticsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingAnalyticsContext() *GroupingAnalyticsContext {
	var p = new(GroupingAnalyticsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingAnalytics
	return p
}

func InitEmptyGroupingAnalyticsContext(p *GroupingAnalyticsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingAnalytics
}

func (*GroupingAnalyticsContext) IsGroupingAnalyticsContext() {}

func NewGroupingAnalyticsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingAnalyticsContext {
	var p = new(GroupingAnalyticsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingAnalytics

	return p
}

func (s *GroupingAnalyticsContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingAnalyticsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *GroupingAnalyticsContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *GroupingAnalyticsContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupingAnalyticsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *GroupingAnalyticsContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLUP, 0)
}

func (s *GroupingAnalyticsContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *GroupingAnalyticsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *GroupingAnalyticsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *GroupingAnalyticsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *GroupingAnalyticsContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *GroupingAnalyticsContext) AllGroupingElement() []IGroupingElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingElementContext); ok {
			len++
		}
	}

	tst := make([]IGroupingElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingElementContext); ok {
			tst[i] = t.(IGroupingElementContext)
			i++
		}
	}

	return tst
}

func (s *GroupingAnalyticsContext) GroupingElement(i int) IGroupingElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupingAnalyticsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingAnalyticsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingAnalyticsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterGroupingAnalytics(s)
	}
}

func (s *GroupingAnalyticsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitGroupingAnalytics(s)
	}
}

func (p *SqlBaseParser) GroupingAnalytics() (localctx IGroupingAnalyticsContext) {
	localctx = NewGroupingAnalyticsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SqlBaseParserRULE_groupingAnalytics)
	var _la int

	p.SetState(2974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserCUBE, SqlBaseParserROLLUP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2949)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCUBE || _la == SqlBaseParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2950)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2951)
			p.GroupingSet()
		}
		p.SetState(2956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(2952)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2953)
				p.GroupingSet()
			}

			p.SetState(2958)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2959)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserGROUPING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2961)
			p.Match(SqlBaseParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2962)
			p.Match(SqlBaseParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2963)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2964)
			p.GroupingElement()
		}
		p.SetState(2969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(2965)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2966)
				p.GroupingElement()
			}

			p.SetState(2971)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2972)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GroupingAnalytics() IGroupingAnalyticsContext
	GroupingSet() IGroupingSetContext

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) GroupingAnalytics() IGroupingAnalyticsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingAnalyticsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingAnalyticsContext)
}

func (s *GroupingElementContext) GroupingSet() IGroupingSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterGroupingElement(s)
	}
}

func (s *GroupingElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitGroupingElement(s)
	}
}

func (p *SqlBaseParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SqlBaseParserRULE_groupingElement)
	p.SetState(2978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2976)
			p.GroupingAnalytics()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2977)
			p.GroupingSet()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *GroupingSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *GroupingSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *SqlBaseParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SqlBaseParserRULE_groupingSet)
	var _la int

	p.SetState(2993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2980)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2989)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2981)
				p.Expression()
			}
			p.SetState(2986)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(2982)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2983)
					p.Expression()
				}

				p.SetState(2988)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2991)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2992)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotClauseContext is an interface to support dynamic dispatch.
type IPivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAggregates returns the aggregates rule contexts.
	GetAggregates() INamedExpressionSeqContext

	// Get_pivotValue returns the _pivotValue rule contexts.
	Get_pivotValue() IPivotValueContext

	// SetAggregates sets the aggregates rule contexts.
	SetAggregates(INamedExpressionSeqContext)

	// Set_pivotValue sets the _pivotValue rule contexts.
	Set_pivotValue(IPivotValueContext)

	// GetPivotValues returns the pivotValues rule context list.
	GetPivotValues() []IPivotValueContext

	// SetPivotValues sets the pivotValues rule context list.
	SetPivotValues([]IPivotValueContext)

	// Getter signatures
	PIVOT() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	FOR() antlr.TerminalNode
	PivotColumn() IPivotColumnContext
	IN() antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	NamedExpressionSeq() INamedExpressionSeqContext
	AllPivotValue() []IPivotValueContext
	PivotValue(i int) IPivotValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPivotClauseContext differentiates from other interfaces.
	IsPivotClauseContext()
}

type PivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	aggregates  INamedExpressionSeqContext
	_pivotValue IPivotValueContext
	pivotValues []IPivotValueContext
}

func NewEmptyPivotClauseContext() *PivotClauseContext {
	var p = new(PivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pivotClause
	return p
}

func InitEmptyPivotClauseContext(p *PivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pivotClause
}

func (*PivotClauseContext) IsPivotClauseContext() {}

func NewPivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotClauseContext {
	var p = new(PivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_pivotClause

	return p
}

func (s *PivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotClauseContext) GetAggregates() INamedExpressionSeqContext { return s.aggregates }

func (s *PivotClauseContext) Get_pivotValue() IPivotValueContext { return s._pivotValue }

func (s *PivotClauseContext) SetAggregates(v INamedExpressionSeqContext) { s.aggregates = v }

func (s *PivotClauseContext) Set_pivotValue(v IPivotValueContext) { s._pivotValue = v }

func (s *PivotClauseContext) GetPivotValues() []IPivotValueContext { return s.pivotValues }

func (s *PivotClauseContext) SetPivotValues(v []IPivotValueContext) { s.pivotValues = v }

func (s *PivotClauseContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPIVOT, 0)
}

func (s *PivotClauseContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *PivotClauseContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *PivotClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *PivotClauseContext) PivotColumn() IPivotColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotColumnContext)
}

func (s *PivotClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *PivotClauseContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *PivotClauseContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *PivotClauseContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *PivotClauseContext) AllPivotValue() []IPivotValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotValueContext); ok {
			len++
		}
	}

	tst := make([]IPivotValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotValueContext); ok {
			tst[i] = t.(IPivotValueContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotValue(i int) IPivotValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotValueContext)
}

func (s *PivotClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *PivotClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *PivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPivotClause(s)
	}
}

func (s *PivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPivotClause(s)
	}
}

func (p *SqlBaseParser) PivotClause() (localctx IPivotClauseContext) {
	localctx = NewPivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SqlBaseParserRULE_pivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2995)
		p.Match(SqlBaseParserPIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2996)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2997)

		var _x = p.NamedExpressionSeq()

		localctx.(*PivotClauseContext).aggregates = _x
	}
	{
		p.SetState(2998)
		p.Match(SqlBaseParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2999)
		p.PivotColumn()
	}
	{
		p.SetState(3000)
		p.Match(SqlBaseParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3001)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3002)

		var _x = p.PivotValue()

		localctx.(*PivotClauseContext)._pivotValue = _x
	}
	localctx.(*PivotClauseContext).pivotValues = append(localctx.(*PivotClauseContext).pivotValues, localctx.(*PivotClauseContext)._pivotValue)
	p.SetState(3007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3003)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3004)

			var _x = p.PivotValue()

			localctx.(*PivotClauseContext)._pivotValue = _x
		}
		localctx.(*PivotClauseContext).pivotValues = append(localctx.(*PivotClauseContext).pivotValues, localctx.(*PivotClauseContext)._pivotValue)

		p.SetState(3009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3010)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3011)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotColumnContext is an interface to support dynamic dispatch.
type IPivotColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetIdentifiers returns the identifiers rule context list.
	GetIdentifiers() []IErrorCapturingIdentifierContext

	// SetIdentifiers sets the identifiers rule context list.
	SetIdentifiers([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPivotColumnContext differentiates from other interfaces.
	IsPivotColumnContext()
}

type PivotColumnContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	identifiers               []IErrorCapturingIdentifierContext
}

func NewEmptyPivotColumnContext() *PivotColumnContext {
	var p = new(PivotColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pivotColumn
	return p
}

func InitEmptyPivotColumnContext(p *PivotColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pivotColumn
}

func (*PivotColumnContext) IsPivotColumnContext() {}

func NewPivotColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotColumnContext {
	var p = new(PivotColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_pivotColumn

	return p
}

func (s *PivotColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotColumnContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *PivotColumnContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *PivotColumnContext) GetIdentifiers() []IErrorCapturingIdentifierContext {
	return s.identifiers
}

func (s *PivotColumnContext) SetIdentifiers(v []IErrorCapturingIdentifierContext) { s.identifiers = v }

func (s *PivotColumnContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PivotColumnContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *PivotColumnContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *PivotColumnContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *PivotColumnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *PivotColumnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *PivotColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPivotColumn(s)
	}
}

func (s *PivotColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPivotColumn(s)
	}
}

func (p *SqlBaseParser) PivotColumn() (localctx IPivotColumnContext) {
	localctx = NewPivotColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SqlBaseParserRULE_pivotColumn)
	var _la int

	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3013)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*PivotColumnContext)._errorCapturingIdentifier = _x
		}
		localctx.(*PivotColumnContext).identifiers = append(localctx.(*PivotColumnContext).identifiers, localctx.(*PivotColumnContext)._errorCapturingIdentifier)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3014)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3015)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*PivotColumnContext)._errorCapturingIdentifier = _x
		}
		localctx.(*PivotColumnContext).identifiers = append(localctx.(*PivotColumnContext).identifiers, localctx.(*PivotColumnContext)._errorCapturingIdentifier)
		p.SetState(3020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(3016)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3017)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*PivotColumnContext)._errorCapturingIdentifier = _x
			}
			localctx.(*PivotColumnContext).identifiers = append(localctx.(*PivotColumnContext).identifiers, localctx.(*PivotColumnContext)._errorCapturingIdentifier)

			p.SetState(3022)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3023)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotValueContext is an interface to support dynamic dispatch.
type IPivotValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	AS() antlr.TerminalNode

	// IsPivotValueContext differentiates from other interfaces.
	IsPivotValueContext()
}

type PivotValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotValueContext() *PivotValueContext {
	var p = new(PivotValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pivotValue
	return p
}

func InitEmptyPivotValueContext(p *PivotValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pivotValue
}

func (*PivotValueContext) IsPivotValueContext() {}

func NewPivotValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotValueContext {
	var p = new(PivotValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_pivotValue

	return p
}

func (s *PivotValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PivotValueContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *PivotValueContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *PivotValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPivotValue(s)
	}
}

func (s *PivotValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPivotValue(s)
	}
}

func (p *SqlBaseParser) PivotValue() (localctx IPivotValueContext) {
	localctx = NewPivotValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SqlBaseParserRULE_pivotValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		p.Expression()
	}
	p.SetState(3032)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext()) == 1 {
		p.SetState(3029)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3028)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3031)
			p.ErrorCapturingIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotClauseContext is an interface to support dynamic dispatch.
type IUnpivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullOperator returns the nullOperator rule contexts.
	GetNullOperator() IUnpivotNullClauseContext

	// GetOperator returns the operator rule contexts.
	GetOperator() IUnpivotOperatorContext

	// SetNullOperator sets the nullOperator rule contexts.
	SetNullOperator(IUnpivotNullClauseContext)

	// SetOperator sets the operator rule contexts.
	SetOperator(IUnpivotOperatorContext)

	// Getter signatures
	UNPIVOT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	UnpivotOperator() IUnpivotOperatorContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	UnpivotNullClause() IUnpivotNullClauseContext
	AS() antlr.TerminalNode

	// IsUnpivotClauseContext differentiates from other interfaces.
	IsUnpivotClauseContext()
}

type UnpivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	nullOperator IUnpivotNullClauseContext
	operator     IUnpivotOperatorContext
}

func NewEmptyUnpivotClauseContext() *UnpivotClauseContext {
	var p = new(UnpivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotClause
	return p
}

func InitEmptyUnpivotClauseContext(p *UnpivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotClause
}

func (*UnpivotClauseContext) IsUnpivotClauseContext() {}

func NewUnpivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotClauseContext {
	var p = new(UnpivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotClause

	return p
}

func (s *UnpivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotClauseContext) GetNullOperator() IUnpivotNullClauseContext { return s.nullOperator }

func (s *UnpivotClauseContext) GetOperator() IUnpivotOperatorContext { return s.operator }

func (s *UnpivotClauseContext) SetNullOperator(v IUnpivotNullClauseContext) { s.nullOperator = v }

func (s *UnpivotClauseContext) SetOperator(v IUnpivotOperatorContext) { s.operator = v }

func (s *UnpivotClauseContext) UNPIVOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNPIVOT, 0)
}

func (s *UnpivotClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *UnpivotClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *UnpivotClauseContext) UnpivotOperator() IUnpivotOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotOperatorContext)
}

func (s *UnpivotClauseContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *UnpivotClauseContext) UnpivotNullClause() IUnpivotNullClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotNullClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotNullClauseContext)
}

func (s *UnpivotClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *UnpivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotClause(s)
	}
}

func (s *UnpivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotClause(s)
	}
}

func (p *SqlBaseParser) UnpivotClause() (localctx IUnpivotClauseContext) {
	localctx = NewUnpivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SqlBaseParserRULE_unpivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3034)
		p.Match(SqlBaseParserUNPIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserEXCLUDE || _la == SqlBaseParserINCLUDE {
		{
			p.SetState(3035)

			var _x = p.UnpivotNullClause()

			localctx.(*UnpivotClauseContext).nullOperator = _x
		}

	}
	{
		p.SetState(3038)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3039)

		var _x = p.UnpivotOperator()

		localctx.(*UnpivotClauseContext).operator = _x
	}
	{
		p.SetState(3040)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3045)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) == 1 {
		p.SetState(3042)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3041)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3044)
			p.ErrorCapturingIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotNullClauseContext is an interface to support dynamic dispatch.
type IUnpivotNullClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULLS() antlr.TerminalNode
	INCLUDE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode

	// IsUnpivotNullClauseContext differentiates from other interfaces.
	IsUnpivotNullClauseContext()
}

type UnpivotNullClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotNullClauseContext() *UnpivotNullClauseContext {
	var p = new(UnpivotNullClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotNullClause
	return p
}

func InitEmptyUnpivotNullClauseContext(p *UnpivotNullClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotNullClause
}

func (*UnpivotNullClauseContext) IsUnpivotNullClauseContext() {}

func NewUnpivotNullClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotNullClauseContext {
	var p = new(UnpivotNullClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotNullClause

	return p
}

func (s *UnpivotNullClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotNullClauseContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *UnpivotNullClauseContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDE, 0)
}

func (s *UnpivotNullClauseContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDE, 0)
}

func (s *UnpivotNullClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotNullClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotNullClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotNullClause(s)
	}
}

func (s *UnpivotNullClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotNullClause(s)
	}
}

func (p *SqlBaseParser) UnpivotNullClause() (localctx IUnpivotNullClauseContext) {
	localctx = NewUnpivotNullClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SqlBaseParserRULE_unpivotNullClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3047)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserEXCLUDE || _la == SqlBaseParserINCLUDE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3048)
		p.Match(SqlBaseParserNULLS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotOperatorContext is an interface to support dynamic dispatch.
type IUnpivotOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnpivotSingleValueColumnClause() IUnpivotSingleValueColumnClauseContext
	UnpivotMultiValueColumnClause() IUnpivotMultiValueColumnClauseContext

	// IsUnpivotOperatorContext differentiates from other interfaces.
	IsUnpivotOperatorContext()
}

type UnpivotOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotOperatorContext() *UnpivotOperatorContext {
	var p = new(UnpivotOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotOperator
	return p
}

func InitEmptyUnpivotOperatorContext(p *UnpivotOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotOperator
}

func (*UnpivotOperatorContext) IsUnpivotOperatorContext() {}

func NewUnpivotOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotOperatorContext {
	var p = new(UnpivotOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotOperator

	return p
}

func (s *UnpivotOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotOperatorContext) UnpivotSingleValueColumnClause() IUnpivotSingleValueColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotSingleValueColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotSingleValueColumnClauseContext)
}

func (s *UnpivotOperatorContext) UnpivotMultiValueColumnClause() IUnpivotMultiValueColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotMultiValueColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotMultiValueColumnClauseContext)
}

func (s *UnpivotOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotOperator(s)
	}
}

func (s *UnpivotOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotOperator(s)
	}
}

func (p *SqlBaseParser) UnpivotOperator() (localctx IUnpivotOperatorContext) {
	localctx = NewUnpivotOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SqlBaseParserRULE_unpivotOperator)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3050)
			p.UnpivotSingleValueColumnClause()
		}

	case 2:
		{
			p.SetState(3051)
			p.UnpivotMultiValueColumnClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotSingleValueColumnClauseContext is an interface to support dynamic dispatch.
type IUnpivotSingleValueColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_unpivotColumnAndAlias returns the _unpivotColumnAndAlias rule contexts.
	Get_unpivotColumnAndAlias() IUnpivotColumnAndAliasContext

	// Set_unpivotColumnAndAlias sets the _unpivotColumnAndAlias rule contexts.
	Set_unpivotColumnAndAlias(IUnpivotColumnAndAliasContext)

	// GetUnpivotColumns returns the unpivotColumns rule context list.
	GetUnpivotColumns() []IUnpivotColumnAndAliasContext

	// SetUnpivotColumns sets the unpivotColumns rule context list.
	SetUnpivotColumns([]IUnpivotColumnAndAliasContext)

	// Getter signatures
	UnpivotValueColumn() IUnpivotValueColumnContext
	FOR() antlr.TerminalNode
	UnpivotNameColumn() IUnpivotNameColumnContext
	IN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllUnpivotColumnAndAlias() []IUnpivotColumnAndAliasContext
	UnpivotColumnAndAlias(i int) IUnpivotColumnAndAliasContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUnpivotSingleValueColumnClauseContext differentiates from other interfaces.
	IsUnpivotSingleValueColumnClauseContext()
}

type UnpivotSingleValueColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	_unpivotColumnAndAlias IUnpivotColumnAndAliasContext
	unpivotColumns         []IUnpivotColumnAndAliasContext
}

func NewEmptyUnpivotSingleValueColumnClauseContext() *UnpivotSingleValueColumnClauseContext {
	var p = new(UnpivotSingleValueColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotSingleValueColumnClause
	return p
}

func InitEmptyUnpivotSingleValueColumnClauseContext(p *UnpivotSingleValueColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotSingleValueColumnClause
}

func (*UnpivotSingleValueColumnClauseContext) IsUnpivotSingleValueColumnClauseContext() {}

func NewUnpivotSingleValueColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotSingleValueColumnClauseContext {
	var p = new(UnpivotSingleValueColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotSingleValueColumnClause

	return p
}

func (s *UnpivotSingleValueColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotSingleValueColumnClauseContext) Get_unpivotColumnAndAlias() IUnpivotColumnAndAliasContext {
	return s._unpivotColumnAndAlias
}

func (s *UnpivotSingleValueColumnClauseContext) Set_unpivotColumnAndAlias(v IUnpivotColumnAndAliasContext) {
	s._unpivotColumnAndAlias = v
}

func (s *UnpivotSingleValueColumnClauseContext) GetUnpivotColumns() []IUnpivotColumnAndAliasContext {
	return s.unpivotColumns
}

func (s *UnpivotSingleValueColumnClauseContext) SetUnpivotColumns(v []IUnpivotColumnAndAliasContext) {
	s.unpivotColumns = v
}

func (s *UnpivotSingleValueColumnClauseContext) UnpivotValueColumn() IUnpivotValueColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotValueColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotValueColumnContext)
}

func (s *UnpivotSingleValueColumnClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *UnpivotSingleValueColumnClauseContext) UnpivotNameColumn() IUnpivotNameColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotNameColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotNameColumnContext)
}

func (s *UnpivotSingleValueColumnClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *UnpivotSingleValueColumnClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *UnpivotSingleValueColumnClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *UnpivotSingleValueColumnClauseContext) AllUnpivotColumnAndAlias() []IUnpivotColumnAndAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnpivotColumnAndAliasContext); ok {
			len++
		}
	}

	tst := make([]IUnpivotColumnAndAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnpivotColumnAndAliasContext); ok {
			tst[i] = t.(IUnpivotColumnAndAliasContext)
			i++
		}
	}

	return tst
}

func (s *UnpivotSingleValueColumnClauseContext) UnpivotColumnAndAlias(i int) IUnpivotColumnAndAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAndAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAndAliasContext)
}

func (s *UnpivotSingleValueColumnClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *UnpivotSingleValueColumnClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *UnpivotSingleValueColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotSingleValueColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotSingleValueColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotSingleValueColumnClause(s)
	}
}

func (s *UnpivotSingleValueColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotSingleValueColumnClause(s)
	}
}

func (p *SqlBaseParser) UnpivotSingleValueColumnClause() (localctx IUnpivotSingleValueColumnClauseContext) {
	localctx = NewUnpivotSingleValueColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SqlBaseParserRULE_unpivotSingleValueColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3054)
		p.UnpivotValueColumn()
	}
	{
		p.SetState(3055)
		p.Match(SqlBaseParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3056)
		p.UnpivotNameColumn()
	}
	{
		p.SetState(3057)
		p.Match(SqlBaseParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3058)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3059)

		var _x = p.UnpivotColumnAndAlias()

		localctx.(*UnpivotSingleValueColumnClauseContext)._unpivotColumnAndAlias = _x
	}
	localctx.(*UnpivotSingleValueColumnClauseContext).unpivotColumns = append(localctx.(*UnpivotSingleValueColumnClauseContext).unpivotColumns, localctx.(*UnpivotSingleValueColumnClauseContext)._unpivotColumnAndAlias)
	p.SetState(3064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3060)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3061)

			var _x = p.UnpivotColumnAndAlias()

			localctx.(*UnpivotSingleValueColumnClauseContext)._unpivotColumnAndAlias = _x
		}
		localctx.(*UnpivotSingleValueColumnClauseContext).unpivotColumns = append(localctx.(*UnpivotSingleValueColumnClauseContext).unpivotColumns, localctx.(*UnpivotSingleValueColumnClauseContext)._unpivotColumnAndAlias)

		p.SetState(3066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3067)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotMultiValueColumnClauseContext is an interface to support dynamic dispatch.
type IUnpivotMultiValueColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_unpivotValueColumn returns the _unpivotValueColumn rule contexts.
	Get_unpivotValueColumn() IUnpivotValueColumnContext

	// Get_unpivotColumnSet returns the _unpivotColumnSet rule contexts.
	Get_unpivotColumnSet() IUnpivotColumnSetContext

	// Set_unpivotValueColumn sets the _unpivotValueColumn rule contexts.
	Set_unpivotValueColumn(IUnpivotValueColumnContext)

	// Set_unpivotColumnSet sets the _unpivotColumnSet rule contexts.
	Set_unpivotColumnSet(IUnpivotColumnSetContext)

	// GetUnpivotValueColumns returns the unpivotValueColumns rule context list.
	GetUnpivotValueColumns() []IUnpivotValueColumnContext

	// GetUnpivotColumnSets returns the unpivotColumnSets rule context list.
	GetUnpivotColumnSets() []IUnpivotColumnSetContext

	// SetUnpivotValueColumns sets the unpivotValueColumns rule context list.
	SetUnpivotValueColumns([]IUnpivotValueColumnContext)

	// SetUnpivotColumnSets sets the unpivotColumnSets rule context list.
	SetUnpivotColumnSets([]IUnpivotColumnSetContext)

	// Getter signatures
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	FOR() antlr.TerminalNode
	UnpivotNameColumn() IUnpivotNameColumnContext
	IN() antlr.TerminalNode
	AllUnpivotValueColumn() []IUnpivotValueColumnContext
	UnpivotValueColumn(i int) IUnpivotValueColumnContext
	AllUnpivotColumnSet() []IUnpivotColumnSetContext
	UnpivotColumnSet(i int) IUnpivotColumnSetContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUnpivotMultiValueColumnClauseContext differentiates from other interfaces.
	IsUnpivotMultiValueColumnClauseContext()
}

type UnpivotMultiValueColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	_unpivotValueColumn IUnpivotValueColumnContext
	unpivotValueColumns []IUnpivotValueColumnContext
	_unpivotColumnSet   IUnpivotColumnSetContext
	unpivotColumnSets   []IUnpivotColumnSetContext
}

func NewEmptyUnpivotMultiValueColumnClauseContext() *UnpivotMultiValueColumnClauseContext {
	var p = new(UnpivotMultiValueColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotMultiValueColumnClause
	return p
}

func InitEmptyUnpivotMultiValueColumnClauseContext(p *UnpivotMultiValueColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotMultiValueColumnClause
}

func (*UnpivotMultiValueColumnClauseContext) IsUnpivotMultiValueColumnClauseContext() {}

func NewUnpivotMultiValueColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotMultiValueColumnClauseContext {
	var p = new(UnpivotMultiValueColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotMultiValueColumnClause

	return p
}

func (s *UnpivotMultiValueColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotMultiValueColumnClauseContext) Get_unpivotValueColumn() IUnpivotValueColumnContext {
	return s._unpivotValueColumn
}

func (s *UnpivotMultiValueColumnClauseContext) Get_unpivotColumnSet() IUnpivotColumnSetContext {
	return s._unpivotColumnSet
}

func (s *UnpivotMultiValueColumnClauseContext) Set_unpivotValueColumn(v IUnpivotValueColumnContext) {
	s._unpivotValueColumn = v
}

func (s *UnpivotMultiValueColumnClauseContext) Set_unpivotColumnSet(v IUnpivotColumnSetContext) {
	s._unpivotColumnSet = v
}

func (s *UnpivotMultiValueColumnClauseContext) GetUnpivotValueColumns() []IUnpivotValueColumnContext {
	return s.unpivotValueColumns
}

func (s *UnpivotMultiValueColumnClauseContext) GetUnpivotColumnSets() []IUnpivotColumnSetContext {
	return s.unpivotColumnSets
}

func (s *UnpivotMultiValueColumnClauseContext) SetUnpivotValueColumns(v []IUnpivotValueColumnContext) {
	s.unpivotValueColumns = v
}

func (s *UnpivotMultiValueColumnClauseContext) SetUnpivotColumnSets(v []IUnpivotColumnSetContext) {
	s.unpivotColumnSets = v
}

func (s *UnpivotMultiValueColumnClauseContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *UnpivotMultiValueColumnClauseContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *UnpivotMultiValueColumnClauseContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *UnpivotMultiValueColumnClauseContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *UnpivotMultiValueColumnClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *UnpivotMultiValueColumnClauseContext) UnpivotNameColumn() IUnpivotNameColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotNameColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotNameColumnContext)
}

func (s *UnpivotMultiValueColumnClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *UnpivotMultiValueColumnClauseContext) AllUnpivotValueColumn() []IUnpivotValueColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnpivotValueColumnContext); ok {
			len++
		}
	}

	tst := make([]IUnpivotValueColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnpivotValueColumnContext); ok {
			tst[i] = t.(IUnpivotValueColumnContext)
			i++
		}
	}

	return tst
}

func (s *UnpivotMultiValueColumnClauseContext) UnpivotValueColumn(i int) IUnpivotValueColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotValueColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotValueColumnContext)
}

func (s *UnpivotMultiValueColumnClauseContext) AllUnpivotColumnSet() []IUnpivotColumnSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnpivotColumnSetContext); ok {
			len++
		}
	}

	tst := make([]IUnpivotColumnSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnpivotColumnSetContext); ok {
			tst[i] = t.(IUnpivotColumnSetContext)
			i++
		}
	}

	return tst
}

func (s *UnpivotMultiValueColumnClauseContext) UnpivotColumnSet(i int) IUnpivotColumnSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnSetContext)
}

func (s *UnpivotMultiValueColumnClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *UnpivotMultiValueColumnClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *UnpivotMultiValueColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotMultiValueColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotMultiValueColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotMultiValueColumnClause(s)
	}
}

func (s *UnpivotMultiValueColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotMultiValueColumnClause(s)
	}
}

func (p *SqlBaseParser) UnpivotMultiValueColumnClause() (localctx IUnpivotMultiValueColumnClauseContext) {
	localctx = NewUnpivotMultiValueColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SqlBaseParserRULE_unpivotMultiValueColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3069)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3070)

		var _x = p.UnpivotValueColumn()

		localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotValueColumn = _x
	}
	localctx.(*UnpivotMultiValueColumnClauseContext).unpivotValueColumns = append(localctx.(*UnpivotMultiValueColumnClauseContext).unpivotValueColumns, localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotValueColumn)
	p.SetState(3075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3071)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3072)

			var _x = p.UnpivotValueColumn()

			localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotValueColumn = _x
		}
		localctx.(*UnpivotMultiValueColumnClauseContext).unpivotValueColumns = append(localctx.(*UnpivotMultiValueColumnClauseContext).unpivotValueColumns, localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotValueColumn)

		p.SetState(3077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3078)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3079)
		p.Match(SqlBaseParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3080)
		p.UnpivotNameColumn()
	}
	{
		p.SetState(3081)
		p.Match(SqlBaseParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3082)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3083)

		var _x = p.UnpivotColumnSet()

		localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotColumnSet = _x
	}
	localctx.(*UnpivotMultiValueColumnClauseContext).unpivotColumnSets = append(localctx.(*UnpivotMultiValueColumnClauseContext).unpivotColumnSets, localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotColumnSet)
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3084)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3085)

			var _x = p.UnpivotColumnSet()

			localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotColumnSet = _x
		}
		localctx.(*UnpivotMultiValueColumnClauseContext).unpivotColumnSets = append(localctx.(*UnpivotMultiValueColumnClauseContext).unpivotColumnSets, localctx.(*UnpivotMultiValueColumnClauseContext)._unpivotColumnSet)

		p.SetState(3090)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3091)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnSetContext is an interface to support dynamic dispatch.
type IUnpivotColumnSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_unpivotColumn returns the _unpivotColumn rule contexts.
	Get_unpivotColumn() IUnpivotColumnContext

	// Set_unpivotColumn sets the _unpivotColumn rule contexts.
	Set_unpivotColumn(IUnpivotColumnContext)

	// GetUnpivotColumns returns the unpivotColumns rule context list.
	GetUnpivotColumns() []IUnpivotColumnContext

	// SetUnpivotColumns sets the unpivotColumns rule context list.
	SetUnpivotColumns([]IUnpivotColumnContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllUnpivotColumn() []IUnpivotColumnContext
	UnpivotColumn(i int) IUnpivotColumnContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	UnpivotAlias() IUnpivotAliasContext

	// IsUnpivotColumnSetContext differentiates from other interfaces.
	IsUnpivotColumnSetContext()
}

type UnpivotColumnSetContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_unpivotColumn IUnpivotColumnContext
	unpivotColumns []IUnpivotColumnContext
}

func NewEmptyUnpivotColumnSetContext() *UnpivotColumnSetContext {
	var p = new(UnpivotColumnSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotColumnSet
	return p
}

func InitEmptyUnpivotColumnSetContext(p *UnpivotColumnSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotColumnSet
}

func (*UnpivotColumnSetContext) IsUnpivotColumnSetContext() {}

func NewUnpivotColumnSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnSetContext {
	var p = new(UnpivotColumnSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotColumnSet

	return p
}

func (s *UnpivotColumnSetContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnSetContext) Get_unpivotColumn() IUnpivotColumnContext { return s._unpivotColumn }

func (s *UnpivotColumnSetContext) Set_unpivotColumn(v IUnpivotColumnContext) { s._unpivotColumn = v }

func (s *UnpivotColumnSetContext) GetUnpivotColumns() []IUnpivotColumnContext {
	return s.unpivotColumns
}

func (s *UnpivotColumnSetContext) SetUnpivotColumns(v []IUnpivotColumnContext) { s.unpivotColumns = v }

func (s *UnpivotColumnSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *UnpivotColumnSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *UnpivotColumnSetContext) AllUnpivotColumn() []IUnpivotColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnpivotColumnContext); ok {
			len++
		}
	}

	tst := make([]IUnpivotColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnpivotColumnContext); ok {
			tst[i] = t.(IUnpivotColumnContext)
			i++
		}
	}

	return tst
}

func (s *UnpivotColumnSetContext) UnpivotColumn(i int) IUnpivotColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnContext)
}

func (s *UnpivotColumnSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *UnpivotColumnSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *UnpivotColumnSetContext) UnpivotAlias() IUnpivotAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotAliasContext)
}

func (s *UnpivotColumnSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotColumnSet(s)
	}
}

func (s *UnpivotColumnSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotColumnSet(s)
	}
}

func (p *SqlBaseParser) UnpivotColumnSet() (localctx IUnpivotColumnSetContext) {
	localctx = NewUnpivotColumnSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SqlBaseParserRULE_unpivotColumnSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3093)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3094)

		var _x = p.UnpivotColumn()

		localctx.(*UnpivotColumnSetContext)._unpivotColumn = _x
	}
	localctx.(*UnpivotColumnSetContext).unpivotColumns = append(localctx.(*UnpivotColumnSetContext).unpivotColumns, localctx.(*UnpivotColumnSetContext)._unpivotColumn)
	p.SetState(3099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3095)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3096)

			var _x = p.UnpivotColumn()

			localctx.(*UnpivotColumnSetContext)._unpivotColumn = _x
		}
		localctx.(*UnpivotColumnSetContext).unpivotColumns = append(localctx.(*UnpivotColumnSetContext).unpivotColumns, localctx.(*UnpivotColumnSetContext)._unpivotColumn)

		p.SetState(3101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3102)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3104)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3103)
			p.UnpivotAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotValueColumnContext is an interface to support dynamic dispatch.
type IUnpivotValueColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsUnpivotValueColumnContext differentiates from other interfaces.
	IsUnpivotValueColumnContext()
}

type UnpivotValueColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotValueColumnContext() *UnpivotValueColumnContext {
	var p = new(UnpivotValueColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotValueColumn
	return p
}

func InitEmptyUnpivotValueColumnContext(p *UnpivotValueColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotValueColumn
}

func (*UnpivotValueColumnContext) IsUnpivotValueColumnContext() {}

func NewUnpivotValueColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotValueColumnContext {
	var p = new(UnpivotValueColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotValueColumn

	return p
}

func (s *UnpivotValueColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotValueColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnpivotValueColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotValueColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotValueColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotValueColumn(s)
	}
}

func (s *UnpivotValueColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotValueColumn(s)
	}
}

func (p *SqlBaseParser) UnpivotValueColumn() (localctx IUnpivotValueColumnContext) {
	localctx = NewUnpivotValueColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SqlBaseParserRULE_unpivotValueColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3106)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotNameColumnContext is an interface to support dynamic dispatch.
type IUnpivotNameColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsUnpivotNameColumnContext differentiates from other interfaces.
	IsUnpivotNameColumnContext()
}

type UnpivotNameColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotNameColumnContext() *UnpivotNameColumnContext {
	var p = new(UnpivotNameColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotNameColumn
	return p
}

func InitEmptyUnpivotNameColumnContext(p *UnpivotNameColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotNameColumn
}

func (*UnpivotNameColumnContext) IsUnpivotNameColumnContext() {}

func NewUnpivotNameColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotNameColumnContext {
	var p = new(UnpivotNameColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotNameColumn

	return p
}

func (s *UnpivotNameColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotNameColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnpivotNameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotNameColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotNameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotNameColumn(s)
	}
}

func (s *UnpivotNameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotNameColumn(s)
	}
}

func (p *SqlBaseParser) UnpivotNameColumn() (localctx IUnpivotNameColumnContext) {
	localctx = NewUnpivotNameColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SqlBaseParserRULE_unpivotNameColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3108)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnAndAliasContext is an interface to support dynamic dispatch.
type IUnpivotColumnAndAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnpivotColumn() IUnpivotColumnContext
	UnpivotAlias() IUnpivotAliasContext

	// IsUnpivotColumnAndAliasContext differentiates from other interfaces.
	IsUnpivotColumnAndAliasContext()
}

type UnpivotColumnAndAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotColumnAndAliasContext() *UnpivotColumnAndAliasContext {
	var p = new(UnpivotColumnAndAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotColumnAndAlias
	return p
}

func InitEmptyUnpivotColumnAndAliasContext(p *UnpivotColumnAndAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotColumnAndAlias
}

func (*UnpivotColumnAndAliasContext) IsUnpivotColumnAndAliasContext() {}

func NewUnpivotColumnAndAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnAndAliasContext {
	var p = new(UnpivotColumnAndAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotColumnAndAlias

	return p
}

func (s *UnpivotColumnAndAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnAndAliasContext) UnpivotColumn() IUnpivotColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnContext)
}

func (s *UnpivotColumnAndAliasContext) UnpivotAlias() IUnpivotAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotAliasContext)
}

func (s *UnpivotColumnAndAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnAndAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnAndAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotColumnAndAlias(s)
	}
}

func (s *UnpivotColumnAndAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotColumnAndAlias(s)
	}
}

func (p *SqlBaseParser) UnpivotColumnAndAlias() (localctx IUnpivotColumnAndAliasContext) {
	localctx = NewUnpivotColumnAndAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SqlBaseParserRULE_unpivotColumnAndAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3110)
		p.UnpivotColumn()
	}
	p.SetState(3112)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3111)
			p.UnpivotAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnContext is an interface to support dynamic dispatch.
type IUnpivotColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext

	// IsUnpivotColumnContext differentiates from other interfaces.
	IsUnpivotColumnContext()
}

type UnpivotColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotColumnContext() *UnpivotColumnContext {
	var p = new(UnpivotColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotColumn
	return p
}

func InitEmptyUnpivotColumnContext(p *UnpivotColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotColumn
}

func (*UnpivotColumnContext) IsUnpivotColumnContext() {}

func NewUnpivotColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnContext {
	var p = new(UnpivotColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotColumn

	return p
}

func (s *UnpivotColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UnpivotColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotColumn(s)
	}
}

func (s *UnpivotColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotColumn(s)
	}
}

func (p *SqlBaseParser) UnpivotColumn() (localctx IUnpivotColumnContext) {
	localctx = NewUnpivotColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SqlBaseParserRULE_unpivotColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3114)
		p.MultipartIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotAliasContext is an interface to support dynamic dispatch.
type IUnpivotAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	AS() antlr.TerminalNode

	// IsUnpivotAliasContext differentiates from other interfaces.
	IsUnpivotAliasContext()
}

type UnpivotAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotAliasContext() *UnpivotAliasContext {
	var p = new(UnpivotAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotAlias
	return p
}

func InitEmptyUnpivotAliasContext(p *UnpivotAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unpivotAlias
}

func (*UnpivotAliasContext) IsUnpivotAliasContext() {}

func NewUnpivotAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotAliasContext {
	var p = new(UnpivotAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unpivotAlias

	return p
}

func (s *UnpivotAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotAliasContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *UnpivotAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *UnpivotAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnpivotAlias(s)
	}
}

func (s *UnpivotAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnpivotAlias(s)
	}
}

func (p *SqlBaseParser) UnpivotAlias() (localctx IUnpivotAliasContext) {
	localctx = NewUnpivotAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SqlBaseParserRULE_unpivotAlias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3117)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3116)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3119)
		p.ErrorCapturingIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralViewContext is an interface to support dynamic dispatch.
type ILateralViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTblName returns the tblName rule contexts.
	GetTblName() IIdentifierContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// SetTblName sets the tblName rule contexts.
	SetTblName(IIdentifierContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetColName returns the colName rule context list.
	GetColName() []IIdentifierContext

	// SetColName sets the colName rule context list.
	SetColName([]IIdentifierContext)

	// Getter signatures
	LATERAL() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	OUTER() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsLateralViewContext differentiates from other interfaces.
	IsLateralViewContext()
}

type LateralViewContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	tblName     IIdentifierContext
	_identifier IIdentifierContext
	colName     []IIdentifierContext
}

func NewEmptyLateralViewContext() *LateralViewContext {
	var p = new(LateralViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_lateralView
	return p
}

func InitEmptyLateralViewContext(p *LateralViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_lateralView
}

func (*LateralViewContext) IsLateralViewContext() {}

func NewLateralViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralViewContext {
	var p = new(LateralViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_lateralView

	return p
}

func (s *LateralViewContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralViewContext) GetTblName() IIdentifierContext { return s.tblName }

func (s *LateralViewContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *LateralViewContext) SetTblName(v IIdentifierContext) { s.tblName = v }

func (s *LateralViewContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *LateralViewContext) GetColName() []IIdentifierContext { return s.colName }

func (s *LateralViewContext) SetColName(v []IIdentifierContext) { s.colName = v }

func (s *LateralViewContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *LateralViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *LateralViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *LateralViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *LateralViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *LateralViewContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LateralViewContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *LateralViewContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LateralViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *LateralViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *LateralViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *LateralViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLateralView(s)
	}
}

func (s *LateralViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLateralView(s)
	}
}

func (p *SqlBaseParser) LateralView() (localctx ILateralViewContext) {
	localctx = NewLateralViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SqlBaseParserRULE_lateralView)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3121)
		p.Match(SqlBaseParserLATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3122)
		p.Match(SqlBaseParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3124)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 369, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3123)
			p.Match(SqlBaseParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3126)
		p.QualifiedName()
	}
	{
		p.SetState(3127)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3136)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 371, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3128)
			p.Expression()
		}
		p.SetState(3133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(3129)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3130)
				p.Expression()
			}

			p.SetState(3135)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3138)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3139)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).tblName = _x
	}
	p.SetState(3151)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext()) == 1 {
		p.SetState(3141)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 372, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3140)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3143)

			var _x = p.Identifier()

			localctx.(*LateralViewContext)._identifier = _x
		}
		localctx.(*LateralViewContext).colName = append(localctx.(*LateralViewContext).colName, localctx.(*LateralViewContext)._identifier)
		p.SetState(3148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 373, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3144)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3145)

					var _x = p.Identifier()

					localctx.(*LateralViewContext)._identifier = _x
				}
				localctx.(*LateralViewContext).colName = append(localctx.(*LateralViewContext).colName, localctx.(*LateralViewContext)._identifier)

			}
			p.SetState(3150)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 373, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *SqlBaseParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SqlBaseParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	LATERAL() antlr.TerminalNode
	AllRelationExtension() []IRelationExtensionContext
	RelationExtension(i int) IRelationExtensionContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *RelationContext) AllRelationExtension() []IRelationExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationExtensionContext); ok {
			len++
		}
	}

	tst := make([]IRelationExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationExtensionContext); ok {
			tst[i] = t.(IRelationExtensionContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) RelationExtension(i int) IRelationExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationExtensionContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (p *SqlBaseParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SqlBaseParserRULE_relation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3156)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3155)
			p.Match(SqlBaseParserLATERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3158)
		p.RelationPrimary()
	}
	p.SetState(3162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3159)
				p.RelationExtension()
			}

		}
		p.SetState(3164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationExtensionContext is an interface to support dynamic dispatch.
type IRelationExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JoinRelation() IJoinRelationContext
	PivotClause() IPivotClauseContext
	UnpivotClause() IUnpivotClauseContext

	// IsRelationExtensionContext differentiates from other interfaces.
	IsRelationExtensionContext()
}

type RelationExtensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationExtensionContext() *RelationExtensionContext {
	var p = new(RelationExtensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationExtension
	return p
}

func InitEmptyRelationExtensionContext(p *RelationExtensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationExtension
}

func (*RelationExtensionContext) IsRelationExtensionContext() {}

func NewRelationExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationExtensionContext {
	var p = new(RelationExtensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relationExtension

	return p
}

func (s *RelationExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationExtensionContext) JoinRelation() IJoinRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationExtensionContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *RelationExtensionContext) UnpivotClause() IUnpivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotClauseContext)
}

func (s *RelationExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRelationExtension(s)
	}
}

func (s *RelationExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRelationExtension(s)
	}
}

func (p *SqlBaseParser) RelationExtension() (localctx IRelationExtensionContext) {
	localctx = NewRelationExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SqlBaseParserRULE_relationExtension)
	p.SetState(3168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserANTI, SqlBaseParserCROSS, SqlBaseParserFULL, SqlBaseParserINNER, SqlBaseParserJOIN, SqlBaseParserLEFT, SqlBaseParserNATURAL, SqlBaseParserRIGHT, SqlBaseParserSEMI:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3165)
			p.JoinRelation()
		}

	case SqlBaseParserPIVOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3166)
			p.PivotClause()
		}

	case SqlBaseParserUNPIVOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3167)
			p.UnpivotClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRight returns the right rule contexts.
	GetRight() IRelationPrimaryContext

	// SetRight sets the right rule contexts.
	SetRight(IRelationPrimaryContext)

	// Getter signatures
	JOIN() antlr.TerminalNode
	RelationPrimary() IRelationPrimaryContext
	JoinType() IJoinTypeContext
	LATERAL() antlr.TerminalNode
	JoinCriteria() IJoinCriteriaContext
	NATURAL() antlr.TerminalNode

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	right  IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRight() IRelationPrimaryContext { return s.right }

func (s *JoinRelationContext) SetRight(v IRelationPrimaryContext) { s.right = v }

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJOIN, 0)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNATURAL, 0)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *SqlBaseParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SqlBaseParserRULE_joinRelation)
	p.SetState(3187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserANTI, SqlBaseParserCROSS, SqlBaseParserFULL, SqlBaseParserINNER, SqlBaseParserJOIN, SqlBaseParserLEFT, SqlBaseParserRIGHT, SqlBaseParserSEMI:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3170)
			p.JoinType()
		}

		{
			p.SetState(3171)
			p.Match(SqlBaseParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3173)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 378, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3172)
				p.Match(SqlBaseParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3175)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).right = _x
		}
		p.SetState(3177)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 379, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3176)
				p.JoinCriteria()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserNATURAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3179)
			p.Match(SqlBaseParserNATURAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3180)
			p.JoinType()
		}
		{
			p.SetState(3181)
			p.Match(SqlBaseParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3183)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3182)
				p.Match(SqlBaseParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3185)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).right = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINNER, 0)
}

func (s *JoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCROSS, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *JoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEMI, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *JoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANTI, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *SqlBaseParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SqlBaseParserRULE_joinType)
	var _la int

	p.SetState(3213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserINNER {
			{
				p.SetState(3189)
				p.Match(SqlBaseParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3192)
			p.Match(SqlBaseParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3193)
			p.Match(SqlBaseParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(3194)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLEFT {
			{
				p.SetState(3197)
				p.Match(SqlBaseParserLEFT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3200)
			p.Match(SqlBaseParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3201)
			p.Match(SqlBaseParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(3202)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3205)
			p.Match(SqlBaseParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(3206)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLEFT {
			{
				p.SetState(3209)
				p.Match(SqlBaseParserLEFT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3212)
			p.Match(SqlBaseParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	USING() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *JoinCriteriaContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *SqlBaseParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SqlBaseParserRULE_joinCriteria)
	p.SetState(3219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3215)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3216)
			p.booleanExpression(0)
		}

	case SqlBaseParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3217)
			p.Match(SqlBaseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3218)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleContext is an interface to support dynamic dispatch.
type ISampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSeed returns the seed token.
	GetSeed() antlr.Token

	// SetSeed sets the seed token.
	SetSeed(antlr.Token)

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	SampleMethod() ISampleMethodContext
	REPEATABLE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsSampleContext differentiates from other interfaces.
	IsSampleContext()
}

type SampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	seed   antlr.Token
}

func NewEmptySampleContext() *SampleContext {
	var p = new(SampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sample
	return p
}

func InitEmptySampleContext(p *SampleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sample
}

func (*SampleContext) IsSampleContext() {}

func NewSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleContext {
	var p = new(SampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sample

	return p
}

func (s *SampleContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleContext) GetSeed() antlr.Token { return s.seed }

func (s *SampleContext) SetSeed(v antlr.Token) { s.seed = v }

func (s *SampleContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *SampleContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *SampleContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *SampleContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *SampleContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *SampleContext) SampleMethod() ISampleMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleMethodContext)
}

func (s *SampleContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *SampleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *SampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSample(s)
	}
}

func (s *SampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSample(s)
	}
}

func (p *SqlBaseParser) Sample() (localctx ISampleContext) {
	localctx = NewSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SqlBaseParserRULE_sample)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3221)
		p.Match(SqlBaseParserTABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3222)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3224)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3223)
			p.SampleMethod()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3226)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3231)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 391, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3227)
			p.Match(SqlBaseParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3228)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3229)

			var _m = p.Match(SqlBaseParserINTEGER_VALUE)

			localctx.(*SampleContext).seed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3230)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleMethodContext is an interface to support dynamic dispatch.
type ISampleMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSampleMethodContext differentiates from other interfaces.
	IsSampleMethodContext()
}

type SampleMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleMethodContext() *SampleMethodContext {
	var p = new(SampleMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampleMethod
	return p
}

func InitEmptySampleMethodContext(p *SampleMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampleMethod
}

func (*SampleMethodContext) IsSampleMethodContext() {}

func NewSampleMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleMethodContext {
	var p = new(SampleMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sampleMethod

	return p
}

func (s *SampleMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleMethodContext) CopyAll(ctx *SampleMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SampleMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SampleByRowsContext struct {
	SampleMethodContext
}

func NewSampleByRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByRowsContext {
	var p = new(SampleByRowsContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByRowsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampleByRowsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *SampleByRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSampleByRows(s)
	}
}

func (s *SampleByRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSampleByRows(s)
	}
}

type SampleByPercentileContext struct {
	SampleMethodContext
	negativeSign antlr.Token
	percentage   antlr.Token
}

func NewSampleByPercentileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByPercentileContext {
	var p = new(SampleByPercentileContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByPercentileContext) GetNegativeSign() antlr.Token { return s.negativeSign }

func (s *SampleByPercentileContext) GetPercentage() antlr.Token { return s.percentage }

func (s *SampleByPercentileContext) SetNegativeSign(v antlr.Token) { s.negativeSign = v }

func (s *SampleByPercentileContext) SetPercentage(v antlr.Token) { s.percentage = v }

func (s *SampleByPercentileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByPercentileContext) PERCENTLIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENTLIT, 0)
}

func (s *SampleByPercentileContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *SampleByPercentileContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *SampleByPercentileContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *SampleByPercentileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSampleByPercentile(s)
	}
}

func (s *SampleByPercentileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSampleByPercentile(s)
	}
}

type SampleByBucketContext struct {
	SampleMethodContext
	sampleType  antlr.Token
	numerator   antlr.Token
	denominator antlr.Token
}

func NewSampleByBucketContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByBucketContext {
	var p = new(SampleByBucketContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByBucketContext) GetSampleType() antlr.Token { return s.sampleType }

func (s *SampleByBucketContext) GetNumerator() antlr.Token { return s.numerator }

func (s *SampleByBucketContext) GetDenominator() antlr.Token { return s.denominator }

func (s *SampleByBucketContext) SetSampleType(v antlr.Token) { s.sampleType = v }

func (s *SampleByBucketContext) SetNumerator(v antlr.Token) { s.numerator = v }

func (s *SampleByBucketContext) SetDenominator(v antlr.Token) { s.denominator = v }

func (s *SampleByBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByBucketContext) OUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUT, 0)
}

func (s *SampleByBucketContext) OF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOF, 0)
}

func (s *SampleByBucketContext) BUCKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBUCKET, 0)
}

func (s *SampleByBucketContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserINTEGER_VALUE)
}

func (s *SampleByBucketContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, i)
}

func (s *SampleByBucketContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *SampleByBucketContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SampleByBucketContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SampleByBucketContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *SampleByBucketContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *SampleByBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSampleByBucket(s)
	}
}

func (s *SampleByBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSampleByBucket(s)
	}
}

type SampleByBytesContext struct {
	SampleMethodContext
	bytes IExpressionContext
}

func NewSampleByBytesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByBytesContext {
	var p = new(SampleByBytesContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByBytesContext) GetBytes() IExpressionContext { return s.bytes }

func (s *SampleByBytesContext) SetBytes(v IExpressionContext) { s.bytes = v }

func (s *SampleByBytesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByBytesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampleByBytesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSampleByBytes(s)
	}
}

func (s *SampleByBytesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSampleByBytes(s)
	}
}

func (p *SqlBaseParser) SampleMethod() (localctx ISampleMethodContext) {
	localctx = NewSampleMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SqlBaseParserRULE_sampleMethod)
	var _la int

	p.SetState(3257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 395, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSampleByPercentileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(3233)

				var _m = p.Match(SqlBaseParserMINUS)

				localctx.(*SampleByPercentileContext).negativeSign = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3236)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SampleByPercentileContext).percentage = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserINTEGER_VALUE || _la == SqlBaseParserDECIMAL_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SampleByPercentileContext).percentage = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3237)
			p.Match(SqlBaseParserPERCENTLIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSampleByRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3238)
			p.Expression()
		}
		{
			p.SetState(3239)
			p.Match(SqlBaseParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSampleByBucketContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3241)

			var _m = p.Match(SqlBaseParserBUCKET)

			localctx.(*SampleByBucketContext).sampleType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3242)

			var _m = p.Match(SqlBaseParserINTEGER_VALUE)

			localctx.(*SampleByBucketContext).numerator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3243)
			p.Match(SqlBaseParserOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3244)
			p.Match(SqlBaseParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3245)

			var _m = p.Match(SqlBaseParserINTEGER_VALUE)

			localctx.(*SampleByBucketContext).denominator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserON {
			{
				p.SetState(3246)
				p.Match(SqlBaseParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3252)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3247)
					p.Identifier()
				}

			case 2:
				{
					p.SetState(3248)
					p.QualifiedName()
				}
				{
					p.SetState(3249)
					p.Match(SqlBaseParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3250)
					p.Match(SqlBaseParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}

	case 4:
		localctx = NewSampleByBytesContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3256)

			var _x = p.Expression()

			localctx.(*SampleByBytesContext).bytes = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *IdentifierListContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *IdentifierListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *SqlBaseParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SqlBaseParserRULE_identifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3259)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3260)
		p.IdentifierSeq()
	}
	{
		p.SetState(3261)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSeqContext is an interface to support dynamic dispatch.
type IIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetIdent returns the ident rule context list.
	GetIdent() []IErrorCapturingIdentifierContext

	// SetIdent sets the ident rule context list.
	SetIdent([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierSeqContext differentiates from other interfaces.
	IsIdentifierSeqContext()
}

type IdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	ident                     []IErrorCapturingIdentifierContext
}

func NewEmptyIdentifierSeqContext() *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierSeq
	return p
}

func InitEmptyIdentifierSeqContext(p *IdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierSeq
}

func (*IdentifierSeqContext) IsIdentifierSeqContext() {}

func NewIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifierSeq

	return p
}

func (s *IdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSeqContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *IdentifierSeqContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *IdentifierSeqContext) GetIdent() []IErrorCapturingIdentifierContext { return s.ident }

func (s *IdentifierSeqContext) SetIdent(v []IErrorCapturingIdentifierContext) { s.ident = v }

func (s *IdentifierSeqContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSeqContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *IdentifierSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *IdentifierSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *IdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentifierSeq(s)
	}
}

func (s *IdentifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentifierSeq(s)
	}
}

func (p *SqlBaseParser) IdentifierSeq() (localctx IIdentifierSeqContext) {
	localctx = NewIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SqlBaseParserRULE_identifierSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3263)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
	}
	localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)
	p.SetState(3268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3264)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3265)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
			}
			localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)

		}
		p.SetState(3270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderedIdentifierListContext is an interface to support dynamic dispatch.
type IOrderedIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllOrderedIdentifier() []IOrderedIdentifierContext
	OrderedIdentifier(i int) IOrderedIdentifierContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderedIdentifierListContext differentiates from other interfaces.
	IsOrderedIdentifierListContext()
}

type OrderedIdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderedIdentifierListContext() *OrderedIdentifierListContext {
	var p = new(OrderedIdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_orderedIdentifierList
	return p
}

func InitEmptyOrderedIdentifierListContext(p *OrderedIdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_orderedIdentifierList
}

func (*OrderedIdentifierListContext) IsOrderedIdentifierListContext() {}

func NewOrderedIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderedIdentifierListContext {
	var p = new(OrderedIdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_orderedIdentifierList

	return p
}

func (s *OrderedIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderedIdentifierListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *OrderedIdentifierListContext) AllOrderedIdentifier() []IOrderedIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderedIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IOrderedIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderedIdentifierContext); ok {
			tst[i] = t.(IOrderedIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *OrderedIdentifierListContext) OrderedIdentifier(i int) IOrderedIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderedIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderedIdentifierContext)
}

func (s *OrderedIdentifierListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *OrderedIdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *OrderedIdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *OrderedIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderedIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderedIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterOrderedIdentifierList(s)
	}
}

func (s *OrderedIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitOrderedIdentifierList(s)
	}
}

func (p *SqlBaseParser) OrderedIdentifierList() (localctx IOrderedIdentifierListContext) {
	localctx = NewOrderedIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SqlBaseParserRULE_orderedIdentifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3271)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3272)
		p.OrderedIdentifier()
	}
	p.SetState(3277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3273)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3274)
			p.OrderedIdentifier()
		}

		p.SetState(3279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3280)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderedIdentifierContext is an interface to support dynamic dispatch.
type IOrderedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// GetIdent returns the ident rule contexts.
	GetIdent() IErrorCapturingIdentifierContext

	// SetIdent sets the ident rule contexts.
	SetIdent(IErrorCapturingIdentifierContext)

	// Getter signatures
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsOrderedIdentifierContext differentiates from other interfaces.
	IsOrderedIdentifierContext()
}

type OrderedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	ident    IErrorCapturingIdentifierContext
	ordering antlr.Token
}

func NewEmptyOrderedIdentifierContext() *OrderedIdentifierContext {
	var p = new(OrderedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_orderedIdentifier
	return p
}

func InitEmptyOrderedIdentifierContext(p *OrderedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_orderedIdentifier
}

func (*OrderedIdentifierContext) IsOrderedIdentifierContext() {}

func NewOrderedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderedIdentifierContext {
	var p = new(OrderedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_orderedIdentifier

	return p
}

func (s *OrderedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderedIdentifierContext) GetOrdering() antlr.Token { return s.ordering }

func (s *OrderedIdentifierContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *OrderedIdentifierContext) GetIdent() IErrorCapturingIdentifierContext { return s.ident }

func (s *OrderedIdentifierContext) SetIdent(v IErrorCapturingIdentifierContext) { s.ident = v }

func (s *OrderedIdentifierContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *OrderedIdentifierContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *OrderedIdentifierContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *OrderedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterOrderedIdentifier(s)
	}
}

func (s *OrderedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitOrderedIdentifier(s)
	}
}

func (p *SqlBaseParser) OrderedIdentifier() (localctx IOrderedIdentifierContext) {
	localctx = NewOrderedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SqlBaseParserRULE_orderedIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3282)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*OrderedIdentifierContext).ident = _x
	}
	p.SetState(3284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserASC || _la == SqlBaseParserDESC {
		{
			p.SetState(3283)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderedIdentifierContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserASC || _la == SqlBaseParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderedIdentifierContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierCommentListContext is an interface to support dynamic dispatch.
type IIdentifierCommentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentifierComment() []IIdentifierCommentContext
	IdentifierComment(i int) IIdentifierCommentContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierCommentListContext differentiates from other interfaces.
	IsIdentifierCommentListContext()
}

type IdentifierCommentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierCommentListContext() *IdentifierCommentListContext {
	var p = new(IdentifierCommentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierCommentList
	return p
}

func InitEmptyIdentifierCommentListContext(p *IdentifierCommentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierCommentList
}

func (*IdentifierCommentListContext) IsIdentifierCommentListContext() {}

func NewIdentifierCommentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierCommentListContext {
	var p = new(IdentifierCommentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifierCommentList

	return p
}

func (s *IdentifierCommentListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierCommentListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *IdentifierCommentListContext) AllIdentifierComment() []IIdentifierCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierCommentContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierCommentContext); ok {
			tst[i] = t.(IIdentifierCommentContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierCommentListContext) IdentifierComment(i int) IIdentifierCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierCommentContext)
}

func (s *IdentifierCommentListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *IdentifierCommentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *IdentifierCommentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *IdentifierCommentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierCommentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierCommentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentifierCommentList(s)
	}
}

func (s *IdentifierCommentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentifierCommentList(s)
	}
}

func (p *SqlBaseParser) IdentifierCommentList() (localctx IIdentifierCommentListContext) {
	localctx = NewIdentifierCommentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SqlBaseParserRULE_identifierCommentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3286)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3287)
		p.IdentifierComment()
	}
	p.SetState(3292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3288)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3289)
			p.IdentifierComment()
		}

		p.SetState(3294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3295)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierCommentContext is an interface to support dynamic dispatch.
type IIdentifierCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CommentSpec() ICommentSpecContext

	// IsIdentifierCommentContext differentiates from other interfaces.
	IsIdentifierCommentContext()
}

type IdentifierCommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierCommentContext() *IdentifierCommentContext {
	var p = new(IdentifierCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierComment
	return p
}

func InitEmptyIdentifierCommentContext(p *IdentifierCommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifierComment
}

func (*IdentifierCommentContext) IsIdentifierCommentContext() {}

func NewIdentifierCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierCommentContext {
	var p = new(IdentifierCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifierComment

	return p
}

func (s *IdentifierCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierCommentContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *IdentifierCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentifierComment(s)
	}
}

func (s *IdentifierCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentifierComment(s)
	}
}

func (p *SqlBaseParser) IdentifierComment() (localctx IIdentifierCommentContext) {
	localctx = NewIdentifierCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SqlBaseParserRULE_identifierComment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3297)
		p.Identifier()
	}
	p.SetState(3299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCOMMENT {
		{
			p.SetState(3298)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StreamRelationContext struct {
	RelationPrimaryContext
}

func NewStreamRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StreamRelationContext {
	var p = new(StreamRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *StreamRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StreamRelationContext) StreamRelationPrimary() IStreamRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStreamRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStreamRelationPrimaryContext)
}

func (s *StreamRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStreamRelation(s)
	}
}

func (s *StreamRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStreamRelation(s)
	}
}

type TableValuedFunctionContext struct {
	RelationPrimaryContext
}

func NewTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableValuedFunctionContext {
	var p = new(TableValuedFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValuedFunctionContext) FunctionTable() IFunctionTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTableContext)
}

func (s *TableValuedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableValuedFunction(s)
	}
}

func (s *TableValuedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableValuedFunction(s)
	}
}

type InlineTableDefault2Context struct {
	RelationPrimaryContext
}

func NewInlineTableDefault2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableDefault2Context {
	var p = new(InlineTableDefault2Context)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *InlineTableDefault2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableDefault2Context) InlineTable() IInlineTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineTableContext)
}

func (s *InlineTableDefault2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInlineTableDefault2(s)
	}
}

func (s *InlineTableDefault2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInlineTableDefault2(s)
	}
}

type AliasedRelationContext struct {
	RelationPrimaryContext
}

func NewAliasedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *AliasedRelationContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *AliasedRelationContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *AliasedRelationContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *AliasedRelationContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

type AliasedQueryContext struct {
	RelationPrimaryContext
}

func NewAliasedQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AliasedQueryContext {
	var p = new(AliasedQueryContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *AliasedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *AliasedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasedQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *AliasedQueryContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *AliasedQueryContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *AliasedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAliasedQuery(s)
	}
}

func (s *AliasedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAliasedQuery(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *TableNameContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableNameContext) TemporalClause() ITemporalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalClauseContext)
}

func (s *TableNameContext) OptionsClause() IOptionsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionsClauseContext)
}

func (s *TableNameContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *SqlBaseParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SqlBaseParserRULE_relationPrimary)
	p.SetState(3332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStreamRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3301)
			p.StreamRelationPrimary()
		}

	case 2:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3302)
			p.IdentifierReference()
		}
		p.SetState(3304)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3303)
				p.TemporalClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3307)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 402, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3306)
				p.OptionsClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3310)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 403, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3309)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3312)
			p.TableAlias()
		}

	case 3:
		localctx = NewAliasedQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3314)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3315)
			p.Query()
		}
		{
			p.SetState(3316)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3318)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 404, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3317)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3320)
			p.TableAlias()
		}

	case 4:
		localctx = NewAliasedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3322)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3323)
			p.Relation()
		}
		{
			p.SetState(3324)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3326)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3325)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3328)
			p.TableAlias()
		}

	case 5:
		localctx = NewInlineTableDefault2Context(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3330)
			p.InlineTable()
		}

	case 6:
		localctx = NewTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3331)
			p.FunctionTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionsClauseContext is an interface to support dynamic dispatch.
type IOptionsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptions returns the options rule contexts.
	GetOptions() IPropertyListContext

	// SetOptions sets the options rule contexts.
	SetOptions(IPropertyListContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsOptionsClauseContext differentiates from other interfaces.
	IsOptionsClauseContext()
}

type OptionsClauseContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	options IPropertyListContext
}

func NewEmptyOptionsClauseContext() *OptionsClauseContext {
	var p = new(OptionsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_optionsClause
	return p
}

func InitEmptyOptionsClauseContext(p *OptionsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_optionsClause
}

func (*OptionsClauseContext) IsOptionsClauseContext() {}

func NewOptionsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionsClauseContext {
	var p = new(OptionsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_optionsClause

	return p
}

func (s *OptionsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionsClauseContext) GetOptions() IPropertyListContext { return s.options }

func (s *OptionsClauseContext) SetOptions(v IPropertyListContext) { s.options = v }

func (s *OptionsClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *OptionsClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *OptionsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterOptionsClause(s)
	}
}

func (s *OptionsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitOptionsClause(s)
	}
}

func (p *SqlBaseParser) OptionsClause() (localctx IOptionsClauseContext) {
	localctx = NewOptionsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SqlBaseParserRULE_optionsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3334)
		p.Match(SqlBaseParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3335)

		var _x = p.PropertyList()

		localctx.(*OptionsClauseContext).options = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineTableContext is an interface to support dynamic dispatch.
type IInlineTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	TableAlias() ITableAliasContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInlineTableContext differentiates from other interfaces.
	IsInlineTableContext()
}

type InlineTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineTableContext() *InlineTableContext {
	var p = new(InlineTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_inlineTable
	return p
}

func InitEmptyInlineTableContext(p *InlineTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_inlineTable
}

func (*InlineTableContext) IsInlineTableContext() {}

func NewInlineTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineTableContext {
	var p = new(InlineTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_inlineTable

	return p
}

func (s *InlineTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *InlineTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *InlineTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *SqlBaseParser) InlineTable() (localctx IInlineTableContext) {
	localctx = NewInlineTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SqlBaseParserRULE_inlineTable)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3337)
		p.Match(SqlBaseParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3338)
		p.Expression()
	}
	p.SetState(3343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 407, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3339)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3340)
				p.Expression()
			}

		}
		p.SetState(3345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 407, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(3346)
		p.TableAlias()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTableSubqueryArgumentContext is an interface to support dynamic dispatch.
type IFunctionTableSubqueryArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	IdentifierReference() IIdentifierReferenceContext
	TableArgumentPartitioning() ITableArgumentPartitioningContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Query() IQueryContext

	// IsFunctionTableSubqueryArgumentContext differentiates from other interfaces.
	IsFunctionTableSubqueryArgumentContext()
}

type FunctionTableSubqueryArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTableSubqueryArgumentContext() *FunctionTableSubqueryArgumentContext {
	var p = new(FunctionTableSubqueryArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableSubqueryArgument
	return p
}

func InitEmptyFunctionTableSubqueryArgumentContext(p *FunctionTableSubqueryArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableSubqueryArgument
}

func (*FunctionTableSubqueryArgumentContext) IsFunctionTableSubqueryArgumentContext() {}

func NewFunctionTableSubqueryArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTableSubqueryArgumentContext {
	var p = new(FunctionTableSubqueryArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionTableSubqueryArgument

	return p
}

func (s *FunctionTableSubqueryArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTableSubqueryArgumentContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *FunctionTableSubqueryArgumentContext) IdentifierReference() IIdentifierReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierReferenceContext)
}

func (s *FunctionTableSubqueryArgumentContext) TableArgumentPartitioning() ITableArgumentPartitioningContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableArgumentPartitioningContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableArgumentPartitioningContext)
}

func (s *FunctionTableSubqueryArgumentContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *FunctionTableSubqueryArgumentContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *FunctionTableSubqueryArgumentContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *FunctionTableSubqueryArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTableSubqueryArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTableSubqueryArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionTableSubqueryArgument(s)
	}
}

func (s *FunctionTableSubqueryArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionTableSubqueryArgument(s)
	}
}

func (p *SqlBaseParser) FunctionTableSubqueryArgument() (localctx IFunctionTableSubqueryArgumentContext) {
	localctx = NewFunctionTableSubqueryArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SqlBaseParserRULE_functionTableSubqueryArgument)
	var _la int

	p.SetState(3367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3348)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3349)
			p.IdentifierReference()
		}
		p.SetState(3351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserDISTRIBUTE || _la == SqlBaseParserPARTITION || _la == SqlBaseParserWITH {
			{
				p.SetState(3350)
				p.TableArgumentPartitioning()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3353)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3354)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3355)
			p.IdentifierReference()
		}
		{
			p.SetState(3356)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserDISTRIBUTE || _la == SqlBaseParserPARTITION || _la == SqlBaseParserWITH {
			{
				p.SetState(3357)
				p.TableArgumentPartitioning()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3360)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3361)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3362)
			p.Query()
		}
		{
			p.SetState(3363)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserDISTRIBUTE || _la == SqlBaseParserPARTITION || _la == SqlBaseParserWITH {
			{
				p.SetState(3364)
				p.TableArgumentPartitioning()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableArgumentPartitioningContext is an interface to support dynamic dispatch.
type ITableArgumentPartitioningContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetInvalidMultiPartitionExpression returns the invalidMultiPartitionExpression rule contexts.
	GetInvalidMultiPartitionExpression() IExpressionContext

	// GetInvalidMultiSortItem returns the invalidMultiSortItem rule contexts.
	GetInvalidMultiSortItem() ISortItemContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetInvalidMultiPartitionExpression sets the invalidMultiPartitionExpression rule contexts.
	SetInvalidMultiPartitionExpression(IExpressionContext)

	// SetInvalidMultiSortItem sets the invalidMultiSortItem rule contexts.
	SetInvalidMultiSortItem(ISortItemContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	SINGLE() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	SORT() antlr.TerminalNode
	DISTRIBUTE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableArgumentPartitioningContext differentiates from other interfaces.
	IsTableArgumentPartitioningContext()
}

type TableArgumentPartitioningContext struct {
	antlr.BaseParserRuleContext
	parser                          antlr.Parser
	_expression                     IExpressionContext
	partition                       []IExpressionContext
	invalidMultiPartitionExpression IExpressionContext
	invalidMultiSortItem            ISortItemContext
}

func NewEmptyTableArgumentPartitioningContext() *TableArgumentPartitioningContext {
	var p = new(TableArgumentPartitioningContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableArgumentPartitioning
	return p
}

func InitEmptyTableArgumentPartitioningContext(p *TableArgumentPartitioningContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableArgumentPartitioning
}

func (*TableArgumentPartitioningContext) IsTableArgumentPartitioningContext() {}

func NewTableArgumentPartitioningContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgumentPartitioningContext {
	var p = new(TableArgumentPartitioningContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableArgumentPartitioning

	return p
}

func (s *TableArgumentPartitioningContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgumentPartitioningContext) Get_expression() IExpressionContext { return s._expression }

func (s *TableArgumentPartitioningContext) GetInvalidMultiPartitionExpression() IExpressionContext {
	return s.invalidMultiPartitionExpression
}

func (s *TableArgumentPartitioningContext) GetInvalidMultiSortItem() ISortItemContext {
	return s.invalidMultiSortItem
}

func (s *TableArgumentPartitioningContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *TableArgumentPartitioningContext) SetInvalidMultiPartitionExpression(v IExpressionContext) {
	s.invalidMultiPartitionExpression = v
}

func (s *TableArgumentPartitioningContext) SetInvalidMultiSortItem(v ISortItemContext) {
	s.invalidMultiSortItem = v
}

func (s *TableArgumentPartitioningContext) GetPartition() []IExpressionContext { return s.partition }

func (s *TableArgumentPartitioningContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *TableArgumentPartitioningContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *TableArgumentPartitioningContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *TableArgumentPartitioningContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *TableArgumentPartitioningContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSINGLE, 0)
}

func (s *TableArgumentPartitioningContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *TableArgumentPartitioningContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *TableArgumentPartitioningContext) SORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORT, 0)
}

func (s *TableArgumentPartitioningContext) DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTE, 0)
}

func (s *TableArgumentPartitioningContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TableArgumentPartitioningContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TableArgumentPartitioningContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *TableArgumentPartitioningContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *TableArgumentPartitioningContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *TableArgumentPartitioningContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *TableArgumentPartitioningContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *TableArgumentPartitioningContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *TableArgumentPartitioningContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *TableArgumentPartitioningContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *TableArgumentPartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgumentPartitioningContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgumentPartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableArgumentPartitioning(s)
	}
}

func (s *TableArgumentPartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableArgumentPartitioning(s)
	}
}

func (p *SqlBaseParser) TableArgumentPartitioning() (localctx ITableArgumentPartitioningContext) {
	localctx = NewTableArgumentPartitioningContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SqlBaseParserRULE_tableArgumentPartitioning)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserWITH:
		{
			p.SetState(3369)
			p.Match(SqlBaseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3370)
			p.Match(SqlBaseParserSINGLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3371)
			p.Match(SqlBaseParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserDISTRIBUTE, SqlBaseParserPARTITION:
		{
			p.SetState(3372)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDISTRIBUTE || _la == SqlBaseParserPARTITION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3373)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3374)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3375)

				var _x = p.Expression()

				localctx.(*TableArgumentPartitioningContext)._expression = _x
			}
			localctx.(*TableArgumentPartitioningContext).partition = append(localctx.(*TableArgumentPartitioningContext).partition, localctx.(*TableArgumentPartitioningContext)._expression)
			p.SetState(3380)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(3376)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3377)

					var _x = p.Expression()

					localctx.(*TableArgumentPartitioningContext)._expression = _x
				}
				localctx.(*TableArgumentPartitioningContext).partition = append(localctx.(*TableArgumentPartitioningContext).partition, localctx.(*TableArgumentPartitioningContext)._expression)

				p.SetState(3382)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3383)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3385)
				p.Expression()
			}
			p.SetState(3388)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(3386)
						p.Match(SqlBaseParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(3387)

						var _x = p.Expression()

						localctx.(*TableArgumentPartitioningContext).invalidMultiPartitionExpression = _x
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

				p.SetState(3390)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(3392)

				var _x = p.Expression()

				localctx.(*TableArgumentPartitioningContext)._expression = _x
			}
			localctx.(*TableArgumentPartitioningContext).partition = append(localctx.(*TableArgumentPartitioningContext).partition, localctx.(*TableArgumentPartitioningContext)._expression)

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserORDER || _la == SqlBaseParserSORT {
		{
			p.SetState(3397)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserORDER || _la == SqlBaseParserSORT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3398)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 418, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3399)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3400)
				p.SortItem()
			}
			p.SetState(3405)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(3401)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3402)
					p.SortItem()
				}

				p.SetState(3407)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3408)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3410)
				p.SortItem()
			}
			p.SetState(3413)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(3411)
						p.Match(SqlBaseParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(3412)

						var _x = p.SortItem()

						localctx.(*TableArgumentPartitioningContext).invalidMultiSortItem = _x
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

				p.SetState(3415)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 417, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(3417)
				p.SortItem()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTableNamedArgumentExpressionContext is an interface to support dynamic dispatch.
type IFunctionTableNamedArgumentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IFunctionTableSubqueryArgumentContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IFunctionTableSubqueryArgumentContext)

	// Getter signatures
	FAT_ARROW() antlr.TerminalNode
	Identifier() IIdentifierContext
	FunctionTableSubqueryArgument() IFunctionTableSubqueryArgumentContext

	// IsFunctionTableNamedArgumentExpressionContext differentiates from other interfaces.
	IsFunctionTableNamedArgumentExpressionContext()
}

type FunctionTableNamedArgumentExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IIdentifierContext
	table  IFunctionTableSubqueryArgumentContext
}

func NewEmptyFunctionTableNamedArgumentExpressionContext() *FunctionTableNamedArgumentExpressionContext {
	var p = new(FunctionTableNamedArgumentExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableNamedArgumentExpression
	return p
}

func InitEmptyFunctionTableNamedArgumentExpressionContext(p *FunctionTableNamedArgumentExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableNamedArgumentExpression
}

func (*FunctionTableNamedArgumentExpressionContext) IsFunctionTableNamedArgumentExpressionContext() {}

func NewFunctionTableNamedArgumentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTableNamedArgumentExpressionContext {
	var p = new(FunctionTableNamedArgumentExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionTableNamedArgumentExpression

	return p
}

func (s *FunctionTableNamedArgumentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTableNamedArgumentExpressionContext) GetKey() IIdentifierContext { return s.key }

func (s *FunctionTableNamedArgumentExpressionContext) GetTable() IFunctionTableSubqueryArgumentContext {
	return s.table
}

func (s *FunctionTableNamedArgumentExpressionContext) SetKey(v IIdentifierContext) { s.key = v }

func (s *FunctionTableNamedArgumentExpressionContext) SetTable(v IFunctionTableSubqueryArgumentContext) {
	s.table = v
}

func (s *FunctionTableNamedArgumentExpressionContext) FAT_ARROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFAT_ARROW, 0)
}

func (s *FunctionTableNamedArgumentExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionTableNamedArgumentExpressionContext) FunctionTableSubqueryArgument() IFunctionTableSubqueryArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTableSubqueryArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTableSubqueryArgumentContext)
}

func (s *FunctionTableNamedArgumentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTableNamedArgumentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTableNamedArgumentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionTableNamedArgumentExpression(s)
	}
}

func (s *FunctionTableNamedArgumentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionTableNamedArgumentExpression(s)
	}
}

func (p *SqlBaseParser) FunctionTableNamedArgumentExpression() (localctx IFunctionTableNamedArgumentExpressionContext) {
	localctx = NewFunctionTableNamedArgumentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SqlBaseParserRULE_functionTableNamedArgumentExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3422)

		var _x = p.Identifier()

		localctx.(*FunctionTableNamedArgumentExpressionContext).key = _x
	}
	{
		p.SetState(3423)
		p.Match(SqlBaseParserFAT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3424)

		var _x = p.FunctionTableSubqueryArgument()

		localctx.(*FunctionTableNamedArgumentExpressionContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTableReferenceArgumentContext is an interface to support dynamic dispatch.
type IFunctionTableReferenceArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionTableSubqueryArgument() IFunctionTableSubqueryArgumentContext
	FunctionTableNamedArgumentExpression() IFunctionTableNamedArgumentExpressionContext

	// IsFunctionTableReferenceArgumentContext differentiates from other interfaces.
	IsFunctionTableReferenceArgumentContext()
}

type FunctionTableReferenceArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTableReferenceArgumentContext() *FunctionTableReferenceArgumentContext {
	var p = new(FunctionTableReferenceArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableReferenceArgument
	return p
}

func InitEmptyFunctionTableReferenceArgumentContext(p *FunctionTableReferenceArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableReferenceArgument
}

func (*FunctionTableReferenceArgumentContext) IsFunctionTableReferenceArgumentContext() {}

func NewFunctionTableReferenceArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTableReferenceArgumentContext {
	var p = new(FunctionTableReferenceArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionTableReferenceArgument

	return p
}

func (s *FunctionTableReferenceArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTableReferenceArgumentContext) FunctionTableSubqueryArgument() IFunctionTableSubqueryArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTableSubqueryArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTableSubqueryArgumentContext)
}

func (s *FunctionTableReferenceArgumentContext) FunctionTableNamedArgumentExpression() IFunctionTableNamedArgumentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTableNamedArgumentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTableNamedArgumentExpressionContext)
}

func (s *FunctionTableReferenceArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTableReferenceArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTableReferenceArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionTableReferenceArgument(s)
	}
}

func (s *FunctionTableReferenceArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionTableReferenceArgument(s)
	}
}

func (p *SqlBaseParser) FunctionTableReferenceArgument() (localctx IFunctionTableReferenceArgumentContext) {
	localctx = NewFunctionTableReferenceArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SqlBaseParserRULE_functionTableReferenceArgument)
	p.SetState(3428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3426)
			p.FunctionTableSubqueryArgument()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3427)
			p.FunctionTableNamedArgumentExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTableArgumentContext is an interface to support dynamic dispatch.
type IFunctionTableArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionTableReferenceArgument() IFunctionTableReferenceArgumentContext
	FunctionArgument() IFunctionArgumentContext

	// IsFunctionTableArgumentContext differentiates from other interfaces.
	IsFunctionTableArgumentContext()
}

type FunctionTableArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTableArgumentContext() *FunctionTableArgumentContext {
	var p = new(FunctionTableArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableArgument
	return p
}

func InitEmptyFunctionTableArgumentContext(p *FunctionTableArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTableArgument
}

func (*FunctionTableArgumentContext) IsFunctionTableArgumentContext() {}

func NewFunctionTableArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTableArgumentContext {
	var p = new(FunctionTableArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionTableArgument

	return p
}

func (s *FunctionTableArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTableArgumentContext) FunctionTableReferenceArgument() IFunctionTableReferenceArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTableReferenceArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTableReferenceArgumentContext)
}

func (s *FunctionTableArgumentContext) FunctionArgument() IFunctionArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionTableArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTableArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTableArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionTableArgument(s)
	}
}

func (s *FunctionTableArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionTableArgument(s)
	}
}

func (p *SqlBaseParser) FunctionTableArgument() (localctx IFunctionTableArgumentContext) {
	localctx = NewFunctionTableArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SqlBaseParserRULE_functionTableArgument)
	p.SetState(3432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3430)
			p.FunctionTableReferenceArgument()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3431)
			p.FunctionArgument()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTableContext is an interface to support dynamic dispatch.
type IFunctionTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() IFunctionNameContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(IFunctionNameContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	TableAlias() ITableAliasContext
	FunctionName() IFunctionNameContext
	AllFunctionTableArgument() []IFunctionTableArgumentContext
	FunctionTableArgument(i int) IFunctionTableArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionTableContext differentiates from other interfaces.
	IsFunctionTableContext()
}

type FunctionTableContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	funcName IFunctionNameContext
}

func NewEmptyFunctionTableContext() *FunctionTableContext {
	var p = new(FunctionTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTable
	return p
}

func InitEmptyFunctionTableContext(p *FunctionTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionTable
}

func (*FunctionTableContext) IsFunctionTableContext() {}

func NewFunctionTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTableContext {
	var p = new(FunctionTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionTable

	return p
}

func (s *FunctionTableContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTableContext) GetFuncName() IFunctionNameContext { return s.funcName }

func (s *FunctionTableContext) SetFuncName(v IFunctionNameContext) { s.funcName = v }

func (s *FunctionTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *FunctionTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *FunctionTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *FunctionTableContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionTableContext) AllFunctionTableArgument() []IFunctionTableArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionTableArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionTableArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionTableArgumentContext); ok {
			tst[i] = t.(IFunctionTableArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTableContext) FunctionTableArgument(i int) IFunctionTableArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTableArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTableArgumentContext)
}

func (s *FunctionTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *FunctionTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *FunctionTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionTable(s)
	}
}

func (s *FunctionTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionTable(s)
	}
}

func (p *SqlBaseParser) FunctionTable() (localctx IFunctionTableContext) {
	localctx = NewFunctionTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SqlBaseParserRULE_functionTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3434)

		var _x = p.FunctionName()

		localctx.(*FunctionTableContext).funcName = _x
	}
	{
		p.SetState(3435)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3444)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3436)
			p.FunctionTableArgument()
		}
		p.SetState(3441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(3437)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3438)
				p.FunctionTableArgument()
			}

			p.SetState(3443)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3446)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3447)
		p.TableAlias()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *TableAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *TableAliasContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (p *SqlBaseParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SqlBaseParserRULE_tableAlias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3456)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext()) == 1 {
		p.SetState(3450)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3449)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3452)
			p.StrictIdentifier()
		}
		p.SetState(3454)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 425, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3453)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowFormatContext is an interface to support dynamic dispatch.
type IRowFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRowFormatContext differentiates from other interfaces.
	IsRowFormatContext()
}

type RowFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowFormatContext() *RowFormatContext {
	var p = new(RowFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_rowFormat
	return p
}

func InitEmptyRowFormatContext(p *RowFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_rowFormat
}

func (*RowFormatContext) IsRowFormatContext() {}

func NewRowFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFormatContext {
	var p = new(RowFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_rowFormat

	return p
}

func (s *RowFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFormatContext) CopyAll(ctx *RowFormatContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RowFormatSerdeContext struct {
	RowFormatContext
	name  IStringLitContext
	props IPropertyListContext
}

func NewRowFormatSerdeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowFormatSerdeContext {
	var p = new(RowFormatSerdeContext)

	InitEmptyRowFormatContext(&p.RowFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*RowFormatContext))

	return p
}

func (s *RowFormatSerdeContext) GetName() IStringLitContext { return s.name }

func (s *RowFormatSerdeContext) GetProps() IPropertyListContext { return s.props }

func (s *RowFormatSerdeContext) SetName(v IStringLitContext) { s.name = v }

func (s *RowFormatSerdeContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *RowFormatSerdeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatSerdeContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *RowFormatSerdeContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *RowFormatSerdeContext) SERDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDE, 0)
}

func (s *RowFormatSerdeContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *RowFormatSerdeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *RowFormatSerdeContext) SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDEPROPERTIES, 0)
}

func (s *RowFormatSerdeContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *RowFormatSerdeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRowFormatSerde(s)
	}
}

func (s *RowFormatSerdeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRowFormatSerde(s)
	}
}

type RowFormatDelimitedContext struct {
	RowFormatContext
	fieldsTerminatedBy          IStringLitContext
	escapedBy                   IStringLitContext
	collectionItemsTerminatedBy IStringLitContext
	keysTerminatedBy            IStringLitContext
	linesSeparatedBy            IStringLitContext
	nullDefinedAs               IStringLitContext
}

func NewRowFormatDelimitedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowFormatDelimitedContext {
	var p = new(RowFormatDelimitedContext)

	InitEmptyRowFormatContext(&p.RowFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*RowFormatContext))

	return p
}

func (s *RowFormatDelimitedContext) GetFieldsTerminatedBy() IStringLitContext {
	return s.fieldsTerminatedBy
}

func (s *RowFormatDelimitedContext) GetEscapedBy() IStringLitContext { return s.escapedBy }

func (s *RowFormatDelimitedContext) GetCollectionItemsTerminatedBy() IStringLitContext {
	return s.collectionItemsTerminatedBy
}

func (s *RowFormatDelimitedContext) GetKeysTerminatedBy() IStringLitContext {
	return s.keysTerminatedBy
}

func (s *RowFormatDelimitedContext) GetLinesSeparatedBy() IStringLitContext {
	return s.linesSeparatedBy
}

func (s *RowFormatDelimitedContext) GetNullDefinedAs() IStringLitContext { return s.nullDefinedAs }

func (s *RowFormatDelimitedContext) SetFieldsTerminatedBy(v IStringLitContext) {
	s.fieldsTerminatedBy = v
}

func (s *RowFormatDelimitedContext) SetEscapedBy(v IStringLitContext) { s.escapedBy = v }

func (s *RowFormatDelimitedContext) SetCollectionItemsTerminatedBy(v IStringLitContext) {
	s.collectionItemsTerminatedBy = v
}

func (s *RowFormatDelimitedContext) SetKeysTerminatedBy(v IStringLitContext) { s.keysTerminatedBy = v }

func (s *RowFormatDelimitedContext) SetLinesSeparatedBy(v IStringLitContext) { s.linesSeparatedBy = v }

func (s *RowFormatDelimitedContext) SetNullDefinedAs(v IStringLitContext) { s.nullDefinedAs = v }

func (s *RowFormatDelimitedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatDelimitedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *RowFormatDelimitedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *RowFormatDelimitedContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELIMITED, 0)
}

func (s *RowFormatDelimitedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIELDS, 0)
}

func (s *RowFormatDelimitedContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTERMINATED)
}

func (s *RowFormatDelimitedContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTERMINATED, i)
}

func (s *RowFormatDelimitedContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *RowFormatDelimitedContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *RowFormatDelimitedContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLLECTION, 0)
}

func (s *RowFormatDelimitedContext) ITEMS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserITEMS, 0)
}

func (s *RowFormatDelimitedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *RowFormatDelimitedContext) KEYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEYS, 0)
}

func (s *RowFormatDelimitedContext) LINES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLINES, 0)
}

func (s *RowFormatDelimitedContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *RowFormatDelimitedContext) DEFINED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINED, 0)
}

func (s *RowFormatDelimitedContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *RowFormatDelimitedContext) AllStringLit() []IStringLitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLitContext); ok {
			len++
		}
	}

	tst := make([]IStringLitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLitContext); ok {
			tst[i] = t.(IStringLitContext)
			i++
		}
	}

	return tst
}

func (s *RowFormatDelimitedContext) StringLit(i int) IStringLitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *RowFormatDelimitedContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPED, 0)
}

func (s *RowFormatDelimitedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRowFormatDelimited(s)
	}
}

func (s *RowFormatDelimitedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRowFormatDelimited(s)
	}
}

func (p *SqlBaseParser) RowFormat() (localctx IRowFormatContext) {
	localctx = NewRowFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SqlBaseParserRULE_rowFormat)
	p.SetState(3507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 434, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRowFormatSerdeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3458)
			p.Match(SqlBaseParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3459)
			p.Match(SqlBaseParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3460)
			p.Match(SqlBaseParserSERDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3461)

			var _x = p.StringLit()

			localctx.(*RowFormatSerdeContext).name = _x
		}
		p.SetState(3465)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3462)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3463)
				p.Match(SqlBaseParserSERDEPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3464)

				var _x = p.PropertyList()

				localctx.(*RowFormatSerdeContext).props = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewRowFormatDelimitedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3467)
			p.Match(SqlBaseParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3468)
			p.Match(SqlBaseParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3469)
			p.Match(SqlBaseParserDELIMITED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3479)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 429, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3470)
				p.Match(SqlBaseParserFIELDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3471)
				p.Match(SqlBaseParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3472)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3473)

				var _x = p.StringLit()

				localctx.(*RowFormatDelimitedContext).fieldsTerminatedBy = _x
			}
			p.SetState(3477)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3474)
					p.Match(SqlBaseParserESCAPED)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3475)
					p.Match(SqlBaseParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3476)

					var _x = p.StringLit()

					localctx.(*RowFormatDelimitedContext).escapedBy = _x
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3486)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3481)
				p.Match(SqlBaseParserCOLLECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3482)
				p.Match(SqlBaseParserITEMS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3483)
				p.Match(SqlBaseParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3484)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3485)

				var _x = p.StringLit()

				localctx.(*RowFormatDelimitedContext).collectionItemsTerminatedBy = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 431, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3488)
				p.Match(SqlBaseParserMAP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3489)
				p.Match(SqlBaseParserKEYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3490)
				p.Match(SqlBaseParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3491)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3492)

				var _x = p.StringLit()

				localctx.(*RowFormatDelimitedContext).keysTerminatedBy = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3499)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3495)
				p.Match(SqlBaseParserLINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3496)
				p.Match(SqlBaseParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3497)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3498)

				var _x = p.StringLit()

				localctx.(*RowFormatDelimitedContext).linesSeparatedBy = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3505)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 433, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3501)
				p.Match(SqlBaseParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3502)
				p.Match(SqlBaseParserDEFINED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3503)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3504)

				var _x = p.StringLit()

				localctx.(*RowFormatDelimitedContext).nullDefinedAs = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierListContext is an interface to support dynamic dispatch.
type IMultipartIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultipartIdentifier() []IMultipartIdentifierContext
	MultipartIdentifier(i int) IMultipartIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultipartIdentifierListContext differentiates from other interfaces.
	IsMultipartIdentifierListContext()
}

type MultipartIdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipartIdentifierListContext() *MultipartIdentifierListContext {
	var p = new(MultipartIdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierList
	return p
}

func InitEmptyMultipartIdentifierListContext(p *MultipartIdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierList
}

func (*MultipartIdentifierListContext) IsMultipartIdentifierListContext() {}

func NewMultipartIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierListContext {
	var p = new(MultipartIdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierList

	return p
}

func (s *MultipartIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierListContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierListContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *MultipartIdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *MultipartIdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *MultipartIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMultipartIdentifierList(s)
	}
}

func (s *MultipartIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMultipartIdentifierList(s)
	}
}

func (p *SqlBaseParser) MultipartIdentifierList() (localctx IMultipartIdentifierListContext) {
	localctx = NewMultipartIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SqlBaseParserRULE_multipartIdentifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3509)
		p.MultipartIdentifier()
	}
	p.SetState(3514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3510)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3511)
			p.MultipartIdentifier()
		}

		p.SetState(3516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierContext is an interface to support dynamic dispatch.
type IMultipartIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetParts returns the parts rule context list.
	GetParts() []IErrorCapturingIdentifierContext

	// SetParts sets the parts rule context list.
	SetParts([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierContext differentiates from other interfaces.
	IsMultipartIdentifierContext()
}

type MultipartIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	parts                     []IErrorCapturingIdentifierContext
}

func NewEmptyMultipartIdentifierContext() *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifier
	return p
}

func InitEmptyMultipartIdentifierContext(p *MultipartIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifier
}

func (*MultipartIdentifierContext) IsMultipartIdentifierContext() {}

func NewMultipartIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifier

	return p
}

func (s *MultipartIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *MultipartIdentifierContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *MultipartIdentifierContext) GetParts() []IErrorCapturingIdentifierContext { return s.parts }

func (s *MultipartIdentifierContext) SetParts(v []IErrorCapturingIdentifierContext) { s.parts = v }

func (s *MultipartIdentifierContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *MultipartIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserDOT)
}

func (s *MultipartIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, i)
}

func (s *MultipartIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMultipartIdentifier(s)
	}
}

func (s *MultipartIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMultipartIdentifier(s)
	}
}

func (p *SqlBaseParser) MultipartIdentifier() (localctx IMultipartIdentifierContext) {
	localctx = NewMultipartIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SqlBaseParserRULE_multipartIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3517)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
	}
	localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)
	p.SetState(3522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 436, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3518)
				p.Match(SqlBaseParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3519)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
			}
			localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)

		}
		p.SetState(3524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 436, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierPropertyListContext is an interface to support dynamic dispatch.
type IMultipartIdentifierPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultipartIdentifierProperty() []IMultipartIdentifierPropertyContext
	MultipartIdentifierProperty(i int) IMultipartIdentifierPropertyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultipartIdentifierPropertyListContext differentiates from other interfaces.
	IsMultipartIdentifierPropertyListContext()
}

type MultipartIdentifierPropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipartIdentifierPropertyListContext() *MultipartIdentifierPropertyListContext {
	var p = new(MultipartIdentifierPropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierPropertyList
	return p
}

func InitEmptyMultipartIdentifierPropertyListContext(p *MultipartIdentifierPropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierPropertyList
}

func (*MultipartIdentifierPropertyListContext) IsMultipartIdentifierPropertyListContext() {}

func NewMultipartIdentifierPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierPropertyListContext {
	var p = new(MultipartIdentifierPropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierPropertyList

	return p
}

func (s *MultipartIdentifierPropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierPropertyListContext) AllMultipartIdentifierProperty() []IMultipartIdentifierPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierPropertyContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierPropertyContext); ok {
			tst[i] = t.(IMultipartIdentifierPropertyContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierPropertyListContext) MultipartIdentifierProperty(i int) IMultipartIdentifierPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierPropertyContext)
}

func (s *MultipartIdentifierPropertyListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *MultipartIdentifierPropertyListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *MultipartIdentifierPropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierPropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierPropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMultipartIdentifierPropertyList(s)
	}
}

func (s *MultipartIdentifierPropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMultipartIdentifierPropertyList(s)
	}
}

func (p *SqlBaseParser) MultipartIdentifierPropertyList() (localctx IMultipartIdentifierPropertyListContext) {
	localctx = NewMultipartIdentifierPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SqlBaseParserRULE_multipartIdentifierPropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3525)
		p.MultipartIdentifierProperty()
	}
	p.SetState(3530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3526)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3527)
			p.MultipartIdentifierProperty()
		}

		p.SetState(3532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierPropertyContext is an interface to support dynamic dispatch.
type IMultipartIdentifierPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptions returns the options rule contexts.
	GetOptions() IPropertyListContext

	// SetOptions sets the options rule contexts.
	SetOptions(IPropertyListContext)

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	OPTIONS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsMultipartIdentifierPropertyContext differentiates from other interfaces.
	IsMultipartIdentifierPropertyContext()
}

type MultipartIdentifierPropertyContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	options IPropertyListContext
}

func NewEmptyMultipartIdentifierPropertyContext() *MultipartIdentifierPropertyContext {
	var p = new(MultipartIdentifierPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierProperty
	return p
}

func InitEmptyMultipartIdentifierPropertyContext(p *MultipartIdentifierPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierProperty
}

func (*MultipartIdentifierPropertyContext) IsMultipartIdentifierPropertyContext() {}

func NewMultipartIdentifierPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierPropertyContext {
	var p = new(MultipartIdentifierPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_multipartIdentifierProperty

	return p
}

func (s *MultipartIdentifierPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierPropertyContext) GetOptions() IPropertyListContext { return s.options }

func (s *MultipartIdentifierPropertyContext) SetOptions(v IPropertyListContext) { s.options = v }

func (s *MultipartIdentifierPropertyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *MultipartIdentifierPropertyContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, 0)
}

func (s *MultipartIdentifierPropertyContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *MultipartIdentifierPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMultipartIdentifierProperty(s)
	}
}

func (s *MultipartIdentifierPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMultipartIdentifierProperty(s)
	}
}

func (p *SqlBaseParser) MultipartIdentifierProperty() (localctx IMultipartIdentifierPropertyContext) {
	localctx = NewMultipartIdentifierPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SqlBaseParserRULE_multipartIdentifierProperty)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3533)
		p.MultipartIdentifier()
	}
	p.SetState(3536)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserOPTIONS {
		{
			p.SetState(3534)
			p.Match(SqlBaseParserOPTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3535)

			var _x = p.PropertyList()

			localctx.(*MultipartIdentifierPropertyContext).options = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableIdentifierContext is an interface to support dynamic dispatch.
type ITableIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IErrorCapturingIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IErrorCapturingIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IErrorCapturingIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	DOT() antlr.TerminalNode

	// IsTableIdentifierContext differentiates from other interfaces.
	IsTableIdentifierContext()
}

type TableIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IErrorCapturingIdentifierContext
	table  IErrorCapturingIdentifierContext
}

func NewEmptyTableIdentifierContext() *TableIdentifierContext {
	var p = new(TableIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableIdentifier
	return p
}

func InitEmptyTableIdentifierContext(p *TableIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableIdentifier
}

func (*TableIdentifierContext) IsTableIdentifierContext() {}

func NewTableIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIdentifierContext {
	var p = new(TableIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableIdentifier

	return p
}

func (s *TableIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIdentifierContext) GetDb() IErrorCapturingIdentifierContext { return s.db }

func (s *TableIdentifierContext) GetTable() IErrorCapturingIdentifierContext { return s.table }

func (s *TableIdentifierContext) SetDb(v IErrorCapturingIdentifierContext) { s.db = v }

func (s *TableIdentifierContext) SetTable(v IErrorCapturingIdentifierContext) { s.table = v }

func (s *TableIdentifierContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TableIdentifierContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *TableIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, 0)
}

func (s *TableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableIdentifier(s)
	}
}

func (s *TableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableIdentifier(s)
	}
}

func (p *SqlBaseParser) TableIdentifier() (localctx ITableIdentifierContext) {
	localctx = NewTableIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SqlBaseParserRULE_tableIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3541)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3538)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*TableIdentifierContext).db = _x
		}
		{
			p.SetState(3539)
			p.Match(SqlBaseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3543)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*TableIdentifierContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IErrorCapturingIdentifierContext

	// GetFunction returns the function rule contexts.
	GetFunction() IErrorCapturingIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IErrorCapturingIdentifierContext)

	// SetFunction sets the function rule contexts.
	SetFunction(IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	DOT() antlr.TerminalNode

	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	db       IErrorCapturingIdentifierContext
	function IErrorCapturingIdentifierContext
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionIdentifier
	return p
}

func InitEmptyFunctionIdentifierContext(p *FunctionIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionIdentifier
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionIdentifierContext) GetDb() IErrorCapturingIdentifierContext { return s.db }

func (s *FunctionIdentifierContext) GetFunction() IErrorCapturingIdentifierContext { return s.function }

func (s *FunctionIdentifierContext) SetDb(v IErrorCapturingIdentifierContext) { s.db = v }

func (s *FunctionIdentifierContext) SetFunction(v IErrorCapturingIdentifierContext) { s.function = v }

func (s *FunctionIdentifierContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *FunctionIdentifierContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *FunctionIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, 0)
}

func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionIdentifier(s)
	}
}

func (s *FunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionIdentifier(s)
	}
}

func (p *SqlBaseParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SqlBaseParserRULE_functionIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3548)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3545)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*FunctionIdentifierContext).db = _x
		}
		{
			p.SetState(3546)
			p.Match(SqlBaseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3550)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*FunctionIdentifierContext).function = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionContext is an interface to support dynamic dispatch.
type INamedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IErrorCapturingIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IErrorCapturingIdentifierContext)

	// Getter signatures
	Expression() IExpressionContext
	IdentifierList() IIdentifierListContext
	AS() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsNamedExpressionContext differentiates from other interfaces.
	IsNamedExpressionContext()
}

type NamedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IErrorCapturingIdentifierContext
}

func NewEmptyNamedExpressionContext() *NamedExpressionContext {
	var p = new(NamedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedExpression
	return p
}

func InitEmptyNamedExpressionContext(p *NamedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedExpression
}

func (*NamedExpressionContext) IsNamedExpressionContext() {}

func NewNamedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionContext {
	var p = new(NamedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedExpression

	return p
}

func (s *NamedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *NamedExpressionContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *NamedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedExpressionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *NamedExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *NamedExpressionContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *NamedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamedExpression(s)
	}
}

func (s *NamedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamedExpression(s)
	}
}

func (p *SqlBaseParser) NamedExpression() (localctx INamedExpressionContext) {
	localctx = NewNamedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SqlBaseParserRULE_namedExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3552)
		p.Expression()
	}
	p.SetState(3560)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 443, p.GetParserRuleContext()) == 1 {
		p.SetState(3554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3553)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 442, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3556)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*NamedExpressionContext).name = _x
			}

		case 2:
			{
				p.SetState(3557)
				p.IdentifierList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionSeqContext is an interface to support dynamic dispatch.
type INamedExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedExpressionSeqContext differentiates from other interfaces.
	IsNamedExpressionSeqContext()
}

type NamedExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionSeqContext() *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedExpressionSeq
	return p
}

func InitEmptyNamedExpressionSeqContext(p *NamedExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedExpressionSeq
}

func (*NamedExpressionSeqContext) IsNamedExpressionSeqContext() {}

func NewNamedExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedExpressionSeq

	return p
}

func (s *NamedExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionSeqContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NamedExpressionSeqContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *NamedExpressionSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *NamedExpressionSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *NamedExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamedExpressionSeq(s)
	}
}

func (s *NamedExpressionSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamedExpressionSeq(s)
	}
}

func (p *SqlBaseParser) NamedExpressionSeq() (localctx INamedExpressionSeqContext) {
	localctx = NewNamedExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SqlBaseParserRULE_namedExpressionSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3562)
		p.NamedExpression()
	}
	p.SetState(3567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 444, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3563)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3564)
				p.NamedExpression()
			}

		}
		p.SetState(3569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 444, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionFieldListContext is an interface to support dynamic dispatch.
type IPartitionFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionField returns the _partitionField rule contexts.
	Get_partitionField() IPartitionFieldContext

	// Set_partitionField sets the _partitionField rule contexts.
	Set_partitionField(IPartitionFieldContext)

	// GetFields returns the fields rule context list.
	GetFields() []IPartitionFieldContext

	// SetFields sets the fields rule context list.
	SetFields([]IPartitionFieldContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllPartitionField() []IPartitionFieldContext
	PartitionField(i int) IPartitionFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionFieldListContext differentiates from other interfaces.
	IsPartitionFieldListContext()
}

type PartitionFieldListContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_partitionField IPartitionFieldContext
	fields          []IPartitionFieldContext
}

func NewEmptyPartitionFieldListContext() *PartitionFieldListContext {
	var p = new(PartitionFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionFieldList
	return p
}

func InitEmptyPartitionFieldListContext(p *PartitionFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionFieldList
}

func (*PartitionFieldListContext) IsPartitionFieldListContext() {}

func NewPartitionFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFieldListContext {
	var p = new(PartitionFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_partitionFieldList

	return p
}

func (s *PartitionFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFieldListContext) Get_partitionField() IPartitionFieldContext {
	return s._partitionField
}

func (s *PartitionFieldListContext) Set_partitionField(v IPartitionFieldContext) {
	s._partitionField = v
}

func (s *PartitionFieldListContext) GetFields() []IPartitionFieldContext { return s.fields }

func (s *PartitionFieldListContext) SetFields(v []IPartitionFieldContext) { s.fields = v }

func (s *PartitionFieldListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *PartitionFieldListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *PartitionFieldListContext) AllPartitionField() []IPartitionFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionFieldContext); ok {
			len++
		}
	}

	tst := make([]IPartitionFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionFieldContext); ok {
			tst[i] = t.(IPartitionFieldContext)
			i++
		}
	}

	return tst
}

func (s *PartitionFieldListContext) PartitionField(i int) IPartitionFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFieldContext)
}

func (s *PartitionFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *PartitionFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *PartitionFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPartitionFieldList(s)
	}
}

func (s *PartitionFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPartitionFieldList(s)
	}
}

func (p *SqlBaseParser) PartitionFieldList() (localctx IPartitionFieldListContext) {
	localctx = NewPartitionFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SqlBaseParserRULE_partitionFieldList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3570)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3571)

		var _x = p.PartitionField()

		localctx.(*PartitionFieldListContext)._partitionField = _x
	}
	localctx.(*PartitionFieldListContext).fields = append(localctx.(*PartitionFieldListContext).fields, localctx.(*PartitionFieldListContext)._partitionField)
	p.SetState(3576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3572)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3573)

			var _x = p.PartitionField()

			localctx.(*PartitionFieldListContext)._partitionField = _x
		}
		localctx.(*PartitionFieldListContext).fields = append(localctx.(*PartitionFieldListContext).fields, localctx.(*PartitionFieldListContext)._partitionField)

		p.SetState(3578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3579)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionFieldContext is an interface to support dynamic dispatch.
type IPartitionFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionFieldContext differentiates from other interfaces.
	IsPartitionFieldContext()
}

type PartitionFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionFieldContext() *PartitionFieldContext {
	var p = new(PartitionFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionField
	return p
}

func InitEmptyPartitionFieldContext(p *PartitionFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionField
}

func (*PartitionFieldContext) IsPartitionFieldContext() {}

func NewPartitionFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFieldContext {
	var p = new(PartitionFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_partitionField

	return p
}

func (s *PartitionFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFieldContext) CopyAll(ctx *PartitionFieldContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionColumnContext struct {
	PartitionFieldContext
}

func NewPartitionColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionColumnContext {
	var p = new(PartitionColumnContext)

	InitEmptyPartitionFieldContext(&p.PartitionFieldContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFieldContext))

	return p
}

func (s *PartitionColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionColumnContext) ColType() IColTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *PartitionColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPartitionColumn(s)
	}
}

func (s *PartitionColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPartitionColumn(s)
	}
}

type PartitionTransformContext struct {
	PartitionFieldContext
}

func NewPartitionTransformContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionTransformContext {
	var p = new(PartitionTransformContext)

	InitEmptyPartitionFieldContext(&p.PartitionFieldContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFieldContext))

	return p
}

func (s *PartitionTransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTransformContext) Transform() ITransformContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransformContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *PartitionTransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPartitionTransform(s)
	}
}

func (s *PartitionTransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPartitionTransform(s)
	}
}

func (p *SqlBaseParser) PartitionField() (localctx IPartitionFieldContext) {
	localctx = NewPartitionFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SqlBaseParserRULE_partitionField)
	p.SetState(3583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionTransformContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3581)
			p.Transform()
		}

	case 2:
		localctx = NewPartitionColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3582)
			p.ColType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransformContext is an interface to support dynamic dispatch.
type ITransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTransformContext differentiates from other interfaces.
	IsTransformContext()
}

type TransformContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformContext() *TransformContext {
	var p = new(TransformContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transform
	return p
}

func InitEmptyTransformContext(p *TransformContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transform
}

func (*TransformContext) IsTransformContext() {}

func NewTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformContext {
	var p = new(TransformContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_transform

	return p
}

func (s *TransformContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformContext) CopyAll(ctx *TransformContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IdentityTransformContext struct {
	TransformContext
}

func NewIdentityTransformContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentityTransformContext {
	var p = new(IdentityTransformContext)

	InitEmptyTransformContext(&p.TransformContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransformContext))

	return p
}

func (s *IdentityTransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityTransformContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *IdentityTransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentityTransform(s)
	}
}

func (s *IdentityTransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentityTransform(s)
	}
}

type ApplyTransformContext struct {
	TransformContext
	transformName      IIdentifierContext
	_transformArgument ITransformArgumentContext
	argument           []ITransformArgumentContext
}

func NewApplyTransformContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ApplyTransformContext {
	var p = new(ApplyTransformContext)

	InitEmptyTransformContext(&p.TransformContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransformContext))

	return p
}

func (s *ApplyTransformContext) GetTransformName() IIdentifierContext { return s.transformName }

func (s *ApplyTransformContext) Get_transformArgument() ITransformArgumentContext {
	return s._transformArgument
}

func (s *ApplyTransformContext) SetTransformName(v IIdentifierContext) { s.transformName = v }

func (s *ApplyTransformContext) Set_transformArgument(v ITransformArgumentContext) {
	s._transformArgument = v
}

func (s *ApplyTransformContext) GetArgument() []ITransformArgumentContext { return s.argument }

func (s *ApplyTransformContext) SetArgument(v []ITransformArgumentContext) { s.argument = v }

func (s *ApplyTransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplyTransformContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ApplyTransformContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ApplyTransformContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ApplyTransformContext) AllTransformArgument() []ITransformArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransformArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITransformArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransformArgumentContext); ok {
			tst[i] = t.(ITransformArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ApplyTransformContext) TransformArgument(i int) ITransformArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransformArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransformArgumentContext)
}

func (s *ApplyTransformContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ApplyTransformContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ApplyTransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterApplyTransform(s)
	}
}

func (s *ApplyTransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitApplyTransform(s)
	}
}

func (p *SqlBaseParser) Transform() (localctx ITransformContext) {
	localctx = NewTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SqlBaseParserRULE_transform)
	var _la int

	p.SetState(3598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 448, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIdentityTransformContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3585)
			p.QualifiedName()
		}

	case 2:
		localctx = NewApplyTransformContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3586)

			var _x = p.Identifier()

			localctx.(*ApplyTransformContext).transformName = _x
		}
		{
			p.SetState(3587)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3588)

			var _x = p.TransformArgument()

			localctx.(*ApplyTransformContext)._transformArgument = _x
		}
		localctx.(*ApplyTransformContext).argument = append(localctx.(*ApplyTransformContext).argument, localctx.(*ApplyTransformContext)._transformArgument)
		p.SetState(3593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(3589)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3590)

				var _x = p.TransformArgument()

				localctx.(*ApplyTransformContext)._transformArgument = _x
			}
			localctx.(*ApplyTransformContext).argument = append(localctx.(*ApplyTransformContext).argument, localctx.(*ApplyTransformContext)._transformArgument)

			p.SetState(3595)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3596)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransformArgumentContext is an interface to support dynamic dispatch.
type ITransformArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	Constant() IConstantContext

	// IsTransformArgumentContext differentiates from other interfaces.
	IsTransformArgumentContext()
}

type TransformArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformArgumentContext() *TransformArgumentContext {
	var p = new(TransformArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transformArgument
	return p
}

func InitEmptyTransformArgumentContext(p *TransformArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transformArgument
}

func (*TransformArgumentContext) IsTransformArgumentContext() {}

func NewTransformArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformArgumentContext {
	var p = new(TransformArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_transformArgument

	return p
}

func (s *TransformArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformArgumentContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TransformArgumentContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *TransformArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTransformArgument(s)
	}
}

func (s *TransformArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTransformArgument(s)
	}
}

func (p *SqlBaseParser) TransformArgument() (localctx ITransformArgumentContext) {
	localctx = NewTransformArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SqlBaseParserRULE_transformArgument)
	p.SetState(3602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 449, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3600)
			p.QualifiedName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3601)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SqlBaseParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SqlBaseParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3604)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentExpressionContext is an interface to support dynamic dispatch.
type INamedArgumentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	FAT_ARROW() antlr.TerminalNode
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsNamedArgumentExpressionContext differentiates from other interfaces.
	IsNamedArgumentExpressionContext()
}

type NamedArgumentExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IIdentifierContext
	value  IExpressionContext
}

func NewEmptyNamedArgumentExpressionContext() *NamedArgumentExpressionContext {
	var p = new(NamedArgumentExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedArgumentExpression
	return p
}

func InitEmptyNamedArgumentExpressionContext(p *NamedArgumentExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedArgumentExpression
}

func (*NamedArgumentExpressionContext) IsNamedArgumentExpressionContext() {}

func NewNamedArgumentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentExpressionContext {
	var p = new(NamedArgumentExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedArgumentExpression

	return p
}

func (s *NamedArgumentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentExpressionContext) GetKey() IIdentifierContext { return s.key }

func (s *NamedArgumentExpressionContext) GetValue() IExpressionContext { return s.value }

func (s *NamedArgumentExpressionContext) SetKey(v IIdentifierContext) { s.key = v }

func (s *NamedArgumentExpressionContext) SetValue(v IExpressionContext) { s.value = v }

func (s *NamedArgumentExpressionContext) FAT_ARROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFAT_ARROW, 0)
}

func (s *NamedArgumentExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamedArgumentExpression(s)
	}
}

func (s *NamedArgumentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamedArgumentExpression(s)
	}
}

func (p *SqlBaseParser) NamedArgumentExpression() (localctx INamedArgumentExpressionContext) {
	localctx = NewNamedArgumentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SqlBaseParserRULE_namedArgumentExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3606)

		var _x = p.Identifier()

		localctx.(*NamedArgumentExpressionContext).key = _x
	}
	{
		p.SetState(3607)
		p.Match(SqlBaseParserFAT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3608)

		var _x = p.Expression()

		localctx.(*NamedArgumentExpressionContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentContext is an interface to support dynamic dispatch.
type IFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	NamedArgumentExpression() INamedArgumentExpressionContext

	// IsFunctionArgumentContext differentiates from other interfaces.
	IsFunctionArgumentContext()
}

type FunctionArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentContext() *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionArgument
	return p
}

func InitEmptyFunctionArgumentContext(p *FunctionArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionArgument
}

func (*FunctionArgumentContext) IsFunctionArgumentContext() {}

func NewFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionArgument

	return p
}

func (s *FunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgumentContext) NamedArgumentExpression() INamedArgumentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentExpressionContext)
}

func (s *FunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionArgument(s)
	}
}

func (s *FunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionArgument(s)
	}
}

func (p *SqlBaseParser) FunctionArgument() (localctx IFunctionArgumentContext) {
	localctx = NewFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SqlBaseParserRULE_functionArgument)
	p.SetState(3612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 450, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3610)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3611)
			p.NamedArgumentExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSeqContext is an interface to support dynamic dispatch.
type IExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionSeqContext differentiates from other interfaces.
	IsExpressionSeqContext()
}

type ExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSeqContext() *ExpressionSeqContext {
	var p = new(ExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expressionSeq
	return p
}

func InitEmptyExpressionSeqContext(p *ExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expressionSeq
}

func (*ExpressionSeqContext) IsExpressionSeqContext() {}

func NewExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSeqContext {
	var p = new(ExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expressionSeq

	return p
}

func (s *ExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSeqContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionSeqContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ExpressionSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExpressionSeq(s)
	}
}

func (s *ExpressionSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExpressionSeq(s)
	}
}

func (p *SqlBaseParser) ExpressionSeq() (localctx IExpressionSeqContext) {
	localctx = NewExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SqlBaseParserRULE_expressionSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3614)
		p.Expression()
	}
	p.SetState(3619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(3615)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3616)
			p.Expression()
		}

		p.SetState(3621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LogicalNotContext) BANG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBANG, 0)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type ExistsContext struct {
	BooleanExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *ExistsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExists(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *SqlBaseParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SqlBaseParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 336
	p.EnterRecursionRule(localctx, 336, SqlBaseParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 453, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3623)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserBANG || _la == SqlBaseParserNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3624)
			p.booleanExpression(5)
		}

	case 2:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3625)
			p.Match(SqlBaseParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3626)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3627)
			p.Query()
		}
		{
			p.SetState(3628)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3630)
			p.valueExpression(0)
		}
		p.SetState(3632)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3631)
				p.Predicate()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 455, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3642)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 454, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(3636)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3637)

					var _m = p.Match(SqlBaseParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3638)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(3639)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3640)

					var _m = p.Match(SqlBaseParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3641)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 455, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// GetQuantifier returns the quantifier token.
	GetQuantifier() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// SetQuantifier sets the quantifier token.
	SetQuantifier(antlr.Token)

	// GetLower returns the lower rule contexts.
	GetLower() IValueExpressionContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IValueExpressionContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IValueExpressionContext

	// GetEscapeChar returns the escapeChar rule contexts.
	GetEscapeChar() IStringLitContext

	// GetRight returns the right rule contexts.
	GetRight() IValueExpressionContext

	// SetLower sets the lower rule contexts.
	SetLower(IValueExpressionContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IValueExpressionContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IValueExpressionContext)

	// SetEscapeChar sets the escapeChar rule contexts.
	SetEscapeChar(IStringLitContext)

	// SetRight sets the right rule contexts.
	SetRight(IValueExpressionContext)

	// Getter signatures
	AND() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	ErrorCapturingNot() IErrorCapturingNotContext
	LEFT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Query() IQueryContext
	RLIKE() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	ANY() antlr.TerminalNode
	SOME() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	StringLit() IStringLitContext
	IS() antlr.TerminalNode
	NULL() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	FROM() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	kind       antlr.Token
	lower      IValueExpressionContext
	upper      IValueExpressionContext
	pattern    IValueExpressionContext
	quantifier antlr.Token
	escapeChar IStringLitContext
	right      IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetKind() antlr.Token { return s.kind }

func (s *PredicateContext) GetQuantifier() antlr.Token { return s.quantifier }

func (s *PredicateContext) SetKind(v antlr.Token) { s.kind = v }

func (s *PredicateContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *PredicateContext) GetLower() IValueExpressionContext { return s.lower }

func (s *PredicateContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *PredicateContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *PredicateContext) GetEscapeChar() IStringLitContext { return s.escapeChar }

func (s *PredicateContext) GetRight() IValueExpressionContext { return s.right }

func (s *PredicateContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *PredicateContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *PredicateContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *PredicateContext) SetEscapeChar(v IStringLitContext) { s.escapeChar = v }

func (s *PredicateContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *PredicateContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *PredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *PredicateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *PredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *PredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *PredicateContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *PredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRLIKE, 0)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *PredicateContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserILIKE, 0)
}

func (s *PredicateContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *PredicateContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *PredicateContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *PredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *PredicateContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *PredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *PredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *PredicateContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *PredicateContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFALSE, 0)
}

func (s *PredicateContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNKNOWN, 0)
}

func (s *PredicateContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *PredicateContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *SqlBaseParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SqlBaseParserRULE_predicate)
	var _la int

	p.SetState(3729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 469, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3647)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3650)

			var _m = p.Match(SqlBaseParserBETWEEN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3651)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).lower = _x
		}
		{
			p.SetState(3652)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3653)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).upper = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3655)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3658)

			var _m = p.Match(SqlBaseParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3659)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3660)
			p.Expression()
		}
		p.SetState(3665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserCOMMA {
			{
				p.SetState(3661)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3662)
				p.Expression()
			}

			p.SetState(3667)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3668)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3670)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3673)

			var _m = p.Match(SqlBaseParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3674)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3675)
			p.Query()
		}
		{
			p.SetState(3676)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3678)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3681)

			var _m = p.Match(SqlBaseParserRLIKE)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3682)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(3684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3683)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3686)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserLIKE || _la == SqlBaseParserILIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3687)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).quantifier = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserALL || _la == SqlBaseParserANY || _la == SqlBaseParserSOME) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).quantifier = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 463, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3688)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3689)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3690)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3691)
				p.Expression()
			}
			p.SetState(3696)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(3692)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3693)
					p.Expression()
				}

				p.SetState(3698)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3699)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(3704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3703)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3706)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserLIKE || _la == SqlBaseParserILIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3707)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}
		p.SetState(3710)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 465, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3708)
				p.Match(SqlBaseParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3709)

				var _x = p.StringLit()

				localctx.(*PredicateContext).escapeChar = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3712)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3713)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3716)

			var _m = p.Match(SqlBaseParserNULL)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3717)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3718)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3721)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFALSE || _la == SqlBaseParserTRUE || _la == SqlBaseParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3722)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
			{
				p.SetState(3723)
				p.ErrorCapturingNot()
			}

		}
		{
			p.SetState(3726)

			var _m = p.Match(SqlBaseParserDISTINCT)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3727)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3728)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingNotContext is an interface to support dynamic dispatch.
type IErrorCapturingNotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	BANG() antlr.TerminalNode

	// IsErrorCapturingNotContext differentiates from other interfaces.
	IsErrorCapturingNotContext()
}

type ErrorCapturingNotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingNotContext() *ErrorCapturingNotContext {
	var p = new(ErrorCapturingNotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingNot
	return p
}

func InitEmptyErrorCapturingNotContext(p *ErrorCapturingNotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingNot
}

func (*ErrorCapturingNotContext) IsErrorCapturingNotContext() {}

func NewErrorCapturingNotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingNotContext {
	var p = new(ErrorCapturingNotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_errorCapturingNot

	return p
}

func (s *ErrorCapturingNotContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *ErrorCapturingNotContext) BANG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBANG, 0)
}

func (s *ErrorCapturingNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingNotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterErrorCapturingNot(s)
	}
}

func (s *ErrorCapturingNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitErrorCapturingNot(s)
	}
}

func (p *SqlBaseParser) ErrorCapturingNot() (localctx IErrorCapturingNotContext) {
	localctx = NewErrorCapturingNotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SqlBaseParserRULE_errorCapturingNot)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3731)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserBANG || _la == SqlBaseParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ComparisonContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

type ShiftExpressionContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ShiftExpressionContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ShiftExpressionContext) GetRight() IValueExpressionContext { return s.right }

func (s *ShiftExpressionContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ShiftExpressionContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExpressionContext) ShiftOperator() IShiftOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftOperatorContext)
}

func (s *ShiftExpressionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExpressionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShiftExpression(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) DIV() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIV, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) CONCAT_PIPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCAT_PIPE, 0)
}

func (s *ArithmeticBinaryContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAMPERSAND, 0)
}

func (s *ArithmeticBinaryContext) HAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAT, 0)
}

func (s *ArithmeticBinaryContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPIPE, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTILDE, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (p *SqlBaseParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SqlBaseParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 342
	p.EnterRecursionRule(localctx, 342, SqlBaseParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 470, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3734)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3735)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-413)) & ^0x3f) == 0 && ((int64(1)<<(_la-413))&35) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3736)
			p.valueExpression(8)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3762)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 471, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(3739)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(3740)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserDIV || ((int64((_la-415)) & ^0x3f) == 0 && ((int64(1)<<(_la-415))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3741)

					var _x = p.valueExpression(8)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(3742)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(3743)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-413)) & ^0x3f) == 0 && ((int64(1)<<(_la-413))&259) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3744)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewShiftExpressionContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ShiftExpressionContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(3745)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(3746)
					p.ShiftOperator()
				}
				{
					p.SetState(3747)

					var _x = p.valueExpression(6)

					localctx.(*ShiftExpressionContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(3749)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(3750)

					var _m = p.Match(SqlBaseParserAMPERSAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3751)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(3752)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(3753)

					var _m = p.Match(SqlBaseParserHAT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3754)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(3755)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3756)

					var _m = p.Match(SqlBaseParserPIPE)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3757)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 7:
				localctx = NewComparisonContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(3758)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3759)
					p.ComparisonOperator()
				}
				{
					p.SetState(3760)

					var _x = p.valueExpression(2)

					localctx.(*ComparisonContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftOperatorContext is an interface to support dynamic dispatch.
type IShiftOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHIFT_LEFT() antlr.TerminalNode
	SHIFT_RIGHT() antlr.TerminalNode
	SHIFT_RIGHT_UNSIGNED() antlr.TerminalNode

	// IsShiftOperatorContext differentiates from other interfaces.
	IsShiftOperatorContext()
}

type ShiftOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftOperatorContext() *ShiftOperatorContext {
	var p = new(ShiftOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_shiftOperator
	return p
}

func InitEmptyShiftOperatorContext(p *ShiftOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_shiftOperator
}

func (*ShiftOperatorContext) IsShiftOperatorContext() {}

func NewShiftOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftOperatorContext {
	var p = new(ShiftOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_shiftOperator

	return p
}

func (s *ShiftOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftOperatorContext) SHIFT_LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHIFT_LEFT, 0)
}

func (s *ShiftOperatorContext) SHIFT_RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHIFT_RIGHT, 0)
}

func (s *ShiftOperatorContext) SHIFT_RIGHT_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHIFT_RIGHT_UNSIGNED, 0)
}

func (s *ShiftOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterShiftOperator(s)
	}
}

func (s *ShiftOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitShiftOperator(s)
	}
}

func (p *SqlBaseParser) ShiftOperator() (localctx IShiftOperatorContext) {
	localctx = NewShiftOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SqlBaseParserRULE_shiftOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3767)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-410)) & ^0x3f) == 0 && ((int64(1)<<(_la-410))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeUnitContext is an interface to support dynamic dispatch.
type IDatetimeUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsDatetimeUnitContext differentiates from other interfaces.
	IsDatetimeUnitContext()
}

type DatetimeUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeUnitContext() *DatetimeUnitContext {
	var p = new(DatetimeUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_datetimeUnit
	return p
}

func InitEmptyDatetimeUnitContext(p *DatetimeUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_datetimeUnit
}

func (*DatetimeUnitContext) IsDatetimeUnitContext() {}

func NewDatetimeUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeUnitContext {
	var p = new(DatetimeUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_datetimeUnit

	return p
}

func (s *DatetimeUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeUnitContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *DatetimeUnitContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUARTER, 0)
}

func (s *DatetimeUnitContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *DatetimeUnitContext) WEEK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWEEK, 0)
}

func (s *DatetimeUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *DatetimeUnitContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAYOFYEAR, 0)
}

func (s *DatetimeUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *DatetimeUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *DatetimeUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *DatetimeUnitContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECOND, 0)
}

func (s *DatetimeUnitContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMICROSECOND, 0)
}

func (s *DatetimeUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDatetimeUnit(s)
	}
}

func (s *DatetimeUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDatetimeUnit(s)
	}
}

func (p *SqlBaseParser) DatetimeUnit() (localctx IDatetimeUnitContext) {
	localctx = NewDatetimeUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SqlBaseParserRULE_datetimeUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3769)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDAY || _la == SqlBaseParserDAYOFYEAR || ((int64((_la-155)) & ^0x3f) == 0 && ((int64(1)<<(_la-155))&6052837899185946625) != 0) || _la == SqlBaseParserMONTH || _la == SqlBaseParserQUARTER || _la == SqlBaseParserSECOND || _la == SqlBaseParserWEEK || _la == SqlBaseParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StructContext struct {
	PrimaryExpressionContext
	_namedExpression INamedExpressionContext
	argument         []INamedExpressionContext
}

func NewStructContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructContext {
	var p = new(StructContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StructContext) Get_namedExpression() INamedExpressionContext { return s._namedExpression }

func (s *StructContext) Set_namedExpression(v INamedExpressionContext) { s._namedExpression = v }

func (s *StructContext) GetArgument() []INamedExpressionContext { return s.argument }

func (s *StructContext) SetArgument(v []INamedExpressionContext) { s.argument = v }

func (s *StructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT, 0)
}

func (s *StructContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *StructContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *StructContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StructContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *StructContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *StructContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *StructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStruct(s)
	}
}

func (s *StructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStruct(s)
	}
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

type CastByColonContext struct {
	PrimaryExpressionContext
}

func NewCastByColonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastByColonContext {
	var p = new(CastByColonContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastByColonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastByColonContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CastByColonContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_COLON, 0)
}

func (s *CastByColonContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastByColonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCastByColon(s)
	}
}

func (s *CastByColonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCastByColon(s)
	}
}

type TimestampaddContext struct {
	PrimaryExpressionContext
	name        antlr.Token
	unit        IDatetimeUnitContext
	invalidUnit IStringLitContext
	unitsAmount IValueExpressionContext
	timestamp   IValueExpressionContext
}

func NewTimestampaddContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimestampaddContext {
	var p = new(TimestampaddContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TimestampaddContext) GetName() antlr.Token { return s.name }

func (s *TimestampaddContext) SetName(v antlr.Token) { s.name = v }

func (s *TimestampaddContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *TimestampaddContext) GetInvalidUnit() IStringLitContext { return s.invalidUnit }

func (s *TimestampaddContext) GetUnitsAmount() IValueExpressionContext { return s.unitsAmount }

func (s *TimestampaddContext) GetTimestamp() IValueExpressionContext { return s.timestamp }

func (s *TimestampaddContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *TimestampaddContext) SetInvalidUnit(v IStringLitContext) { s.invalidUnit = v }

func (s *TimestampaddContext) SetUnitsAmount(v IValueExpressionContext) { s.unitsAmount = v }

func (s *TimestampaddContext) SetTimestamp(v IValueExpressionContext) { s.timestamp = v }

func (s *TimestampaddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampaddContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *TimestampaddContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *TimestampaddContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *TimestampaddContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *TimestampaddContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TimestampaddContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TimestampaddContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMPADD, 0)
}

func (s *TimestampaddContext) DATEADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATEADD, 0)
}

func (s *TimestampaddContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE_ADD, 0)
}

func (s *TimestampaddContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *TimestampaddContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *TimestampaddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTimestampadd(s)
	}
}

func (s *TimestampaddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTimestampadd(s)
	}
}

type SubstringContext struct {
	PrimaryExpressionContext
	str  IValueExpressionContext
	pos  IValueExpressionContext
	len_ IValueExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetStr() IValueExpressionContext { return s.str }

func (s *SubstringContext) GetPos() IValueExpressionContext { return s.pos }

func (s *SubstringContext) GetLen_() IValueExpressionContext { return s.len_ }

func (s *SubstringContext) SetStr(v IValueExpressionContext) { s.str = v }

func (s *SubstringContext) SetPos(v IValueExpressionContext) { s.pos = v }

func (s *SubstringContext) SetLen_(v IValueExpressionContext) { s.len_ = v }

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *SubstringContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *SubstringContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTR, 0)
}

func (s *SubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *SubstringContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *SubstringContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *SubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSubstring(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetName() antlr.Token { return s.name }

func (s *CastContext) SetName(v antlr.Token) { s.name = v }

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CastContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCAST, 0)
}

func (s *CastContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCast(s)
	}
}

type LambdaContext struct {
	PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARROW, 0)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *LambdaContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *LambdaContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *LambdaContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLambda(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type Any_valueContext struct {
	PrimaryExpressionContext
}

func NewAny_valueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Any_valueContext {
	var p = new(Any_valueContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *Any_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Any_valueContext) ANY_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY_VALUE, 0)
}

func (s *Any_valueContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *Any_valueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Any_valueContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *Any_valueContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *Any_valueContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *Any_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAny_value(s)
	}
}

func (s *Any_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAny_value(s)
	}
}

type TrimContext struct {
	PrimaryExpressionContext
	trimOption antlr.Token
	trimStr    IValueExpressionContext
	srcStr     IValueExpressionContext
}

func NewTrimContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TrimContext {
	var p = new(TrimContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TrimContext) GetTrimOption() antlr.Token { return s.trimOption }

func (s *TrimContext) SetTrimOption(v antlr.Token) { s.trimOption = v }

func (s *TrimContext) GetTrimStr() IValueExpressionContext { return s.trimStr }

func (s *TrimContext) GetSrcStr() IValueExpressionContext { return s.srcStr }

func (s *TrimContext) SetTrimStr(v IValueExpressionContext) { s.trimStr = v }

func (s *TrimContext) SetSrcStr(v IValueExpressionContext) { s.srcStr = v }

func (s *TrimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimContext) TRIM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRIM, 0)
}

func (s *TrimContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *TrimContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *TrimContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *TrimContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TrimContext) BOTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBOTH, 0)
}

func (s *TrimContext) LEADING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEADING, 0)
}

func (s *TrimContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRAILING, 0)
}

func (s *TrimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTrim(s)
	}
}

func (s *TrimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTrim(s)
	}
}

type SemiStructuredExtractContext struct {
	PrimaryExpressionContext
	col  IPrimaryExpressionContext
	path ISemiStructuredExtractionPathContext
}

func NewSemiStructuredExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SemiStructuredExtractContext {
	var p = new(SemiStructuredExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SemiStructuredExtractContext) GetCol() IPrimaryExpressionContext { return s.col }

func (s *SemiStructuredExtractContext) GetPath() ISemiStructuredExtractionPathContext { return s.path }

func (s *SemiStructuredExtractContext) SetCol(v IPrimaryExpressionContext) { s.col = v }

func (s *SemiStructuredExtractContext) SetPath(v ISemiStructuredExtractionPathContext) { s.path = v }

func (s *SemiStructuredExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemiStructuredExtractContext) COLON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLON, 0)
}

func (s *SemiStructuredExtractContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SemiStructuredExtractContext) SemiStructuredExtractionPath() ISemiStructuredExtractionPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiStructuredExtractionPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiStructuredExtractionPathContext)
}

func (s *SemiStructuredExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSemiStructuredExtract(s)
	}
}

func (s *SemiStructuredExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSemiStructuredExtract(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	value          IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetValue() IExpressionContext { return s.value }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetValue(v IExpressionContext) { s.value = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type CurrentLikeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentLikeContext {
	var p = new(CurrentLikeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentLikeContext) GetName() antlr.Token { return s.name }

func (s *CurrentLikeContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentLikeContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_DATE, 0)
}

func (s *CurrentLikeContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentLikeContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_USER, 0)
}

func (s *CurrentLikeContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSER, 0)
}

func (s *CurrentLikeContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION_USER, 0)
}

func (s *CurrentLikeContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIME, 0)
}

func (s *CurrentLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCurrentLike(s)
	}
}

func (s *CurrentLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCurrentLike(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type RowConstructorContext struct {
	PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *RowConstructorContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RowConstructorContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *RowConstructorContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *RowConstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *RowConstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

type LastContext struct {
	PrimaryExpressionContext
}

func NewLastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LastContext {
	var p = new(LastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *LastContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *LastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LastContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *LastContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *LastContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *LastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLast(s)
	}
}

func (s *LastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLast(s)
	}
}

type StarContext struct {
	PrimaryExpressionContext
}

func NewStarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StarContext {
	var p = new(StarContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *StarContext) ExceptClause() IExceptClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptClauseContext)
}

func (s *StarContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StarContext) DOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, 0)
}

func (s *StarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStar(s)
	}
}

func (s *StarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStar(s)
	}
}

type OverlayContext struct {
	PrimaryExpressionContext
	input    IValueExpressionContext
	replace  IValueExpressionContext
	position IValueExpressionContext
	length   IValueExpressionContext
}

func NewOverlayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OverlayContext {
	var p = new(OverlayContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *OverlayContext) GetInput() IValueExpressionContext { return s.input }

func (s *OverlayContext) GetReplace() IValueExpressionContext { return s.replace }

func (s *OverlayContext) GetPosition() IValueExpressionContext { return s.position }

func (s *OverlayContext) GetLength() IValueExpressionContext { return s.length }

func (s *OverlayContext) SetInput(v IValueExpressionContext) { s.input = v }

func (s *OverlayContext) SetReplace(v IValueExpressionContext) { s.replace = v }

func (s *OverlayContext) SetPosition(v IValueExpressionContext) { s.position = v }

func (s *OverlayContext) SetLength(v IValueExpressionContext) { s.length = v }

func (s *OverlayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverlayContext) OVERLAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERLAY, 0)
}

func (s *OverlayContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *OverlayContext) PLACING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLACING, 0)
}

func (s *OverlayContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *OverlayContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *OverlayContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OverlayContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *OverlayContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *OverlayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterOverlay(s)
	}
}

func (s *OverlayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitOverlay(s)
	}
}

type SubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_BRACKET, 0)
}

func (s *SubscriptContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_BRACKET, 0)
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type TimestampdiffContext struct {
	PrimaryExpressionContext
	name           antlr.Token
	unit           IDatetimeUnitContext
	invalidUnit    IStringLitContext
	startTimestamp IValueExpressionContext
	endTimestamp   IValueExpressionContext
}

func NewTimestampdiffContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimestampdiffContext {
	var p = new(TimestampdiffContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TimestampdiffContext) GetName() antlr.Token { return s.name }

func (s *TimestampdiffContext) SetName(v antlr.Token) { s.name = v }

func (s *TimestampdiffContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *TimestampdiffContext) GetInvalidUnit() IStringLitContext { return s.invalidUnit }

func (s *TimestampdiffContext) GetStartTimestamp() IValueExpressionContext { return s.startTimestamp }

func (s *TimestampdiffContext) GetEndTimestamp() IValueExpressionContext { return s.endTimestamp }

func (s *TimestampdiffContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *TimestampdiffContext) SetInvalidUnit(v IStringLitContext) { s.invalidUnit = v }

func (s *TimestampdiffContext) SetStartTimestamp(v IValueExpressionContext) { s.startTimestamp = v }

func (s *TimestampdiffContext) SetEndTimestamp(v IValueExpressionContext) { s.endTimestamp = v }

func (s *TimestampdiffContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampdiffContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *TimestampdiffContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *TimestampdiffContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *TimestampdiffContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *TimestampdiffContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TimestampdiffContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TimestampdiffContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMPDIFF, 0)
}

func (s *TimestampdiffContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATEDIFF, 0)
}

func (s *TimestampdiffContext) DATE_DIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE_DIFF, 0)
}

func (s *TimestampdiffContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMEDIFF, 0)
}

func (s *TimestampdiffContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *TimestampdiffContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *TimestampdiffContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTimestampdiff(s)
	}
}

func (s *TimestampdiffContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTimestampdiff(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) CollateClause() ICollateClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCollate(s)
	}
}

type ConstantDefaultContext struct {
	PrimaryExpressionContext
}

func NewConstantDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantDefaultContext {
	var p = new(ConstantDefaultContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConstantDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefaultContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterConstantDefault(s)
	}
}

func (s *ConstantDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitConstantDefault(s)
	}
}

type ExtractContext struct {
	PrimaryExpressionContext
	field  IIdentifierContext
	source IValueExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetField() IIdentifierContext { return s.field }

func (s *ExtractContext) GetSource() IValueExpressionContext { return s.source }

func (s *ExtractContext) SetField(v IIdentifierContext) { s.field = v }

func (s *ExtractContext) SetSource(v IValueExpressionContext) { s.source = v }

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTRACT, 0)
}

func (s *ExtractContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ExtractContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExtract(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
	_functionArgument IFunctionArgumentContext
	argument          []IFunctionArgumentContext
	where             IBooleanExpressionContext
	nullsOption       antlr.Token
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetNullsOption() antlr.Token { return s.nullsOption }

func (s *FunctionCallContext) SetNullsOption(v antlr.Token) { s.nullsOption = v }

func (s *FunctionCallContext) Get_functionArgument() IFunctionArgumentContext {
	return s._functionArgument
}

func (s *FunctionCallContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *FunctionCallContext) Set_functionArgument(v IFunctionArgumentContext) {
	s._functionArgument = v
}

func (s *FunctionCallContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *FunctionCallContext) GetArgument() []IFunctionArgumentContext { return s.argument }

func (s *FunctionCallContext) SetArgument(v []IFunctionArgumentContext) { s.argument = v }

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionCallContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserLEFT_PAREN)
}

func (s *FunctionCallContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, i)
}

func (s *FunctionCallContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserRIGHT_PAREN)
}

func (s *FunctionCallContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, i)
}

func (s *FunctionCallContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHIN, 0)
}

func (s *FunctionCallContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *FunctionCallContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *FunctionCallContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *FunctionCallContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *FunctionCallContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *FunctionCallContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *FunctionCallContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *FunctionCallContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *FunctionCallContext) AllFunctionArgument() []IFunctionArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgumentContext); ok {
			tst[i] = t.(IFunctionArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionCallContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FunctionCallContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *FunctionCallContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESPECT, 0)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *FunctionCallContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type PositionContext struct {
	PrimaryExpressionContext
	substr IValueExpressionContext
	str    IValueExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetSubstr() IValueExpressionContext { return s.substr }

func (s *PositionContext) GetStr() IValueExpressionContext { return s.str }

func (s *PositionContext) SetSubstr(v IValueExpressionContext) { s.substr = v }

func (s *PositionContext) SetStr(v IValueExpressionContext) { s.str = v }

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *PositionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *PositionContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *PositionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPosition(s)
	}
}

type FirstContext struct {
	PrimaryExpressionContext
}

func NewFirstContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FirstContext {
	var p = new(FirstContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FirstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FirstContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *FirstContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *FirstContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FirstContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *FirstContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *FirstContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *FirstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFirst(s)
	}
}

func (s *FirstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFirst(s)
	}
}

func (p *SqlBaseParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SqlBaseParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 348
	p.EnterRecursionRule(localctx, 348, SqlBaseParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentLikeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3772)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CurrentLikeContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&15) != 0) || _la == SqlBaseParserSESSION_USER || _la == SqlBaseParserUSER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CurrentLikeContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		localctx = NewTimestampaddContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3773)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TimestampaddContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDATEADD || _la == SqlBaseParserDATE_ADD || _la == SqlBaseParserTIMESTAMPADD) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TimestampaddContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3774)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 473, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3775)

				var _x = p.DatetimeUnit()

				localctx.(*TimestampaddContext).unit = _x
			}

		case 2:
			{
				p.SetState(3776)

				var _x = p.StringLit()

				localctx.(*TimestampaddContext).invalidUnit = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3779)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3780)

			var _x = p.valueExpression(0)

			localctx.(*TimestampaddContext).unitsAmount = _x
		}
		{
			p.SetState(3781)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3782)

			var _x = p.valueExpression(0)

			localctx.(*TimestampaddContext).timestamp = _x
		}
		{
			p.SetState(3783)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewTimestampdiffContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3785)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TimestampdiffContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDATEDIFF || _la == SqlBaseParserDATE_DIFF || _la == SqlBaseParserTIMEDIFF || _la == SqlBaseParserTIMESTAMPDIFF) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TimestampdiffContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3786)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 474, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3787)

				var _x = p.DatetimeUnit()

				localctx.(*TimestampdiffContext).unit = _x
			}

		case 2:
			{
				p.SetState(3788)

				var _x = p.StringLit()

				localctx.(*TimestampdiffContext).invalidUnit = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3791)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3792)

			var _x = p.valueExpression(0)

			localctx.(*TimestampdiffContext).startTimestamp = _x
		}
		{
			p.SetState(3793)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3794)

			var _x = p.valueExpression(0)

			localctx.(*TimestampdiffContext).endTimestamp = _x
		}
		{
			p.SetState(3795)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3797)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(3798)
				p.WhenClause()
			}

			p.SetState(3801)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(3803)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3804)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(3807)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3809)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3810)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).value = _x
		}
		p.SetState(3812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(3811)
				p.WhenClause()
			}

			p.SetState(3814)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(3816)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3817)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(3820)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3822)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CastContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCAST || _la == SqlBaseParserTRY_CAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CastContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3823)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3824)
			p.Expression()
		}
		{
			p.SetState(3825)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3826)
			p.DataType()
		}
		{
			p.SetState(3827)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewStructContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3829)
			p.Match(SqlBaseParserSTRUCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3830)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3839)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3831)

				var _x = p.NamedExpression()

				localctx.(*StructContext)._namedExpression = _x
			}
			localctx.(*StructContext).argument = append(localctx.(*StructContext).argument, localctx.(*StructContext)._namedExpression)
			p.SetState(3836)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(3832)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3833)

					var _x = p.NamedExpression()

					localctx.(*StructContext)._namedExpression = _x
				}
				localctx.(*StructContext).argument = append(localctx.(*StructContext).argument, localctx.(*StructContext)._namedExpression)

				p.SetState(3838)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3841)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewFirstContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3842)
			p.Match(SqlBaseParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3843)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3844)
			p.Expression()
		}
		p.SetState(3847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIGNORE {
			{
				p.SetState(3845)
				p.Match(SqlBaseParserIGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3846)
				p.Match(SqlBaseParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3849)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewAny_valueContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3851)
			p.Match(SqlBaseParserANY_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3852)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3853)
			p.Expression()
		}
		p.SetState(3856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIGNORE {
			{
				p.SetState(3854)
				p.Match(SqlBaseParserIGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3855)
				p.Match(SqlBaseParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3858)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewLastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3860)
			p.Match(SqlBaseParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3861)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3862)
			p.Expression()
		}
		p.SetState(3865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserIGNORE {
			{
				p.SetState(3863)
				p.Match(SqlBaseParserIGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3864)
				p.Match(SqlBaseParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3867)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3869)
			p.Match(SqlBaseParserPOSITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3870)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3871)

			var _x = p.valueExpression(0)

			localctx.(*PositionContext).substr = _x
		}
		{
			p.SetState(3872)
			p.Match(SqlBaseParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3873)

			var _x = p.valueExpression(0)

			localctx.(*PositionContext).str = _x
		}
		{
			p.SetState(3874)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewConstantDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3876)
			p.Constant()
		}

	case 13:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3877)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3879)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 484, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3878)
				p.ExceptClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3881)
			p.QualifiedName()
		}
		{
			p.SetState(3882)
			p.Match(SqlBaseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3883)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3885)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3884)
				p.ExceptClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 15:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3887)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3888)
			p.NamedExpression()
		}
		p.SetState(3891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserCOMMA {
			{
				p.SetState(3889)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3890)
				p.NamedExpression()
			}

			p.SetState(3893)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3895)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3897)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3898)
			p.Query()
		}
		{
			p.SetState(3899)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3901)
			p.FunctionName()
		}
		{
			p.SetState(3902)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3914)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 489, p.GetParserRuleContext()) == 1 {
			p.SetState(3904)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 487, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3903)
					p.SetQuantifier()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3906)

				var _x = p.FunctionArgument()

				localctx.(*FunctionCallContext)._functionArgument = _x
			}
			localctx.(*FunctionCallContext).argument = append(localctx.(*FunctionCallContext).argument, localctx.(*FunctionCallContext)._functionArgument)
			p.SetState(3911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(3907)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3908)

					var _x = p.FunctionArgument()

					localctx.(*FunctionCallContext)._functionArgument = _x
				}
				localctx.(*FunctionCallContext).argument = append(localctx.(*FunctionCallContext).argument, localctx.(*FunctionCallContext)._functionArgument)

				p.SetState(3913)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3916)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3932)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3917)
				p.Match(SqlBaseParserWITHIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3918)
				p.Match(SqlBaseParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3919)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3920)
				p.Match(SqlBaseParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3921)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3922)
				p.SortItem()
			}
			p.SetState(3927)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(3923)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3924)
					p.SortItem()
				}

				p.SetState(3929)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3930)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3940)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 492, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3934)
				p.Match(SqlBaseParserFILTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3935)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3936)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3937)

				var _x = p.booleanExpression(0)

				localctx.(*FunctionCallContext).where = _x
			}
			{
				p.SetState(3938)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3944)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3942)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*FunctionCallContext).nullsOption = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserIGNORE || _la == SqlBaseParserRESPECT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*FunctionCallContext).nullsOption = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(3943)
				p.Match(SqlBaseParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3948)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 494, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3946)
				p.Match(SqlBaseParserOVER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3947)
				p.WindowSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 18:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3950)
			p.Identifier()
		}
		{
			p.SetState(3951)
			p.Match(SqlBaseParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3952)
			p.Expression()
		}

	case 19:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3954)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3955)
			p.Identifier()
		}
		p.SetState(3958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserCOMMA {
			{
				p.SetState(3956)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3957)
				p.Identifier()
			}

			p.SetState(3960)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3962)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3963)
			p.Match(SqlBaseParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3964)
			p.Expression()
		}

	case 20:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3966)
			p.Identifier()
		}

	case 21:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3967)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3968)
			p.Expression()
		}
		{
			p.SetState(3969)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3971)
			p.Match(SqlBaseParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3972)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3973)

			var _x = p.Identifier()

			localctx.(*ExtractContext).field = _x
		}
		{
			p.SetState(3974)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3975)

			var _x = p.valueExpression(0)

			localctx.(*ExtractContext).source = _x
		}
		{
			p.SetState(3976)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3978)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSUBSTR || _la == SqlBaseParserSUBSTRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3979)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3980)

			var _x = p.valueExpression(0)

			localctx.(*SubstringContext).str = _x
		}
		{
			p.SetState(3981)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCOMMA || _la == SqlBaseParserFROM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3982)

			var _x = p.valueExpression(0)

			localctx.(*SubstringContext).pos = _x
		}
		p.SetState(3985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCOMMA || _la == SqlBaseParserFOR {
			{
				p.SetState(3983)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserCOMMA || _la == SqlBaseParserFOR) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(3984)

				var _x = p.valueExpression(0)

				localctx.(*SubstringContext).len_ = _x
			}

		}
		{
			p.SetState(3987)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewTrimContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3989)
			p.Match(SqlBaseParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3990)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3992)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 497, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3991)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*TrimContext).trimOption = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserBOTH || _la == SqlBaseParserLEADING || _la == SqlBaseParserTRAILING) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*TrimContext).trimOption = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3995)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 498, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3994)

				var _x = p.valueExpression(0)

				localctx.(*TrimContext).trimStr = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3997)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3998)

			var _x = p.valueExpression(0)

			localctx.(*TrimContext).srcStr = _x
		}
		{
			p.SetState(3999)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewOverlayContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4001)
			p.Match(SqlBaseParserOVERLAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4002)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4003)

			var _x = p.valueExpression(0)

			localctx.(*OverlayContext).input = _x
		}
		{
			p.SetState(4004)
			p.Match(SqlBaseParserPLACING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4005)

			var _x = p.valueExpression(0)

			localctx.(*OverlayContext).replace = _x
		}
		{
			p.SetState(4006)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4007)

			var _x = p.valueExpression(0)

			localctx.(*OverlayContext).position = _x
		}
		p.SetState(4010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(4008)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4009)

				var _x = p.valueExpression(0)

				localctx.(*OverlayContext).length = _x
			}

		}
		{
			p.SetState(4012)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4032)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 501, p.GetParserRuleContext()) {
			case 1:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(4016)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(4017)
					p.CollateClause()
				}

			case 2:
				localctx = NewCastByColonContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(4018)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(4019)
					p.Match(SqlBaseParserDOUBLE_COLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4020)
					p.DataType()
				}

			case 3:
				localctx = NewSemiStructuredExtractContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SemiStructuredExtractContext).col = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(4021)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(4022)
					p.Match(SqlBaseParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4023)

					var _x = p.SemiStructuredExtractionPath()

					localctx.(*SemiStructuredExtractContext).path = _x
				}

			case 4:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(4024)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(4025)
					p.Match(SqlBaseParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4026)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(4027)
					p.Match(SqlBaseParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 5:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(4029)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(4030)
					p.Match(SqlBaseParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4031)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISemiStructuredExtractionPathContext is an interface to support dynamic dispatch.
type ISemiStructuredExtractionPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JsonPathFirstPart() IJsonPathFirstPartContext
	AllJsonPathParts() []IJsonPathPartsContext
	JsonPathParts(i int) IJsonPathPartsContext

	// IsSemiStructuredExtractionPathContext differentiates from other interfaces.
	IsSemiStructuredExtractionPathContext()
}

type SemiStructuredExtractionPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemiStructuredExtractionPathContext() *SemiStructuredExtractionPathContext {
	var p = new(SemiStructuredExtractionPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_semiStructuredExtractionPath
	return p
}

func InitEmptySemiStructuredExtractionPathContext(p *SemiStructuredExtractionPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_semiStructuredExtractionPath
}

func (*SemiStructuredExtractionPathContext) IsSemiStructuredExtractionPathContext() {}

func NewSemiStructuredExtractionPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemiStructuredExtractionPathContext {
	var p = new(SemiStructuredExtractionPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_semiStructuredExtractionPath

	return p
}

func (s *SemiStructuredExtractionPathContext) GetParser() antlr.Parser { return s.parser }

func (s *SemiStructuredExtractionPathContext) JsonPathFirstPart() IJsonPathFirstPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathFirstPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathFirstPartContext)
}

func (s *SemiStructuredExtractionPathContext) AllJsonPathParts() []IJsonPathPartsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonPathPartsContext); ok {
			len++
		}
	}

	tst := make([]IJsonPathPartsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonPathPartsContext); ok {
			tst[i] = t.(IJsonPathPartsContext)
			i++
		}
	}

	return tst
}

func (s *SemiStructuredExtractionPathContext) JsonPathParts(i int) IJsonPathPartsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathPartsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathPartsContext)
}

func (s *SemiStructuredExtractionPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemiStructuredExtractionPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemiStructuredExtractionPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSemiStructuredExtractionPath(s)
	}
}

func (s *SemiStructuredExtractionPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSemiStructuredExtractionPath(s)
	}
}

func (p *SqlBaseParser) SemiStructuredExtractionPath() (localctx ISemiStructuredExtractionPathContext) {
	localctx = NewSemiStructuredExtractionPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SqlBaseParserRULE_semiStructuredExtractionPath)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4037)
		p.JsonPathFirstPart()
	}
	p.SetState(4041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 503, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4038)
				p.JsonPathParts()
			}

		}
		p.SetState(4043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 503, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonPathIdentifierContext is an interface to support dynamic dispatch.
type IJsonPathIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode

	// IsJsonPathIdentifierContext differentiates from other interfaces.
	IsJsonPathIdentifierContext()
}

type JsonPathIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonPathIdentifierContext() *JsonPathIdentifierContext {
	var p = new(JsonPathIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathIdentifier
	return p
}

func InitEmptyJsonPathIdentifierContext(p *JsonPathIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathIdentifier
}

func (*JsonPathIdentifierContext) IsJsonPathIdentifierContext() {}

func NewJsonPathIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonPathIdentifierContext {
	var p = new(JsonPathIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_jsonPathIdentifier

	return p
}

func (s *JsonPathIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonPathIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JsonPathIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *JsonPathIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonPathIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonPathIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterJsonPathIdentifier(s)
	}
}

func (s *JsonPathIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitJsonPathIdentifier(s)
	}
}

func (p *SqlBaseParser) JsonPathIdentifier() (localctx IJsonPathIdentifierContext) {
	localctx = NewJsonPathIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SqlBaseParserRULE_jsonPathIdentifier)
	p.SetState(4046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4044)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4045)
			p.Match(SqlBaseParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonPathBracketedIdentifierContext is an interface to support dynamic dispatch.
type IJsonPathBracketedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACKET() antlr.TerminalNode
	StringLit() IStringLitContext
	RIGHT_BRACKET() antlr.TerminalNode

	// IsJsonPathBracketedIdentifierContext differentiates from other interfaces.
	IsJsonPathBracketedIdentifierContext()
}

type JsonPathBracketedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonPathBracketedIdentifierContext() *JsonPathBracketedIdentifierContext {
	var p = new(JsonPathBracketedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathBracketedIdentifier
	return p
}

func InitEmptyJsonPathBracketedIdentifierContext(p *JsonPathBracketedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathBracketedIdentifier
}

func (*JsonPathBracketedIdentifierContext) IsJsonPathBracketedIdentifierContext() {}

func NewJsonPathBracketedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonPathBracketedIdentifierContext {
	var p = new(JsonPathBracketedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_jsonPathBracketedIdentifier

	return p
}

func (s *JsonPathBracketedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonPathBracketedIdentifierContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_BRACKET, 0)
}

func (s *JsonPathBracketedIdentifierContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *JsonPathBracketedIdentifierContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_BRACKET, 0)
}

func (s *JsonPathBracketedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonPathBracketedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonPathBracketedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterJsonPathBracketedIdentifier(s)
	}
}

func (s *JsonPathBracketedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitJsonPathBracketedIdentifier(s)
	}
}

func (p *SqlBaseParser) JsonPathBracketedIdentifier() (localctx IJsonPathBracketedIdentifierContext) {
	localctx = NewJsonPathBracketedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SqlBaseParserRULE_jsonPathBracketedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4048)
		p.Match(SqlBaseParserLEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4049)
		p.StringLit()
	}
	{
		p.SetState(4050)
		p.Match(SqlBaseParserRIGHT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonPathFirstPartContext is an interface to support dynamic dispatch.
type IJsonPathFirstPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JsonPathIdentifier() IJsonPathIdentifierContext
	JsonPathBracketedIdentifier() IJsonPathBracketedIdentifierContext
	LEFT_BRACKET() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RIGHT_BRACKET() antlr.TerminalNode

	// IsJsonPathFirstPartContext differentiates from other interfaces.
	IsJsonPathFirstPartContext()
}

type JsonPathFirstPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonPathFirstPartContext() *JsonPathFirstPartContext {
	var p = new(JsonPathFirstPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathFirstPart
	return p
}

func InitEmptyJsonPathFirstPartContext(p *JsonPathFirstPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathFirstPart
}

func (*JsonPathFirstPartContext) IsJsonPathFirstPartContext() {}

func NewJsonPathFirstPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonPathFirstPartContext {
	var p = new(JsonPathFirstPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_jsonPathFirstPart

	return p
}

func (s *JsonPathFirstPartContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonPathFirstPartContext) JsonPathIdentifier() IJsonPathIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathIdentifierContext)
}

func (s *JsonPathFirstPartContext) JsonPathBracketedIdentifier() IJsonPathBracketedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathBracketedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathBracketedIdentifierContext)
}

func (s *JsonPathFirstPartContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_BRACKET, 0)
}

func (s *JsonPathFirstPartContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *JsonPathFirstPartContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_BRACKET, 0)
}

func (s *JsonPathFirstPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonPathFirstPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonPathFirstPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterJsonPathFirstPart(s)
	}
}

func (s *JsonPathFirstPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitJsonPathFirstPart(s)
	}
}

func (p *SqlBaseParser) JsonPathFirstPart() (localctx IJsonPathFirstPartContext) {
	localctx = NewJsonPathFirstPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SqlBaseParserRULE_jsonPathFirstPart)
	p.SetState(4057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 505, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4052)
			p.JsonPathIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4053)
			p.JsonPathBracketedIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4054)
			p.Match(SqlBaseParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4055)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4056)
			p.Match(SqlBaseParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonPathPartsContext is an interface to support dynamic dispatch.
type IJsonPathPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	JsonPathIdentifier() IJsonPathIdentifierContext
	JsonPathBracketedIdentifier() IJsonPathBracketedIdentifierContext
	LEFT_BRACKET() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RIGHT_BRACKET() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsJsonPathPartsContext differentiates from other interfaces.
	IsJsonPathPartsContext()
}

type JsonPathPartsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonPathPartsContext() *JsonPathPartsContext {
	var p = new(JsonPathPartsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathParts
	return p
}

func InitEmptyJsonPathPartsContext(p *JsonPathPartsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_jsonPathParts
}

func (*JsonPathPartsContext) IsJsonPathPartsContext() {}

func NewJsonPathPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonPathPartsContext {
	var p = new(JsonPathPartsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_jsonPathParts

	return p
}

func (s *JsonPathPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonPathPartsContext) DOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, 0)
}

func (s *JsonPathPartsContext) JsonPathIdentifier() IJsonPathIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathIdentifierContext)
}

func (s *JsonPathPartsContext) JsonPathBracketedIdentifier() IJsonPathBracketedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathBracketedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathBracketedIdentifierContext)
}

func (s *JsonPathPartsContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_BRACKET, 0)
}

func (s *JsonPathPartsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *JsonPathPartsContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_BRACKET, 0)
}

func (s *JsonPathPartsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JsonPathPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonPathPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonPathPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterJsonPathParts(s)
	}
}

func (s *JsonPathPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitJsonPathParts(s)
	}
}

func (p *SqlBaseParser) JsonPathParts() (localctx IJsonPathPartsContext) {
	localctx = NewJsonPathPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, SqlBaseParserRULE_jsonPathParts)
	p.SetState(4069)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4059)
			p.Match(SqlBaseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4060)
			p.JsonPathIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4061)
			p.JsonPathBracketedIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4062)
			p.Match(SqlBaseParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4063)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4064)
			p.Match(SqlBaseParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4065)
			p.Match(SqlBaseParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4066)
			p.Identifier()
		}
		{
			p.SetState(4067)
			p.Match(SqlBaseParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralTypeContext is an interface to support dynamic dispatch.
type ILiteralTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnsupportedType returns the unsupportedType rule contexts.
	GetUnsupportedType() IIdentifierContext

	// SetUnsupportedType sets the unsupportedType rule contexts.
	SetUnsupportedType(IIdentifierContext)

	// Getter signatures
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMP_LTZ() antlr.TerminalNode
	TIMESTAMP_NTZ() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	BINARY_HEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsLiteralTypeContext differentiates from other interfaces.
	IsLiteralTypeContext()
}

type LiteralTypeContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	unsupportedType IIdentifierContext
}

func NewEmptyLiteralTypeContext() *LiteralTypeContext {
	var p = new(LiteralTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_literalType
	return p
}

func InitEmptyLiteralTypeContext(p *LiteralTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_literalType
}

func (*LiteralTypeContext) IsLiteralTypeContext() {}

func NewLiteralTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralTypeContext {
	var p = new(LiteralTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_literalType

	return p
}

func (s *LiteralTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralTypeContext) GetUnsupportedType() IIdentifierContext { return s.unsupportedType }

func (s *LiteralTypeContext) SetUnsupportedType(v IIdentifierContext) { s.unsupportedType = v }

func (s *LiteralTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *LiteralTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *LiteralTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *LiteralTypeContext) TIMESTAMP_LTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_LTZ, 0)
}

func (s *LiteralTypeContext) TIMESTAMP_NTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_NTZ, 0)
}

func (s *LiteralTypeContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *LiteralTypeContext) BINARY_HEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY_HEX, 0)
}

func (s *LiteralTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LiteralTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLiteralType(s)
	}
}

func (s *LiteralTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLiteralType(s)
	}
}

func (p *SqlBaseParser) LiteralType() (localctx ILiteralTypeContext) {
	localctx = NewLiteralTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, SqlBaseParserRULE_literalType)
	p.SetState(4079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 507, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4071)
			p.Match(SqlBaseParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4072)
			p.Match(SqlBaseParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4073)
			p.Match(SqlBaseParserTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4074)
			p.Match(SqlBaseParserTIMESTAMP_LTZ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4075)
			p.Match(SqlBaseParserTIMESTAMP_NTZ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4076)
			p.Match(SqlBaseParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4077)
			p.Match(SqlBaseParserBINARY_HEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4078)

			var _x = p.Identifier()

			localctx.(*LiteralTypeContext).unsupportedType = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) CopyAll(ctx *ConstantContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NullLiteralContext struct {
	ConstantContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	ConstantContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) AllStringLit() []IStringLitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLitContext); ok {
			len++
		}
	}

	tst := make([]IStringLitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLitContext); ok {
			tst[i] = t.(IStringLitContext)
			i++
		}
	}

	return tst
}

func (s *StringLiteralContext) StringLit(i int) IStringLitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type TypeConstructorContext struct {
	ConstantContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) LiteralType() ILiteralTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralTypeContext)
}

func (s *TypeConstructorContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type PosParameterLiteralContext struct {
	ConstantContext
}

func NewPosParameterLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PosParameterLiteralContext {
	var p = new(PosParameterLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *PosParameterLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PosParameterLiteralContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUESTION, 0)
}

func (s *PosParameterLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPosParameterLiteral(s)
	}
}

func (s *PosParameterLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPosParameterLiteral(s)
	}
}

type NamedParameterLiteralContext struct {
	ConstantContext
}

func NewNamedParameterLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedParameterLiteralContext {
	var p = new(NamedParameterLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NamedParameterLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedParameterLiteralContext) COLON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLON, 0)
}

func (s *NamedParameterLiteralContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedParameterLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamedParameterLiteral(s)
	}
}

func (s *NamedParameterLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamedParameterLiteral(s)
	}
}

type IntervalLiteralContext struct {
	ConstantContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type NumericLiteralContext struct {
	ConstantContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	ConstantContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *SqlBaseParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, SqlBaseParserRULE_constant)
	var _alt int

	p.SetState(4096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 509, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4081)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewPosParameterLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4082)
			p.Match(SqlBaseParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewNamedParameterLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4083)
			p.Match(SqlBaseParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4084)
			p.Identifier()
		}

	case 4:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4085)
			p.Interval()
		}

	case 5:
		localctx = NewTypeConstructorContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4086)
			p.LiteralType()
		}
		{
			p.SetState(4087)
			p.StringLit()
		}

	case 6:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4089)
			p.Number()
		}

	case 7:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4090)
			p.BooleanValue()
		}

	case 8:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(4092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4091)
					p.StringLit()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4094)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 508, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	NEQJ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	NSEQ() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEQ, 0)
}

func (s *ComparisonOperatorContext) NEQJ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEQJ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGTE, 0)
}

func (s *ComparisonOperatorContext) NSEQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNSEQ, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *SqlBaseParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, SqlBaseParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4098)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-402)) & ^0x3f) == 0 && ((int64(1)<<(_la-402))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArithmeticOperatorContext is an interface to support dynamic dispatch.
type IArithmeticOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	DIV() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	CONCAT_PIPE() antlr.TerminalNode
	HAT() antlr.TerminalNode

	// IsArithmeticOperatorContext differentiates from other interfaces.
	IsArithmeticOperatorContext()
}

type ArithmeticOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmeticOperatorContext() *ArithmeticOperatorContext {
	var p = new(ArithmeticOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_arithmeticOperator
	return p
}

func InitEmptyArithmeticOperatorContext(p *ArithmeticOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_arithmeticOperator
}

func (*ArithmeticOperatorContext) IsArithmeticOperatorContext() {}

func NewArithmeticOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArithmeticOperatorContext {
	var p = new(ArithmeticOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_arithmeticOperator

	return p
}

func (s *ArithmeticOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ArithmeticOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticOperatorContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *ArithmeticOperatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSLASH, 0)
}

func (s *ArithmeticOperatorContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENT, 0)
}

func (s *ArithmeticOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIV, 0)
}

func (s *ArithmeticOperatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTILDE, 0)
}

func (s *ArithmeticOperatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAMPERSAND, 0)
}

func (s *ArithmeticOperatorContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPIPE, 0)
}

func (s *ArithmeticOperatorContext) CONCAT_PIPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCAT_PIPE, 0)
}

func (s *ArithmeticOperatorContext) HAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAT, 0)
}

func (s *ArithmeticOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArithmeticOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterArithmeticOperator(s)
	}
}

func (s *ArithmeticOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitArithmeticOperator(s)
	}
}

func (p *SqlBaseParser) ArithmeticOperator() (localctx IArithmeticOperatorContext) {
	localctx = NewArithmeticOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, SqlBaseParserRULE_arithmeticOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4100)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDIV || ((int64((_la-413)) & ^0x3f) == 0 && ((int64(1)<<(_la-413))&1535) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateOperatorContext is an interface to support dynamic dispatch.
type IPredicateOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	AND() antlr.TerminalNode
	IN() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsPredicateOperatorContext differentiates from other interfaces.
	IsPredicateOperatorContext()
}

type PredicateOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateOperatorContext() *PredicateOperatorContext {
	var p = new(PredicateOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicateOperator
	return p
}

func InitEmptyPredicateOperatorContext(p *PredicateOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicateOperator
}

func (*PredicateOperatorContext) IsPredicateOperatorContext() {}

func NewPredicateOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateOperatorContext {
	var p = new(PredicateOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_predicateOperator

	return p
}

func (s *PredicateOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *PredicateOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *PredicateOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *PredicateOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *PredicateOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPredicateOperator(s)
	}
}

func (s *PredicateOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPredicateOperator(s)
	}
}

func (p *SqlBaseParser) PredicateOperator() (localctx IPredicateOperatorContext) {
	localctx = NewPredicateOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, SqlBaseParserRULE_predicateOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4102)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserAND || _la == SqlBaseParserIN || _la == SqlBaseParserNOT || _la == SqlBaseParserOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *SqlBaseParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, SqlBaseParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4104)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserFALSE || _la == SqlBaseParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	ErrorCapturingMultiUnitsInterval() IErrorCapturingMultiUnitsIntervalContext
	ErrorCapturingUnitToUnitInterval() IErrorCapturingUnitToUnitIntervalContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *IntervalContext) ErrorCapturingMultiUnitsInterval() IErrorCapturingMultiUnitsIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingMultiUnitsIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingMultiUnitsIntervalContext)
}

func (s *IntervalContext) ErrorCapturingUnitToUnitInterval() IErrorCapturingUnitToUnitIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingUnitToUnitIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingUnitToUnitIntervalContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *SqlBaseParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, SqlBaseParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4106)
		p.Match(SqlBaseParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 510, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4107)
			p.ErrorCapturingMultiUnitsInterval()
		}

	case 2:
		{
			p.SetState(4108)
			p.ErrorCapturingUnitToUnitInterval()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingMultiUnitsIntervalContext is an interface to support dynamic dispatch.
type IErrorCapturingMultiUnitsIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBody returns the body rule contexts.
	GetBody() IMultiUnitsIntervalContext

	// SetBody sets the body rule contexts.
	SetBody(IMultiUnitsIntervalContext)

	// Getter signatures
	MultiUnitsInterval() IMultiUnitsIntervalContext
	UnitToUnitInterval() IUnitToUnitIntervalContext

	// IsErrorCapturingMultiUnitsIntervalContext differentiates from other interfaces.
	IsErrorCapturingMultiUnitsIntervalContext()
}

type ErrorCapturingMultiUnitsIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	body   IMultiUnitsIntervalContext
}

func NewEmptyErrorCapturingMultiUnitsIntervalContext() *ErrorCapturingMultiUnitsIntervalContext {
	var p = new(ErrorCapturingMultiUnitsIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingMultiUnitsInterval
	return p
}

func InitEmptyErrorCapturingMultiUnitsIntervalContext(p *ErrorCapturingMultiUnitsIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingMultiUnitsInterval
}

func (*ErrorCapturingMultiUnitsIntervalContext) IsErrorCapturingMultiUnitsIntervalContext() {}

func NewErrorCapturingMultiUnitsIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingMultiUnitsIntervalContext {
	var p = new(ErrorCapturingMultiUnitsIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_errorCapturingMultiUnitsInterval

	return p
}

func (s *ErrorCapturingMultiUnitsIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingMultiUnitsIntervalContext) GetBody() IMultiUnitsIntervalContext { return s.body }

func (s *ErrorCapturingMultiUnitsIntervalContext) SetBody(v IMultiUnitsIntervalContext) { s.body = v }

func (s *ErrorCapturingMultiUnitsIntervalContext) MultiUnitsInterval() IMultiUnitsIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiUnitsIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiUnitsIntervalContext)
}

func (s *ErrorCapturingMultiUnitsIntervalContext) UnitToUnitInterval() IUnitToUnitIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitToUnitIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitToUnitIntervalContext)
}

func (s *ErrorCapturingMultiUnitsIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingMultiUnitsIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingMultiUnitsIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterErrorCapturingMultiUnitsInterval(s)
	}
}

func (s *ErrorCapturingMultiUnitsIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitErrorCapturingMultiUnitsInterval(s)
	}
}

func (p *SqlBaseParser) ErrorCapturingMultiUnitsInterval() (localctx IErrorCapturingMultiUnitsIntervalContext) {
	localctx = NewErrorCapturingMultiUnitsIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, SqlBaseParserRULE_errorCapturingMultiUnitsInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4111)

		var _x = p.MultiUnitsInterval()

		localctx.(*ErrorCapturingMultiUnitsIntervalContext).body = _x
	}
	p.SetState(4113)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 511, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4112)
			p.UnitToUnitInterval()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiUnitsIntervalContext is an interface to support dynamic dispatch.
type IMultiUnitsIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_unitInMultiUnits returns the _unitInMultiUnits rule contexts.
	Get_unitInMultiUnits() IUnitInMultiUnitsContext

	// Set_unitInMultiUnits sets the _unitInMultiUnits rule contexts.
	Set_unitInMultiUnits(IUnitInMultiUnitsContext)

	// GetUnit returns the unit rule context list.
	GetUnit() []IUnitInMultiUnitsContext

	// SetUnit sets the unit rule context list.
	SetUnit([]IUnitInMultiUnitsContext)

	// Getter signatures
	AllIntervalValue() []IIntervalValueContext
	IntervalValue(i int) IIntervalValueContext
	AllUnitInMultiUnits() []IUnitInMultiUnitsContext
	UnitInMultiUnits(i int) IUnitInMultiUnitsContext

	// IsMultiUnitsIntervalContext differentiates from other interfaces.
	IsMultiUnitsIntervalContext()
}

type MultiUnitsIntervalContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	_unitInMultiUnits IUnitInMultiUnitsContext
	unit              []IUnitInMultiUnitsContext
}

func NewEmptyMultiUnitsIntervalContext() *MultiUnitsIntervalContext {
	var p = new(MultiUnitsIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multiUnitsInterval
	return p
}

func InitEmptyMultiUnitsIntervalContext(p *MultiUnitsIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_multiUnitsInterval
}

func (*MultiUnitsIntervalContext) IsMultiUnitsIntervalContext() {}

func NewMultiUnitsIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiUnitsIntervalContext {
	var p = new(MultiUnitsIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_multiUnitsInterval

	return p
}

func (s *MultiUnitsIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiUnitsIntervalContext) Get_unitInMultiUnits() IUnitInMultiUnitsContext {
	return s._unitInMultiUnits
}

func (s *MultiUnitsIntervalContext) Set_unitInMultiUnits(v IUnitInMultiUnitsContext) {
	s._unitInMultiUnits = v
}

func (s *MultiUnitsIntervalContext) GetUnit() []IUnitInMultiUnitsContext { return s.unit }

func (s *MultiUnitsIntervalContext) SetUnit(v []IUnitInMultiUnitsContext) { s.unit = v }

func (s *MultiUnitsIntervalContext) AllIntervalValue() []IIntervalValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalValueContext); ok {
			len++
		}
	}

	tst := make([]IIntervalValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalValueContext); ok {
			tst[i] = t.(IIntervalValueContext)
			i++
		}
	}

	return tst
}

func (s *MultiUnitsIntervalContext) IntervalValue(i int) IIntervalValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalValueContext)
}

func (s *MultiUnitsIntervalContext) AllUnitInMultiUnits() []IUnitInMultiUnitsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnitInMultiUnitsContext); ok {
			len++
		}
	}

	tst := make([]IUnitInMultiUnitsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnitInMultiUnitsContext); ok {
			tst[i] = t.(IUnitInMultiUnitsContext)
			i++
		}
	}

	return tst
}

func (s *MultiUnitsIntervalContext) UnitInMultiUnits(i int) IUnitInMultiUnitsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitInMultiUnitsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitInMultiUnitsContext)
}

func (s *MultiUnitsIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiUnitsIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiUnitsIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterMultiUnitsInterval(s)
	}
}

func (s *MultiUnitsIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitMultiUnitsInterval(s)
	}
}

func (p *SqlBaseParser) MultiUnitsInterval() (localctx IMultiUnitsIntervalContext) {
	localctx = NewMultiUnitsIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, SqlBaseParserRULE_multiUnitsInterval)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4115)
				p.IntervalValue()
			}
			{
				p.SetState(4116)

				var _x = p.UnitInMultiUnits()

				localctx.(*MultiUnitsIntervalContext)._unitInMultiUnits = _x
			}
			localctx.(*MultiUnitsIntervalContext).unit = append(localctx.(*MultiUnitsIntervalContext).unit, localctx.(*MultiUnitsIntervalContext)._unitInMultiUnits)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4120)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 512, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingUnitToUnitIntervalContext is an interface to support dynamic dispatch.
type IErrorCapturingUnitToUnitIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBody returns the body rule contexts.
	GetBody() IUnitToUnitIntervalContext

	// GetError1 returns the error1 rule contexts.
	GetError1() IMultiUnitsIntervalContext

	// GetError2 returns the error2 rule contexts.
	GetError2() IUnitToUnitIntervalContext

	// SetBody sets the body rule contexts.
	SetBody(IUnitToUnitIntervalContext)

	// SetError1 sets the error1 rule contexts.
	SetError1(IMultiUnitsIntervalContext)

	// SetError2 sets the error2 rule contexts.
	SetError2(IUnitToUnitIntervalContext)

	// Getter signatures
	AllUnitToUnitInterval() []IUnitToUnitIntervalContext
	UnitToUnitInterval(i int) IUnitToUnitIntervalContext
	MultiUnitsInterval() IMultiUnitsIntervalContext

	// IsErrorCapturingUnitToUnitIntervalContext differentiates from other interfaces.
	IsErrorCapturingUnitToUnitIntervalContext()
}

type ErrorCapturingUnitToUnitIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	body   IUnitToUnitIntervalContext
	error1 IMultiUnitsIntervalContext
	error2 IUnitToUnitIntervalContext
}

func NewEmptyErrorCapturingUnitToUnitIntervalContext() *ErrorCapturingUnitToUnitIntervalContext {
	var p = new(ErrorCapturingUnitToUnitIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingUnitToUnitInterval
	return p
}

func InitEmptyErrorCapturingUnitToUnitIntervalContext(p *ErrorCapturingUnitToUnitIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingUnitToUnitInterval
}

func (*ErrorCapturingUnitToUnitIntervalContext) IsErrorCapturingUnitToUnitIntervalContext() {}

func NewErrorCapturingUnitToUnitIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingUnitToUnitIntervalContext {
	var p = new(ErrorCapturingUnitToUnitIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_errorCapturingUnitToUnitInterval

	return p
}

func (s *ErrorCapturingUnitToUnitIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingUnitToUnitIntervalContext) GetBody() IUnitToUnitIntervalContext { return s.body }

func (s *ErrorCapturingUnitToUnitIntervalContext) GetError1() IMultiUnitsIntervalContext {
	return s.error1
}

func (s *ErrorCapturingUnitToUnitIntervalContext) GetError2() IUnitToUnitIntervalContext {
	return s.error2
}

func (s *ErrorCapturingUnitToUnitIntervalContext) SetBody(v IUnitToUnitIntervalContext) { s.body = v }

func (s *ErrorCapturingUnitToUnitIntervalContext) SetError1(v IMultiUnitsIntervalContext) {
	s.error1 = v
}

func (s *ErrorCapturingUnitToUnitIntervalContext) SetError2(v IUnitToUnitIntervalContext) {
	s.error2 = v
}

func (s *ErrorCapturingUnitToUnitIntervalContext) AllUnitToUnitInterval() []IUnitToUnitIntervalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnitToUnitIntervalContext); ok {
			len++
		}
	}

	tst := make([]IUnitToUnitIntervalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnitToUnitIntervalContext); ok {
			tst[i] = t.(IUnitToUnitIntervalContext)
			i++
		}
	}

	return tst
}

func (s *ErrorCapturingUnitToUnitIntervalContext) UnitToUnitInterval(i int) IUnitToUnitIntervalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitToUnitIntervalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitToUnitIntervalContext)
}

func (s *ErrorCapturingUnitToUnitIntervalContext) MultiUnitsInterval() IMultiUnitsIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiUnitsIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiUnitsIntervalContext)
}

func (s *ErrorCapturingUnitToUnitIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingUnitToUnitIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingUnitToUnitIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterErrorCapturingUnitToUnitInterval(s)
	}
}

func (s *ErrorCapturingUnitToUnitIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitErrorCapturingUnitToUnitInterval(s)
	}
}

func (p *SqlBaseParser) ErrorCapturingUnitToUnitInterval() (localctx IErrorCapturingUnitToUnitIntervalContext) {
	localctx = NewErrorCapturingUnitToUnitIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, SqlBaseParserRULE_errorCapturingUnitToUnitInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4122)

		var _x = p.UnitToUnitInterval()

		localctx.(*ErrorCapturingUnitToUnitIntervalContext).body = _x
	}
	p.SetState(4125)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4123)

			var _x = p.MultiUnitsInterval()

			localctx.(*ErrorCapturingUnitToUnitIntervalContext).error1 = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4124)

			var _x = p.UnitToUnitInterval()

			localctx.(*ErrorCapturingUnitToUnitIntervalContext).error2 = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitToUnitIntervalContext is an interface to support dynamic dispatch.
type IUnitToUnitIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IIntervalValueContext

	// GetFrom returns the from rule contexts.
	GetFrom() IUnitInUnitToUnitContext

	// GetTo returns the to rule contexts.
	GetTo() IUnitInUnitToUnitContext

	// SetValue sets the value rule contexts.
	SetValue(IIntervalValueContext)

	// SetFrom sets the from rule contexts.
	SetFrom(IUnitInUnitToUnitContext)

	// SetTo sets the to rule contexts.
	SetTo(IUnitInUnitToUnitContext)

	// Getter signatures
	TO() antlr.TerminalNode
	IntervalValue() IIntervalValueContext
	AllUnitInUnitToUnit() []IUnitInUnitToUnitContext
	UnitInUnitToUnit(i int) IUnitInUnitToUnitContext

	// IsUnitToUnitIntervalContext differentiates from other interfaces.
	IsUnitToUnitIntervalContext()
}

type UnitToUnitIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IIntervalValueContext
	from   IUnitInUnitToUnitContext
	to     IUnitInUnitToUnitContext
}

func NewEmptyUnitToUnitIntervalContext() *UnitToUnitIntervalContext {
	var p = new(UnitToUnitIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unitToUnitInterval
	return p
}

func InitEmptyUnitToUnitIntervalContext(p *UnitToUnitIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unitToUnitInterval
}

func (*UnitToUnitIntervalContext) IsUnitToUnitIntervalContext() {}

func NewUnitToUnitIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitToUnitIntervalContext {
	var p = new(UnitToUnitIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unitToUnitInterval

	return p
}

func (s *UnitToUnitIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitToUnitIntervalContext) GetValue() IIntervalValueContext { return s.value }

func (s *UnitToUnitIntervalContext) GetFrom() IUnitInUnitToUnitContext { return s.from }

func (s *UnitToUnitIntervalContext) GetTo() IUnitInUnitToUnitContext { return s.to }

func (s *UnitToUnitIntervalContext) SetValue(v IIntervalValueContext) { s.value = v }

func (s *UnitToUnitIntervalContext) SetFrom(v IUnitInUnitToUnitContext) { s.from = v }

func (s *UnitToUnitIntervalContext) SetTo(v IUnitInUnitToUnitContext) { s.to = v }

func (s *UnitToUnitIntervalContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *UnitToUnitIntervalContext) IntervalValue() IIntervalValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalValueContext)
}

func (s *UnitToUnitIntervalContext) AllUnitInUnitToUnit() []IUnitInUnitToUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnitInUnitToUnitContext); ok {
			len++
		}
	}

	tst := make([]IUnitInUnitToUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnitInUnitToUnitContext); ok {
			tst[i] = t.(IUnitInUnitToUnitContext)
			i++
		}
	}

	return tst
}

func (s *UnitToUnitIntervalContext) UnitInUnitToUnit(i int) IUnitInUnitToUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitInUnitToUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitInUnitToUnitContext)
}

func (s *UnitToUnitIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitToUnitIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitToUnitIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnitToUnitInterval(s)
	}
}

func (s *UnitToUnitIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnitToUnitInterval(s)
	}
}

func (p *SqlBaseParser) UnitToUnitInterval() (localctx IUnitToUnitIntervalContext) {
	localctx = NewUnitToUnitIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, SqlBaseParserRULE_unitToUnitInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4127)

		var _x = p.IntervalValue()

		localctx.(*UnitToUnitIntervalContext).value = _x
	}
	{
		p.SetState(4128)

		var _x = p.UnitInUnitToUnit()

		localctx.(*UnitToUnitIntervalContext).from = _x
	}
	{
		p.SetState(4129)
		p.Match(SqlBaseParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4130)

		var _x = p.UnitInUnitToUnit()

		localctx.(*UnitToUnitIntervalContext).to = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalValueContext is an interface to support dynamic dispatch.
type IIntervalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	StringLit() IStringLitContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsIntervalValueContext differentiates from other interfaces.
	IsIntervalValueContext()
}

type IntervalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalValueContext() *IntervalValueContext {
	var p = new(IntervalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalValue
	return p
}

func InitEmptyIntervalValueContext(p *IntervalValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalValue
}

func (*IntervalValueContext) IsIntervalValueContext() {}

func NewIntervalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalValueContext {
	var p = new(IntervalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_intervalValue

	return p
}

func (s *IntervalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalValueContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *IntervalValueContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *IntervalValueContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *IntervalValueContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *IntervalValueContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntervalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIntervalValue(s)
	}
}

func (s *IntervalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIntervalValue(s)
	}
}

func (p *SqlBaseParser) IntervalValue() (localctx IIntervalValueContext) {
	localctx = NewIntervalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, SqlBaseParserRULE_intervalValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4132)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4135)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4136)
			p.Match(SqlBaseParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4137)
			p.StringLit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitInMultiUnitsContext is an interface to support dynamic dispatch.
type IUnitInMultiUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NANOSECOND() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKS() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHS() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARS() antlr.TerminalNode

	// IsUnitInMultiUnitsContext differentiates from other interfaces.
	IsUnitInMultiUnitsContext()
}

type UnitInMultiUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitInMultiUnitsContext() *UnitInMultiUnitsContext {
	var p = new(UnitInMultiUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unitInMultiUnits
	return p
}

func InitEmptyUnitInMultiUnitsContext(p *UnitInMultiUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unitInMultiUnits
}

func (*UnitInMultiUnitsContext) IsUnitInMultiUnitsContext() {}

func NewUnitInMultiUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitInMultiUnitsContext {
	var p = new(UnitInMultiUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unitInMultiUnits

	return p
}

func (s *UnitInMultiUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitInMultiUnitsContext) NANOSECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNANOSECOND, 0)
}

func (s *UnitInMultiUnitsContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNANOSECONDS, 0)
}

func (s *UnitInMultiUnitsContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMICROSECOND, 0)
}

func (s *UnitInMultiUnitsContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMICROSECONDS, 0)
}

func (s *UnitInMultiUnitsContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECOND, 0)
}

func (s *UnitInMultiUnitsContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECONDS, 0)
}

func (s *UnitInMultiUnitsContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *UnitInMultiUnitsContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECONDS, 0)
}

func (s *UnitInMultiUnitsContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *UnitInMultiUnitsContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTES, 0)
}

func (s *UnitInMultiUnitsContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *UnitInMultiUnitsContext) HOURS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOURS, 0)
}

func (s *UnitInMultiUnitsContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *UnitInMultiUnitsContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAYS, 0)
}

func (s *UnitInMultiUnitsContext) WEEK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWEEK, 0)
}

func (s *UnitInMultiUnitsContext) WEEKS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWEEKS, 0)
}

func (s *UnitInMultiUnitsContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *UnitInMultiUnitsContext) MONTHS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTHS, 0)
}

func (s *UnitInMultiUnitsContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *UnitInMultiUnitsContext) YEARS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEARS, 0)
}

func (s *UnitInMultiUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitInMultiUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitInMultiUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnitInMultiUnits(s)
	}
}

func (s *UnitInMultiUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnitInMultiUnits(s)
	}
}

func (p *SqlBaseParser) UnitInMultiUnits() (localctx IUnitInMultiUnitsContext) {
	localctx = NewUnitInMultiUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, SqlBaseParserRULE_unitInMultiUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4140)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDAY || _la == SqlBaseParserDAYS || ((int64((_la-155)) & ^0x3f) == 0 && ((int64(1)<<(_la-155))&-288230376151711741) != 0) || ((int64((_la-220)) & ^0x3f) == 0 && ((int64(1)<<(_la-220))&195) != 0) || _la == SqlBaseParserSECOND || _la == SqlBaseParserSECONDS || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&1539) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitInUnitToUnitContext is an interface to support dynamic dispatch.
type IUnitInUnitToUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	DAY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsUnitInUnitToUnitContext differentiates from other interfaces.
	IsUnitInUnitToUnitContext()
}

type UnitInUnitToUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitInUnitToUnitContext() *UnitInUnitToUnitContext {
	var p = new(UnitInUnitToUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unitInUnitToUnit
	return p
}

func InitEmptyUnitInUnitToUnitContext(p *UnitInUnitToUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_unitInUnitToUnit
}

func (*UnitInUnitToUnitContext) IsUnitInUnitToUnitContext() {}

func NewUnitInUnitToUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitInUnitToUnitContext {
	var p = new(UnitInUnitToUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_unitInUnitToUnit

	return p
}

func (s *UnitInUnitToUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitInUnitToUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *UnitInUnitToUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *UnitInUnitToUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *UnitInUnitToUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *UnitInUnitToUnitContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *UnitInUnitToUnitContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *UnitInUnitToUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitInUnitToUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitInUnitToUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnitInUnitToUnit(s)
	}
}

func (s *UnitInUnitToUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnitInUnitToUnit(s)
	}
}

func (p *SqlBaseParser) UnitInUnitToUnit() (localctx IUnitInUnitToUnitContext) {
	localctx = NewUnitInUnitToUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, SqlBaseParserRULE_unitInUnitToUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4142)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDAY || _la == SqlBaseParserHOUR || _la == SqlBaseParserMINUTE || _la == SqlBaseParserMONTH || _la == SqlBaseParserSECOND || _la == SqlBaseParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColPositionContext is an interface to support dynamic dispatch.
type IColPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPosition returns the position token.
	GetPosition() antlr.Token

	// SetPosition sets the position token.
	SetPosition(antlr.Token)

	// GetAfterCol returns the afterCol rule contexts.
	GetAfterCol() IErrorCapturingIdentifierContext

	// SetAfterCol sets the afterCol rule contexts.
	SetAfterCol(IErrorCapturingIdentifierContext)

	// Getter signatures
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsColPositionContext differentiates from other interfaces.
	IsColPositionContext()
}

type ColPositionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	position antlr.Token
	afterCol IErrorCapturingIdentifierContext
}

func NewEmptyColPositionContext() *ColPositionContext {
	var p = new(ColPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colPosition
	return p
}

func InitEmptyColPositionContext(p *ColPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colPosition
}

func (*ColPositionContext) IsColPositionContext() {}

func NewColPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColPositionContext {
	var p = new(ColPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_colPosition

	return p
}

func (s *ColPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColPositionContext) GetPosition() antlr.Token { return s.position }

func (s *ColPositionContext) SetPosition(v antlr.Token) { s.position = v }

func (s *ColPositionContext) GetAfterCol() IErrorCapturingIdentifierContext { return s.afterCol }

func (s *ColPositionContext) SetAfterCol(v IErrorCapturingIdentifierContext) { s.afterCol = v }

func (s *ColPositionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *ColPositionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAFTER, 0)
}

func (s *ColPositionContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *ColPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColPosition(s)
	}
}

func (s *ColPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColPosition(s)
	}
}

func (p *SqlBaseParser) ColPosition() (localctx IColPositionContext) {
	localctx = NewColPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, SqlBaseParserRULE_colPosition)
	p.SetState(4147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserFIRST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4144)

			var _m = p.Match(SqlBaseParserFIRST)

			localctx.(*ColPositionContext).position = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserAFTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4145)

			var _m = p.Match(SqlBaseParserAFTER)

			localctx.(*ColPositionContext).position = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4146)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*ColPositionContext).afterCol = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollationSpecContext is an interface to support dynamic dispatch.
type ICollationSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCollationName returns the collationName rule contexts.
	GetCollationName() IIdentifierContext

	// SetCollationName sets the collationName rule contexts.
	SetCollationName(IIdentifierContext)

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsCollationSpecContext differentiates from other interfaces.
	IsCollationSpecContext()
}

type CollationSpecContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	collationName IIdentifierContext
}

func NewEmptyCollationSpecContext() *CollationSpecContext {
	var p = new(CollationSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_collationSpec
	return p
}

func InitEmptyCollationSpecContext(p *CollationSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_collationSpec
}

func (*CollationSpecContext) IsCollationSpecContext() {}

func NewCollationSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationSpecContext {
	var p = new(CollationSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_collationSpec

	return p
}

func (s *CollationSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationSpecContext) GetCollationName() IIdentifierContext { return s.collationName }

func (s *CollationSpecContext) SetCollationName(v IIdentifierContext) { s.collationName = v }

func (s *CollationSpecContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *CollationSpecContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLLATION, 0)
}

func (s *CollationSpecContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollationSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCollationSpec(s)
	}
}

func (s *CollationSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCollationSpec(s)
	}
}

func (p *SqlBaseParser) CollationSpec() (localctx ICollationSpecContext) {
	localctx = NewCollationSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, SqlBaseParserRULE_collationSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4149)
		p.Match(SqlBaseParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4150)
		p.Match(SqlBaseParserCOLLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4151)

		var _x = p.Identifier()

		localctx.(*CollationSpecContext).collationName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateClauseContext is an interface to support dynamic dispatch.
type ICollateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCollationName returns the collationName rule contexts.
	GetCollationName() IMultipartIdentifierContext

	// SetCollationName sets the collationName rule contexts.
	SetCollationName(IMultipartIdentifierContext)

	// Getter signatures
	COLLATE() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsCollateClauseContext differentiates from other interfaces.
	IsCollateClauseContext()
}

type CollateClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	collationName IMultipartIdentifierContext
}

func NewEmptyCollateClauseContext() *CollateClauseContext {
	var p = new(CollateClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_collateClause
	return p
}

func InitEmptyCollateClauseContext(p *CollateClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_collateClause
}

func (*CollateClauseContext) IsCollateClauseContext() {}

func NewCollateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateClauseContext {
	var p = new(CollateClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_collateClause

	return p
}

func (s *CollateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateClauseContext) GetCollationName() IMultipartIdentifierContext { return s.collationName }

func (s *CollateClauseContext) SetCollationName(v IMultipartIdentifierContext) { s.collationName = v }

func (s *CollateClauseContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLLATE, 0)
}

func (s *CollateClauseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CollateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCollateClause(s)
	}
}

func (s *CollateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCollateClause(s)
	}
}

func (p *SqlBaseParser) CollateClause() (localctx ICollateClauseContext) {
	localctx = NewCollateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, SqlBaseParserRULE_collateClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4153)
		p.Match(SqlBaseParserCOLLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4154)

		var _x = p.MultipartIdentifier()

		localctx.(*CollateClauseContext).collationName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonTrivialPrimitiveTypeContext is an interface to support dynamic dispatch.
type INonTrivialPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLength returns the length token.
	GetLength() antlr.Token

	// GetPrecision returns the precision token.
	GetPrecision() antlr.Token

	// GetScale returns the scale token.
	GetScale() antlr.Token

	// GetFromYearMonth returns the fromYearMonth token.
	GetFromYearMonth() antlr.Token

	// GetTo returns the to token.
	GetTo() antlr.Token

	// GetFromDayTime returns the fromDayTime token.
	GetFromDayTime() antlr.Token

	// SetLength sets the length token.
	SetLength(antlr.Token)

	// SetPrecision sets the precision token.
	SetPrecision(antlr.Token)

	// SetScale sets the scale token.
	SetScale(antlr.Token)

	// SetFromYearMonth sets the fromYearMonth token.
	SetFromYearMonth(antlr.Token)

	// SetTo sets the to token.
	SetTo(antlr.Token)

	// SetFromDayTime sets the fromDayTime token.
	SetFromDayTime(antlr.Token)

	// Getter signatures
	STRING() antlr.TerminalNode
	CollateClause() ICollateClauseContext
	CHARACTER() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DEC() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	AllMONTH() []antlr.TerminalNode
	MONTH(i int) antlr.TerminalNode
	DAY() antlr.TerminalNode
	AllHOUR() []antlr.TerminalNode
	HOUR(i int) antlr.TerminalNode
	AllMINUTE() []antlr.TerminalNode
	MINUTE(i int) antlr.TerminalNode
	AllSECOND() []antlr.TerminalNode
	SECOND(i int) antlr.TerminalNode
	TO() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	AllTIME() []antlr.TerminalNode
	TIME(i int) antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsNonTrivialPrimitiveTypeContext differentiates from other interfaces.
	IsNonTrivialPrimitiveTypeContext()
}

type NonTrivialPrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	length        antlr.Token
	precision     antlr.Token
	scale         antlr.Token
	fromYearMonth antlr.Token
	to            antlr.Token
	fromDayTime   antlr.Token
}

func NewEmptyNonTrivialPrimitiveTypeContext() *NonTrivialPrimitiveTypeContext {
	var p = new(NonTrivialPrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonTrivialPrimitiveType
	return p
}

func InitEmptyNonTrivialPrimitiveTypeContext(p *NonTrivialPrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonTrivialPrimitiveType
}

func (*NonTrivialPrimitiveTypeContext) IsNonTrivialPrimitiveTypeContext() {}

func NewNonTrivialPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonTrivialPrimitiveTypeContext {
	var p = new(NonTrivialPrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nonTrivialPrimitiveType

	return p
}

func (s *NonTrivialPrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NonTrivialPrimitiveTypeContext) GetLength() antlr.Token { return s.length }

func (s *NonTrivialPrimitiveTypeContext) GetPrecision() antlr.Token { return s.precision }

func (s *NonTrivialPrimitiveTypeContext) GetScale() antlr.Token { return s.scale }

func (s *NonTrivialPrimitiveTypeContext) GetFromYearMonth() antlr.Token { return s.fromYearMonth }

func (s *NonTrivialPrimitiveTypeContext) GetTo() antlr.Token { return s.to }

func (s *NonTrivialPrimitiveTypeContext) GetFromDayTime() antlr.Token { return s.fromDayTime }

func (s *NonTrivialPrimitiveTypeContext) SetLength(v antlr.Token) { s.length = v }

func (s *NonTrivialPrimitiveTypeContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *NonTrivialPrimitiveTypeContext) SetScale(v antlr.Token) { s.scale = v }

func (s *NonTrivialPrimitiveTypeContext) SetFromYearMonth(v antlr.Token) { s.fromYearMonth = v }

func (s *NonTrivialPrimitiveTypeContext) SetTo(v antlr.Token) { s.to = v }

func (s *NonTrivialPrimitiveTypeContext) SetFromDayTime(v antlr.Token) { s.fromDayTime = v }

func (s *NonTrivialPrimitiveTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *NonTrivialPrimitiveTypeContext) CollateClause() ICollateClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *NonTrivialPrimitiveTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHARACTER, 0)
}

func (s *NonTrivialPrimitiveTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHAR, 0)
}

func (s *NonTrivialPrimitiveTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *NonTrivialPrimitiveTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *NonTrivialPrimitiveTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserINTEGER_VALUE)
}

func (s *NonTrivialPrimitiveTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, i)
}

func (s *NonTrivialPrimitiveTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARCHAR, 0)
}

func (s *NonTrivialPrimitiveTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL, 0)
}

func (s *NonTrivialPrimitiveTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEC, 0)
}

func (s *NonTrivialPrimitiveTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNUMERIC, 0)
}

func (s *NonTrivialPrimitiveTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, 0)
}

func (s *NonTrivialPrimitiveTypeContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *NonTrivialPrimitiveTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *NonTrivialPrimitiveTypeContext) AllMONTH() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserMONTH)
}

func (s *NonTrivialPrimitiveTypeContext) MONTH(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, i)
}

func (s *NonTrivialPrimitiveTypeContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *NonTrivialPrimitiveTypeContext) AllHOUR() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserHOUR)
}

func (s *NonTrivialPrimitiveTypeContext) HOUR(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, i)
}

func (s *NonTrivialPrimitiveTypeContext) AllMINUTE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserMINUTE)
}

func (s *NonTrivialPrimitiveTypeContext) MINUTE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, i)
}

func (s *NonTrivialPrimitiveTypeContext) AllSECOND() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserSECOND)
}

func (s *NonTrivialPrimitiveTypeContext) SECOND(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, i)
}

func (s *NonTrivialPrimitiveTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *NonTrivialPrimitiveTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *NonTrivialPrimitiveTypeContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHOUT, 0)
}

func (s *NonTrivialPrimitiveTypeContext) AllTIME() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTIME)
}

func (s *NonTrivialPrimitiveTypeContext) TIME(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, i)
}

func (s *NonTrivialPrimitiveTypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *NonTrivialPrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonTrivialPrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonTrivialPrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNonTrivialPrimitiveType(s)
	}
}

func (s *NonTrivialPrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNonTrivialPrimitiveType(s)
	}
}

func (p *SqlBaseParser) NonTrivialPrimitiveType() (localctx INonTrivialPrimitiveTypeContext) {
	localctx = NewNonTrivialPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, SqlBaseParserRULE_nonTrivialPrimitiveType)
	var _la int

	p.SetState(4212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4156)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4158)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4157)
				p.CollateClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserCHAR, SqlBaseParserCHARACTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4160)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserCHAR || _la == SqlBaseParserCHARACTER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4164)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4161)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4162)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*NonTrivialPrimitiveTypeContext).length = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4163)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserVARCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4166)
			p.Match(SqlBaseParserVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4170)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4167)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4168)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*NonTrivialPrimitiveTypeContext).length = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4169)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserDEC, SqlBaseParserDECIMAL, SqlBaseParserNUMERIC:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4172)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDEC || _la == SqlBaseParserDECIMAL || _la == SqlBaseParserNUMERIC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4180)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 521, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4173)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4174)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*NonTrivialPrimitiveTypeContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4177)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserCOMMA {
				{
					p.SetState(4175)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4176)

					var _m = p.Match(SqlBaseParserINTEGER_VALUE)

					localctx.(*NonTrivialPrimitiveTypeContext).scale = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4179)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserINTERVAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4182)
			p.Match(SqlBaseParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 524, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4183)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*NonTrivialPrimitiveTypeContext).fromYearMonth = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserMONTH || _la == SqlBaseParserYEAR) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*NonTrivialPrimitiveTypeContext).fromYearMonth = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(4186)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 522, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4184)
					p.Match(SqlBaseParserTO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4185)

					var _m = p.Match(SqlBaseParserMONTH)

					localctx.(*NonTrivialPrimitiveTypeContext).to = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 524, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4188)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*NonTrivialPrimitiveTypeContext).fromDayTime = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserDAY || _la == SqlBaseParserHOUR || _la == SqlBaseParserMINUTE || _la == SqlBaseParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*NonTrivialPrimitiveTypeContext).fromDayTime = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(4191)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4189)
					p.Match(SqlBaseParserTO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4190)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*NonTrivialPrimitiveTypeContext).to = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserHOUR || _la == SqlBaseParserMINUTE || _la == SqlBaseParserSECOND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*NonTrivialPrimitiveTypeContext).to = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4195)
			p.Match(SqlBaseParserTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4199)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 525, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4196)
				p.Match(SqlBaseParserWITHOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4197)
				p.Match(SqlBaseParserTIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4198)
				p.Match(SqlBaseParserZONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4201)
			p.Match(SqlBaseParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4205)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 526, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4202)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4203)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*NonTrivialPrimitiveTypeContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4204)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4210)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 527, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4207)
				p.Match(SqlBaseParserWITHOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4208)
				p.Match(SqlBaseParserTIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4209)
				p.Match(SqlBaseParserZONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrivialPrimitiveTypeContext is an interface to support dynamic dispatch.
type ITrivialPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	BYTE() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	SHORT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LONG() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	TIMESTAMP_LTZ() antlr.TerminalNode
	TIMESTAMP_NTZ() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	VOID() antlr.TerminalNode
	VARIANT() antlr.TerminalNode

	// IsTrivialPrimitiveTypeContext differentiates from other interfaces.
	IsTrivialPrimitiveTypeContext()
}

type TrivialPrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrivialPrimitiveTypeContext() *TrivialPrimitiveTypeContext {
	var p = new(TrivialPrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_trivialPrimitiveType
	return p
}

func InitEmptyTrivialPrimitiveTypeContext(p *TrivialPrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_trivialPrimitiveType
}

func (*TrivialPrimitiveTypeContext) IsTrivialPrimitiveTypeContext() {}

func NewTrivialPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrivialPrimitiveTypeContext {
	var p = new(TrivialPrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_trivialPrimitiveType

	return p
}

func (s *TrivialPrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TrivialPrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBOOLEAN, 0)
}

func (s *TrivialPrimitiveTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTINYINT, 0)
}

func (s *TrivialPrimitiveTypeContext) BYTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBYTE, 0)
}

func (s *TrivialPrimitiveTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSMALLINT, 0)
}

func (s *TrivialPrimitiveTypeContext) SHORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHORT, 0)
}

func (s *TrivialPrimitiveTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINT, 0)
}

func (s *TrivialPrimitiveTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER, 0)
}

func (s *TrivialPrimitiveTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBIGINT, 0)
}

func (s *TrivialPrimitiveTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLONG, 0)
}

func (s *TrivialPrimitiveTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOAT, 0)
}

func (s *TrivialPrimitiveTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAL, 0)
}

func (s *TrivialPrimitiveTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE, 0)
}

func (s *TrivialPrimitiveTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *TrivialPrimitiveTypeContext) TIMESTAMP_LTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_LTZ, 0)
}

func (s *TrivialPrimitiveTypeContext) TIMESTAMP_NTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_NTZ, 0)
}

func (s *TrivialPrimitiveTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY, 0)
}

func (s *TrivialPrimitiveTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVOID, 0)
}

func (s *TrivialPrimitiveTypeContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIANT, 0)
}

func (s *TrivialPrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrivialPrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrivialPrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTrivialPrimitiveType(s)
	}
}

func (s *TrivialPrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTrivialPrimitiveType(s)
	}
}

func (p *SqlBaseParser) TrivialPrimitiveType() (localctx ITrivialPrimitiveTypeContext) {
	localctx = NewTrivialPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, SqlBaseParserRULE_trivialPrimitiveType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4214)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&143344533504) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&4503599694479361) != 0) || ((int64((_la-175)) & ^0x3f) == 0 && ((int64(1)<<(_la-175))&1073741827) != 0) || ((int64((_la-269)) & ^0x3f) == 0 && ((int64(1)<<(_la-269))&149533581377537) != 0) || ((int64((_la-349)) & ^0x3f) == 0 && ((int64(1)<<(_la-349))&1168231104531) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnsupportedType returns the unsupportedType rule contexts.
	GetUnsupportedType() IIdentifierContext

	// SetUnsupportedType sets the unsupportedType rule contexts.
	SetUnsupportedType(IIdentifierContext)

	// Getter signatures
	NonTrivialPrimitiveType() INonTrivialPrimitiveTypeContext
	TrivialPrimitiveType() ITrivialPrimitiveTypeContext
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	unsupportedType IIdentifierContext
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) GetUnsupportedType() IIdentifierContext { return s.unsupportedType }

func (s *PrimitiveTypeContext) SetUnsupportedType(v IIdentifierContext) { s.unsupportedType = v }

func (s *PrimitiveTypeContext) NonTrivialPrimitiveType() INonTrivialPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonTrivialPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonTrivialPrimitiveTypeContext)
}

func (s *PrimitiveTypeContext) TrivialPrimitiveType() ITrivialPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrivialPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrivialPrimitiveTypeContext)
}

func (s *PrimitiveTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimitiveTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *PrimitiveTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserINTEGER_VALUE)
}

func (s *PrimitiveTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, i)
}

func (s *PrimitiveTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *PrimitiveTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *PrimitiveTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *SqlBaseParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, SqlBaseParserRULE_primitiveType)
	var _la int

	p.SetState(4231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4216)
			p.NonTrivialPrimitiveType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4217)
			p.TrivialPrimitiveType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4218)

			var _x = p.Identifier()

			localctx.(*PrimitiveTypeContext).unsupportedType = _x
		}
		p.SetState(4229)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 530, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4219)
				p.Match(SqlBaseParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4220)
				p.Match(SqlBaseParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4225)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(4221)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4222)
					p.Match(SqlBaseParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(4227)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4228)
				p.Match(SqlBaseParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComplexDataTypeContext struct {
	DataTypeContext
	complex_ antlr.Token
}

func NewComplexDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComplexDataTypeContext {
	var p = new(ComplexDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *ComplexDataTypeContext) GetComplex_() antlr.Token { return s.complex_ }

func (s *ComplexDataTypeContext) SetComplex_(v antlr.Token) { s.complex_ = v }

func (s *ComplexDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *ComplexDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *ComplexDataTypeContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexDataTypeContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *ComplexDataTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *ComplexDataTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, 0)
}

func (s *ComplexDataTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT, 0)
}

func (s *ComplexDataTypeContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEQ, 0)
}

func (s *ComplexDataTypeContext) ComplexColTypeList() IComplexColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeListContext)
}

func (s *ComplexDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterComplexDataType(s)
	}
}

func (s *ComplexDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitComplexDataType(s)
	}
}

type PrimitiveDataTypeContext struct {
	DataTypeContext
}

func NewPrimitiveDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimitiveDataTypeContext {
	var p = new(PrimitiveDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *PrimitiveDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveDataTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *PrimitiveDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterPrimitiveDataType(s)
	}
}

func (s *PrimitiveDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitPrimitiveDataType(s)
	}
}

func (p *SqlBaseParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, SqlBaseParserRULE_dataType)
	p.SetState(4259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4233)

			var _m = p.Match(SqlBaseParserARRAY)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4238)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4234)
				p.Match(SqlBaseParserLT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4235)
				p.DataType()
			}
			{
				p.SetState(4236)
				p.Match(SqlBaseParserGT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4240)

			var _m = p.Match(SqlBaseParserMAP)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4247)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4241)
				p.Match(SqlBaseParserLT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4242)
				p.DataType()
			}
			{
				p.SetState(4243)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4244)
				p.DataType()
			}
			{
				p.SetState(4245)
				p.Match(SqlBaseParserGT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4249)

			var _m = p.Match(SqlBaseParserSTRUCT)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4256)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4250)
				p.Match(SqlBaseParserLT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4252)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4251)
					p.ComplexColTypeList()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(4254)
				p.Match(SqlBaseParserGT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4255)
				p.Match(SqlBaseParserNEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewPrimitiveDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4258)
			p.PrimitiveType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedColTypeWithPositionListContext is an interface to support dynamic dispatch.
type IQualifiedColTypeWithPositionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedColTypeWithPosition() []IQualifiedColTypeWithPositionContext
	QualifiedColTypeWithPosition(i int) IQualifiedColTypeWithPositionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsQualifiedColTypeWithPositionListContext differentiates from other interfaces.
	IsQualifiedColTypeWithPositionListContext()
}

type QualifiedColTypeWithPositionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedColTypeWithPositionListContext() *QualifiedColTypeWithPositionListContext {
	var p = new(QualifiedColTypeWithPositionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedColTypeWithPositionList
	return p
}

func InitEmptyQualifiedColTypeWithPositionListContext(p *QualifiedColTypeWithPositionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedColTypeWithPositionList
}

func (*QualifiedColTypeWithPositionListContext) IsQualifiedColTypeWithPositionListContext() {}

func NewQualifiedColTypeWithPositionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedColTypeWithPositionListContext {
	var p = new(QualifiedColTypeWithPositionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_qualifiedColTypeWithPositionList

	return p
}

func (s *QualifiedColTypeWithPositionListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedColTypeWithPositionListContext) AllQualifiedColTypeWithPosition() []IQualifiedColTypeWithPositionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedColTypeWithPositionContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedColTypeWithPositionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedColTypeWithPositionContext); ok {
			tst[i] = t.(IQualifiedColTypeWithPositionContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedColTypeWithPositionListContext) QualifiedColTypeWithPosition(i int) IQualifiedColTypeWithPositionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedColTypeWithPositionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedColTypeWithPositionContext)
}

func (s *QualifiedColTypeWithPositionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *QualifiedColTypeWithPositionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *QualifiedColTypeWithPositionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedColTypeWithPositionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedColTypeWithPositionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQualifiedColTypeWithPositionList(s)
	}
}

func (s *QualifiedColTypeWithPositionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQualifiedColTypeWithPositionList(s)
	}
}

func (p *SqlBaseParser) QualifiedColTypeWithPositionList() (localctx IQualifiedColTypeWithPositionListContext) {
	localctx = NewQualifiedColTypeWithPositionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, SqlBaseParserRULE_qualifiedColTypeWithPositionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4261)
		p.QualifiedColTypeWithPosition()
	}
	p.SetState(4266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(4262)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4263)
			p.QualifiedColTypeWithPosition()
		}

		p.SetState(4268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedColTypeWithPositionContext is an interface to support dynamic dispatch.
type IQualifiedColTypeWithPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IMultipartIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IMultipartIdentifierContext)

	// Getter signatures
	DataType() IDataTypeContext
	MultipartIdentifier() IMultipartIdentifierContext
	AllColDefinitionDescriptorWithPosition() []IColDefinitionDescriptorWithPositionContext
	ColDefinitionDescriptorWithPosition(i int) IColDefinitionDescriptorWithPositionContext

	// IsQualifiedColTypeWithPositionContext differentiates from other interfaces.
	IsQualifiedColTypeWithPositionContext()
}

type QualifiedColTypeWithPositionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IMultipartIdentifierContext
}

func NewEmptyQualifiedColTypeWithPositionContext() *QualifiedColTypeWithPositionContext {
	var p = new(QualifiedColTypeWithPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedColTypeWithPosition
	return p
}

func InitEmptyQualifiedColTypeWithPositionContext(p *QualifiedColTypeWithPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedColTypeWithPosition
}

func (*QualifiedColTypeWithPositionContext) IsQualifiedColTypeWithPositionContext() {}

func NewQualifiedColTypeWithPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedColTypeWithPositionContext {
	var p = new(QualifiedColTypeWithPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_qualifiedColTypeWithPosition

	return p
}

func (s *QualifiedColTypeWithPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedColTypeWithPositionContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *QualifiedColTypeWithPositionContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *QualifiedColTypeWithPositionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *QualifiedColTypeWithPositionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *QualifiedColTypeWithPositionContext) AllColDefinitionDescriptorWithPosition() []IColDefinitionDescriptorWithPositionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColDefinitionDescriptorWithPositionContext); ok {
			len++
		}
	}

	tst := make([]IColDefinitionDescriptorWithPositionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColDefinitionDescriptorWithPositionContext); ok {
			tst[i] = t.(IColDefinitionDescriptorWithPositionContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedColTypeWithPositionContext) ColDefinitionDescriptorWithPosition(i int) IColDefinitionDescriptorWithPositionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColDefinitionDescriptorWithPositionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColDefinitionDescriptorWithPositionContext)
}

func (s *QualifiedColTypeWithPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedColTypeWithPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedColTypeWithPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQualifiedColTypeWithPosition(s)
	}
}

func (s *QualifiedColTypeWithPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQualifiedColTypeWithPosition(s)
	}
}

func (p *SqlBaseParser) QualifiedColTypeWithPosition() (localctx IQualifiedColTypeWithPositionContext) {
	localctx = NewQualifiedColTypeWithPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, SqlBaseParserRULE_qualifiedColTypeWithPosition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4269)

		var _x = p.MultipartIdentifier()

		localctx.(*QualifiedColTypeWithPositionContext).name = _x
	}
	{
		p.SetState(4270)
		p.DataType()
	}
	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 538, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4271)
				p.ColDefinitionDescriptorWithPosition()
			}

		}
		p.SetState(4276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 538, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColDefinitionDescriptorWithPositionContext is an interface to support dynamic dispatch.
type IColDefinitionDescriptorWithPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ErrorCapturingNot() IErrorCapturingNotContext
	NULL() antlr.TerminalNode
	DefaultExpression() IDefaultExpressionContext
	CommentSpec() ICommentSpecContext
	ColPosition() IColPositionContext

	// IsColDefinitionDescriptorWithPositionContext differentiates from other interfaces.
	IsColDefinitionDescriptorWithPositionContext()
}

type ColDefinitionDescriptorWithPositionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColDefinitionDescriptorWithPositionContext() *ColDefinitionDescriptorWithPositionContext {
	var p = new(ColDefinitionDescriptorWithPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinitionDescriptorWithPosition
	return p
}

func InitEmptyColDefinitionDescriptorWithPositionContext(p *ColDefinitionDescriptorWithPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinitionDescriptorWithPosition
}

func (*ColDefinitionDescriptorWithPositionContext) IsColDefinitionDescriptorWithPositionContext() {}

func NewColDefinitionDescriptorWithPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColDefinitionDescriptorWithPositionContext {
	var p = new(ColDefinitionDescriptorWithPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_colDefinitionDescriptorWithPosition

	return p
}

func (s *ColDefinitionDescriptorWithPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColDefinitionDescriptorWithPositionContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *ColDefinitionDescriptorWithPositionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *ColDefinitionDescriptorWithPositionContext) DefaultExpression() IDefaultExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultExpressionContext)
}

func (s *ColDefinitionDescriptorWithPositionContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ColDefinitionDescriptorWithPositionContext) ColPosition() IColPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColPositionContext)
}

func (s *ColDefinitionDescriptorWithPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColDefinitionDescriptorWithPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColDefinitionDescriptorWithPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColDefinitionDescriptorWithPosition(s)
	}
}

func (s *ColDefinitionDescriptorWithPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColDefinitionDescriptorWithPosition(s)
	}
}

func (p *SqlBaseParser) ColDefinitionDescriptorWithPosition() (localctx IColDefinitionDescriptorWithPositionContext) {
	localctx = NewColDefinitionDescriptorWithPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, SqlBaseParserRULE_colDefinitionDescriptorWithPosition)
	p.SetState(4283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserBANG, SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4277)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(4278)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4280)
			p.DefaultExpression()
		}

	case SqlBaseParserCOMMENT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4281)
			p.CommentSpec()
		}

	case SqlBaseParserAFTER, SqlBaseParserFIRST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4282)
			p.ColPosition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultExpressionContext is an interface to support dynamic dispatch.
type IDefaultExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDefaultExpressionContext differentiates from other interfaces.
	IsDefaultExpressionContext()
}

type DefaultExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultExpressionContext() *DefaultExpressionContext {
	var p = new(DefaultExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_defaultExpression
	return p
}

func InitEmptyDefaultExpressionContext(p *DefaultExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_defaultExpression
}

func (*DefaultExpressionContext) IsDefaultExpressionContext() {}

func NewDefaultExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultExpressionContext {
	var p = new(DefaultExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_defaultExpression

	return p
}

func (s *DefaultExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultExpressionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *DefaultExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDefaultExpression(s)
	}
}

func (s *DefaultExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDefaultExpression(s)
	}
}

func (p *SqlBaseParser) DefaultExpression() (localctx IDefaultExpressionContext) {
	localctx = NewDefaultExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, SqlBaseParserRULE_defaultExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4285)
		p.Match(SqlBaseParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4286)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDefaultExpressionContext is an interface to support dynamic dispatch.
type IVariableDefaultExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsVariableDefaultExpressionContext differentiates from other interfaces.
	IsVariableDefaultExpressionContext()
}

type VariableDefaultExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDefaultExpressionContext() *VariableDefaultExpressionContext {
	var p = new(VariableDefaultExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variableDefaultExpression
	return p
}

func InitEmptyVariableDefaultExpressionContext(p *VariableDefaultExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variableDefaultExpression
}

func (*VariableDefaultExpressionContext) IsVariableDefaultExpressionContext() {}

func NewVariableDefaultExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDefaultExpressionContext {
	var p = new(VariableDefaultExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_variableDefaultExpression

	return p
}

func (s *VariableDefaultExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDefaultExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDefaultExpressionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *VariableDefaultExpressionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *VariableDefaultExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDefaultExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDefaultExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterVariableDefaultExpression(s)
	}
}

func (s *VariableDefaultExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitVariableDefaultExpression(s)
	}
}

func (p *SqlBaseParser) VariableDefaultExpression() (localctx IVariableDefaultExpressionContext) {
	localctx = NewVariableDefaultExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, SqlBaseParserRULE_variableDefaultExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4288)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDEFAULT || _la == SqlBaseParserEQ) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4289)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColTypeListContext is an interface to support dynamic dispatch.
type IColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColType() []IColTypeContext
	ColType(i int) IColTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColTypeListContext differentiates from other interfaces.
	IsColTypeListContext()
}

type ColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColTypeListContext() *ColTypeListContext {
	var p = new(ColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colTypeList
	return p
}

func InitEmptyColTypeListContext(p *ColTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colTypeList
}

func (*ColTypeListContext) IsColTypeListContext() {}

func NewColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColTypeListContext {
	var p = new(ColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_colTypeList

	return p
}

func (s *ColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColTypeListContext) AllColType() []IColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColTypeContext); ok {
			len++
		}
	}

	tst := make([]IColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColTypeContext); ok {
			tst[i] = t.(IColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ColTypeListContext) ColType(i int) IColTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColTypeContext)
}

func (s *ColTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ColTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColTypeList(s)
	}
}

func (s *ColTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColTypeList(s)
	}
}

func (p *SqlBaseParser) ColTypeList() (localctx IColTypeListContext) {
	localctx = NewColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, SqlBaseParserRULE_colTypeList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4291)
		p.ColType()
	}
	p.SetState(4296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 540, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4292)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4293)
				p.ColType()
			}

		}
		p.SetState(4298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 540, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColTypeContext is an interface to support dynamic dispatch.
type IColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColName returns the colName rule contexts.
	GetColName() IErrorCapturingIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IErrorCapturingIdentifierContext)

	// Getter signatures
	DataType() IDataTypeContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	ErrorCapturingNot() IErrorCapturingNotContext
	NULL() antlr.TerminalNode
	CommentSpec() ICommentSpecContext

	// IsColTypeContext differentiates from other interfaces.
	IsColTypeContext()
}

type ColTypeContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	colName IErrorCapturingIdentifierContext
}

func NewEmptyColTypeContext() *ColTypeContext {
	var p = new(ColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colType
	return p
}

func InitEmptyColTypeContext(p *ColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colType
}

func (*ColTypeContext) IsColTypeContext() {}

func NewColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColTypeContext {
	var p = new(ColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_colType

	return p
}

func (s *ColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ColTypeContext) GetColName() IErrorCapturingIdentifierContext { return s.colName }

func (s *ColTypeContext) SetColName(v IErrorCapturingIdentifierContext) { s.colName = v }

func (s *ColTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColTypeContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *ColTypeContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *ColTypeContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *ColTypeContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColType(s)
	}
}

func (s *ColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColType(s)
	}
}

func (p *SqlBaseParser) ColType() (localctx IColTypeContext) {
	localctx = NewColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, SqlBaseParserRULE_colType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4299)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*ColTypeContext).colName = _x
	}
	{
		p.SetState(4300)
		p.DataType()
	}
	p.SetState(4304)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4301)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(4302)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4307)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4306)
			p.CommentSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementListContext is an interface to support dynamic dispatch.
type ITableElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableElement() []ITableElementContext
	TableElement(i int) ITableElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableElementListContext differentiates from other interfaces.
	IsTableElementListContext()
}

type TableElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementListContext() *TableElementListContext {
	var p = new(TableElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElementList
	return p
}

func InitEmptyTableElementListContext(p *TableElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElementList
}

func (*TableElementListContext) IsTableElementListContext() {}

func NewTableElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementListContext {
	var p = new(TableElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableElementList

	return p
}

func (s *TableElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementListContext) AllTableElement() []ITableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementContext); ok {
			len++
		}
	}

	tst := make([]ITableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementContext); ok {
			tst[i] = t.(ITableElementContext)
			i++
		}
	}

	return tst
}

func (s *TableElementListContext) TableElement(i int) ITableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *TableElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *TableElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *TableElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableElementList(s)
	}
}

func (s *TableElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableElementList(s)
	}
}

func (p *SqlBaseParser) TableElementList() (localctx ITableElementListContext) {
	localctx = NewTableElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, SqlBaseParserRULE_tableElementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4309)
		p.TableElement()
	}
	p.SetState(4314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(4310)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4311)
			p.TableElement()
		}

		p.SetState(4316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableConstraintDefinition() ITableConstraintDefinitionContext
	ColDefinition() IColDefinitionContext

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElement
	return p
}

func InitEmptyTableElementContext(p *TableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElement
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) TableConstraintDefinition() ITableConstraintDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintDefinitionContext)
}

func (s *TableElementContext) ColDefinition() IColDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColDefinitionContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *SqlBaseParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, SqlBaseParserRULE_tableElement)
	p.SetState(4319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 544, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4317)
			p.TableConstraintDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4318)
			p.ColDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColDefinitionListContext is an interface to support dynamic dispatch.
type IColDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColDefinition() []IColDefinitionContext
	ColDefinition(i int) IColDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColDefinitionListContext differentiates from other interfaces.
	IsColDefinitionListContext()
}

type ColDefinitionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColDefinitionListContext() *ColDefinitionListContext {
	var p = new(ColDefinitionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinitionList
	return p
}

func InitEmptyColDefinitionListContext(p *ColDefinitionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinitionList
}

func (*ColDefinitionListContext) IsColDefinitionListContext() {}

func NewColDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColDefinitionListContext {
	var p = new(ColDefinitionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_colDefinitionList

	return p
}

func (s *ColDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColDefinitionListContext) AllColDefinition() []IColDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColDefinitionContext); ok {
			tst[i] = t.(IColDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ColDefinitionListContext) ColDefinition(i int) IColDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColDefinitionContext)
}

func (s *ColDefinitionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ColDefinitionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ColDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColDefinitionList(s)
	}
}

func (s *ColDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColDefinitionList(s)
	}
}

func (p *SqlBaseParser) ColDefinitionList() (localctx IColDefinitionListContext) {
	localctx = NewColDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, SqlBaseParserRULE_colDefinitionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4321)
		p.ColDefinition()
	}
	p.SetState(4326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(4322)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4323)
			p.ColDefinition()
		}

		p.SetState(4328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColDefinitionContext is an interface to support dynamic dispatch.
type IColDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColName returns the colName rule contexts.
	GetColName() IErrorCapturingIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IErrorCapturingIdentifierContext)

	// Getter signatures
	DataType() IDataTypeContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	AllColDefinitionOption() []IColDefinitionOptionContext
	ColDefinitionOption(i int) IColDefinitionOptionContext

	// IsColDefinitionContext differentiates from other interfaces.
	IsColDefinitionContext()
}

type ColDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	colName IErrorCapturingIdentifierContext
}

func NewEmptyColDefinitionContext() *ColDefinitionContext {
	var p = new(ColDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinition
	return p
}

func InitEmptyColDefinitionContext(p *ColDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinition
}

func (*ColDefinitionContext) IsColDefinitionContext() {}

func NewColDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColDefinitionContext {
	var p = new(ColDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_colDefinition

	return p
}

func (s *ColDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColDefinitionContext) GetColName() IErrorCapturingIdentifierContext { return s.colName }

func (s *ColDefinitionContext) SetColName(v IErrorCapturingIdentifierContext) { s.colName = v }

func (s *ColDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColDefinitionContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *ColDefinitionContext) AllColDefinitionOption() []IColDefinitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColDefinitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IColDefinitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColDefinitionOptionContext); ok {
			tst[i] = t.(IColDefinitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *ColDefinitionContext) ColDefinitionOption(i int) IColDefinitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColDefinitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColDefinitionOptionContext)
}

func (s *ColDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColDefinition(s)
	}
}

func (s *ColDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColDefinition(s)
	}
}

func (p *SqlBaseParser) ColDefinition() (localctx IColDefinitionContext) {
	localctx = NewColDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, SqlBaseParserRULE_colDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4329)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*ColDefinitionContext).colName = _x
	}
	{
		p.SetState(4330)
		p.DataType()
	}
	p.SetState(4334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-8)) & ^0x3f) == 0 && ((int64(1)<<(_la-8))&578714751140364289) != 0) || _la == SqlBaseParserDEFAULT || _la == SqlBaseParserGENERATED || ((int64((_la-231)) & ^0x3f) == 0 && ((int64(1)<<(_la-231))&35184640524289) != 0) || _la == SqlBaseParserUNIQUE {
		{
			p.SetState(4331)
			p.ColDefinitionOption()
		}

		p.SetState(4336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColDefinitionOptionContext is an interface to support dynamic dispatch.
type IColDefinitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ErrorCapturingNot() IErrorCapturingNotContext
	NULL() antlr.TerminalNode
	DefaultExpression() IDefaultExpressionContext
	GenerationExpression() IGenerationExpressionContext
	CommentSpec() ICommentSpecContext
	ColumnConstraintDefinition() IColumnConstraintDefinitionContext

	// IsColDefinitionOptionContext differentiates from other interfaces.
	IsColDefinitionOptionContext()
}

type ColDefinitionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColDefinitionOptionContext() *ColDefinitionOptionContext {
	var p = new(ColDefinitionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinitionOption
	return p
}

func InitEmptyColDefinitionOptionContext(p *ColDefinitionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_colDefinitionOption
}

func (*ColDefinitionOptionContext) IsColDefinitionOptionContext() {}

func NewColDefinitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColDefinitionOptionContext {
	var p = new(ColDefinitionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_colDefinitionOption

	return p
}

func (s *ColDefinitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColDefinitionOptionContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *ColDefinitionOptionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *ColDefinitionOptionContext) DefaultExpression() IDefaultExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultExpressionContext)
}

func (s *ColDefinitionOptionContext) GenerationExpression() IGenerationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenerationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenerationExpressionContext)
}

func (s *ColDefinitionOptionContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ColDefinitionOptionContext) ColumnConstraintDefinition() IColumnConstraintDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintDefinitionContext)
}

func (s *ColDefinitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColDefinitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColDefinitionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColDefinitionOption(s)
	}
}

func (s *ColDefinitionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColDefinitionOption(s)
	}
}

func (p *SqlBaseParser) ColDefinitionOption() (localctx IColDefinitionOptionContext) {
	localctx = NewColDefinitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, SqlBaseParserRULE_colDefinitionOption)
	p.SetState(4344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserBANG, SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4337)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(4338)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4340)
			p.DefaultExpression()
		}

	case SqlBaseParserGENERATED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4341)
			p.GenerationExpression()
		}

	case SqlBaseParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4342)
			p.CommentSpec()
		}

	case SqlBaseParserCHECK, SqlBaseParserCONSTRAINT, SqlBaseParserPRIMARY, SqlBaseParserREFERENCES, SqlBaseParserUNIQUE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4343)
			p.ColumnConstraintDefinition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenerationExpressionContext is an interface to support dynamic dispatch.
type IGenerationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGenerationExpressionContext differentiates from other interfaces.
	IsGenerationExpressionContext()
}

type GenerationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerationExpressionContext() *GenerationExpressionContext {
	var p = new(GenerationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_generationExpression
	return p
}

func InitEmptyGenerationExpressionContext(p *GenerationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_generationExpression
}

func (*GenerationExpressionContext) IsGenerationExpressionContext() {}

func NewGenerationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenerationExpressionContext {
	var p = new(GenerationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_generationExpression

	return p
}

func (s *GenerationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *GenerationExpressionContext) CopyAll(ctx *GenerationExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GenerationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenerationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GeneratedColumnContext struct {
	GenerationExpressionContext
}

func NewGeneratedColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratedColumnContext {
	var p = new(GeneratedColumnContext)

	InitEmptyGenerationExpressionContext(&p.GenerationExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*GenerationExpressionContext))

	return p
}

func (s *GeneratedColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGENERATED, 0)
}

func (s *GeneratedColumnContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALWAYS, 0)
}

func (s *GeneratedColumnContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *GeneratedColumnContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *GeneratedColumnContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *GeneratedColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterGeneratedColumn(s)
	}
}

func (s *GeneratedColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitGeneratedColumn(s)
	}
}

type IdentityColumnContext struct {
	GenerationExpressionContext
}

func NewIdentityColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentityColumnContext {
	var p = new(IdentityColumnContext)

	InitEmptyGenerationExpressionContext(&p.GenerationExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*GenerationExpressionContext))

	return p
}

func (s *IdentityColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityColumnContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGENERATED, 0)
}

func (s *IdentityColumnContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *IdentityColumnContext) IDENTITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTITY, 0)
}

func (s *IdentityColumnContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALWAYS, 0)
}

func (s *IdentityColumnContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *IdentityColumnContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *IdentityColumnContext) IdentityColSpec() IIdentityColSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityColSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityColSpecContext)
}

func (s *IdentityColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentityColumn(s)
	}
}

func (s *IdentityColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentityColumn(s)
	}
}

func (p *SqlBaseParser) GenerationExpression() (localctx IGenerationExpressionContext) {
	localctx = NewGenerationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, SqlBaseParserRULE_generationExpression)
	var _la int

	p.SetState(4364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 550, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGeneratedColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4346)
			p.Match(SqlBaseParserGENERATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4347)
			p.Match(SqlBaseParserALWAYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4348)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4349)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4350)
			p.Expression()
		}
		{
			p.SetState(4351)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewIdentityColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4353)
			p.Match(SqlBaseParserGENERATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SqlBaseParserALWAYS:
			{
				p.SetState(4354)
				p.Match(SqlBaseParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SqlBaseParserBY:
			{
				p.SetState(4355)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4356)
				p.Match(SqlBaseParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(4359)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4360)
			p.Match(SqlBaseParserIDENTITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLEFT_PAREN {
			{
				p.SetState(4361)
				p.IdentityColSpec()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityColSpecContext is an interface to support dynamic dispatch.
type IIdentityColSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllSequenceGeneratorOption() []ISequenceGeneratorOptionContext
	SequenceGeneratorOption(i int) ISequenceGeneratorOptionContext

	// IsIdentityColSpecContext differentiates from other interfaces.
	IsIdentityColSpecContext()
}

type IdentityColSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentityColSpecContext() *IdentityColSpecContext {
	var p = new(IdentityColSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identityColSpec
	return p
}

func InitEmptyIdentityColSpecContext(p *IdentityColSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identityColSpec
}

func (*IdentityColSpecContext) IsIdentityColSpecContext() {}

func NewIdentityColSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityColSpecContext {
	var p = new(IdentityColSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identityColSpec

	return p
}

func (s *IdentityColSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityColSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *IdentityColSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *IdentityColSpecContext) AllSequenceGeneratorOption() []ISequenceGeneratorOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceGeneratorOptionContext); ok {
			len++
		}
	}

	tst := make([]ISequenceGeneratorOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceGeneratorOptionContext); ok {
			tst[i] = t.(ISequenceGeneratorOptionContext)
			i++
		}
	}

	return tst
}

func (s *IdentityColSpecContext) SequenceGeneratorOption(i int) ISequenceGeneratorOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceGeneratorOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceGeneratorOptionContext)
}

func (s *IdentityColSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityColSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityColSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentityColSpec(s)
	}
}

func (s *IdentityColSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentityColSpec(s)
	}
}

func (p *SqlBaseParser) IdentityColSpec() (localctx IIdentityColSpecContext) {
	localctx = NewIdentityColSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, SqlBaseParserRULE_identityColSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4366)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserINCREMENT || _la == SqlBaseParserSTART {
		{
			p.SetState(4367)
			p.SequenceGeneratorOption()
		}

		p.SetState(4372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4373)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceGeneratorOptionContext is an interface to support dynamic dispatch.
type ISequenceGeneratorOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() ISequenceGeneratorStartOrStepContext

	// GetStep returns the step rule contexts.
	GetStep() ISequenceGeneratorStartOrStepContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(ISequenceGeneratorStartOrStepContext)

	// SetStep sets the step rule contexts.
	SetStep(ISequenceGeneratorStartOrStepContext)

	// Getter signatures
	START() antlr.TerminalNode
	WITH() antlr.TerminalNode
	SequenceGeneratorStartOrStep() ISequenceGeneratorStartOrStepContext
	INCREMENT() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsSequenceGeneratorOptionContext differentiates from other interfaces.
	IsSequenceGeneratorOptionContext()
}

type SequenceGeneratorOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ ISequenceGeneratorStartOrStepContext
	step   ISequenceGeneratorStartOrStepContext
}

func NewEmptySequenceGeneratorOptionContext() *SequenceGeneratorOptionContext {
	var p = new(SequenceGeneratorOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sequenceGeneratorOption
	return p
}

func InitEmptySequenceGeneratorOptionContext(p *SequenceGeneratorOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sequenceGeneratorOption
}

func (*SequenceGeneratorOptionContext) IsSequenceGeneratorOptionContext() {}

func NewSequenceGeneratorOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceGeneratorOptionContext {
	var p = new(SequenceGeneratorOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sequenceGeneratorOption

	return p
}

func (s *SequenceGeneratorOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceGeneratorOptionContext) GetStart_() ISequenceGeneratorStartOrStepContext {
	return s.start_
}

func (s *SequenceGeneratorOptionContext) GetStep() ISequenceGeneratorStartOrStepContext {
	return s.step
}

func (s *SequenceGeneratorOptionContext) SetStart_(v ISequenceGeneratorStartOrStepContext) {
	s.start_ = v
}

func (s *SequenceGeneratorOptionContext) SetStep(v ISequenceGeneratorStartOrStepContext) { s.step = v }

func (s *SequenceGeneratorOptionContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *SequenceGeneratorOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *SequenceGeneratorOptionContext) SequenceGeneratorStartOrStep() ISequenceGeneratorStartOrStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceGeneratorStartOrStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceGeneratorStartOrStepContext)
}

func (s *SequenceGeneratorOptionContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCREMENT, 0)
}

func (s *SequenceGeneratorOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *SequenceGeneratorOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceGeneratorOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceGeneratorOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSequenceGeneratorOption(s)
	}
}

func (s *SequenceGeneratorOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSequenceGeneratorOption(s)
	}
}

func (p *SqlBaseParser) SequenceGeneratorOption() (localctx ISequenceGeneratorOptionContext) {
	localctx = NewSequenceGeneratorOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, SqlBaseParserRULE_sequenceGeneratorOption)
	p.SetState(4381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSTART:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4375)
			p.Match(SqlBaseParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4376)
			p.Match(SqlBaseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4377)

			var _x = p.SequenceGeneratorStartOrStep()

			localctx.(*SequenceGeneratorOptionContext).start_ = _x
		}

	case SqlBaseParserINCREMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4378)
			p.Match(SqlBaseParserINCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4379)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4380)

			var _x = p.SequenceGeneratorStartOrStep()

			localctx.(*SequenceGeneratorOptionContext).step = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceGeneratorStartOrStepContext is an interface to support dynamic dispatch.
type ISequenceGeneratorStartOrStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	BIGINT_LITERAL() antlr.TerminalNode

	// IsSequenceGeneratorStartOrStepContext differentiates from other interfaces.
	IsSequenceGeneratorStartOrStepContext()
}

type SequenceGeneratorStartOrStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceGeneratorStartOrStepContext() *SequenceGeneratorStartOrStepContext {
	var p = new(SequenceGeneratorStartOrStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sequenceGeneratorStartOrStep
	return p
}

func InitEmptySequenceGeneratorStartOrStepContext(p *SequenceGeneratorStartOrStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sequenceGeneratorStartOrStep
}

func (*SequenceGeneratorStartOrStepContext) IsSequenceGeneratorStartOrStepContext() {}

func NewSequenceGeneratorStartOrStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceGeneratorStartOrStepContext {
	var p = new(SequenceGeneratorStartOrStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sequenceGeneratorStartOrStep

	return p
}

func (s *SequenceGeneratorStartOrStepContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceGeneratorStartOrStepContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *SequenceGeneratorStartOrStepContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *SequenceGeneratorStartOrStepContext) BIGINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBIGINT_LITERAL, 0)
}

func (s *SequenceGeneratorStartOrStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceGeneratorStartOrStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceGeneratorStartOrStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSequenceGeneratorStartOrStep(s)
	}
}

func (s *SequenceGeneratorStartOrStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSequenceGeneratorStartOrStep(s)
	}
}

func (p *SqlBaseParser) SequenceGeneratorStartOrStep() (localctx ISequenceGeneratorStartOrStepContext) {
	localctx = NewSequenceGeneratorStartOrStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, SqlBaseParserRULE_sequenceGeneratorStartOrStep)
	var _la int

	p.SetState(4391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 555, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4383)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4386)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4387)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4390)
			p.Match(SqlBaseParserBIGINT_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeListContext is an interface to support dynamic dispatch.
type IComplexColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComplexColType() []IComplexColTypeContext
	ComplexColType(i int) IComplexColTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsComplexColTypeListContext differentiates from other interfaces.
	IsComplexColTypeListContext()
}

type ComplexColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeListContext() *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_complexColTypeList
	return p
}

func InitEmptyComplexColTypeListContext(p *ComplexColTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_complexColTypeList
}

func (*ComplexColTypeListContext) IsComplexColTypeListContext() {}

func NewComplexColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_complexColTypeList

	return p
}

func (s *ComplexColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeListContext) AllComplexColType() []IComplexColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			len++
		}
	}

	tst := make([]IComplexColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComplexColTypeContext); ok {
			tst[i] = t.(IComplexColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexColTypeListContext) ComplexColType(i int) IComplexColTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeContext)
}

func (s *ComplexColTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *ComplexColTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *ComplexColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterComplexColTypeList(s)
	}
}

func (s *ComplexColTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitComplexColTypeList(s)
	}
}

func (p *SqlBaseParser) ComplexColTypeList() (localctx IComplexColTypeListContext) {
	localctx = NewComplexColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, SqlBaseParserRULE_complexColTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4393)
		p.ComplexColType()
	}
	p.SetState(4398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(4394)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4395)
			p.ComplexColType()
		}

		p.SetState(4400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeContext is an interface to support dynamic dispatch.
type IComplexColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	DataType() IDataTypeContext
	COLON() antlr.TerminalNode
	ErrorCapturingNot() IErrorCapturingNotContext
	NULL() antlr.TerminalNode
	CommentSpec() ICommentSpecContext

	// IsComplexColTypeContext differentiates from other interfaces.
	IsComplexColTypeContext()
}

type ComplexColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeContext() *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_complexColType
	return p
}

func InitEmptyComplexColTypeContext(p *ComplexColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_complexColType
}

func (*ComplexColTypeContext) IsComplexColTypeContext() {}

func NewComplexColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_complexColType

	return p
}

func (s *ComplexColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *ComplexColTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexColTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLON, 0)
}

func (s *ComplexColTypeContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *ComplexColTypeContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *ComplexColTypeContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ComplexColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterComplexColType(s)
	}
}

func (s *ComplexColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitComplexColType(s)
	}
}

func (p *SqlBaseParser) ComplexColType() (localctx IComplexColTypeContext) {
	localctx = NewComplexColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, SqlBaseParserRULE_complexColType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4401)
		p.ErrorCapturingIdentifier()
	}
	p.SetState(4403)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 557, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4402)
			p.Match(SqlBaseParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4405)
		p.DataType()
	}
	p.SetState(4409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserBANG || _la == SqlBaseParserNOT {
		{
			p.SetState(4406)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(4407)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCOMMENT {
		{
			p.SetState(4411)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineCharacteristicsContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRoutineLanguage() []IRoutineLanguageContext
	RoutineLanguage(i int) IRoutineLanguageContext
	AllSpecificName() []ISpecificNameContext
	SpecificName(i int) ISpecificNameContext
	AllDeterministic() []IDeterministicContext
	Deterministic(i int) IDeterministicContext
	AllSqlDataAccess() []ISqlDataAccessContext
	SqlDataAccess(i int) ISqlDataAccessContext
	AllNullCall() []INullCallContext
	NullCall(i int) INullCallContext
	AllCommentSpec() []ICommentSpecContext
	CommentSpec(i int) ICommentSpecContext
	AllRightsClause() []IRightsClauseContext
	RightsClause(i int) IRightsClauseContext

	// IsRoutineCharacteristicsContext differentiates from other interfaces.
	IsRoutineCharacteristicsContext()
}

type RoutineCharacteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicsContext() *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics
	return p
}

func InitEmptyRoutineCharacteristicsContext(p *RoutineCharacteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics
}

func (*RoutineCharacteristicsContext) IsRoutineCharacteristicsContext() {}

func NewRoutineCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics

	return p
}

func (s *RoutineCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicsContext) AllRoutineLanguage() []IRoutineLanguageContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineLanguageContext); ok {
			len++
		}
	}

	tst := make([]IRoutineLanguageContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineLanguageContext); ok {
			tst[i] = t.(IRoutineLanguageContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) RoutineLanguage(i int) IRoutineLanguageContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineLanguageContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineLanguageContext)
}

func (s *RoutineCharacteristicsContext) AllSpecificName() []ISpecificNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISpecificNameContext); ok {
			len++
		}
	}

	tst := make([]ISpecificNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISpecificNameContext); ok {
			tst[i] = t.(ISpecificNameContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) SpecificName(i int) ISpecificNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecificNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecificNameContext)
}

func (s *RoutineCharacteristicsContext) AllDeterministic() []IDeterministicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeterministicContext); ok {
			len++
		}
	}

	tst := make([]IDeterministicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeterministicContext); ok {
			tst[i] = t.(IDeterministicContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) Deterministic(i int) IDeterministicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeterministicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeterministicContext)
}

func (s *RoutineCharacteristicsContext) AllSqlDataAccess() []ISqlDataAccessContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlDataAccessContext); ok {
			len++
		}
	}

	tst := make([]ISqlDataAccessContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlDataAccessContext); ok {
			tst[i] = t.(ISqlDataAccessContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) SqlDataAccess(i int) ISqlDataAccessContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlDataAccessContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlDataAccessContext)
}

func (s *RoutineCharacteristicsContext) AllNullCall() []INullCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INullCallContext); ok {
			len++
		}
	}

	tst := make([]INullCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INullCallContext); ok {
			tst[i] = t.(INullCallContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) NullCall(i int) INullCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullCallContext)
}

func (s *RoutineCharacteristicsContext) AllCommentSpec() []ICommentSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentSpecContext); ok {
			len++
		}
	}

	tst := make([]ICommentSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentSpecContext); ok {
			tst[i] = t.(ICommentSpecContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) CommentSpec(i int) ICommentSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *RoutineCharacteristicsContext) AllRightsClause() []IRightsClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRightsClauseContext); ok {
			len++
		}
	}

	tst := make([]IRightsClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRightsClauseContext); ok {
			tst[i] = t.(IRightsClauseContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) RightsClause(i int) IRightsClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRightsClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRightsClauseContext)
}

func (s *RoutineCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRoutineCharacteristics(s)
	}
}

func (s *RoutineCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRoutineCharacteristics(s)
	}
}

func (p *SqlBaseParser) RoutineCharacteristics() (localctx IRoutineCharacteristicsContext) {
	localctx = NewRoutineCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, SqlBaseParserRULE_routineCharacteristics)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&576461851815051520) != 0) || _la == SqlBaseParserCONTAINS || _la == SqlBaseParserDETERMINISTIC || ((int64((_la-186)) & ^0x3f) == 0 && ((int64(1)<<(_la-186))&43989055045633) != 0) || ((int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&27021597765271553) != 0) {
		p.SetState(4421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SqlBaseParserLANGUAGE:
			{
				p.SetState(4414)
				p.RoutineLanguage()
			}

		case SqlBaseParserSPECIFIC:
			{
				p.SetState(4415)
				p.SpecificName()
			}

		case SqlBaseParserBANG, SqlBaseParserDETERMINISTIC, SqlBaseParserNOT:
			{
				p.SetState(4416)
				p.Deterministic()
			}

		case SqlBaseParserCONTAINS, SqlBaseParserMODIFIES, SqlBaseParserNO, SqlBaseParserREADS:
			{
				p.SetState(4417)
				p.SqlDataAccess()
			}

		case SqlBaseParserCALLED, SqlBaseParserRETURNS:
			{
				p.SetState(4418)
				p.NullCall()
			}

		case SqlBaseParserCOMMENT:
			{
				p.SetState(4419)
				p.CommentSpec()
			}

		case SqlBaseParserSQL:
			{
				p.SetState(4420)
				p.RightsClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineLanguageContext is an interface to support dynamic dispatch.
type IRoutineLanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGUAGE() antlr.TerminalNode
	SQL() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsRoutineLanguageContext differentiates from other interfaces.
	IsRoutineLanguageContext()
}

type RoutineLanguageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineLanguageContext() *RoutineLanguageContext {
	var p = new(RoutineLanguageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineLanguage
	return p
}

func InitEmptyRoutineLanguageContext(p *RoutineLanguageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineLanguage
}

func (*RoutineLanguageContext) IsRoutineLanguageContext() {}

func NewRoutineLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineLanguageContext {
	var p = new(RoutineLanguageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineLanguage

	return p
}

func (s *RoutineLanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineLanguageContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLANGUAGE, 0)
}

func (s *RoutineLanguageContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQL, 0)
}

func (s *RoutineLanguageContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *RoutineLanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineLanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineLanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRoutineLanguage(s)
	}
}

func (p *SqlBaseParser) RoutineLanguage() (localctx IRoutineLanguageContext) {
	localctx = NewRoutineLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, SqlBaseParserRULE_routineLanguage)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4426)
		p.Match(SqlBaseParserLANGUAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4427)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserSQL || _la == SqlBaseParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecificNameContext is an interface to support dynamic dispatch.
type ISpecificNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSpecific returns the specific rule contexts.
	GetSpecific() IErrorCapturingIdentifierContext

	// SetSpecific sets the specific rule contexts.
	SetSpecific(IErrorCapturingIdentifierContext)

	// Getter signatures
	SPECIFIC() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsSpecificNameContext differentiates from other interfaces.
	IsSpecificNameContext()
}

type SpecificNameContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	specific IErrorCapturingIdentifierContext
}

func NewEmptySpecificNameContext() *SpecificNameContext {
	var p = new(SpecificNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_specificName
	return p
}

func InitEmptySpecificNameContext(p *SpecificNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_specificName
}

func (*SpecificNameContext) IsSpecificNameContext() {}

func NewSpecificNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificNameContext {
	var p = new(SpecificNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_specificName

	return p
}

func (s *SpecificNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificNameContext) GetSpecific() IErrorCapturingIdentifierContext { return s.specific }

func (s *SpecificNameContext) SetSpecific(v IErrorCapturingIdentifierContext) { s.specific = v }

func (s *SpecificNameContext) SPECIFIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSPECIFIC, 0)
}

func (s *SpecificNameContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *SpecificNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecificNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSpecificName(s)
	}
}

func (s *SpecificNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSpecificName(s)
	}
}

func (p *SqlBaseParser) SpecificName() (localctx ISpecificNameContext) {
	localctx = NewSpecificNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, SqlBaseParserRULE_specificName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4429)
		p.Match(SqlBaseParserSPECIFIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4430)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*SpecificNameContext).specific = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeterministicContext is an interface to support dynamic dispatch.
type IDeterministicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DETERMINISTIC() antlr.TerminalNode
	ErrorCapturingNot() IErrorCapturingNotContext

	// IsDeterministicContext differentiates from other interfaces.
	IsDeterministicContext()
}

type DeterministicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeterministicContext() *DeterministicContext {
	var p = new(DeterministicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_deterministic
	return p
}

func InitEmptyDeterministicContext(p *DeterministicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_deterministic
}

func (*DeterministicContext) IsDeterministicContext() {}

func NewDeterministicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeterministicContext {
	var p = new(DeterministicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_deterministic

	return p
}

func (s *DeterministicContext) GetParser() antlr.Parser { return s.parser }

func (s *DeterministicContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDETERMINISTIC, 0)
}

func (s *DeterministicContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *DeterministicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeterministicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeterministicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDeterministic(s)
	}
}

func (s *DeterministicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDeterministic(s)
	}
}

func (p *SqlBaseParser) Deterministic() (localctx IDeterministicContext) {
	localctx = NewDeterministicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, SqlBaseParserRULE_deterministic)
	p.SetState(4436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserDETERMINISTIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4432)
			p.Match(SqlBaseParserDETERMINISTIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserBANG, SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4433)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(4434)
			p.Match(SqlBaseParserDETERMINISTIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlDataAccessContext is an interface to support dynamic dispatch.
type ISqlDataAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAccess returns the access token.
	GetAccess() antlr.Token

	// SetAccess sets the access token.
	SetAccess(antlr.Token)

	// Getter signatures
	SQL() antlr.TerminalNode
	NO() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	DATA() antlr.TerminalNode
	READS() antlr.TerminalNode
	MODIFIES() antlr.TerminalNode

	// IsSqlDataAccessContext differentiates from other interfaces.
	IsSqlDataAccessContext()
}

type SqlDataAccessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	access antlr.Token
}

func NewEmptySqlDataAccessContext() *SqlDataAccessContext {
	var p = new(SqlDataAccessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sqlDataAccess
	return p
}

func InitEmptySqlDataAccessContext(p *SqlDataAccessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sqlDataAccess
}

func (*SqlDataAccessContext) IsSqlDataAccessContext() {}

func NewSqlDataAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlDataAccessContext {
	var p = new(SqlDataAccessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sqlDataAccess

	return p
}

func (s *SqlDataAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlDataAccessContext) GetAccess() antlr.Token { return s.access }

func (s *SqlDataAccessContext) SetAccess(v antlr.Token) { s.access = v }

func (s *SqlDataAccessContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQL, 0)
}

func (s *SqlDataAccessContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *SqlDataAccessContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONTAINS, 0)
}

func (s *SqlDataAccessContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *SqlDataAccessContext) READS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREADS, 0)
}

func (s *SqlDataAccessContext) MODIFIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMODIFIES, 0)
}

func (s *SqlDataAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlDataAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlDataAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSqlDataAccess(s)
	}
}

func (s *SqlDataAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSqlDataAccess(s)
	}
}

func (p *SqlBaseParser) SqlDataAccess() (localctx ISqlDataAccessContext) {
	localctx = NewSqlDataAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, SqlBaseParserRULE_sqlDataAccess)
	p.SetState(4448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserNO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4438)

			var _m = p.Match(SqlBaseParserNO)

			localctx.(*SqlDataAccessContext).access = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4439)
			p.Match(SqlBaseParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserCONTAINS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4440)

			var _m = p.Match(SqlBaseParserCONTAINS)

			localctx.(*SqlDataAccessContext).access = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4441)
			p.Match(SqlBaseParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserREADS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4442)

			var _m = p.Match(SqlBaseParserREADS)

			localctx.(*SqlDataAccessContext).access = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4443)
			p.Match(SqlBaseParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4444)
			p.Match(SqlBaseParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserMODIFIES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4445)

			var _m = p.Match(SqlBaseParserMODIFIES)

			localctx.(*SqlDataAccessContext).access = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4446)
			p.Match(SqlBaseParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4447)
			p.Match(SqlBaseParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullCallContext is an interface to support dynamic dispatch.
type INullCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURNS() antlr.TerminalNode
	AllNULL() []antlr.TerminalNode
	NULL(i int) antlr.TerminalNode
	ON() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	CALLED() antlr.TerminalNode

	// IsNullCallContext differentiates from other interfaces.
	IsNullCallContext()
}

type NullCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullCallContext() *NullCallContext {
	var p = new(NullCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullCall
	return p
}

func InitEmptyNullCallContext(p *NullCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullCall
}

func (*NullCallContext) IsNullCallContext() {}

func NewNullCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullCallContext {
	var p = new(NullCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nullCall

	return p
}

func (s *NullCallContext) GetParser() antlr.Parser { return s.parser }

func (s *NullCallContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *NullCallContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserNULL)
}

func (s *NullCallContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, i)
}

func (s *NullCallContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *NullCallContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *NullCallContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALLED, 0)
}

func (s *NullCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNullCall(s)
	}
}

func (s *NullCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNullCall(s)
	}
}

func (p *SqlBaseParser) NullCall() (localctx INullCallContext) {
	localctx = NewNullCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, SqlBaseParserRULE_nullCall)
	p.SetState(4459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserRETURNS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4450)
			p.Match(SqlBaseParserRETURNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4451)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4452)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4453)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4454)
			p.Match(SqlBaseParserINPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserCALLED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4455)
			p.Match(SqlBaseParserCALLED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4456)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4457)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4458)
			p.Match(SqlBaseParserINPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRightsClauseContext is an interface to support dynamic dispatch.
type IRightsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	DEFINER() antlr.TerminalNode

	// IsRightsClauseContext differentiates from other interfaces.
	IsRightsClauseContext()
}

type RightsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRightsClauseContext() *RightsClauseContext {
	var p = new(RightsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_rightsClause
	return p
}

func InitEmptyRightsClauseContext(p *RightsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_rightsClause
}

func (*RightsClauseContext) IsRightsClauseContext() {}

func NewRightsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RightsClauseContext {
	var p = new(RightsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_rightsClause

	return p
}

func (s *RightsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RightsClauseContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQL, 0)
}

func (s *RightsClauseContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *RightsClauseContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *RightsClauseContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *RightsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RightsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RightsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRightsClause(s)
	}
}

func (s *RightsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRightsClause(s)
	}
}

func (p *SqlBaseParser) RightsClause() (localctx IRightsClauseContext) {
	localctx = NewRightsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, SqlBaseParserRULE_rightsClause)
	p.SetState(4467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 565, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4461)
			p.Match(SqlBaseParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4462)
			p.Match(SqlBaseParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4463)
			p.Match(SqlBaseParserINVOKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4464)
			p.Match(SqlBaseParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4465)
			p.Match(SqlBaseParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4466)
			p.Match(SqlBaseParserDEFINER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *SqlBaseParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, SqlBaseParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4469)
		p.Match(SqlBaseParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4470)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(4471)
		p.Match(SqlBaseParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4472)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	AllNamedWindow() []INamedWindowContext
	NamedWindow(i int) INamedWindowContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWINDOW, 0)
}

func (s *WindowClauseContext) AllNamedWindow() []INamedWindowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedWindowContext); ok {
			len++
		}
	}

	tst := make([]INamedWindowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedWindowContext); ok {
			tst[i] = t.(INamedWindowContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) NamedWindow(i int) INamedWindowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedWindowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedWindowContext)
}

func (s *WindowClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *WindowClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (p *SqlBaseParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, SqlBaseParserRULE_windowClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4474)
		p.Match(SqlBaseParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4475)
		p.NamedWindow()
	}
	p.SetState(4480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 566, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4476)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4477)
				p.NamedWindow()
			}

		}
		p.SetState(4482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 566, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedWindowContext is an interface to support dynamic dispatch.
type INamedWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IErrorCapturingIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IErrorCapturingIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsNamedWindowContext differentiates from other interfaces.
	IsNamedWindowContext()
}

type NamedWindowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IErrorCapturingIdentifierContext
}

func NewEmptyNamedWindowContext() *NamedWindowContext {
	var p = new(NamedWindowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedWindow
	return p
}

func InitEmptyNamedWindowContext(p *NamedWindowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedWindow
}

func (*NamedWindowContext) IsNamedWindowContext() {}

func NewNamedWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedWindowContext {
	var p = new(NamedWindowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedWindow

	return p
}

func (s *NamedWindowContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedWindowContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *NamedWindowContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *NamedWindowContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *NamedWindowContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *NamedWindowContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *NamedWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedWindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNamedWindow(s)
	}
}

func (s *NamedWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNamedWindow(s)
	}
}

func (p *SqlBaseParser) NamedWindow() (localctx INamedWindowContext) {
	localctx = NewNamedWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, SqlBaseParserRULE_namedWindow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4483)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*NamedWindowContext).name = _x
	}
	{
		p.SetState(4484)
		p.Match(SqlBaseParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4485)
		p.WindowSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) CopyAll(ctx *WindowSpecContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WindowRefContext struct {
	WindowSpecContext
	name IErrorCapturingIdentifierContext
}

func NewWindowRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowRefContext {
	var p = new(WindowRefContext)

	InitEmptyWindowSpecContext(&p.WindowSpecContext)
	p.parser = parser
	p.CopyAll(ctx.(*WindowSpecContext))

	return p
}

func (s *WindowRefContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *WindowRefContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *WindowRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowRefContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *WindowRefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *WindowRefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *WindowRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterWindowRef(s)
	}
}

func (s *WindowRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitWindowRef(s)
	}
}

type WindowDefContext struct {
	WindowSpecContext
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewWindowDefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowDefContext {
	var p = new(WindowDefContext)

	InitEmptyWindowSpecContext(&p.WindowSpecContext)
	p.parser = parser
	p.CopyAll(ctx.(*WindowSpecContext))

	return p
}

func (s *WindowDefContext) Get_expression() IExpressionContext { return s._expression }

func (s *WindowDefContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *WindowDefContext) GetPartition() []IExpressionContext { return s.partition }

func (s *WindowDefContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *WindowDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *WindowDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *WindowDefContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTER, 0)
}

func (s *WindowDefContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *WindowDefContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *WindowDefContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WindowDefContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WindowDefContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *WindowDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *WindowDefContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *WindowDefContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *WindowDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *WindowDefContext) DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTE, 0)
}

func (s *WindowDefContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *WindowDefContext) SORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORT, 0)
}

func (s *WindowDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterWindowDef(s)
	}
}

func (s *WindowDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitWindowDef(s)
	}
}

func (p *SqlBaseParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, SqlBaseParserRULE_windowSpec)
	var _la int

	p.SetState(4533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 574, p.GetParserRuleContext()) {
	case 1:
		localctx = NewWindowRefContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4487)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*WindowRefContext).name = _x
		}

	case 2:
		localctx = NewWindowRefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4488)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4489)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*WindowRefContext).name = _x
		}
		{
			p.SetState(4490)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewWindowDefContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4492)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SqlBaseParserCLUSTER:
			{
				p.SetState(4493)
				p.Match(SqlBaseParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4494)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4495)

				var _x = p.Expression()

				localctx.(*WindowDefContext)._expression = _x
			}
			localctx.(*WindowDefContext).partition = append(localctx.(*WindowDefContext).partition, localctx.(*WindowDefContext)._expression)
			p.SetState(4500)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserCOMMA {
				{
					p.SetState(4496)
					p.Match(SqlBaseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4497)

					var _x = p.Expression()

					localctx.(*WindowDefContext)._expression = _x
				}
				localctx.(*WindowDefContext).partition = append(localctx.(*WindowDefContext).partition, localctx.(*WindowDefContext)._expression)

				p.SetState(4502)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case SqlBaseParserRIGHT_PAREN, SqlBaseParserDISTRIBUTE, SqlBaseParserORDER, SqlBaseParserPARTITION, SqlBaseParserRANGE, SqlBaseParserROWS, SqlBaseParserSORT:
			p.SetState(4513)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserDISTRIBUTE || _la == SqlBaseParserPARTITION {
				{
					p.SetState(4503)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserDISTRIBUTE || _la == SqlBaseParserPARTITION) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4504)
					p.Match(SqlBaseParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4505)

					var _x = p.Expression()

					localctx.(*WindowDefContext)._expression = _x
				}
				localctx.(*WindowDefContext).partition = append(localctx.(*WindowDefContext).partition, localctx.(*WindowDefContext)._expression)
				p.SetState(4510)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == SqlBaseParserCOMMA {
					{
						p.SetState(4506)
						p.Match(SqlBaseParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(4507)

						var _x = p.Expression()

						localctx.(*WindowDefContext)._expression = _x
					}
					localctx.(*WindowDefContext).partition = append(localctx.(*WindowDefContext).partition, localctx.(*WindowDefContext)._expression)

					p.SetState(4512)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}
			p.SetState(4525)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserORDER || _la == SqlBaseParserSORT {
				{
					p.SetState(4515)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserORDER || _la == SqlBaseParserSORT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4516)
					p.Match(SqlBaseParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4517)
					p.SortItem()
				}
				p.SetState(4522)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == SqlBaseParserCOMMA {
					{
						p.SetState(4518)
						p.Match(SqlBaseParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(4519)
						p.SortItem()
					}

					p.SetState(4524)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserRANGE || _la == SqlBaseParserROWS {
			{
				p.SetState(4529)
				p.WindowFrame()
			}

		}
		{
			p.SetState(4532)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// Getter signatures
	RANGE() antlr.TerminalNode
	AllFrameBound() []IFrameBoundContext
	FrameBound(i int) IFrameBoundContext
	ROWS() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start_    IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *SqlBaseParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, SqlBaseParserRULE_windowFrame)
	p.SetState(4551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 575, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4535)

			var _m = p.Match(SqlBaseParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4536)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4537)

			var _m = p.Match(SqlBaseParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4538)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4539)

			var _m = p.Match(SqlBaseParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4540)
			p.Match(SqlBaseParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4541)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(4542)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4543)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4545)

			var _m = p.Match(SqlBaseParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4546)
			p.Match(SqlBaseParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4547)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(4548)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4549)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBoundType returns the boundType token.
	GetBoundType() antlr.Token

	// SetBoundType sets the boundType token.
	SetBoundType(antlr.Token)

	// Getter signatures
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	ROW() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	boundType antlr.Token
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) GetBoundType() antlr.Token { return s.boundType }

func (s *FrameBoundContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *FrameBoundContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *FrameBoundContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *FrameBoundContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *FrameBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *FrameBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *FrameBoundContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFrameBound(s)
	}
}

func (s *FrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFrameBound(s)
	}
}

func (p *SqlBaseParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, SqlBaseParserRULE_frameBound)
	var _la int

	p.SetState(4560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 576, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4553)
			p.Match(SqlBaseParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4554)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFOLLOWING || _la == SqlBaseParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4555)

			var _m = p.Match(SqlBaseParserCURRENT)

			localctx.(*FrameBoundContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4556)
			p.Match(SqlBaseParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4557)
			p.Expression()
		}
		{
			p.SetState(4558)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFOLLOWING || _la == SqlBaseParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameListContext is an interface to support dynamic dispatch.
type IQualifiedNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsQualifiedNameListContext differentiates from other interfaces.
	IsQualifiedNameListContext()
}

type QualifiedNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameListContext() *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedNameList
	return p
}

func InitEmptyQualifiedNameListContext(p *QualifiedNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedNameList
}

func (*QualifiedNameListContext) IsQualifiedNameListContext() {}

func NewQualifiedNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_qualifiedNameList

	return p
}

func (s *QualifiedNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameListContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *QualifiedNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *QualifiedNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *QualifiedNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQualifiedNameList(s)
	}
}

func (s *QualifiedNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQualifiedNameList(s)
	}
}

func (p *SqlBaseParser) QualifiedNameList() (localctx IQualifiedNameListContext) {
	localctx = NewQualifiedNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, SqlBaseParserRULE_qualifiedNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4562)
		p.QualifiedName()
	}
	p.SetState(4567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(4563)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4564)
			p.QualifiedName()
		}

		p.SetState(4569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIdentFunc returns the identFunc token.
	GetIdentFunc() antlr.Token

	// SetIdentFunc sets the identFunc token.
	SetIdentFunc(antlr.Token)

	// Getter signatures
	IDENTIFIER_KW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FILTER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	identFunc antlr.Token
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) GetIdentFunc() antlr.Token { return s.identFunc }

func (s *FunctionNameContext) SetIdentFunc(v antlr.Token) { s.identFunc = v }

func (s *FunctionNameContext) IDENTIFIER_KW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER_KW, 0)
}

func (s *FunctionNameContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *FunctionNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionNameContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *FunctionNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionNameContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *FunctionNameContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT, 0)
}

func (s *FunctionNameContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT, 0)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (p *SqlBaseParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, SqlBaseParserRULE_functionName)
	p.SetState(4580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4570)
			p.Match(SqlBaseParserIDENTIFIER_KW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4571)
			p.Match(SqlBaseParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4572)
			p.Expression()
		}
		{
			p.SetState(4573)
			p.Match(SqlBaseParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4575)

			var _m = p.Match(SqlBaseParserIDENTIFIER_KW)

			localctx.(*FunctionNameContext).identFunc = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4576)
			p.QualifiedName()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4577)
			p.Match(SqlBaseParserFILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4578)
			p.Match(SqlBaseParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4579)
			p.Match(SqlBaseParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *SqlBaseParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, SqlBaseParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4582)
		p.Identifier()
	}
	p.SetState(4587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4583)
				p.Match(SqlBaseParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4584)
				p.Identifier()
			}

		}
		p.SetState(4589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext

	// IsErrorCapturingIdentifierContext differentiates from other interfaces.
	IsErrorCapturingIdentifierContext()
}

type ErrorCapturingIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierContext() *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingIdentifier
	return p
}

func InitEmptyErrorCapturingIdentifierContext(p *ErrorCapturingIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingIdentifier
}

func (*ErrorCapturingIdentifierContext) IsErrorCapturingIdentifierContext() {}

func NewErrorCapturingIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_errorCapturingIdentifier

	return p
}

func (s *ErrorCapturingIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorCapturingIdentifierContext) ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierExtraContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierExtraContext)
}

func (s *ErrorCapturingIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterErrorCapturingIdentifier(s)
	}
}

func (s *ErrorCapturingIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitErrorCapturingIdentifier(s)
	}
}

func (p *SqlBaseParser) ErrorCapturingIdentifier() (localctx IErrorCapturingIdentifierContext) {
	localctx = NewErrorCapturingIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, SqlBaseParserRULE_errorCapturingIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4590)
		p.Identifier()
	}
	{
		p.SetState(4591)
		p.ErrorCapturingIdentifierExtra()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierExtraContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierExtraContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsErrorCapturingIdentifierExtraContext differentiates from other interfaces.
	IsErrorCapturingIdentifierExtraContext()
}

type ErrorCapturingIdentifierExtraContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierExtraContext() *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingIdentifierExtra
	return p
}

func InitEmptyErrorCapturingIdentifierExtraContext(p *ErrorCapturingIdentifierExtraContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_errorCapturingIdentifierExtra
}

func (*ErrorCapturingIdentifierExtraContext) IsErrorCapturingIdentifierExtraContext() {}

func NewErrorCapturingIdentifierExtraContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_errorCapturingIdentifierExtra

	return p
}

func (s *ErrorCapturingIdentifierExtraContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierExtraContext) CopyAll(ctx *ErrorCapturingIdentifierExtraContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ErrorCapturingIdentifierExtraContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierExtraContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ErrorIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewErrorIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorIdentContext {
	var p = new(ErrorIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *ErrorIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorIdentContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserMINUS)
}

func (s *ErrorIdentContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, i)
}

func (s *ErrorIdentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ErrorIdentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterErrorIdent(s)
	}
}

func (s *ErrorIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitErrorIdent(s)
	}
}

type RealIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewRealIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RealIdentContext {
	var p = new(RealIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *RealIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRealIdent(s)
	}
}

func (s *RealIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRealIdent(s)
	}
}

func (p *SqlBaseParser) ErrorCapturingIdentifierExtra() (localctx IErrorCapturingIdentifierExtraContext) {
	localctx = NewErrorCapturingIdentifierExtraContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, SqlBaseParserRULE_errorCapturingIdentifierExtra)
	var _alt int

	p.SetState(4600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext()) {
	case 1:
		localctx = NewErrorIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4593)
					p.Match(SqlBaseParserMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4594)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4597)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewRealIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext
	StrictNonReserved() IStrictNonReservedContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *IdentifierContext) StrictNonReserved() IStrictNonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictNonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictNonReservedContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *SqlBaseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, SqlBaseParserRULE_identifier)
	p.SetState(4605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 582, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4602)
			p.StrictIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4603)

		if !(!SQL_standard_keyword_behavior) {
			p.SetError(antlr.NewFailedPredicateException(p, "!SQL_standard_keyword_behavior", ""))
			goto errorExit
		}
		{
			p.SetState(4604)
			p.StrictNonReserved()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrictIdentifierContext is an interface to support dynamic dispatch.
type IStrictIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStrictIdentifierContext differentiates from other interfaces.
	IsStrictIdentifierContext()
}

type StrictIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrictIdentifierContext() *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_strictIdentifier
	return p
}

func InitEmptyStrictIdentifierContext(p *StrictIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_strictIdentifier
}

func (*StrictIdentifierContext) IsStrictIdentifierContext() {}

func NewStrictIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_strictIdentifier

	return p
}

func (s *StrictIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StrictIdentifierContext) CopyAll(ctx *StrictIdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StrictIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrictIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuotedIdentifierAlternativeContext struct {
	StrictIdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type UnquotedIdentifierContext struct {
	StrictIdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) AnsiNonReserved() IAnsiNonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnsiNonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnsiNonReservedContext)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *SqlBaseParser) StrictIdentifier() (localctx IStrictIdentifierContext) {
	localctx = NewStrictIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, SqlBaseParserRULE_strictIdentifier)
	p.SetState(4613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 583, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4607)
			p.Match(SqlBaseParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4608)
			p.QuotedIdentifier()
		}

	case 3:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(4609)

		if !(SQL_standard_keyword_behavior) {
			p.SetError(antlr.NewFailedPredicateException(p, "SQL_standard_keyword_behavior", ""))
			goto errorExit
		}
		{
			p.SetState(4610)
			p.AnsiNonReserved()
		}

	case 4:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4611)

		if !(!SQL_standard_keyword_behavior) {
			p.SetError(antlr.NewFailedPredicateException(p, "!SQL_standard_keyword_behavior", ""))
			goto errorExit
		}
		{
			p.SetState(4612)
			p.NonReserved()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedIdentifierContext is an interface to support dynamic dispatch.
type IQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode
	DOUBLEQUOTED_STRING() antlr.TerminalNode

	// IsQuotedIdentifierContext differentiates from other interfaces.
	IsQuotedIdentifierContext()
}

type QuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedIdentifierContext() *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_quotedIdentifier
	return p
}

func InitEmptyQuotedIdentifierContext(p *QuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_quotedIdentifier
}

func (*QuotedIdentifierContext) IsQuotedIdentifierContext() {}

func NewQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_quotedIdentifier

	return p
}

func (s *QuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) DOUBLEQUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLEQUOTED_STRING, 0)
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (p *SqlBaseParser) QuotedIdentifier() (localctx IQuotedIdentifierContext) {
	localctx = NewQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, SqlBaseParserRULE_quotedIdentifier)
	p.SetState(4618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 584, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4615)
			p.Match(SqlBaseParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4616)

		if !(double_quoted_identifiers) {
			p.SetError(antlr.NewFailedPredicateException(p, "double_quoted_identifiers", ""))
			goto errorExit
		}
		{
			p.SetState(4617)
			p.Match(SqlBaseParserDOUBLEQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackQuotedIdentifierContext is an interface to support dynamic dispatch.
type IBackQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode

	// IsBackQuotedIdentifierContext differentiates from other interfaces.
	IsBackQuotedIdentifierContext()
}

type BackQuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackQuotedIdentifierContext() *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_backQuotedIdentifier
	return p
}

func InitEmptyBackQuotedIdentifierContext(p *BackQuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_backQuotedIdentifier
}

func (*BackQuotedIdentifierContext) IsBackQuotedIdentifierContext() {}

func NewBackQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_backQuotedIdentifier

	return p
}

func (s *BackQuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (p *SqlBaseParser) BackQuotedIdentifier() (localctx IBackQuotedIdentifierContext) {
	localctx = NewBackQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, SqlBaseParserRULE_backQuotedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4620)
		p.Match(SqlBaseParserBACKQUOTED_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type BigIntLiteralContext struct {
	NumberContext
}

func NewBigIntLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BigIntLiteralContext {
	var p = new(BigIntLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *BigIntLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigIntLiteralContext) BIGINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBIGINT_LITERAL, 0)
}

func (s *BigIntLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *BigIntLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBigIntLiteral(s)
	}
}

func (s *BigIntLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBigIntLiteral(s)
	}
}

type TinyIntLiteralContext struct {
	NumberContext
}

func NewTinyIntLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TinyIntLiteralContext {
	var p = new(TinyIntLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *TinyIntLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TinyIntLiteralContext) TINYINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTINYINT_LITERAL, 0)
}

func (s *TinyIntLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *TinyIntLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTinyIntLiteral(s)
	}
}

func (s *TinyIntLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTinyIntLiteral(s)
	}
}

type LegacyDecimalLiteralContext struct {
	NumberContext
}

func NewLegacyDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LegacyDecimalLiteralContext {
	var p = new(LegacyDecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *LegacyDecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyDecimalLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPONENT_VALUE, 0)
}

func (s *LegacyDecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *LegacyDecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *LegacyDecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterLegacyDecimalLiteral(s)
	}
}

func (s *LegacyDecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitLegacyDecimalLiteral(s)
	}
}

type BigDecimalLiteralContext struct {
	NumberContext
}

func NewBigDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BigDecimalLiteralContext {
	var p = new(BigDecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *BigDecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigDecimalLiteralContext) BIGDECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBIGDECIMAL_LITERAL, 0)
}

func (s *BigDecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *BigDecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterBigDecimalLiteral(s)
	}
}

func (s *BigDecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitBigDecimalLiteral(s)
	}
}

type ExponentLiteralContext struct {
	NumberContext
}

func NewExponentLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExponentLiteralContext {
	var p = new(ExponentLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *ExponentLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExponentLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPONENT_VALUE, 0)
}

func (s *ExponentLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ExponentLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterExponentLiteral(s)
	}
}

func (s *ExponentLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitExponentLiteral(s)
	}
}

type DoubleLiteralContext struct {
	NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_LITERAL, 0)
}

func (s *DoubleLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

type FloatLiteralContext struct {
	NumberContext
}

func NewFloatLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOAT_LITERAL, 0)
}

func (s *FloatLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

type SmallIntLiteralContext struct {
	NumberContext
}

func NewSmallIntLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SmallIntLiteralContext {
	var p = new(SmallIntLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *SmallIntLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SmallIntLiteralContext) SMALLINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSMALLINT_LITERAL, 0)
}

func (s *SmallIntLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *SmallIntLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterSmallIntLiteral(s)
	}
}

func (s *SmallIntLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitSmallIntLiteral(s)
	}
}

func (p *SqlBaseParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, SqlBaseParserRULE_number)
	var _la int

	p.SetState(4665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExponentLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4622)

		if !(!legacy_exponent_literal_as_decimal_enabled) {
			p.SetError(antlr.NewFailedPredicateException(p, "!legacy_exponent_literal_as_decimal_enabled", ""))
			goto errorExit
		}
		p.SetState(4624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4623)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4626)
			p.Match(SqlBaseParserEXPONENT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4627)

		if !(!legacy_exponent_literal_as_decimal_enabled) {
			p.SetError(antlr.NewFailedPredicateException(p, "!legacy_exponent_literal_as_decimal_enabled", ""))
			goto errorExit
		}
		p.SetState(4629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4628)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4631)
			p.Match(SqlBaseParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewLegacyDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(4632)

		if !(legacy_exponent_literal_as_decimal_enabled) {
			p.SetError(antlr.NewFailedPredicateException(p, "legacy_exponent_literal_as_decimal_enabled", ""))
			goto errorExit
		}
		p.SetState(4634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4633)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4636)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserEXPONENT_VALUE || _la == SqlBaseParserDECIMAL_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4637)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4640)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewBigIntLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(4642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4641)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4644)
			p.Match(SqlBaseParserBIGINT_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewSmallIntLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(4646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4645)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4648)
			p.Match(SqlBaseParserSMALLINT_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewTinyIntLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(4650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4649)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4652)
			p.Match(SqlBaseParserTINYINT_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(4654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4653)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4656)
			p.Match(SqlBaseParserDOUBLE_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewFloatLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		p.SetState(4658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4657)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4660)
			p.Match(SqlBaseParserFLOAT_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewBigDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(4662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(4661)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4664)
			p.Match(SqlBaseParserBIGDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintDefinitionContext is an interface to support dynamic dispatch.
type IColumnConstraintDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IErrorCapturingIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IErrorCapturingIdentifierContext)

	// Getter signatures
	ColumnConstraint() IColumnConstraintContext
	CONSTRAINT() antlr.TerminalNode
	AllConstraintCharacteristic() []IConstraintCharacteristicContext
	ConstraintCharacteristic(i int) IConstraintCharacteristicContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsColumnConstraintDefinitionContext differentiates from other interfaces.
	IsColumnConstraintDefinitionContext()
}

type ColumnConstraintDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IErrorCapturingIdentifierContext
}

func NewEmptyColumnConstraintDefinitionContext() *ColumnConstraintDefinitionContext {
	var p = new(ColumnConstraintDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnConstraintDefinition
	return p
}

func InitEmptyColumnConstraintDefinitionContext(p *ColumnConstraintDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnConstraintDefinition
}

func (*ColumnConstraintDefinitionContext) IsColumnConstraintDefinitionContext() {}

func NewColumnConstraintDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintDefinitionContext {
	var p = new(ColumnConstraintDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnConstraintDefinition

	return p
}

func (s *ColumnConstraintDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintDefinitionContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *ColumnConstraintDefinitionContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *ColumnConstraintDefinitionContext) ColumnConstraint() IColumnConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnConstraintDefinitionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONSTRAINT, 0)
}

func (s *ColumnConstraintDefinitionContext) AllConstraintCharacteristic() []IConstraintCharacteristicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstraintCharacteristicContext); ok {
			len++
		}
	}

	tst := make([]IConstraintCharacteristicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstraintCharacteristicContext); ok {
			tst[i] = t.(IConstraintCharacteristicContext)
			i++
		}
	}

	return tst
}

func (s *ColumnConstraintDefinitionContext) ConstraintCharacteristic(i int) IConstraintCharacteristicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintCharacteristicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintCharacteristicContext)
}

func (s *ColumnConstraintDefinitionContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *ColumnConstraintDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColumnConstraintDefinition(s)
	}
}

func (s *ColumnConstraintDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColumnConstraintDefinition(s)
	}
}

func (p *SqlBaseParser) ColumnConstraintDefinition() (localctx IColumnConstraintDefinitionContext) {
	localctx = NewColumnConstraintDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, SqlBaseParserRULE_columnConstraintDefinition)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCONSTRAINT {
		{
			p.SetState(4667)
			p.Match(SqlBaseParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4668)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*ColumnConstraintDefinitionContext).name = _x
		}

	}
	{
		p.SetState(4671)
		p.ColumnConstraint()
	}
	p.SetState(4675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 597, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4672)
				p.ConstraintCharacteristic()
			}

		}
		p.SetState(4677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 597, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CheckConstraint() ICheckConstraintContext
	UniqueSpec() IUniqueSpecContext
	ReferenceSpec() IReferenceSpecContext

	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) CheckConstraint() ICheckConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *ColumnConstraintContext) UniqueSpec() IUniqueSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueSpecContext)
}

func (s *ColumnConstraintContext) ReferenceSpec() IReferenceSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceSpecContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitColumnConstraint(s)
	}
}

func (p *SqlBaseParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, SqlBaseParserRULE_columnConstraint)
	p.SetState(4681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserCHECK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4678)
			p.CheckConstraint()
		}

	case SqlBaseParserPRIMARY, SqlBaseParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4679)
			p.UniqueSpec()
		}

	case SqlBaseParserREFERENCES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4680)
			p.ReferenceSpec()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintDefinitionContext is an interface to support dynamic dispatch.
type ITableConstraintDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IErrorCapturingIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IErrorCapturingIdentifierContext)

	// Getter signatures
	TableConstraint() ITableConstraintContext
	CONSTRAINT() antlr.TerminalNode
	AllConstraintCharacteristic() []IConstraintCharacteristicContext
	ConstraintCharacteristic(i int) IConstraintCharacteristicContext
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext

	// IsTableConstraintDefinitionContext differentiates from other interfaces.
	IsTableConstraintDefinitionContext()
}

type TableConstraintDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IErrorCapturingIdentifierContext
}

func NewEmptyTableConstraintDefinitionContext() *TableConstraintDefinitionContext {
	var p = new(TableConstraintDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableConstraintDefinition
	return p
}

func InitEmptyTableConstraintDefinitionContext(p *TableConstraintDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableConstraintDefinition
}

func (*TableConstraintDefinitionContext) IsTableConstraintDefinitionContext() {}

func NewTableConstraintDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintDefinitionContext {
	var p = new(TableConstraintDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableConstraintDefinition

	return p
}

func (s *TableConstraintDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintDefinitionContext) GetName() IErrorCapturingIdentifierContext { return s.name }

func (s *TableConstraintDefinitionContext) SetName(v IErrorCapturingIdentifierContext) { s.name = v }

func (s *TableConstraintDefinitionContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *TableConstraintDefinitionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONSTRAINT, 0)
}

func (s *TableConstraintDefinitionContext) AllConstraintCharacteristic() []IConstraintCharacteristicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstraintCharacteristicContext); ok {
			len++
		}
	}

	tst := make([]IConstraintCharacteristicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstraintCharacteristicContext); ok {
			tst[i] = t.(IConstraintCharacteristicContext)
			i++
		}
	}

	return tst
}

func (s *TableConstraintDefinitionContext) ConstraintCharacteristic(i int) IConstraintCharacteristicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintCharacteristicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintCharacteristicContext)
}

func (s *TableConstraintDefinitionContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *TableConstraintDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableConstraintDefinition(s)
	}
}

func (s *TableConstraintDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableConstraintDefinition(s)
	}
}

func (p *SqlBaseParser) TableConstraintDefinition() (localctx ITableConstraintDefinitionContext) {
	localctx = NewTableConstraintDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, SqlBaseParserRULE_tableConstraintDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCONSTRAINT {
		{
			p.SetState(4683)
			p.Match(SqlBaseParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4684)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*TableConstraintDefinitionContext).name = _x
		}

	}
	{
		p.SetState(4687)
		p.TableConstraint()
	}
	p.SetState(4691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserENFORCED || ((int64((_la-231)) & ^0x3f) == 0 && ((int64(1)<<(_la-231))&140737488355345) != 0) {
		{
			p.SetState(4688)
			p.ConstraintCharacteristic()
		}

		p.SetState(4693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CheckConstraint() ICheckConstraintContext
	UniqueConstraint() IUniqueConstraintContext
	ForeignKeyConstraint() IForeignKeyConstraintContext

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CheckConstraint() ICheckConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *TableConstraintContext) UniqueConstraint() IUniqueConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueConstraintContext)
}

func (s *TableConstraintContext) ForeignKeyConstraint() IForeignKeyConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeignKeyConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeignKeyConstraintContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (p *SqlBaseParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, SqlBaseParserRULE_tableConstraint)
	p.SetState(4697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserCHECK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4694)
			p.CheckConstraint()
		}

	case SqlBaseParserPRIMARY, SqlBaseParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4695)
			p.UniqueConstraint()
		}

	case SqlBaseParserFOREIGN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4696)
			p.ForeignKeyConstraint()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckConstraintContext is an interface to support dynamic dispatch.
type ICheckConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExpr returns the expr rule contexts.
	GetExpr() IBooleanExpressionContext

	// SetExpr sets the expr rule contexts.
	SetExpr(IBooleanExpressionContext)

	// Getter signatures
	CHECK() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsCheckConstraintContext differentiates from other interfaces.
	IsCheckConstraintContext()
}

type CheckConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	expr   IBooleanExpressionContext
}

func NewEmptyCheckConstraintContext() *CheckConstraintContext {
	var p = new(CheckConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_checkConstraint
	return p
}

func InitEmptyCheckConstraintContext(p *CheckConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_checkConstraint
}

func (*CheckConstraintContext) IsCheckConstraintContext() {}

func NewCheckConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckConstraintContext {
	var p = new(CheckConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_checkConstraint

	return p
}

func (s *CheckConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckConstraintContext) GetExpr() IBooleanExpressionContext { return s.expr }

func (s *CheckConstraintContext) SetExpr(v IBooleanExpressionContext) { s.expr = v }

func (s *CheckConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHECK, 0)
}

func (s *CheckConstraintContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT_PAREN, 0)
}

func (s *CheckConstraintContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT_PAREN, 0)
}

func (s *CheckConstraintContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *CheckConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitCheckConstraint(s)
	}
}

func (p *SqlBaseParser) CheckConstraint() (localctx ICheckConstraintContext) {
	localctx = NewCheckConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, SqlBaseParserRULE_checkConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4699)
		p.Match(SqlBaseParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4700)
		p.Match(SqlBaseParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(4701)

		var _x = p.booleanExpression(0)

		localctx.(*CheckConstraintContext).expr = _x
	}

	{
		p.SetState(4702)
		p.Match(SqlBaseParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUniqueSpecContext is an interface to support dynamic dispatch.
type IUniqueSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIQUE() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsUniqueSpecContext differentiates from other interfaces.
	IsUniqueSpecContext()
}

type UniqueSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueSpecContext() *UniqueSpecContext {
	var p = new(UniqueSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_uniqueSpec
	return p
}

func InitEmptyUniqueSpecContext(p *UniqueSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_uniqueSpec
}

func (*UniqueSpecContext) IsUniqueSpecContext() {}

func NewUniqueSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueSpecContext {
	var p = new(UniqueSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_uniqueSpec

	return p
}

func (s *UniqueSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueSpecContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNIQUE, 0)
}

func (s *UniqueSpecContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIMARY, 0)
}

func (s *UniqueSpecContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *UniqueSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UniqueSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUniqueSpec(s)
	}
}

func (s *UniqueSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUniqueSpec(s)
	}
}

func (p *SqlBaseParser) UniqueSpec() (localctx IUniqueSpecContext) {
	localctx = NewUniqueSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, SqlBaseParserRULE_uniqueSpec)
	p.SetState(4707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserUNIQUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4704)
			p.Match(SqlBaseParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserPRIMARY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4705)
			p.Match(SqlBaseParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4706)
			p.Match(SqlBaseParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUniqueConstraintContext is an interface to support dynamic dispatch.
type IUniqueConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UniqueSpec() IUniqueSpecContext
	IdentifierList() IIdentifierListContext

	// IsUniqueConstraintContext differentiates from other interfaces.
	IsUniqueConstraintContext()
}

type UniqueConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueConstraintContext() *UniqueConstraintContext {
	var p = new(UniqueConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_uniqueConstraint
	return p
}

func InitEmptyUniqueConstraintContext(p *UniqueConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_uniqueConstraint
}

func (*UniqueConstraintContext) IsUniqueConstraintContext() {}

func NewUniqueConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueConstraintContext {
	var p = new(UniqueConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_uniqueConstraint

	return p
}

func (s *UniqueConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueConstraintContext) UniqueSpec() IUniqueSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueSpecContext)
}

func (s *UniqueConstraintContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *UniqueConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UniqueConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterUniqueConstraint(s)
	}
}

func (s *UniqueConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitUniqueConstraint(s)
	}
}

func (p *SqlBaseParser) UniqueConstraint() (localctx IUniqueConstraintContext) {
	localctx = NewUniqueConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, SqlBaseParserRULE_uniqueConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4709)
		p.UniqueSpec()
	}
	{
		p.SetState(4710)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceSpecContext is an interface to support dynamic dispatch.
type IReferenceSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParentColumns returns the parentColumns rule contexts.
	GetParentColumns() IIdentifierListContext

	// SetParentColumns sets the parentColumns rule contexts.
	SetParentColumns(IIdentifierListContext)

	// Getter signatures
	REFERENCES() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	IdentifierList() IIdentifierListContext

	// IsReferenceSpecContext differentiates from other interfaces.
	IsReferenceSpecContext()
}

type ReferenceSpecContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	parentColumns IIdentifierListContext
}

func NewEmptyReferenceSpecContext() *ReferenceSpecContext {
	var p = new(ReferenceSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_referenceSpec
	return p
}

func InitEmptyReferenceSpecContext(p *ReferenceSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_referenceSpec
}

func (*ReferenceSpecContext) IsReferenceSpecContext() {}

func NewReferenceSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceSpecContext {
	var p = new(ReferenceSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_referenceSpec

	return p
}

func (s *ReferenceSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceSpecContext) GetParentColumns() IIdentifierListContext { return s.parentColumns }

func (s *ReferenceSpecContext) SetParentColumns(v IIdentifierListContext) { s.parentColumns = v }

func (s *ReferenceSpecContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFERENCES, 0)
}

func (s *ReferenceSpecContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ReferenceSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReferenceSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterReferenceSpec(s)
	}
}

func (s *ReferenceSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitReferenceSpec(s)
	}
}

func (p *SqlBaseParser) ReferenceSpec() (localctx IReferenceSpecContext) {
	localctx = NewReferenceSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, SqlBaseParserRULE_referenceSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4712)
		p.Match(SqlBaseParserREFERENCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4713)
		p.MultipartIdentifier()
	}
	p.SetState(4715)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 603, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4714)

			var _x = p.IdentifierList()

			localctx.(*ReferenceSpecContext).parentColumns = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeignKeyConstraintContext is an interface to support dynamic dispatch.
type IForeignKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOREIGN() antlr.TerminalNode
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	ReferenceSpec() IReferenceSpecContext

	// IsForeignKeyConstraintContext differentiates from other interfaces.
	IsForeignKeyConstraintContext()
}

type ForeignKeyConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeignKeyConstraintContext() *ForeignKeyConstraintContext {
	var p = new(ForeignKeyConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_foreignKeyConstraint
	return p
}

func InitEmptyForeignKeyConstraintContext(p *ForeignKeyConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_foreignKeyConstraint
}

func (*ForeignKeyConstraintContext) IsForeignKeyConstraintContext() {}

func NewForeignKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeignKeyConstraintContext {
	var p = new(ForeignKeyConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_foreignKeyConstraint

	return p
}

func (s *ForeignKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeignKeyConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOREIGN, 0)
}

func (s *ForeignKeyConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *ForeignKeyConstraintContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ForeignKeyConstraintContext) ReferenceSpec() IReferenceSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceSpecContext)
}

func (s *ForeignKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeignKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterForeignKeyConstraint(s)
	}
}

func (s *ForeignKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitForeignKeyConstraint(s)
	}
}

func (p *SqlBaseParser) ForeignKeyConstraint() (localctx IForeignKeyConstraintContext) {
	localctx = NewForeignKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, SqlBaseParserRULE_foreignKeyConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4717)
		p.Match(SqlBaseParserFOREIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4718)
		p.Match(SqlBaseParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4719)
		p.IdentifierList()
	}
	{
		p.SetState(4720)
		p.ReferenceSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintCharacteristicContext is an interface to support dynamic dispatch.
type IConstraintCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnforcedCharacteristic() IEnforcedCharacteristicContext
	RelyCharacteristic() IRelyCharacteristicContext

	// IsConstraintCharacteristicContext differentiates from other interfaces.
	IsConstraintCharacteristicContext()
}

type ConstraintCharacteristicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintCharacteristicContext() *ConstraintCharacteristicContext {
	var p = new(ConstraintCharacteristicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_constraintCharacteristic
	return p
}

func InitEmptyConstraintCharacteristicContext(p *ConstraintCharacteristicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_constraintCharacteristic
}

func (*ConstraintCharacteristicContext) IsConstraintCharacteristicContext() {}

func NewConstraintCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintCharacteristicContext {
	var p = new(ConstraintCharacteristicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_constraintCharacteristic

	return p
}

func (s *ConstraintCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintCharacteristicContext) EnforcedCharacteristic() IEnforcedCharacteristicContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnforcedCharacteristicContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnforcedCharacteristicContext)
}

func (s *ConstraintCharacteristicContext) RelyCharacteristic() IRelyCharacteristicContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelyCharacteristicContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelyCharacteristicContext)
}

func (s *ConstraintCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterConstraintCharacteristic(s)
	}
}

func (s *ConstraintCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitConstraintCharacteristic(s)
	}
}

func (p *SqlBaseParser) ConstraintCharacteristic() (localctx IConstraintCharacteristicContext) {
	localctx = NewConstraintCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, SqlBaseParserRULE_constraintCharacteristic)
	p.SetState(4724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserENFORCED, SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4722)
			p.EnforcedCharacteristic()
		}

	case SqlBaseParserNORELY, SqlBaseParserRELY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4723)
			p.RelyCharacteristic()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnforcedCharacteristicContext is an interface to support dynamic dispatch.
type IEnforcedCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENFORCED() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsEnforcedCharacteristicContext differentiates from other interfaces.
	IsEnforcedCharacteristicContext()
}

type EnforcedCharacteristicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnforcedCharacteristicContext() *EnforcedCharacteristicContext {
	var p = new(EnforcedCharacteristicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_enforcedCharacteristic
	return p
}

func InitEmptyEnforcedCharacteristicContext(p *EnforcedCharacteristicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_enforcedCharacteristic
}

func (*EnforcedCharacteristicContext) IsEnforcedCharacteristicContext() {}

func NewEnforcedCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnforcedCharacteristicContext {
	var p = new(EnforcedCharacteristicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_enforcedCharacteristic

	return p
}

func (s *EnforcedCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *EnforcedCharacteristicContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserENFORCED, 0)
}

func (s *EnforcedCharacteristicContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *EnforcedCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnforcedCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnforcedCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterEnforcedCharacteristic(s)
	}
}

func (s *EnforcedCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitEnforcedCharacteristic(s)
	}
}

func (p *SqlBaseParser) EnforcedCharacteristic() (localctx IEnforcedCharacteristicContext) {
	localctx = NewEnforcedCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, SqlBaseParserRULE_enforcedCharacteristic)
	p.SetState(4729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserENFORCED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4726)
			p.Match(SqlBaseParserENFORCED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4727)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4728)
			p.Match(SqlBaseParserENFORCED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelyCharacteristicContext is an interface to support dynamic dispatch.
type IRelyCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELY() antlr.TerminalNode
	NORELY() antlr.TerminalNode

	// IsRelyCharacteristicContext differentiates from other interfaces.
	IsRelyCharacteristicContext()
}

type RelyCharacteristicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelyCharacteristicContext() *RelyCharacteristicContext {
	var p = new(RelyCharacteristicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relyCharacteristic
	return p
}

func InitEmptyRelyCharacteristicContext(p *RelyCharacteristicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relyCharacteristic
}

func (*RelyCharacteristicContext) IsRelyCharacteristicContext() {}

func NewRelyCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelyCharacteristicContext {
	var p = new(RelyCharacteristicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relyCharacteristic

	return p
}

func (s *RelyCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *RelyCharacteristicContext) RELY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRELY, 0)
}

func (s *RelyCharacteristicContext) NORELY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNORELY, 0)
}

func (s *RelyCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelyCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelyCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterRelyCharacteristic(s)
	}
}

func (s *RelyCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitRelyCharacteristic(s)
	}
}

func (p *SqlBaseParser) RelyCharacteristic() (localctx IRelyCharacteristicContext) {
	localctx = NewRelyCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, SqlBaseParserRULE_relyCharacteristic)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4731)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserNORELY || _la == SqlBaseParserRELY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterColumnSpecListContext is an interface to support dynamic dispatch.
type IAlterColumnSpecListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterColumnSpec() []IAlterColumnSpecContext
	AlterColumnSpec(i int) IAlterColumnSpecContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterColumnSpecListContext differentiates from other interfaces.
	IsAlterColumnSpecListContext()
}

type AlterColumnSpecListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterColumnSpecListContext() *AlterColumnSpecListContext {
	var p = new(AlterColumnSpecListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterColumnSpecList
	return p
}

func InitEmptyAlterColumnSpecListContext(p *AlterColumnSpecListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterColumnSpecList
}

func (*AlterColumnSpecListContext) IsAlterColumnSpecListContext() {}

func NewAlterColumnSpecListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColumnSpecListContext {
	var p = new(AlterColumnSpecListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_alterColumnSpecList

	return p
}

func (s *AlterColumnSpecListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColumnSpecListContext) AllAlterColumnSpec() []IAlterColumnSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterColumnSpecContext); ok {
			len++
		}
	}

	tst := make([]IAlterColumnSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterColumnSpecContext); ok {
			tst[i] = t.(IAlterColumnSpecContext)
			i++
		}
	}

	return tst
}

func (s *AlterColumnSpecListContext) AlterColumnSpec(i int) IAlterColumnSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterColumnSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterColumnSpecContext)
}

func (s *AlterColumnSpecListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *AlterColumnSpecListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *AlterColumnSpecListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnSpecListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterColumnSpecListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterColumnSpecList(s)
	}
}

func (s *AlterColumnSpecListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterColumnSpecList(s)
	}
}

func (p *SqlBaseParser) AlterColumnSpecList() (localctx IAlterColumnSpecListContext) {
	localctx = NewAlterColumnSpecListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, SqlBaseParserRULE_alterColumnSpecList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4733)
		p.AlterColumnSpec()
	}
	p.SetState(4738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCOMMA {
		{
			p.SetState(4734)
			p.Match(SqlBaseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4735)
			p.AlterColumnSpec()
		}

		p.SetState(4740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterColumnSpecContext is an interface to support dynamic dispatch.
type IAlterColumnSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumn returns the column rule contexts.
	GetColumn() IMultipartIdentifierContext

	// SetColumn sets the column rule contexts.
	SetColumn(IMultipartIdentifierContext)

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	AlterColumnAction() IAlterColumnActionContext

	// IsAlterColumnSpecContext differentiates from other interfaces.
	IsAlterColumnSpecContext()
}

type AlterColumnSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	column IMultipartIdentifierContext
}

func NewEmptyAlterColumnSpecContext() *AlterColumnSpecContext {
	var p = new(AlterColumnSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterColumnSpec
	return p
}

func InitEmptyAlterColumnSpecContext(p *AlterColumnSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterColumnSpec
}

func (*AlterColumnSpecContext) IsAlterColumnSpecContext() {}

func NewAlterColumnSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColumnSpecContext {
	var p = new(AlterColumnSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_alterColumnSpec

	return p
}

func (s *AlterColumnSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColumnSpecContext) GetColumn() IMultipartIdentifierContext { return s.column }

func (s *AlterColumnSpecContext) SetColumn(v IMultipartIdentifierContext) { s.column = v }

func (s *AlterColumnSpecContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColumnSpecContext) AlterColumnAction() IAlterColumnActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterColumnActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterColumnActionContext)
}

func (s *AlterColumnSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterColumnSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterColumnSpec(s)
	}
}

func (s *AlterColumnSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterColumnSpec(s)
	}
}

func (p *SqlBaseParser) AlterColumnSpec() (localctx IAlterColumnSpecContext) {
	localctx = NewAlterColumnSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, SqlBaseParserRULE_alterColumnSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4741)

		var _x = p.MultipartIdentifier()

		localctx.(*AlterColumnSpecContext).column = _x
	}
	p.SetState(4743)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 607, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4742)
			p.AlterColumnAction()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterColumnActionContext is an interface to support dynamic dispatch.
type IAlterColumnActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSetOrDrop returns the setOrDrop token.
	GetSetOrDrop() antlr.Token

	// GetDropDefault returns the dropDefault token.
	GetDropDefault() antlr.Token

	// SetSetOrDrop sets the setOrDrop token.
	SetSetOrDrop(antlr.Token)

	// SetDropDefault sets the dropDefault token.
	SetDropDefault(antlr.Token)

	// Getter signatures
	TYPE() antlr.TerminalNode
	DataType() IDataTypeContext
	CommentSpec() ICommentSpecContext
	ColPosition() IColPositionContext
	ErrorCapturingNot() IErrorCapturingNotContext
	NULL() antlr.TerminalNode
	SET() antlr.TerminalNode
	DROP() antlr.TerminalNode
	DefaultExpression() IDefaultExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsAlterColumnActionContext differentiates from other interfaces.
	IsAlterColumnActionContext()
}

type AlterColumnActionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	setOrDrop   antlr.Token
	dropDefault antlr.Token
}

func NewEmptyAlterColumnActionContext() *AlterColumnActionContext {
	var p = new(AlterColumnActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterColumnAction
	return p
}

func InitEmptyAlterColumnActionContext(p *AlterColumnActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterColumnAction
}

func (*AlterColumnActionContext) IsAlterColumnActionContext() {}

func NewAlterColumnActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColumnActionContext {
	var p = new(AlterColumnActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_alterColumnAction

	return p
}

func (s *AlterColumnActionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColumnActionContext) GetSetOrDrop() antlr.Token { return s.setOrDrop }

func (s *AlterColumnActionContext) GetDropDefault() antlr.Token { return s.dropDefault }

func (s *AlterColumnActionContext) SetSetOrDrop(v antlr.Token) { s.setOrDrop = v }

func (s *AlterColumnActionContext) SetDropDefault(v antlr.Token) { s.dropDefault = v }

func (s *AlterColumnActionContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *AlterColumnActionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterColumnActionContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *AlterColumnActionContext) ColPosition() IColPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColPositionContext)
}

func (s *AlterColumnActionContext) ErrorCapturingNot() IErrorCapturingNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingNotContext)
}

func (s *AlterColumnActionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *AlterColumnActionContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *AlterColumnActionContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *AlterColumnActionContext) DefaultExpression() IDefaultExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultExpressionContext)
}

func (s *AlterColumnActionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *AlterColumnActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterColumnActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAlterColumnAction(s)
	}
}

func (s *AlterColumnActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAlterColumnAction(s)
	}
}

func (p *SqlBaseParser) AlterColumnAction() (localctx IAlterColumnActionContext) {
	localctx = NewAlterColumnActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, SqlBaseParserRULE_alterColumnAction)
	var _la int

	p.SetState(4757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 608, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4745)
			p.Match(SqlBaseParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4746)
			p.DataType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4747)
			p.CommentSpec()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4748)
			p.ColPosition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4749)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterColumnActionContext).setOrDrop = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDROP || _la == SqlBaseParserSET) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterColumnActionContext).setOrDrop = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4750)
			p.ErrorCapturingNot()
		}
		{
			p.SetState(4751)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4753)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4754)
			p.DefaultExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4755)

			var _m = p.Match(SqlBaseParserDROP)

			localctx.(*AlterColumnActionContext).dropDefault = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4756)
			p.Match(SqlBaseParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLitContext is an interface to support dynamic dispatch.
type IStringLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	DOUBLEQUOTED_STRING() antlr.TerminalNode

	// IsStringLitContext differentiates from other interfaces.
	IsStringLitContext()
}

type StringLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLitContext() *StringLitContext {
	var p = new(StringLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_stringLit
	return p
}

func InitEmptyStringLitContext(p *StringLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_stringLit
}

func (*StringLitContext) IsStringLitContext() {}

func NewStringLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLitContext {
	var p = new(StringLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_stringLit

	return p
}

func (s *StringLitContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLitContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING_LITERAL, 0)
}

func (s *StringLitContext) DOUBLEQUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLEQUOTED_STRING, 0)
}

func (s *StringLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStringLit(s)
	}
}

func (s *StringLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStringLit(s)
	}
}

func (p *SqlBaseParser) StringLit() (localctx IStringLitContext) {
	localctx = NewStringLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, SqlBaseParserRULE_stringLit)
	p.SetState(4762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 609, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4759)
			p.Match(SqlBaseParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4760)

		if !(!double_quoted_identifiers) {
			p.SetError(antlr.NewFailedPredicateException(p, "!double_quoted_identifiers", ""))
			goto errorExit
		}
		{
			p.SetState(4761)
			p.Match(SqlBaseParserDOUBLEQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLit() IStringLitContext
	NULL() antlr.TerminalNode

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comment
	return p
}

func InitEmptyCommentContext(p *CommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comment
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *CommentContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *SqlBaseParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, SqlBaseParserRULE_comment)
	p.SetState(4766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 610, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4764)
			p.StringLit()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4765)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	StringLit() IStringLitContext

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_version
	return p
}

func InitEmptyVersionContext(p *VersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_version
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *VersionContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitVersion(s)
	}
}

func (p *SqlBaseParser) Version() (localctx IVersionContext) {
	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, SqlBaseParserRULE_version)
	p.SetState(4770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4768)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4769)
			p.StringLit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperatorPipeRightSideContext is an interface to support dynamic dispatch.
type IOperatorPipeRightSideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOperator returns the operator token.
	GetOperator() antlr.Token

	// SetOperator sets the operator token.
	SetOperator(antlr.Token)

	// GetExtendList returns the extendList rule contexts.
	GetExtendList() INamedExpressionSeqContext

	// GetRight returns the right rule contexts.
	GetRight() IQueryPrimaryContext

	// SetExtendList sets the extendList rule contexts.
	SetExtendList(INamedExpressionSeqContext)

	// SetRight sets the right rule contexts.
	SetRight(IQueryPrimaryContext)

	// Getter signatures
	SelectClause() ISelectClauseContext
	WindowClause() IWindowClauseContext
	EXTEND() antlr.TerminalNode
	NamedExpressionSeq() INamedExpressionSeqContext
	SET() antlr.TerminalNode
	OperatorPipeSetAssignmentSeq() IOperatorPipeSetAssignmentSeqContext
	DROP() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	AS() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	WhereClause() IWhereClauseContext
	PivotClause() IPivotClauseContext
	UnpivotClause() IUnpivotClauseContext
	Sample() ISampleContext
	JoinRelation() IJoinRelationContext
	QueryPrimary() IQueryPrimaryContext
	UNION() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	SETMINUS() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	SetQuantifier() ISetQuantifierContext
	QueryOrganization() IQueryOrganizationContext
	AGGREGATE() antlr.TerminalNode
	AggregationClause() IAggregationClauseContext

	// IsOperatorPipeRightSideContext differentiates from other interfaces.
	IsOperatorPipeRightSideContext()
}

type OperatorPipeRightSideContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	extendList INamedExpressionSeqContext
	operator   antlr.Token
	right      IQueryPrimaryContext
}

func NewEmptyOperatorPipeRightSideContext() *OperatorPipeRightSideContext {
	var p = new(OperatorPipeRightSideContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_operatorPipeRightSide
	return p
}

func InitEmptyOperatorPipeRightSideContext(p *OperatorPipeRightSideContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_operatorPipeRightSide
}

func (*OperatorPipeRightSideContext) IsOperatorPipeRightSideContext() {}

func NewOperatorPipeRightSideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorPipeRightSideContext {
	var p = new(OperatorPipeRightSideContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_operatorPipeRightSide

	return p
}

func (s *OperatorPipeRightSideContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorPipeRightSideContext) GetOperator() antlr.Token { return s.operator }

func (s *OperatorPipeRightSideContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *OperatorPipeRightSideContext) GetExtendList() INamedExpressionSeqContext {
	return s.extendList
}

func (s *OperatorPipeRightSideContext) GetRight() IQueryPrimaryContext { return s.right }

func (s *OperatorPipeRightSideContext) SetExtendList(v INamedExpressionSeqContext) { s.extendList = v }

func (s *OperatorPipeRightSideContext) SetRight(v IQueryPrimaryContext) { s.right = v }

func (s *OperatorPipeRightSideContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *OperatorPipeRightSideContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *OperatorPipeRightSideContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTEND, 0)
}

func (s *OperatorPipeRightSideContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *OperatorPipeRightSideContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *OperatorPipeRightSideContext) OperatorPipeSetAssignmentSeq() IOperatorPipeSetAssignmentSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorPipeSetAssignmentSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorPipeSetAssignmentSeqContext)
}

func (s *OperatorPipeRightSideContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *OperatorPipeRightSideContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *OperatorPipeRightSideContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *OperatorPipeRightSideContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *OperatorPipeRightSideContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *OperatorPipeRightSideContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *OperatorPipeRightSideContext) UnpivotClause() IUnpivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotClauseContext)
}

func (s *OperatorPipeRightSideContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *OperatorPipeRightSideContext) JoinRelation() IJoinRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *OperatorPipeRightSideContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *OperatorPipeRightSideContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNION, 0)
}

func (s *OperatorPipeRightSideContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCEPT, 0)
}

func (s *OperatorPipeRightSideContext) SETMINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETMINUS, 0)
}

func (s *OperatorPipeRightSideContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERSECT, 0)
}

func (s *OperatorPipeRightSideContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *OperatorPipeRightSideContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *OperatorPipeRightSideContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAGGREGATE, 0)
}

func (s *OperatorPipeRightSideContext) AggregationClause() IAggregationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationClauseContext)
}

func (s *OperatorPipeRightSideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorPipeRightSideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorPipeRightSideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterOperatorPipeRightSide(s)
	}
}

func (s *OperatorPipeRightSideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitOperatorPipeRightSide(s)
	}
}

func (p *SqlBaseParser) OperatorPipeRightSide() (localctx IOperatorPipeRightSideContext) {
	localctx = NewOperatorPipeRightSideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, SqlBaseParserRULE_operatorPipeRightSide)
	var _la int

	p.SetState(4811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 619, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4772)
			p.SelectClause()
		}
		p.SetState(4774)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4773)
				p.WindowClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4776)
			p.Match(SqlBaseParserEXTEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4777)

			var _x = p.NamedExpressionSeq()

			localctx.(*OperatorPipeRightSideContext).extendList = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4778)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4779)
			p.OperatorPipeSetAssignmentSeq()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4780)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4781)
			p.IdentifierSeq()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4782)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4783)
			p.ErrorCapturingIdentifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4784)
			p.WhereClause()
		}
		p.SetState(4786)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 613, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4785)
				p.WindowClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4788)
			p.PivotClause()
		}
		p.SetState(4790)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4789)
				p.UnpivotClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4792)
			p.UnpivotClause()
		}
		p.SetState(4794)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 615, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4793)
				p.PivotClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4796)
			p.Sample()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4797)
			p.JoinRelation()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4798)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OperatorPipeRightSideContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserEXCEPT || _la == SqlBaseParserINTERSECT || _la == SqlBaseParserSETMINUS || _la == SqlBaseParserUNION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OperatorPipeRightSideContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
			{
				p.SetState(4799)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(4802)

			var _x = p.QueryPrimary()

			localctx.(*OperatorPipeRightSideContext).right = _x
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4803)
			p.QueryOrganization()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4804)
			p.Match(SqlBaseParserAGGREGATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4806)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 617, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4805)
				p.NamedExpressionSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4809)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 618, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4808)
				p.AggregationClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperatorPipeSetAssignmentSeqContext is an interface to support dynamic dispatch.
type IOperatorPipeSetAssignmentSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetIdent returns the ident rule context list.
	GetIdent() []IErrorCapturingIdentifierContext

	// SetIdent sets the ident rule context list.
	SetIdent([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOperatorPipeSetAssignmentSeqContext differentiates from other interfaces.
	IsOperatorPipeSetAssignmentSeqContext()
}

type OperatorPipeSetAssignmentSeqContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	ident                     []IErrorCapturingIdentifierContext
}

func NewEmptyOperatorPipeSetAssignmentSeqContext() *OperatorPipeSetAssignmentSeqContext {
	var p = new(OperatorPipeSetAssignmentSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_operatorPipeSetAssignmentSeq
	return p
}

func InitEmptyOperatorPipeSetAssignmentSeqContext(p *OperatorPipeSetAssignmentSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_operatorPipeSetAssignmentSeq
}

func (*OperatorPipeSetAssignmentSeqContext) IsOperatorPipeSetAssignmentSeqContext() {}

func NewOperatorPipeSetAssignmentSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorPipeSetAssignmentSeqContext {
	var p = new(OperatorPipeSetAssignmentSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_operatorPipeSetAssignmentSeq

	return p
}

func (s *OperatorPipeSetAssignmentSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorPipeSetAssignmentSeqContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *OperatorPipeSetAssignmentSeqContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *OperatorPipeSetAssignmentSeqContext) GetIdent() []IErrorCapturingIdentifierContext {
	return s.ident
}

func (s *OperatorPipeSetAssignmentSeqContext) SetIdent(v []IErrorCapturingIdentifierContext) {
	s.ident = v
}

func (s *OperatorPipeSetAssignmentSeqContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserEQ)
}

func (s *OperatorPipeSetAssignmentSeqContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, i)
}

func (s *OperatorPipeSetAssignmentSeqContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OperatorPipeSetAssignmentSeqContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OperatorPipeSetAssignmentSeqContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *OperatorPipeSetAssignmentSeqContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *OperatorPipeSetAssignmentSeqContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserDOT)
}

func (s *OperatorPipeSetAssignmentSeqContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOT, i)
}

func (s *OperatorPipeSetAssignmentSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserCOMMA)
}

func (s *OperatorPipeSetAssignmentSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMA, i)
}

func (s *OperatorPipeSetAssignmentSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorPipeSetAssignmentSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorPipeSetAssignmentSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterOperatorPipeSetAssignmentSeq(s)
	}
}

func (s *OperatorPipeSetAssignmentSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitOperatorPipeSetAssignmentSeq(s)
	}
}

func (p *SqlBaseParser) OperatorPipeSetAssignmentSeq() (localctx IOperatorPipeSetAssignmentSeqContext) {
	localctx = NewOperatorPipeSetAssignmentSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, SqlBaseParserRULE_operatorPipeSetAssignmentSeq)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4813)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*OperatorPipeSetAssignmentSeqContext)._errorCapturingIdentifier = _x
	}
	localctx.(*OperatorPipeSetAssignmentSeqContext).ident = append(localctx.(*OperatorPipeSetAssignmentSeqContext).ident, localctx.(*OperatorPipeSetAssignmentSeqContext)._errorCapturingIdentifier)
	p.SetState(4818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserDOT {
		{
			p.SetState(4814)
			p.Match(SqlBaseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4815)
			p.ErrorCapturingIdentifier()
		}

		p.SetState(4820)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4821)
		p.Match(SqlBaseParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4822)
		p.Expression()
	}
	p.SetState(4837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 622, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4823)
				p.Match(SqlBaseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4824)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*OperatorPipeSetAssignmentSeqContext)._errorCapturingIdentifier = _x
			}
			localctx.(*OperatorPipeSetAssignmentSeqContext).ident = append(localctx.(*OperatorPipeSetAssignmentSeqContext).ident, localctx.(*OperatorPipeSetAssignmentSeqContext)._errorCapturingIdentifier)
			p.SetState(4829)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserDOT {
				{
					p.SetState(4825)
					p.Match(SqlBaseParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4826)
					p.ErrorCapturingIdentifier()
				}

				p.SetState(4831)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4832)
				p.Match(SqlBaseParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4833)
				p.Expression()
			}

		}
		p.SetState(4839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 622, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnsiNonReservedContext is an interface to support dynamic dispatch.
type IAnsiNonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	ANY_VALUE() antlr.TerminalNode
	ARCHIVE() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	ASC() antlr.TerminalNode
	AT() antlr.TerminalNode
	ATOMIC() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	BINARY_HEX() antlr.TerminalNode
	BINDING() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BUCKET() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BY() antlr.TerminalNode
	BYTE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CALLED() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CHANGE() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERED() antlr.TerminalNode
	CODEGEN() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPACTIONS() antlr.TerminalNode
	COMPENSATION() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONCATENATE() antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	COST() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATEADD() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATE_DIFF() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	DBPROPERTIES() antlr.TerminalNode
	DEC() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECLARE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFINED() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DELIMITED() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETERMINISTIC() antlr.TerminalNode
	DFS() antlr.TerminalNode
	DIRECTORIES() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISTRIBUTE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	DO() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	ELSEIF() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode
	ESCAPED() antlr.TerminalNode
	EVOLUTION() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTEND() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILEFORMAT() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	FLOW() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FORMATTED() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	IDENTIFIER_KW() antlr.TerminalNode
	IDENTITY() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INCLUDE() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INPATH() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	INPUTFORMAT() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	ITEMS() antlr.TerminalNode
	ITERATE() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KEYS() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LAZY() antlr.TerminalNode
	LEAVE() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	LINES() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOCKS() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	LONG() antlr.TerminalNode
	LOOP() antlr.TerminalNode
	MACRO() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MATCHED() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODIFIES() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHS() antlr.TerminalNode
	MSCK() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMESPACE() antlr.TerminalNode
	NAMESPACES() antlr.TerminalNode
	NANOSECOND() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	NO() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NORELY() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	OF() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OUTPUTFORMAT() antlr.TerminalNode
	OVER() antlr.TerminalNode
	OVERLAY() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PARTITIONED() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PERCENTLIT() antlr.TerminalNode
	PIVOT() antlr.TerminalNode
	PLACING() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRINCIPALS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	PROCEDURES() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PURGE() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	READS() antlr.TerminalNode
	REAL() antlr.TerminalNode
	RECORDREADER() antlr.TerminalNode
	RECORDWRITER() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECURSION() antlr.TerminalNode
	REDUCE() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	RELY() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPEAT() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SEPARATED() antlr.TerminalNode
	SERDE() antlr.TerminalNode
	SERDEPROPERTIES() antlr.TerminalNode
	SET() antlr.TerminalNode
	SETMINUS() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SHORT() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	SINGLE() antlr.TerminalNode
	SKEWED() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	SORT() antlr.TerminalNode
	SORTED() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SPECIFIC() antlr.TerminalNode
	SQLEXCEPTION() antlr.TerminalNode
	SQLSTATE() antlr.TerminalNode
	START() antlr.TerminalNode
	STATISTICS() antlr.TerminalNode
	STORED() antlr.TerminalNode
	STRATIFY() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	STREAMING() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	SYSTEM_VERSION() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	TARGET() antlr.TerminalNode
	TBLPROPERTIES() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	TIMEDIFF() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMP_LTZ() antlr.TerminalNode
	TIMESTAMP_NTZ() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	TOUCH() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRANSACTIONS() antlr.TerminalNode
	TRANSFORM() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TRY_CAST() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNARCHIVE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNCACHE() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	UNPIVOT() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USE() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	VAR() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	VOID() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKS() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARS() antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsAnsiNonReservedContext differentiates from other interfaces.
	IsAnsiNonReservedContext()
}

type AnsiNonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnsiNonReservedContext() *AnsiNonReservedContext {
	var p = new(AnsiNonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_ansiNonReserved
	return p
}

func InitEmptyAnsiNonReservedContext(p *AnsiNonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_ansiNonReserved
}

func (*AnsiNonReservedContext) IsAnsiNonReservedContext() {}

func NewAnsiNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnsiNonReservedContext {
	var p = new(AnsiNonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_ansiNonReserved

	return p
}

func (s *AnsiNonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *AnsiNonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *AnsiNonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAFTER, 0)
}

func (s *AnsiNonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAGGREGATE, 0)
}

func (s *AnsiNonReservedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AnsiNonReservedContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALWAYS, 0)
}

func (s *AnsiNonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *AnsiNonReservedContext) ANTI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANTI, 0)
}

func (s *AnsiNonReservedContext) ANY_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY_VALUE, 0)
}

func (s *AnsiNonReservedContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARCHIVE, 0)
}

func (s *AnsiNonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *AnsiNonReservedContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *AnsiNonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *AnsiNonReservedContext) ATOMIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserATOMIC, 0)
}

func (s *AnsiNonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBEGIN, 0)
}

func (s *AnsiNonReservedContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *AnsiNonReservedContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBIGINT, 0)
}

func (s *AnsiNonReservedContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY, 0)
}

func (s *AnsiNonReservedContext) BINARY_HEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY_HEX, 0)
}

func (s *AnsiNonReservedContext) BINDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINDING, 0)
}

func (s *AnsiNonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBOOLEAN, 0)
}

func (s *AnsiNonReservedContext) BUCKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBUCKET, 0)
}

func (s *AnsiNonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBUCKETS, 0)
}

func (s *AnsiNonReservedContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *AnsiNonReservedContext) BYTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBYTE, 0)
}

func (s *AnsiNonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *AnsiNonReservedContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALLED, 0)
}

func (s *AnsiNonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *AnsiNonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOG, 0)
}

func (s *AnsiNonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *AnsiNonReservedContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHANGE, 0)
}

func (s *AnsiNonReservedContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHAR, 0)
}

func (s *AnsiNonReservedContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHARACTER, 0)
}

func (s *AnsiNonReservedContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLEAR, 0)
}

func (s *AnsiNonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTER, 0)
}

func (s *AnsiNonReservedContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTERED, 0)
}

func (s *AnsiNonReservedContext) CODEGEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCODEGEN, 0)
}

func (s *AnsiNonReservedContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLLECTION, 0)
}

func (s *AnsiNonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *AnsiNonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *AnsiNonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *AnsiNonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPACT, 0)
}

func (s *AnsiNonReservedContext) COMPACTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPACTIONS, 0)
}

func (s *AnsiNonReservedContext) COMPENSATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPENSATION, 0)
}

func (s *AnsiNonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPUTE, 0)
}

func (s *AnsiNonReservedContext) CONCATENATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCATENATE, 0)
}

func (s *AnsiNonReservedContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONDITION, 0)
}

func (s *AnsiNonReservedContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONTAINS, 0)
}

func (s *AnsiNonReservedContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONTINUE, 0)
}

func (s *AnsiNonReservedContext) COST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOST, 0)
}

func (s *AnsiNonReservedContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *AnsiNonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *AnsiNonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *AnsiNonReservedContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *AnsiNonReservedContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASES, 0)
}

func (s *AnsiNonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *AnsiNonReservedContext) DATEADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATEADD, 0)
}

func (s *AnsiNonReservedContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE_ADD, 0)
}

func (s *AnsiNonReservedContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATEDIFF, 0)
}

func (s *AnsiNonReservedContext) DATE_DIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE_DIFF, 0)
}

func (s *AnsiNonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *AnsiNonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAYS, 0)
}

func (s *AnsiNonReservedContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAYOFYEAR, 0)
}

func (s *AnsiNonReservedContext) DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDBPROPERTIES, 0)
}

func (s *AnsiNonReservedContext) DEC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEC, 0)
}

func (s *AnsiNonReservedContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL, 0)
}

func (s *AnsiNonReservedContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECLARE, 0)
}

func (s *AnsiNonReservedContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *AnsiNonReservedContext) DEFINED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINED, 0)
}

func (s *AnsiNonReservedContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *AnsiNonReservedContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *AnsiNonReservedContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELIMITED, 0)
}

func (s *AnsiNonReservedContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *AnsiNonReservedContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *AnsiNonReservedContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDETERMINISTIC, 0)
}

func (s *AnsiNonReservedContext) DFS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDFS, 0)
}

func (s *AnsiNonReservedContext) DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORIES, 0)
}

func (s *AnsiNonReservedContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORY, 0)
}

func (s *AnsiNonReservedContext) DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTE, 0)
}

func (s *AnsiNonReservedContext) DIV() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIV, 0)
}

func (s *AnsiNonReservedContext) DO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDO, 0)
}

func (s *AnsiNonReservedContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE, 0)
}

func (s *AnsiNonReservedContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *AnsiNonReservedContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSEIF, 0)
}

func (s *AnsiNonReservedContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserENFORCED, 0)
}

func (s *AnsiNonReservedContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPED, 0)
}

func (s *AnsiNonReservedContext) EVOLUTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEVOLUTION, 0)
}

func (s *AnsiNonReservedContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCHANGE, 0)
}

func (s *AnsiNonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDE, 0)
}

func (s *AnsiNonReservedContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *AnsiNonReservedContext) EXIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXIT, 0)
}

func (s *AnsiNonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *AnsiNonReservedContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPORT, 0)
}

func (s *AnsiNonReservedContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTEND, 0)
}

func (s *AnsiNonReservedContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *AnsiNonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *AnsiNonReservedContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTRACT, 0)
}

func (s *AnsiNonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIELDS, 0)
}

func (s *AnsiNonReservedContext) FILEFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILEFORMAT, 0)
}

func (s *AnsiNonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *AnsiNonReservedContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOAT, 0)
}

func (s *AnsiNonReservedContext) FLOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOW, 0)
}

func (s *AnsiNonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *AnsiNonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *AnsiNonReservedContext) FORMATTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMATTED, 0)
}

func (s *AnsiNonReservedContext) FOUND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOUND, 0)
}

func (s *AnsiNonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *AnsiNonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *AnsiNonReservedContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGENERATED, 0)
}

func (s *AnsiNonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGLOBAL, 0)
}

func (s *AnsiNonReservedContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *AnsiNonReservedContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHANDLER, 0)
}

func (s *AnsiNonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *AnsiNonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOURS, 0)
}

func (s *AnsiNonReservedContext) IDENTIFIER_KW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER_KW, 0)
}

func (s *AnsiNonReservedContext) IDENTITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTITY, 0)
}

func (s *AnsiNonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *AnsiNonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *AnsiNonReservedContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIMMEDIATE, 0)
}

func (s *AnsiNonReservedContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIMPORT, 0)
}

func (s *AnsiNonReservedContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDE, 0)
}

func (s *AnsiNonReservedContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCREMENT, 0)
}

func (s *AnsiNonReservedContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *AnsiNonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEXES, 0)
}

func (s *AnsiNonReservedContext) INPATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPATH, 0)
}

func (s *AnsiNonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *AnsiNonReservedContext) INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUTFORMAT, 0)
}

func (s *AnsiNonReservedContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *AnsiNonReservedContext) INT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINT, 0)
}

func (s *AnsiNonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER, 0)
}

func (s *AnsiNonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *AnsiNonReservedContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *AnsiNonReservedContext) ITEMS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserITEMS, 0)
}

func (s *AnsiNonReservedContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserITERATE, 0)
}

func (s *AnsiNonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *AnsiNonReservedContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *AnsiNonReservedContext) KEYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEYS, 0)
}

func (s *AnsiNonReservedContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLANGUAGE, 0)
}

func (s *AnsiNonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *AnsiNonReservedContext) LAZY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAZY, 0)
}

func (s *AnsiNonReservedContext) LEAVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEAVE, 0)
}

func (s *AnsiNonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *AnsiNonReservedContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *AnsiNonReservedContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserILIKE, 0)
}

func (s *AnsiNonReservedContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *AnsiNonReservedContext) LINES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLINES, 0)
}

func (s *AnsiNonReservedContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *AnsiNonReservedContext) LOAD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOAD, 0)
}

func (s *AnsiNonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCAL, 0)
}

func (s *AnsiNonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCATION, 0)
}

func (s *AnsiNonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCK, 0)
}

func (s *AnsiNonReservedContext) LOCKS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCKS, 0)
}

func (s *AnsiNonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *AnsiNonReservedContext) LONG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLONG, 0)
}

func (s *AnsiNonReservedContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOOP, 0)
}

func (s *AnsiNonReservedContext) MACRO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMACRO, 0)
}

func (s *AnsiNonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *AnsiNonReservedContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATCHED, 0)
}

func (s *AnsiNonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *AnsiNonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAX, 0)
}

func (s *AnsiNonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMERGE, 0)
}

func (s *AnsiNonReservedContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMICROSECOND, 0)
}

func (s *AnsiNonReservedContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMICROSECONDS, 0)
}

func (s *AnsiNonReservedContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECOND, 0)
}

func (s *AnsiNonReservedContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECONDS, 0)
}

func (s *AnsiNonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *AnsiNonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTES, 0)
}

func (s *AnsiNonReservedContext) MODIFIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMODIFIES, 0)
}

func (s *AnsiNonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *AnsiNonReservedContext) MONTHS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTHS, 0)
}

func (s *AnsiNonReservedContext) MSCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMSCK, 0)
}

func (s *AnsiNonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *AnsiNonReservedContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAMESPACE, 0)
}

func (s *AnsiNonReservedContext) NAMESPACES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAMESPACES, 0)
}

func (s *AnsiNonReservedContext) NANOSECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNANOSECOND, 0)
}

func (s *AnsiNonReservedContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNANOSECONDS, 0)
}

func (s *AnsiNonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *AnsiNonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *AnsiNonReservedContext) NORELY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNORELY, 0)
}

func (s *AnsiNonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *AnsiNonReservedContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNUMERIC, 0)
}

func (s *AnsiNonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOF, 0)
}

func (s *AnsiNonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *AnsiNonReservedContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, 0)
}

func (s *AnsiNonReservedContext) OUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUT, 0)
}

func (s *AnsiNonReservedContext) OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUTFORMAT, 0)
}

func (s *AnsiNonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *AnsiNonReservedContext) OVERLAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERLAY, 0)
}

func (s *AnsiNonReservedContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *AnsiNonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *AnsiNonReservedContext) PARTITIONED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONED, 0)
}

func (s *AnsiNonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *AnsiNonReservedContext) PERCENTLIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENTLIT, 0)
}

func (s *AnsiNonReservedContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPIVOT, 0)
}

func (s *AnsiNonReservedContext) PLACING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLACING, 0)
}

func (s *AnsiNonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *AnsiNonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *AnsiNonReservedContext) PRINCIPALS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRINCIPALS, 0)
}

func (s *AnsiNonReservedContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROCEDURE, 0)
}

func (s *AnsiNonReservedContext) PROCEDURES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROCEDURES, 0)
}

func (s *AnsiNonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *AnsiNonReservedContext) PURGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPURGE, 0)
}

func (s *AnsiNonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUARTER, 0)
}

func (s *AnsiNonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUERY, 0)
}

func (s *AnsiNonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *AnsiNonReservedContext) READS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREADS, 0)
}

func (s *AnsiNonReservedContext) REAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAL, 0)
}

func (s *AnsiNonReservedContext) RECORDREADER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECORDREADER, 0)
}

func (s *AnsiNonReservedContext) RECORDWRITER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECORDWRITER, 0)
}

func (s *AnsiNonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECOVER, 0)
}

func (s *AnsiNonReservedContext) RECURSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSION, 0)
}

func (s *AnsiNonReservedContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREDUCE, 0)
}

func (s *AnsiNonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *AnsiNonReservedContext) RELY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRELY, 0)
}

func (s *AnsiNonReservedContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *AnsiNonReservedContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPAIR, 0)
}

func (s *AnsiNonReservedContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEAT, 0)
}

func (s *AnsiNonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *AnsiNonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *AnsiNonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *AnsiNonReservedContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESPECT, 0)
}

func (s *AnsiNonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *AnsiNonReservedContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURN, 0)
}

func (s *AnsiNonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *AnsiNonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *AnsiNonReservedContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRLIKE, 0)
}

func (s *AnsiNonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *AnsiNonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *AnsiNonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *AnsiNonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLUP, 0)
}

func (s *AnsiNonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *AnsiNonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *AnsiNonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *AnsiNonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *AnsiNonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *AnsiNonReservedContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECONDS, 0)
}

func (s *AnsiNonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *AnsiNonReservedContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEMI, 0)
}

func (s *AnsiNonReservedContext) SEPARATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEPARATED, 0)
}

func (s *AnsiNonReservedContext) SERDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDE, 0)
}

func (s *AnsiNonReservedContext) SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDEPROPERTIES, 0)
}

func (s *AnsiNonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *AnsiNonReservedContext) SETMINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETMINUS, 0)
}

func (s *AnsiNonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *AnsiNonReservedContext) SHORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHORT, 0)
}

func (s *AnsiNonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *AnsiNonReservedContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSINGLE, 0)
}

func (s *AnsiNonReservedContext) SKEWED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSKEWED, 0)
}

func (s *AnsiNonReservedContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSMALLINT, 0)
}

func (s *AnsiNonReservedContext) SORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORT, 0)
}

func (s *AnsiNonReservedContext) SORTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORTED, 0)
}

func (s *AnsiNonReservedContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *AnsiNonReservedContext) SPECIFIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSPECIFIC, 0)
}

func (s *AnsiNonReservedContext) SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQLEXCEPTION, 0)
}

func (s *AnsiNonReservedContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQLSTATE, 0)
}

func (s *AnsiNonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *AnsiNonReservedContext) STATISTICS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATISTICS, 0)
}

func (s *AnsiNonReservedContext) STORED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTORED, 0)
}

func (s *AnsiNonReservedContext) STRATIFY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRATIFY, 0)
}

func (s *AnsiNonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *AnsiNonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT, 0)
}

func (s *AnsiNonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *AnsiNonReservedContext) STREAMING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAMING, 0)
}

func (s *AnsiNonReservedContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTR, 0)
}

func (s *AnsiNonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *AnsiNonReservedContext) SYNC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYNC, 0)
}

func (s *AnsiNonReservedContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM_TIME, 0)
}

func (s *AnsiNonReservedContext) SYSTEM_VERSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM_VERSION, 0)
}

func (s *AnsiNonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *AnsiNonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *AnsiNonReservedContext) TARGET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTARGET, 0)
}

func (s *AnsiNonReservedContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, 0)
}

func (s *AnsiNonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *AnsiNonReservedContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTERMINATED, 0)
}

func (s *AnsiNonReservedContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMEDIFF, 0)
}

func (s *AnsiNonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *AnsiNonReservedContext) TIMESTAMP_LTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_LTZ, 0)
}

func (s *AnsiNonReservedContext) TIMESTAMP_NTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_NTZ, 0)
}

func (s *AnsiNonReservedContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMPADD, 0)
}

func (s *AnsiNonReservedContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMPDIFF, 0)
}

func (s *AnsiNonReservedContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTINYINT, 0)
}

func (s *AnsiNonReservedContext) TOUCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTOUCH, 0)
}

func (s *AnsiNonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *AnsiNonReservedContext) TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTIONS, 0)
}

func (s *AnsiNonReservedContext) TRANSFORM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSFORM, 0)
}

func (s *AnsiNonReservedContext) TRIM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRIM, 0)
}

func (s *AnsiNonReservedContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *AnsiNonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUNCATE, 0)
}

func (s *AnsiNonReservedContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *AnsiNonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *AnsiNonReservedContext) UNARCHIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNARCHIVE, 0)
}

func (s *AnsiNonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *AnsiNonReservedContext) UNCACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCACHE, 0)
}

func (s *AnsiNonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNLOCK, 0)
}

func (s *AnsiNonReservedContext) UNPIVOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNPIVOT, 0)
}

func (s *AnsiNonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNSET, 0)
}

func (s *AnsiNonReservedContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNTIL, 0)
}

func (s *AnsiNonReservedContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *AnsiNonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *AnsiNonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUE, 0)
}

func (s *AnsiNonReservedContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *AnsiNonReservedContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARCHAR, 0)
}

func (s *AnsiNonReservedContext) VAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVAR, 0)
}

func (s *AnsiNonReservedContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIABLE, 0)
}

func (s *AnsiNonReservedContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIANT, 0)
}

func (s *AnsiNonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERSION, 0)
}

func (s *AnsiNonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *AnsiNonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEWS, 0)
}

func (s *AnsiNonReservedContext) VOID() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVOID, 0)
}

func (s *AnsiNonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWEEK, 0)
}

func (s *AnsiNonReservedContext) WEEKS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWEEKS, 0)
}

func (s *AnsiNonReservedContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHILE, 0)
}

func (s *AnsiNonReservedContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWINDOW, 0)
}

func (s *AnsiNonReservedContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHOUT, 0)
}

func (s *AnsiNonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *AnsiNonReservedContext) YEARS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEARS, 0)
}

func (s *AnsiNonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *AnsiNonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnsiNonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnsiNonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterAnsiNonReserved(s)
	}
}

func (s *AnsiNonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitAnsiNonReserved(s)
	}
}

func (p *SqlBaseParser) AnsiNonReserved() (localctx IAnsiNonReservedContext) {
	localctx = NewAnsiNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, SqlBaseParserRULE_ansiNonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4840)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-198735086114640384) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-20972084788230537) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-5785472989594225687) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-42345250802368513) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-1155243681755299845) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-434315983604285443) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&124543) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrictNonReservedContext is an interface to support dynamic dispatch.
type IStrictNonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANTI() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	ON() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SETMINUS() antlr.TerminalNode
	UNION() antlr.TerminalNode
	USING() antlr.TerminalNode

	// IsStrictNonReservedContext differentiates from other interfaces.
	IsStrictNonReservedContext()
}

type StrictNonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrictNonReservedContext() *StrictNonReservedContext {
	var p = new(StrictNonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_strictNonReserved
	return p
}

func InitEmptyStrictNonReservedContext(p *StrictNonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_strictNonReserved
}

func (*StrictNonReservedContext) IsStrictNonReservedContext() {}

func NewStrictNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrictNonReservedContext {
	var p = new(StrictNonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_strictNonReserved

	return p
}

func (s *StrictNonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *StrictNonReservedContext) ANTI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANTI, 0)
}

func (s *StrictNonReservedContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCROSS, 0)
}

func (s *StrictNonReservedContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCEPT, 0)
}

func (s *StrictNonReservedContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *StrictNonReservedContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINNER, 0)
}

func (s *StrictNonReservedContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERSECT, 0)
}

func (s *StrictNonReservedContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJOIN, 0)
}

func (s *StrictNonReservedContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *StrictNonReservedContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT, 0)
}

func (s *StrictNonReservedContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNATURAL, 0)
}

func (s *StrictNonReservedContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *StrictNonReservedContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT, 0)
}

func (s *StrictNonReservedContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEMI, 0)
}

func (s *StrictNonReservedContext) SETMINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETMINUS, 0)
}

func (s *StrictNonReservedContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNION, 0)
}

func (s *StrictNonReservedContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *StrictNonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrictNonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrictNonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterStrictNonReserved(s)
	}
}

func (s *StrictNonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitStrictNonReserved(s)
	}
}

func (p *SqlBaseParser) StrictNonReserved() (localctx IStrictNonReservedContext) {
	localctx = NewStrictNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, SqlBaseParserRULE_strictNonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4842)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserANTI || _la == SqlBaseParserCROSS || ((int64((_la-118)) & ^0x3f) == 0 && ((int64(1)<<(_la-118))&37154696992915457) != 0) || ((int64((_la-182)) & ^0x3f) == 0 && ((int64(1)<<(_la-182))&72127962782106689) != 0) || ((int64((_la-290)) & ^0x3f) == 0 && ((int64(1)<<(_la-290))&1064961) != 0) || _la == SqlBaseParserUNION || _la == SqlBaseParserUSING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ANY_VALUE() antlr.TerminalNode
	ARCHIVE() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	AT() antlr.TerminalNode
	ATOMIC() antlr.TerminalNode
	AUTHORIZATION() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	BINARY_HEX() antlr.TerminalNode
	BINDING() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BOTH() antlr.TerminalNode
	BUCKET() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BY() antlr.TerminalNode
	BYTE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CALL() antlr.TerminalNode
	CALLED() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CHANGE() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERED() antlr.TerminalNode
	CODEGEN() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPACTIONS() antlr.TerminalNode
	COMPENSATION() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONCATENATE() antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	COST() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATEADD() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATE_DIFF() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	DBPROPERTIES() antlr.TerminalNode
	DEC() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECLARE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFINED() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DELIMITED() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETERMINISTIC() antlr.TerminalNode
	DFS() antlr.TerminalNode
	DIRECTORIES() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	DISTRIBUTE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	DO() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	ELSEIF() antlr.TerminalNode
	END() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	ESCAPED() antlr.TerminalNode
	EVOLUTION() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTEND() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	FETCH() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILEFORMAT() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	FLOW() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FORMATTED() antlr.TerminalNode
	FROM() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	IDENTIFIER_KW() antlr.TerminalNode
	IDENTITY() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCLUDE() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INPATH() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	INPUTFORMAT() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	INTO() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IS() antlr.TerminalNode
	ITEMS() antlr.TerminalNode
	ITERATE() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KEYS() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LAZY() antlr.TerminalNode
	LEADING() antlr.TerminalNode
	LEAVE() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	LONG() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	LINES() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOCKS() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	LOOP() antlr.TerminalNode
	MACRO() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MATCHED() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODIFIES() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHS() antlr.TerminalNode
	MSCK() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMESPACE() antlr.TerminalNode
	NAMESPACES() antlr.TerminalNode
	NANOSECOND() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	NO() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NORELY() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULL() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	OUTPUTFORMAT() antlr.TerminalNode
	OVER() antlr.TerminalNode
	OVERLAPS() antlr.TerminalNode
	OVERLAY() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PARTITIONED() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PERCENTLIT() antlr.TerminalNode
	PIVOT() antlr.TerminalNode
	PLACING() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PRINCIPALS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	PROCEDURES() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PURGE() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	READS() antlr.TerminalNode
	REAL() antlr.TerminalNode
	RECORDREADER() antlr.TerminalNode
	RECORDWRITER() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECURSION() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REDUCE() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	RELY() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPEAT() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SEPARATED() antlr.TerminalNode
	SERDE() antlr.TerminalNode
	SERDEPROPERTIES() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SET() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SHORT() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	SINGLE() antlr.TerminalNode
	SKEWED() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SORT() antlr.TerminalNode
	SORTED() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SPECIFIC() antlr.TerminalNode
	SQL() antlr.TerminalNode
	SQLEXCEPTION() antlr.TerminalNode
	SQLSTATE() antlr.TerminalNode
	START() antlr.TerminalNode
	STATISTICS() antlr.TerminalNode
	STORED() antlr.TerminalNode
	STRATIFY() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	STREAMING() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	SYSTEM_VERSION() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	TARGET() antlr.TerminalNode
	TBLPROPERTIES() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMEDIFF() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMP_LTZ() antlr.TerminalNode
	TIMESTAMP_NTZ() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	TO() antlr.TerminalNode
	TOUCH() antlr.TerminalNode
	TRAILING() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRANSACTIONS() antlr.TerminalNode
	TRANSFORM() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TRY_CAST() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNARCHIVE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNCACHE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	UNPIVOT() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USE() antlr.TerminalNode
	USER() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	VAR() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	VOID() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKS() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WITHIN() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARS() antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAFTER, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAGGREGATE, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *NonReservedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *NonReservedContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALWAYS, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *NonReservedContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *NonReservedContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *NonReservedContext) ANY_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY_VALUE, 0)
}

func (s *NonReservedContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARCHIVE, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *NonReservedContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *NonReservedContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *NonReservedContext) ATOMIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserATOMIC, 0)
}

func (s *NonReservedContext) AUTHORIZATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAUTHORIZATION, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBEGIN, 0)
}

func (s *NonReservedContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *NonReservedContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBIGINT, 0)
}

func (s *NonReservedContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY, 0)
}

func (s *NonReservedContext) BINARY_HEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY_HEX, 0)
}

func (s *NonReservedContext) BINDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINDING, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBOOLEAN, 0)
}

func (s *NonReservedContext) BOTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBOTH, 0)
}

func (s *NonReservedContext) BUCKET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBUCKET, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBUCKETS, 0)
}

func (s *NonReservedContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *NonReservedContext) BYTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBYTE, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALL, 0)
}

func (s *NonReservedContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALLED, 0)
}

func (s *NonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *NonReservedContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *NonReservedContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCAST, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *NonReservedContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHANGE, 0)
}

func (s *NonReservedContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHAR, 0)
}

func (s *NonReservedContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHARACTER, 0)
}

func (s *NonReservedContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHECK, 0)
}

func (s *NonReservedContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLEAR, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCLUSTERED, 0)
}

func (s *NonReservedContext) CODEGEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCODEGEN, 0)
}

func (s *NonReservedContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLLATE, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLLATION, 0)
}

func (s *NonReservedContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLLECTION, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPACT, 0)
}

func (s *NonReservedContext) COMPACTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPACTIONS, 0)
}

func (s *NonReservedContext) COMPENSATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPENSATION, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONCATENATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCATENATE, 0)
}

func (s *NonReservedContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONDITION, 0)
}

func (s *NonReservedContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONSTRAINT, 0)
}

func (s *NonReservedContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONTAINS, 0)
}

func (s *NonReservedContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONTINUE, 0)
}

func (s *NonReservedContext) COST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOST, 0)
}

func (s *NonReservedContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *NonReservedContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *NonReservedContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_DATE, 0)
}

func (s *NonReservedContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIME, 0)
}

func (s *NonReservedContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIMESTAMP, 0)
}

func (s *NonReservedContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_USER, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *NonReservedContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *NonReservedContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASES, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *NonReservedContext) DATEADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATEADD, 0)
}

func (s *NonReservedContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE_ADD, 0)
}

func (s *NonReservedContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATEDIFF, 0)
}

func (s *NonReservedContext) DATE_DIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE_DIFF, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *NonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAYS, 0)
}

func (s *NonReservedContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAYOFYEAR, 0)
}

func (s *NonReservedContext) DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDBPROPERTIES, 0)
}

func (s *NonReservedContext) DEC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEC, 0)
}

func (s *NonReservedContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL, 0)
}

func (s *NonReservedContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECLARE, 0)
}

func (s *NonReservedContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFAULT, 0)
}

func (s *NonReservedContext) DEFINED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINED, 0)
}

func (s *NonReservedContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *NonReservedContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *NonReservedContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELIMITED, 0)
}

func (s *NonReservedContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *NonReservedContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *NonReservedContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDETERMINISTIC, 0)
}

func (s *NonReservedContext) DFS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDFS, 0)
}

func (s *NonReservedContext) DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORIES, 0)
}

func (s *NonReservedContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIRECTORY, 0)
}

func (s *NonReservedContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *NonReservedContext) DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTE, 0)
}

func (s *NonReservedContext) DIV() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIV, 0)
}

func (s *NonReservedContext) DO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDO, 0)
}

func (s *NonReservedContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE, 0)
}

func (s *NonReservedContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *NonReservedContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *NonReservedContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSEIF, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *NonReservedContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserENFORCED, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *NonReservedContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPED, 0)
}

func (s *NonReservedContext) EVOLUTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEVOLUTION, 0)
}

func (s *NonReservedContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCHANGE, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXECUTE, 0)
}

func (s *NonReservedContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *NonReservedContext) EXIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXIT, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *NonReservedContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPORT, 0)
}

func (s *NonReservedContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTEND, 0)
}

func (s *NonReservedContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *NonReservedContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTRACT, 0)
}

func (s *NonReservedContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFALSE, 0)
}

func (s *NonReservedContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFETCH, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIELDS, 0)
}

func (s *NonReservedContext) FILEFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILEFORMAT, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *NonReservedContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOAT, 0)
}

func (s *NonReservedContext) FLOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOW, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *NonReservedContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *NonReservedContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOREIGN, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *NonReservedContext) FORMATTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMATTED, 0)
}

func (s *NonReservedContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *NonReservedContext) FOUND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOUND, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGENERATED, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGLOBAL, 0)
}

func (s *NonReservedContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *NonReservedContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *NonReservedContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *NonReservedContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHANDLER, 0)
}

func (s *NonReservedContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAVING, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *NonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOURS, 0)
}

func (s *NonReservedContext) IDENTIFIER_KW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER_KW, 0)
}

func (s *NonReservedContext) IDENTITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTITY, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *NonReservedContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIMMEDIATE, 0)
}

func (s *NonReservedContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIMPORT, 0)
}

func (s *NonReservedContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *NonReservedContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDE, 0)
}

func (s *NonReservedContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCREMENT, 0)
}

func (s *NonReservedContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEXES, 0)
}

func (s *NonReservedContext) INPATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPATH, 0)
}

func (s *NonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *NonReservedContext) INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUTFORMAT, 0)
}

func (s *NonReservedContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *NonReservedContext) INT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINT, 0)
}

func (s *NonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *NonReservedContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *NonReservedContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *NonReservedContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *NonReservedContext) ITEMS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserITEMS, 0)
}

func (s *NonReservedContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserITERATE, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *NonReservedContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *NonReservedContext) KEYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEYS, 0)
}

func (s *NonReservedContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLANGUAGE, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *NonReservedContext) LAZY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAZY, 0)
}

func (s *NonReservedContext) LEADING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEADING, 0)
}

func (s *NonReservedContext) LEAVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEAVE, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *NonReservedContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *NonReservedContext) LONG() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLONG, 0)
}

func (s *NonReservedContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserILIKE, 0)
}

func (s *NonReservedContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *NonReservedContext) LINES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLINES, 0)
}

func (s *NonReservedContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *NonReservedContext) LOAD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOAD, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCAL, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCATION, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCK, 0)
}

func (s *NonReservedContext) LOCKS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCKS, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *NonReservedContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOOP, 0)
}

func (s *NonReservedContext) MACRO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMACRO, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *NonReservedContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATCHED, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAX, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMERGE, 0)
}

func (s *NonReservedContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMICROSECOND, 0)
}

func (s *NonReservedContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMICROSECONDS, 0)
}

func (s *NonReservedContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECOND, 0)
}

func (s *NonReservedContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECONDS, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *NonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTES, 0)
}

func (s *NonReservedContext) MODIFIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMODIFIES, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *NonReservedContext) MONTHS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTHS, 0)
}

func (s *NonReservedContext) MSCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMSCK, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *NonReservedContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAMESPACE, 0)
}

func (s *NonReservedContext) NAMESPACES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAMESPACES, 0)
}

func (s *NonReservedContext) NANOSECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNANOSECOND, 0)
}

func (s *NonReservedContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNANOSECONDS, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *NonReservedContext) NORELY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNORELY, 0)
}

func (s *NonReservedContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *NonReservedContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *NonReservedContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNUMERIC, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *NonReservedContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTIONS, 0)
}

func (s *NonReservedContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *NonReservedContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *NonReservedContext) OUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUT, 0)
}

func (s *NonReservedContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *NonReservedContext) OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUTFORMAT, 0)
}

func (s *NonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *NonReservedContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERLAPS, 0)
}

func (s *NonReservedContext) OVERLAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERLAY, 0)
}

func (s *NonReservedContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *NonReservedContext) PARTITIONED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONED, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *NonReservedContext) PERCENTLIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENTLIT, 0)
}

func (s *NonReservedContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPIVOT, 0)
}

func (s *NonReservedContext) PLACING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLACING, 0)
}

func (s *NonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIMARY, 0)
}

func (s *NonReservedContext) PRINCIPALS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRINCIPALS, 0)
}

func (s *NonReservedContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROCEDURE, 0)
}

func (s *NonReservedContext) PROCEDURES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROCEDURES, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *NonReservedContext) PURGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPURGE, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUERY, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *NonReservedContext) READS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREADS, 0)
}

func (s *NonReservedContext) REAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAL, 0)
}

func (s *NonReservedContext) RECORDREADER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECORDREADER, 0)
}

func (s *NonReservedContext) RECORDWRITER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECORDWRITER, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECOVER, 0)
}

func (s *NonReservedContext) RECURSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSION, 0)
}

func (s *NonReservedContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSIVE, 0)
}

func (s *NonReservedContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREDUCE, 0)
}

func (s *NonReservedContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFERENCES, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *NonReservedContext) RELY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRELY, 0)
}

func (s *NonReservedContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *NonReservedContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPAIR, 0)
}

func (s *NonReservedContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEAT, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *NonReservedContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESPECT, 0)
}

func (s *NonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *NonReservedContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURN, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *NonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *NonReservedContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRLIKE, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLUP, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *NonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *NonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *NonReservedContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECONDS, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *NonReservedContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *NonReservedContext) SEPARATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSEPARATED, 0)
}

func (s *NonReservedContext) SERDE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDE, 0)
}

func (s *NonReservedContext) SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERDEPROPERTIES, 0)
}

func (s *NonReservedContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION_USER, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *NonReservedContext) SHORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHORT, 0)
}

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *NonReservedContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSINGLE, 0)
}

func (s *NonReservedContext) SKEWED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSKEWED, 0)
}

func (s *NonReservedContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSMALLINT, 0)
}

func (s *NonReservedContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *NonReservedContext) SORT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORT, 0)
}

func (s *NonReservedContext) SORTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSORTED, 0)
}

func (s *NonReservedContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *NonReservedContext) SPECIFIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSPECIFIC, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQL, 0)
}

func (s *NonReservedContext) SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQLEXCEPTION, 0)
}

func (s *NonReservedContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQLSTATE, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *NonReservedContext) STATISTICS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATISTICS, 0)
}

func (s *NonReservedContext) STORED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTORED, 0)
}

func (s *NonReservedContext) STRATIFY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRATIFY, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *NonReservedContext) STREAMING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAMING, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT, 0)
}

func (s *NonReservedContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTR, 0)
}

func (s *NonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *NonReservedContext) SYNC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYNC, 0)
}

func (s *NonReservedContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM_TIME, 0)
}

func (s *NonReservedContext) SYSTEM_VERSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM_VERSION, 0)
}

func (s *NonReservedContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *NonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *NonReservedContext) TARGET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTARGET, 0)
}

func (s *NonReservedContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTBLPROPERTIES, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *NonReservedContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTERMINATED, 0)
}

func (s *NonReservedContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *NonReservedContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMEDIFF, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TIMESTAMP_LTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_LTZ, 0)
}

func (s *NonReservedContext) TIMESTAMP_NTZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_NTZ, 0)
}

func (s *NonReservedContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMPADD, 0)
}

func (s *NonReservedContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMPDIFF, 0)
}

func (s *NonReservedContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTINYINT, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *NonReservedContext) TOUCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTOUCH, 0)
}

func (s *NonReservedContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRAILING, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTIONS, 0)
}

func (s *NonReservedContext) TRANSFORM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSFORM, 0)
}

func (s *NonReservedContext) TRIM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRIM, 0)
}

func (s *NonReservedContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUNCATE, 0)
}

func (s *NonReservedContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *NonReservedContext) UNARCHIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNARCHIVE, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCACHE, 0)
}

func (s *NonReservedContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNIQUE, 0)
}

func (s *NonReservedContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNKNOWN, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNLOCK, 0)
}

func (s *NonReservedContext) UNPIVOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNPIVOT, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNSET, 0)
}

func (s *NonReservedContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNTIL, 0)
}

func (s *NonReservedContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *NonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSER, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUE, 0)
}

func (s *NonReservedContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *NonReservedContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARCHAR, 0)
}

func (s *NonReservedContext) VAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVAR, 0)
}

func (s *NonReservedContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIABLE, 0)
}

func (s *NonReservedContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIANT, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERSION, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEWS, 0)
}

func (s *NonReservedContext) VOID() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVOID, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWEEK, 0)
}

func (s *NonReservedContext) WEEKS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWEEKS, 0)
}

func (s *NonReservedContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHILE, 0)
}

func (s *NonReservedContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *NonReservedContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *NonReservedContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWINDOW, 0)
}

func (s *NonReservedContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *NonReservedContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHIN, 0)
}

func (s *NonReservedContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHOUT, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *NonReservedContext) YEARS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEARS, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseParserListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *SqlBaseParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, SqlBaseParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4844)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-131584) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-18014398509482241) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1170972187000111105) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-35218731827201) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9147945333030913) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511851128422401) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&131071) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SqlBaseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 83:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 168:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 171:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 174:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 237:
		var t *IdentifierContext = nil
		if localctx != nil {
			t = localctx.(*IdentifierContext)
		}
		return p.Identifier_Sempred(t, predIndex)

	case 238:
		var t *StrictIdentifierContext = nil
		if localctx != nil {
			t = localctx.(*StrictIdentifierContext)
		}
		return p.StrictIdentifier_Sempred(t, predIndex)

	case 239:
		var t *QuotedIdentifierContext = nil
		if localctx != nil {
			t = localctx.(*QuotedIdentifierContext)
		}
		return p.QuotedIdentifier_Sempred(t, predIndex)

	case 241:
		var t *NumberContext = nil
		if localctx != nil {
			t = localctx.(*NumberContext)
		}
		return p.Number_Sempred(t, predIndex)

	case 257:
		var t *StringLitContext = nil
		if localctx != nil {
			t = localctx.(*StringLitContext)
		}
		return p.StringLit_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SqlBaseParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 1:
		return legacy_setops_precedence_enabled

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 3:
		return !legacy_setops_precedence_enabled

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 5:
		return !legacy_setops_precedence_enabled

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Identifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 21:
		return !SQL_standard_keyword_behavior

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) StrictIdentifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 22:
		return SQL_standard_keyword_behavior

	case 23:
		return !SQL_standard_keyword_behavior

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) QuotedIdentifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 24:
		return double_quoted_identifiers

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Number_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 25:
		return !legacy_exponent_literal_as_decimal_enabled

	case 26:
		return !legacy_exponent_literal_as_decimal_enabled

	case 27:
		return legacy_exponent_literal_as_decimal_enabled

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) StringLit_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 28:
		return !double_quoted_identifiers

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
